<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Socket.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86cb34938e927f531ff1ab3b495e670e7f3a8bb0398.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b34938e927f531ff1ab3b495e670e7f3a8bb0398</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Implements the Berkeley sockets interface.</source>
          <target state="translated">Implémente l'interface de sockets Berkeley.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class provides a rich set of methods and properties for network communications.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe fournit un ensemble complet de méthodes et propriétés pour les communications réseau.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> enumeration.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe vous permet d’effectuer des synchrone et de transfert de données asynchrone à l’aide d’un des protocoles de communication répertoriées dans le <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class follows the .NET Framework naming pattern for asynchronous methods.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe suit le modèle d’affectation de noms du .NET Framework pour les méthodes asynchrones.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>For example, the synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method corresponds to the asynchronous <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods.</source>
          <target state="translated">Par exemple, synchrones <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode correspond à asynchrone <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</source>
          <target state="translated">Si votre application requiert uniquement un seul thread pendant l’exécution, utilisez les méthodes suivantes, qui sont conçues pour le mode de fonctionnement synchrone.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, tels que TCP, votre serveur peut écouter les connexions à l’aide de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method processes any incoming connection requests and returns a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to communicate data with the remote host.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> méthode traite toutes les connexions entrantes des demandes et retourne un <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que vous pouvez utiliser pour communiquer des données avec l’hôte distant.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Utilisez cette retourné <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> pour appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method prior to calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method if you want to specify the local IP address and port number.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> méthode si vous souhaitez spécifier le nombre d’adresse et le port IP local.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use a port number of zero if you want the underlying service provider to assign a free port for you.</source>
          <target state="translated">Utiliser un numéro de port de zéro si vous souhaitez que le fournisseur de service sous-jacent pour affecter un port disponible pour vous.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you want to connect to a listening host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez vous connecter à un hôte à l’écoute, appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To communicate data, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Pour communiquer des données, appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion tel que UDP, il est inutile écouter les connexions du tout.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method to accept any incoming datagrams.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode accepter tous les datagrammes entrants.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method to send datagrams to a remote host.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> méthode pour envoyer des datagrammes à un hôte distant.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</source>
          <target state="translated">Pour traiter les communications à l’aide de threads distincts au cours de l’exécution, utilisez les méthodes suivantes, qui sont conçues pour le mode d’opération asynchrone.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> methods to connect with a listening host.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, tels que TCP, utilisez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, et <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> méthodes pour se connecter à un hôte à l’écoute.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods to communicate data asynchronously.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> et <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthodes pour communiquer des données de façon asynchrone.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Incoming connection requests can be processed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.</source>
          <target state="translated">Demandes de connexion entrantes peuvent être traitées à l’aide de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> to send datagrams, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> to receive datagrams.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion tel que UDP, vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> pour envoyer des datagrammes, et <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> et <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> pour recevoir des datagrammes.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</source>
          <target state="translated">Si vous effectuez plusieurs opérations asynchrones sur un socket, elles n’est pas nécessairement effectuez dans l’ordre dans lequel ils sont démarrés.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>When you are finished sending and receiving data, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Lorsque vous avez fini d’envoyer et de recevoir des données, utilisez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> méthode permettant de désactiver le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to release all resources associated with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Après avoir appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode pour libérer toutes les ressources associées à la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to configure your <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe vous permet de configurer votre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à l’aide de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Retrieve these settings using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Récupérez ces paramètres à l’aide de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are writing a relatively simple application and do not require maximum performance, consider using <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.</source>
          <target state="translated">Si vous écrivez une application relativement simple et ne nécessitent pas d’optimiser les performances, envisagez d’utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, et <ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>These classes provide a simpler and more user-friendly interface to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> communications.</source>
          <target state="translated">Ces classes fournissent une interface plus simple et plus conviviale à <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> communications.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The following code example shows how the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can be used to send data to an HTTP server and receive the response.</source>
          <target state="translated">Le code suivant exemple montre comment la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe peut être utilisée pour envoyer des données à un serveur HTTP et recevoir la réponse.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>This example blocks until the entire page is received.</source>
          <target state="translated">Cet exemple est bloquée jusqu'à la page entière est reçue.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To establish an outgoing connection or accept an incoming request.</source>
          <target state="translated">Pour établir une connexion sortante ou accepter une demande entrante.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Instances of this class are thread safe.</source>
          <target state="translated">Les instances de cette classe sont thread-safe.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>The socket information returned by <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Informations de socket retournées par <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified value returned from <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> avec la valeur spécifiée retournée par <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>s with the same underlying socket.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructeur plusieurs fois avec le même tableau d’octets comme argument pour chaque appel, vous créerez plusieurs gérés <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>s avec le même socket sous-jacent.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">Cette pratique est fortement déconseillée.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified socket type and protocol.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> à l'aide du type de socket et du protocole spécifiés.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`socketType`</ph> parameter specifies the type of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class and the <ph id="ph3">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">`socketType`</ph> paramètre spécifie le type de la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe et le <ph id="ph3">`protocolType`</ph> paramètre spécifie le protocole utilisé par <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The two parameters are not independent.</source>
          <target state="translated">Les deux paramètres ne sont pas indépendants.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">Fréquence à laquelle le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type est implicite dans le protocole.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la combinaison de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type et protocole type se traduit par un non valide <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, ce constructeur lève une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si ce constructeur lève une <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of  <ph id="ph1">&lt;paramref name="socketType" /&gt;</ph> and <ph id="ph2">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          <target state="translated">La combinaison de <ph id="ph1">&lt;paramref name="socketType" /&gt;</ph> et <ph id="ph2">&lt;paramref name="protocolType" /&gt;</ph> aboutit à un socket non valide.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified address family, socket type and protocol.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> en utilisant la famille d'adresses, le type de socket et le protocole spécifiés.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`addressFamily`</ph> parameter specifies the addressing scheme that the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class uses, the <ph id="ph3">`socketType`</ph> parameter specifies the type of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class, and the <ph id="ph5">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">`addressFamily`</ph> paramètre spécifie le schéma d’adressage la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe utilise, le <ph id="ph3">`socketType`</ph> paramètre spécifie le type de la <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (classe) et le <ph id="ph5">`protocolType`</ph> paramètre spécifie le protocole utilisé par <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The three parameters are not independent.</source>
          <target state="translated">Les trois paramètres ne sont pas indépendants.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Some address families restrict which protocols can be used with them, and often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">Certaines familles d’adresses restreindre les protocoles peuvent être utilisés avec eux et souvent la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type est implicite dans le protocole.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of address family, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type, and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la combinaison de la famille d’adresses, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type et le protocole de type se traduit par un non valide <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, ce constructeur lève une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si ce constructeur lève une <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The following code example demonstrates how to create an instance of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">L’exemple de code suivant montre comment créer une instance de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of <ph id="ph1">&lt;paramref name="addressFamily" /&gt;</ph>, <ph id="ph2">&lt;paramref name="socketType" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          <target state="translated">La combinaison de <ph id="ph1">&lt;paramref name="addressFamily" /&gt;</ph>, <ph id="ph2">&lt;paramref name="socketType" /&gt;</ph> et <ph id="ph3">&lt;paramref name="protocolType" /&gt;</ph> crée un socket non valide.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          <target state="translated">Crée un nouveau <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> pour une connexion nouvellement créée.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> pour une connexion nouvellement créée.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> mode synchrone extrait la première demande de connexion en attente à partir de la file d’attente de demande de connexion de socket en écoute, puis crée et retourne un nouveau <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Vous ne pouvez pas utiliser cette retourné <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à accepter des connexions supplémentaires à partir de la file d’attente de connexion.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>However, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> method of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">Toutefois, vous pouvez appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> méthode retourné <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> pour identifier le numéro d’adresse et le port réseau de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>In blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> blocks until an incoming connection attempt is queued.</source>
          <target state="translated">En mode blocage, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> bloque jusqu'à ce qu’une tentative de connexion entrante est en attente.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Once a connection is accepted, the original <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> continues queuing incoming connection requests until you close it.</source>
          <target state="translated">Une fois qu’une connexion est acceptée, la version d’origine <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> continue de file d’attente demandes de connexion entrantes jusqu'à ce que vous fermez il.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you call this method using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and no connection requests are queued, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous appelez cette méthode à l’aide d’un non bloquant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>et aucune connexion de demandes sont en attente, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> lève une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method, you must first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode), vous devez d’abord appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The following code example accepts a simple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection.</source>
          <target state="translated">L’exemple de code suivant accepte un simple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">Le socket acceptant n'écoute pas les connexions.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>.</source>
          <target state="translated">Vous devez appeler <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> et <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> avant d'appeler <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Les protocoles orientés connexion peuvent utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> tente de méthode pour traiter de manière asynchrone une connexion entrante.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Accepter les connexions en mode asynchrone, vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> (méthode), vous devez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and hook it to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; délégué et la connecter à la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">Les propriétés et événements suivants sur le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objet sont requises :</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller can optionally specify an existing <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use for the incoming connection by specifying the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">L’appelant peut éventuellement spécifier un existant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à utiliser pour la connexion entrante en spécifiant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à utiliser avec le <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property is null, a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is constructed with the same <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> as the current <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and set as the <ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> propriété est null, un nouveau <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> est construit avec les mêmes <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, et <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> en cours <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et défini en tant que le <ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">L’appelant peut affecter la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">Si vous le souhaitez, une mémoire tampon peut-être être fournie qui recevra le bloc initial de données sur le socket après le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode réussit.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to receive and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the maximum number of bytes of data to receive in the buffer.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> propriété doit être définie dans la mémoire tampon qui contient les données à recevoir et le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> propriété doit être définie pour le nombre maximal d’octets de données à recevoir dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>These properties can be set using the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Ces propriétés peuvent être définies à l’aide de la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</source>
          <target state="translated">Partie de la mémoire tampon passé est utilisé en interne pour une utilisation par l’appel de Winsock AcceptEx sous-jacent.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This means that the amount of data returned will always be less than the value of the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> instance provided.</source>
          <target state="translated">Cela signifie que la quantité de données retournées sera toujours inférieure à la valeur de la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> propriété sur le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> instance fournie.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The amount of the buffer used internally varies based on the address family of the socket.</source>
          <target state="translated">La quantité de la mémoire tampon utilisée en interne varie en fonction de la famille d’adresses du socket.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The minimum buffer size required is 288 bytes.</source>
          <target state="translated">La taille de mémoire tampon minimale requise est 288 octets.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a larger buffer size is specified, then the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</source>
          <target state="translated">Si une plus grande taille de mémoire tampon est spécifiée, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> attendra quelques données supplémentaires autres que les données d’adresse reçues par l’appel de Winsock AcceptEx et attend que ces données supplémentaires sont reçues.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a timeout occurs, the connection is reset.</source>
          <target state="translated">Si un délai d’attente se produit, la connexion est rétablie.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</source>
          <target state="translated">Donc si des données supplémentaires sont attendues d’un montant spécifique, la taille du tampon doit être définie à la taille minimale de mémoire tampon plus cette quantité.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The completion callback method should examine the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> operation was successful.</source>
          <target state="translated">La méthode de rappel d’exécution doit examiner la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> propriété pour déterminer si le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> opération a réussi.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event can occur in some cases when no connection has been accepted and cause the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to be set to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> événement peut se produire dans certains cas, lorsque aucune connexion n’a pas été acceptée et entraîner la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> propriété à définir <ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can occur as a result of port scanning using a half-open SYN type scan (a SYN -&gt; SYN-ACK -&gt; RST sequence).</source>
          <target state="translated">Cela peut se produire suite à l’analyse des ports à l’aide d’une analyse de type ouvert SYN (un SYN -&gt; SYN ACK-&gt; séquence RST).</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Applications using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method should be prepared to handle this condition.</source>
          <target state="translated">Les applications à l’aide de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> méthode doit être préparée à gérer cette condition.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">Un argument n’est pas valide.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the buffer provided is not large enough.</source>
          <target state="translated">Cette exception se produit si la mémoire tampon fournie n'est pas assez grande.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.</source>
          <target state="translated">La mémoire tampon doit être d'au moins 2 * (taille de (SOCKADDR_STORAGE + 16) octets.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">Cette exception se produit également si plusieurs mémoires tampons sont spécifiées, la propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> n'est pas null.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is out of range.</source>
          <target state="translated">Un argument est hors limites.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The exception occurs if the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /&gt;</ph> is less than 0.</source>
          <target state="translated">L'exception se produit si <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An invalid operation was requested.</source>
          <target state="translated">Une opération incorrecte a été demandée.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the accepting <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not listening for connections or the accepted socket is bound.</source>
          <target state="translated">Cette exception se produit si le <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> acceptant n'écoute pas les connexions ou si le socket accepté est lié.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must call the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> method before calling the <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">Vous devez appeler les méthodes <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> et <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> avant d'appeler la méthode <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Cette exception se produit également si le socket est déjà connecté ou si une opération de socket utilisait déjà le paramètre de <ph id="ph1">&lt;paramref name="e" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>Gets the address family of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtient la famille d'adresses de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> specifies the addressing scheme that an instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can use.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> Spécifie le schéma d’adressage une instance de la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe peut utiliser.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>This property is read-only and is set when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated">Cette propriété est en lecture seule et est définie lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> est créé.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">Le code suivant exemple affiche la <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> à la console.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>Gets the amount of data that has been received from the network and is available to be read.</source>
          <target state="translated">Obtient la quantité de données reçues du réseau et disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The number of bytes of data received from the network and available to be read.</source>
          <target state="translated">Nombre d'octets de données reçus du réseau et disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you are using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is a good way to determine whether data is queued for reading, before calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un non bloquant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est un bon moyen pour déterminer si les données sont en file d’attente pour la lecture, avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The available data is the total amount of data queued in the network buffer for reading.</source>
          <target state="translated">Les données disponibles seront que la quantité totale de données en file d’attente dans le tampon réseau pour la lecture.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If no data is queued in the network buffer, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> returns 0.</source>
          <target state="translated">Si aucune donnée n’est en attente dans la mémoire tampon réseau, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> retourne 0.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If the remote host shuts down or closes the connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> can throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si l’hôte distant arrête ou ferme la connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> peut lever un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The following code example compares the results of calling IOControl with FIONREAD and the Available property.</source>
          <target state="translated">L’exemple de code suivant compare les résultats de l’appel de IOControl avec FIONREAD et la propriété disponible.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la création asynchrone de <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Les protocoles orientés connexion peuvent utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> tente de méthode pour traiter de manière asynchrone une connexion entrante.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Accepter les connexions en mode asynchrone, vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode), vous devez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Vous devez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Pour ce faire, au minimum, vous devez passer à l’écoute <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> objet <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> via la <ph id="ph3">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, généralement, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> jusqu'à ce qu’une connexion en attente est extraite.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> will return a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Retourne un nouveau <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> de l’objet que vous pouvez utiliser pour envoyer et recevoir des données avec l’hôte distant.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Vous ne pouvez pas utiliser cette retourné <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à accepter des connexions supplémentaires à partir de la file d’attente de connexion.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode, utilisez <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">Le système peut également utiliser le thread appelant pour appeler la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> propriété retourné <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> sera configuré pour indiquer que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode terminé de façon synchrone.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Pour annuler un appel en attente à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode), fermez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Un appel ultérieur à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> pour indiquer que l’opération a été annulée.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">Vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> propriété retourné <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> pour identifier le numéro d’adresse et le port réseau de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, consultez la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The following code example attempts to receive an incoming connection asynchronously.</source>
          <target state="translated">L’exemple de code suivant tente de recevoir une connexion entrante de façon asynchrone.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">Le socket acceptant n'écoute pas les connexions.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Vous devez appeler <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> et <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> avant d'appeler <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">Le socket accepté est lié.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes to accept from the sender.</source>
          <target state="translated">Nombre d'octets à accepter de l'expéditeur.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</source>
          <target state="translated">Lance une opération asynchrone d'acceptation d'une tentative de connexion entrante et reçoit le premier bloc de données envoyé par l'application cliente.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la création asynchrone de <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Les protocoles orientés connexion peuvent utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> tente de méthode pour traiter de manière asynchrone une connexion entrante.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</source>
          <target state="translated">Acceptant les connexions de manière asynchrone vous permet d’envoyer et recevoir des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">Cette surcharge vous permet de spécifier le nombre d’octets à accepter dans le transfert initial dans le <ph id="ph1">`receiveSize`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode), vous devez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Vous devez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Pour ce faire, au minimum, vous devez passer à l’écoute <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> objet <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> via la <ph id="ph3">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, généralement, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> jusqu'à ce qu’une connexion en attente est extraite.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Retourne un nouveau <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que vous pouvez utiliser pour envoyer et recevoir des données avec l’hôte distant.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Vous ne pouvez pas utiliser cette retourné <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à accepter des connexions supplémentaires à partir de la file d’attente de connexion.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode, utilisez <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">Le système peut également utiliser le thread appelant pour appeler la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> propriété retourné <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> sera configuré pour indiquer que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode terminé de façon synchrone.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Pour annuler un appel en attente à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode), fermez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Un appel ultérieur à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> pour indiquer que l’opération a été annulée.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You can call use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">Vous pouvez appeler à utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> propriété retourné <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> objet pour identifier le numéro d’adresse et le port réseau de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">L’exemple de code suivant ouvre un socket et accepte une connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data.</source>
          <target state="translated">Dans cet exemple, le socket accepte les 10 premiers octets de données.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">Le nombre d’octets reçus et les données sont affichées sur la console par le délégué de rappel.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> pour obtenir une description de la façon dont les données restantes sont reçues.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">Le socket acceptant n'écoute pas les connexions.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Vous devez appeler <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> et <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> avant d'appeler <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">Le socket accepté est lié.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> accepté.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This value may be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cette valeur peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to receive.</source>
          <target state="translated">Nombre maximal d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</source>
          <target state="translated">Lance une opération asynchrone d'acceptation d'une tentative de connexion entrante provenant d'un socket spécifié et reçoit le premier bloc de données envoyé par l'application cliente.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object creation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la création d'un objet <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> asynchrone.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Les protocoles orientés connexion peuvent utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> tente de méthode pour traiter de manière asynchrone une connexion entrante.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Accepter les connexions en mode asynchrone, vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the accepted socket in the <ph id="ph1">`acceptSocket`</ph> parameter.</source>
          <target state="translated">Cette surcharge vous permet de spécifier le socket accepté dans le <ph id="ph1">`acceptSocket`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this parameter is <ph id="ph1">`null`</ph>, the accepted socket is created by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Si ce paramètre est <ph id="ph1">`null`</ph>, le socket accepté est créé par le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">Vous pouvez spécifier le nombre d’octets à accepter dans le transfert initial dans le <ph id="ph1">`receiveSize`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode), vous devez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Vous devez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Pour ce faire, au minimum, vous devez passer à l’écoute <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> objet <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> via la <ph id="ph3">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, généralement, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> jusqu'à ce qu’une connexion en attente est extraite.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Retourne un nouveau <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> de l’objet que vous pouvez utiliser pour envoyer et recevoir des données avec l’hôte distant.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Vous ne pouvez pas utiliser cette retourné <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à accepter des connexions supplémentaires à partir de la file d’attente de connexion.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode, utilisez <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">Le système peut également utiliser le thread appelant pour appeler la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> propriété retourné <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> sera configuré pour indiquer que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode terminé de façon synchrone.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Pour annuler un appel en attente à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode), fermez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Un appel ultérieur à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> pour indiquer que l’opération a été annulée.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">Vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> propriété retourné <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> objet pour identifier le numéro d’adresse et le port réseau de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">L’exemple de code suivant ouvre un socket et accepte une connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data and the <ph id="ph1">`acceptSocket`</ph> parameter is <ph id="ph2">`null`</ph>, which forces the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to create the accepted socket.</source>
          <target state="translated">Dans cet exemple, le socket accepte les 10 premiers octets de données et la <ph id="ph1">`acceptSocket`</ph> paramètre est <ph id="ph2">`null`</ph>, qui force le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthode pour créer le socket accepté.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">Le nombre d’octets reçus et les données sont affichées sur la console par le délégué de rappel.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> pour obtenir une description de la façon dont les données restantes sont reçues.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">Le socket acceptant n'écoute pas les connexions.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Vous devez appeler <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> et <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> avant d'appeler <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">Le socket accepté est lié.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Démarre une demande asynchrone pour une connexion d'hôte distant.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Démarre une demande asynchrone pour une connexion d'hôte distant.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method starts an asynchronous request for a connection to the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode démarre une demande asynchrone pour une connexion à la <ph id="ph2">`remoteEP`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> établit un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Connexion ou la définition de façon asynchrone l’hôte distant par défaut vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>At the very minimum, you must pass the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Au minimum, vous devez passer le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> via la <ph id="ph3">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connects successfully or throws an exception.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> jusqu'à ce que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> se connecte correctement ou lève une exception.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode, utilisez <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> avant d’envoyer et recevoir des données.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> pour communiquer avec un hôte distant.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Si vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, tous les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you wish to set your default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> et la valeur diffusion <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you cannot, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous ne pouvez pas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion et que vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, le fournisseur de service sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, le fournisseur de services assignera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous appeliez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">Si vous souhaitez changer l’hôte distant par défaut, appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode avec le point de terminaison souhaité.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Pour annuler un appel en attente à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> (méthode), fermez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Un appel ultérieur à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> pour indiquer que l’opération a été annulée.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Si ce socket a été déconnecté précédemment, puis <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> doit être appelé sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Il s’agit d’une limitation du fournisseur sous-jacent.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">L’exemple de code suivant lance une tentative de connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été mis dans un état d’écoute en appelant <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, ou une opération asynchrone est déjà en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> of the remote host.</source>
          <target state="translated">Élément <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">Numéro de port de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">Cet objet est passé au délégué <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> quand l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Démarre une demande asynchrone pour une connexion d'hôte distant.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and a port number.</source>
          <target state="translated">L’hôte est spécifié par <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> et un numéro de port.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> opération doit être effectuée en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">En règle générale, la méthode est appelée par le <ph id="ph1">`requestCallback`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.</source>
          <target state="translated">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> surcharges de méthode, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Pour annuler un appel en attente à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> (méthode), fermez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Un appel ultérieur à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> pour indiquer que l’opération a été annulée.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez <bpt id="p1">[</bpt>appel asynchrone des méthodes synchrones<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Si ce socket a été déconnecté précédemment, puis <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> doit être appelé sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Il s’agit d’une limitation du fournisseur sous-jacent.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">Également le <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> qui est utilisé doit être différent.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">L’exemple de code suivant lance une tentative de connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not in the socket family.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> n’est pas dans la famille des sockets.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">Le numéro de port n’est pas valide.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="address" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été mis dans un état d’écoute en appelant <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, ou une opération asynchrone est déjà en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>At least one <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>, designating the remote host.</source>
          <target state="translated">Au moins un <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>, désignant l’hôte distant.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">Numéro de port de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">Cet objet est passé au délégué <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> quand l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Démarre une demande asynchrone pour une connexion d'hôte distant.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> array and a port number.</source>
          <target state="translated">L’hôte est spécifié par un tableau <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> et un numéro de port.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connections.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence aux connexions asynchrones.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> opération doit être effectuée en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">En règle générale, la méthode est appelée par le <ph id="ph1">`requestCallback`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> surcharges de méthode.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Pour annuler un appel en attente à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> (méthode), fermez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Un appel ultérieur à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> pour indiquer que l’opération a été annulée.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez <bpt id="p1">[</bpt>appel asynchrone des méthodes synchrones<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Si ce socket a été déconnecté précédemment, puis <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> doit être appelé sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Il s’agit d’une limitation du fournisseur sous-jacent.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">Également le <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> qui est utilisé doit être différent.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">L’exemple de code suivant lance une tentative de connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets that use <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</source>
          <target state="translated">Cette méthode est valide pour les sockets qui utilisent <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">Le numéro de port n’est pas valide.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="address" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été mis dans un état d’écoute en appelant <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, ou une opération asynchrone est déjà en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The name of the remote host.</source>
          <target state="translated">Nom de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">Numéro de port de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">Cet objet est passé au délégué <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> quand l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Démarre une demande asynchrone pour une connexion d'hôte distant.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by a host name and a port number.</source>
          <target state="translated">L’hôte est spécifié par un nom d’hôte et un numéro de port.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> opération doit être effectuée en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">En règle générale, la méthode est appelée par le <ph id="ph1">`requestCallback`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> surcharges de méthode.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the  <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Pour annuler un appel en attente à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> (méthode), fermez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Un appel ultérieur à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> pour indiquer que l’opération a été annulée.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez <bpt id="p1">[</bpt>appel asynchrone des méthodes synchrones<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Si ce socket a été déconnecté précédemment, puis <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> doit être appelé sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Il s’agit d’une limitation du fournisseur sous-jacent.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">Également le <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> qui est utilisé doit être différent.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">L’exemple de code suivant lance une tentative de connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="host" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Cette méthode est valide pour les sockets appartenant aux familles <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">Le numéro de port n’est pas valide.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été mis dans un état d’écoute en appelant <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, ou une opération asynchrone est déjà en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si ce socket peut être réutilisé après la fermeture de la connexion ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          <target state="translated">Lance une demande asynchrone de déconnexion d'un point de terminaison distant.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à l'opération asynchrone.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method to request a disconnect from a remote endpoint.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous pouvez appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> méthode pour demander la déconnexion d’un point de terminaison distant.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">Si <ph id="ph1">`reuseSocket`</ph> est <ph id="ph2">`true`</ph>, vous pouvez réutiliser le socket.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method uses a separate thread to invoke the specified callback method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> méthode utilise un thread séparé pour appeler la méthode de rappel spécifiée.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the pending disconnect is complete.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> méthode s’interrompt jusqu'à ce que la déconnexion en attente est terminée.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, utilisez la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">L’exemple de code suivant crée un socket pour la communication asynchrone et envoie des données à un hôte distant.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">Lorsque les données ont été envoyées, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> est appelée pour arrêter l’envoi et l’activité de réception.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated">Puis <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> est appelé pour lancer une demande de déconnexion.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">Lorsque la demande est terminée, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriété est interrogée pour tester si le socket est déconnecté.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Démarre la réception asynchrone de données à partir d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> qui fait référence à la méthode à appeler quand l'opération est terminée.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Cet objet est passé au délégué <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> quand l'opération est terminée.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Démarre la réception asynchrone de données à partir d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">Asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> opération doit être effectuée en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">En règle générale, la méthode est appelée par le <ph id="ph1">`callback`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> surcharges de méthode.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Pour annuler un en attente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez <bpt id="p1">[</bpt>appel asynchrone des méthodes synchrones<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> est une instanciation d’une classe définie par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> qui stocke l'erreur de socket.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> qui fait référence à la méthode à appeler quand l'opération est terminée.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Cet objet est passé au délégué <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> quand l'opération est terminée.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Démarre la réception asynchrone de données à partir d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">Asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> opération doit être effectuée en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">En règle générale, la méthode est appelée par le <ph id="ph1">`callback`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> surcharges de méthode.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Pour annuler un en attente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez <bpt id="p1">[</bpt>appel asynchrone des méthodes synchrones<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> est une instanciation d’une classe définie par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the received data.</source>
          <target state="translated">Position de base zéro dans le paramètre <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> à laquelle stocker les données reçues.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> qui fait référence à la méthode à appeler quand l'opération est terminée.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Cet objet est passé au délégué <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> quand l'opération est terminée.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Démarre la réception asynchrone de données à partir d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">Asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> opération doit être effectuée en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">En règle générale, la méthode est appelée par le <ph id="ph1">`callback`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> surcharges de méthode.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Pour annuler un en attente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez <bpt id="p1">[</bpt>appel asynchrone des méthodes synchrones<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> est une instanciation d’une classe définie par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins to asynchronously receive data from a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant commence à la réception asynchrone de données à partir d’un connecté <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          <target state="translated">Emplacement dans <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> où stocker les données reçues.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> qui fait référence à la méthode à appeler quand l'opération est terminée.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Cet objet est passé au délégué <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> quand l'opération est terminée.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Démarre la réception asynchrone de données à partir d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">Asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> opération doit être effectuée en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">En règle générale, la méthode est appelée par le <ph id="ph1">`callback`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> surcharges de méthode.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Pour annuler un en attente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez <bpt id="p1">[</bpt>appel asynchrone des méthodes synchrones<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> est une instanciation d’une classe définie par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          <target state="translated">Position de base zéro dans le paramètre <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> à laquelle stocker les données.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          <target state="translated">Démarre la réception asynchrone de données à partir d'un périphérique réseau spécifié.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method starts asynchronously reading connectionless datagrams from a remote host.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> méthode démarre la lecture asynchrone des datagrammes sans connexion à partir d’un hôte distant.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method gives you the ability to receive data within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> méthode vous donne la possibilité de recevoir des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Pour ce faire, au minimum, votre <ph id="ph1">`state`</ph> paramètre doit contenir le connecté ou par défaut <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> utilisé pour la communication.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and it will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> reads data or throws an exception.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et il se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> jusqu'à ce que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> lit les données ou lève une exception.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> méthode, utilisez <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will throw a <ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, vous devez lier explicitement la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à un point de terminaison local à l’aide de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode), ou <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> lèvera une <ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent.</source>
          <target state="translated">Cette méthode lit les données dans le <ph id="ph1">`buffer`</ph> de paramètre et de capture à partir de laquelle les données sont envoyées de point de terminaison de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur la récupération de ce point de terminaison, consultez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Cette méthode est particulièrement utile si vous avez l’intention de réception asynchrone des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Dans ce cas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de <ph id="ph1">`buffer`</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> méthode remplira <ph id="ph3">`buffer`</ph> avec autant de messages et lève un <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> méthode avec une mémoire tampon insuffisante.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method and then call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method with the <ph id="ph4">`optionLevel`</ph> parameter set to <ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph> or <ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> as appropriate, the <ph id="ph7">`optionName`</ph> parameter set to <ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>, and the <ph id="ph9">`optionValue`</ph> parameter to enable this option before calling the <ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Pour garantir que le point de terminaison d’hôte distant est toujours retourné, une application doit lier explicitement la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à un point de terminaison local à l’aide la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode), puis appelez le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> méthode avec le <ph id="ph4">`optionLevel`</ph> paramètre la valeur <ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>ou <ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> selon le cas, le <ph id="ph7">`optionName`</ph> paramètre la valeur <ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>et le <ph id="ph9">`optionValue`</ph> paramètre pour activer cette option avant d’appeler le <ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Sinon, il est possible que le point de terminaison d’hôte distant ne soit ne pas retourné lorsque l’émetteur a envoyé plusieurs datagrammes avant que le récepteur a appelé le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Bien que <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method or accept an incoming connection request by calling the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> <ph id="ph2"> / </ph> <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode ou acceptez une demande de connexion entrante en appelant le <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method before establishing or accepting a connection, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> méthode avant l’établissement ou l’acceptation d’une connexion, vous obtiendrez un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Dans les deux cas, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> méthode ignore la <ph id="ph2">`remoteEP`</ph> paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Avec des sockets orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> lira autant de données est disponible jusqu’au nombre d’octets spécifié par le <ph id="ph2">`size`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Pour annuler un en attente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously receives connectionless datagrams from a remote host.</source>
          <target state="translated">L’exemple de code suivant reçoit de façon asynchrone des datagrammes sans connexion à partir d’un hôte distant.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          <target state="translated">Position de base zéro dans le paramètre <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> à laquelle stocker les données.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the source of the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> qui représente la source des données.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information..</source>
          <target state="translated">Démarre la réception asynchrone du nombre spécifié d'octets de données dans l'emplacement spécifié de la mémoire tampon de données, à l'aide du <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié et stocke le point de terminaison ainsi que les informations sur le paquet.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The asynchronous receive operation must be completed by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Opération de réception asynchrone doit être effectuée en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`asyncCallback`</ph> delegate.</source>
          <target state="translated">En règle générale, la méthode est appelée par le <ph id="ph1">`asyncCallback`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation completes.</source>
          <target state="translated">Cette méthode ne bloque pas jusqu'à ce que l’opération se termine.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To block until the operation completes, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Pour annuler un en attente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez <bpt id="p1">[</bpt>appel asynchrone des méthodes synchrones<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</source>
          <target state="translated">Cette méthode lit les données dans le <ph id="ph1">`buffer`</ph> paramètre et capture le point de terminaison à partir de laquelle les données sont envoyées de l’hôte distant, ainsi que les informations sur le paquet reçu.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur la récupération de ce point de terminaison, consultez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Cette méthode est particulièrement utile si vous avez l’intention de réception asynchrone des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envoie des données de façon asynchrone à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envoie des données de façon asynchrone à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à l'envoi asynchrone.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lève une exception si vous n’appelez pas tout d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Pour ce faire, au minimum, votre <ph id="ph1">`state`</ph> paramètre doit contenir le connecté ou par défaut <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> utilisé pour la communication.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> jusqu'à ce que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envoie le nombre d’octets demandé ou lève une exception.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode, utilisez la <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Bien que destiné à des protocoles orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode pour établir un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Il est OK à utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> est une instanciation d’une classe définie par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consultez la section Notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> qui stocke l'erreur de socket.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envoie des données de façon asynchrone à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à l'envoi asynchrone.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lève une exception si vous n’appelez pas tout d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Pour ce faire, au minimum, votre <ph id="ph1">`state`</ph> paramètre doit contenir le connecté ou par défaut <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> utilisé pour la communication.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> jusqu'à ce que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envoie le nombre d’octets demandé ou lève une exception.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode, utilisez la <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Bien que destiné à des protocoles orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode pour établir un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Il est OK à utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> est une instanciation d’une classe définie par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consultez la section Notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          <target state="translated">Position de base zéro dans le paramètre <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> à laquelle commencer l’envoi des données.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">Le nombre d’octets à envoyer.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> qui stocke l'erreur de socket.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envoie des données de façon asynchrone à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à l'envoi asynchrone.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lève une exception si vous n’appelez pas tout d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Pour ce faire, au minimum, votre <ph id="ph1">`state`</ph> paramètre doit contenir le connecté ou par défaut <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> utilisé pour la communication.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> jusqu'à ce que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envoie le nombre d’octets demandé ou lève une exception.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode, utilisez la <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Bien que destiné à des protocoles orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode pour établir un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Il est OK à utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> est une instanciation d’une classe définie par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consultez la section Notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          <target state="translated">Position de base zéro dans le paramètre <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> à laquelle commencer l’envoi des données.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">Le nombre d’octets à envoyer.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envoie des données de façon asynchrone à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à l'envoi asynchrone.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lève une exception si vous n’appelez pas tout d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Pour ce faire, au minimum, votre <ph id="ph1">`state`</ph> paramètre doit contenir le connecté ou par défaut <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> utilisé pour la communication.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> jusqu'à ce que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envoie le nombre d’octets demandé ou lève une exception.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode, utilisez la <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Bien que destiné à des protocoles orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode pour établir un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Il est OK à utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> est une instanciation d’une classe définie par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins asynchronously sending data to a remote host.</source>
          <target state="translated">L’exemple de code suivant démarre l’envoi asynchrone des données à un hôte distant.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consultez la section Notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Envoie un fichier de façon asynchrone à un objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to send.</source>
          <target state="translated">Chaîne qui contient le chemin d'accès et le nom du fichier à envoyer.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> flag.</source>
          <target state="translated">Envoie le fichier <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> à un objet <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté à l'aide de l'indicateur <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous send.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui représente l'envoi asynchrone.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">Cette surcharge envoie le fichier <ph id="ph1">`fileName`</ph> au socket connecté.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Si <ph id="ph1">`fileName`</ph> est dans le répertoire local, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Les caractères génériques («.. <ph id="ph1">\\</ph>\myfile.txt ») et les noms de partage UNC («<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared active<ph id="ph5">\\</ph>\myfile.txt ») sont pris en charge.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Si le fichier est introuvable, l’exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Cette méthode utilise le <ph id="ph1">`TransmitFile`</ph> de trouver la fonction dans l’API Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur la <ph id="ph1">`TransmitFile`</ph> fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> lève une exception si vous n’appelez pas tout d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method enables you to send a file within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> méthode vous permet d’envoyer un fichier dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">Pour terminer l’opération, vous pouvez créer une méthode de rappel appelée par le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> paramètre de délégué.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">Pour ce faire, au minimum, le <ph id="ph1">`state`</ph> paramètre doit contenir le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> de l’objet utilisé pour la communication.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une classe ou une structure contenant les <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cet objet personnalisé à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> jusqu'à ce que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envoie l’intégralité du fichier ou lève une exception.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Bien que destiné à des protocoles orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode pour établir un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre fichier ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Dans ce cas, le datagramme n’est pas envoyé et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, utilisez la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication.</source>
          <target state="translated">L’exemple de code suivant crée et connecte à un socket pour la communication asynchrone.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>First, the file "text.txt" is sent asynchronously to the remote host.</source>
          <target state="translated">Tout d’abord, le fichier « text.txt » est envoyé de manière asynchrone à l’hôte distant.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">Le délégué de rappel appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> pour terminer la transmission.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">Le socket n’est pas connecté à un hôte distant.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">Le fichier <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consultez la section Notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to be sent.</source>
          <target state="translated">Chaîne qui contient le chemin d'accès et le nom du fichier à envoyer.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant les données à envoyer avant l’envoi du fichier.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant les données à envoyer après l’envoi du fichier.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits de valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate to be invoked when this operation completes.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> à appeler une fois cette opération terminée.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains state information for this request.</source>
          <target state="translated">Objet défini par l'utilisateur contenant les informations d'état de cette demande.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Sends a file and buffers of data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Envoie de façon asynchrone un fichier et des mémoires tampon de données à un objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui représente l'opération asynchrone.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">Cette surcharge requiert le nom du fichier à envoyer et une combinaison d’opérations de <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated">Le <ph id="ph1">`preBuffer`</ph> paramètre contient les données que vous voulez faire précéder le fichier.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> contient des données que vous souhaitez suivre le fichier.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Si <ph id="ph1">`fileName`</ph> est dans le répertoire local, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Les caractères génériques («.. <ph id="ph1">\\</ph>\myfile.txt ») et les noms de partage UNC («<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared active<ph id="ph5">\\</ph>\myfile.txt ») sont pris en charge.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Si le fichier est introuvable, l’exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated">Le <ph id="ph1">`flags`</ph> paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur le transfert de fichiers.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Cette méthode utilise le <ph id="ph1">`TransmitFile`</ph> de trouver la fonction dans l’API Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur la <ph id="ph1">`TransmitFile`</ph> fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> lève une exception si vous n’appelez pas tout d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method gives you the ability to send a file within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> méthode vous donne la possibilité d’envoyer un fichier dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">Pour terminer l’opération, vous pouvez créer une méthode de rappel appelée par le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> paramètre de délégué.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">Pour ce faire, au minimum, le <ph id="ph1">`state`</ph> paramètre doit contenir le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> de l’objet utilisé pour la communication.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une classe ou une structure contenant les <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cet objet personnalisé à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> jusqu'à ce que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envoie l’intégralité du fichier ou lève une exception.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Bien que destiné à des protocoles orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode pour établir un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre fichier ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Dans ce cas, le datagramme n’est pas envoyé et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, utilisez la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">L’exemple de code suivant crée et connecte à un socket pour la communication asynchrone et commence à envoyer le fichier « text.txt » en mode asynchrone à l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>In this example, a <ph id="ph1">`preBuffer`</ph> and a <ph id="ph2">`postBuffer`</ph> of data is created to send with the file and the default <ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> value is used.</source>
          <target state="translated">Dans cet exemple, un <ph id="ph1">`preBuffer`</ph> et un <ph id="ph2">`postBuffer`</ph> de données est créé pour envoyer le fichier et la valeur par défaut <ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> valeur est utilisée.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">Le délégué de rappel appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> pour terminer la transmission.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consultez la section Notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The operating system is not Windows NT or later.</source>
          <target state="translated">Le système d'exploitation n'est pas Windows NT ou une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">Le socket n’est pas connecté à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">Le fichier <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The zero-based position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin sending data.</source>
          <target state="translated">Position de base zéro dans <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> à laquelle commencer l’envoi des données.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">Le nombre d’octets à envoyer.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Objet qui contient les informations d’état de cette demande.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a specific remote host.</source>
          <target state="translated">Envoie des données de façon asynchrone à un hôte distant spécifique.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui fait référence à l'envoi asynchrone.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> méthode démarre une opération d’envoi asynchrone à l’hôte distant spécifié dans le <ph id="ph2">`remoteEP`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">Bien que destiné aux protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> fonctionne avec les protocoles orientés connexion.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez créer une méthode de rappel qui implémente le <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> délégué et passe son nom à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Pour ce faire, au minimum, votre <ph id="ph1">`state`</ph> paramètre doit contenir le connecté ou par défaut <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> utilisé pour la communication.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>et les autres informations requises.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passez une instance de cette classe pour le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> méthode via la <ph id="ph2">`state`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method.</source>
          <target state="translated">Votre méthode de rappel doit appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Lorsque votre application appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> jusqu'à ce que le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envoie le nombre d’octets demandé ou lève une exception.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> méthode, utilisez la <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information about writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez <bpt id="p1">[</bpt>Marshaling d’un délégué comme méthode de rappel<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will throw a <ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode), ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> lèvera une <ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> ignore le <ph id="ph2">`remoteEP`</ph> paramètre et envoyer des données à la <ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph> établie dans le <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez procéder ainsi si vous voulez appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph4">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, le <ph id="ph4">`remoteEP`</ph> paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Vous ne devez pas également pour appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>In this case, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Dans ce cas, le fournisseur de service sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">Utiliser un numéro de port de zéro si vous souhaitez que le fournisseur de service sous-jacent pour sélectionner un port libre.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriété après la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> terminée.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">-Vous devez également vous assurer de que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> (méthode), un spécifique <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously sends data to the specified remote host.</source>
          <target state="translated">L’exemple de code suivant envoie de façon asynchrone à l’hôte distant spécifié les données.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The local <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> to associate with the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> local à associer à <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associates a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> with a local endpoint.</source>
          <target state="translated">Associe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> à un point de terminaison local.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you need to use a specific local endpoint.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode si vous devez utiliser un point de terminaison local spécifique.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">Vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> avant de pouvoir appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You do not need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method unless you need to use a specific local endpoint.</source>
          <target state="translated">Vous n’avez pas besoin d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> avant d’utiliser le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode), sauf si vous devez utiliser un point de terminaison local spécifique.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method on both connectionless and connection-oriented protocols.</source>
          <target state="translated">Vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode sur les protocoles orientés connexion.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, you must first create the local <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> from which you intend to communicate data.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, vous devez d’abord créer local <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> à partir de laquelle vous souhaitez communiquer des données.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local address is assigned, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using <ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph> as the address parameter, and the underlying service provider will assign the most appropriate network address.</source>
          <target state="translated">Si vous ne souhaitez pas quelle adresse locale est affectée, vous pouvez créer un <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> à l’aide de <ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph> en tant que le paramètre d’adresse et le service sous-jacent fournisseur assigne l’adresse réseau la plus appropriée.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This might help simplify your application if you have multiple network interfaces.</source>
          <target state="translated">Cela peut vous aider à simplifier votre application si vous avez plusieurs interfaces réseau.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local port is used, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using 0 for the port number.</source>
          <target state="translated">Si vous ne souhaitez pas de port local est utilisé, vous pouvez créer un <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> à l’aide de 0 pour le numéro de port.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>In this case, the service provider will assign an available port number between 1024 and 5000.</source>
          <target state="translated">Dans ce cas, le fournisseur de services affecte un numéro de port disponible entre 1024 et 5000.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you use the above approach, you can discover what local network address and port number has been assigned by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez l’approche ci-dessus, vous pouvez découvrir le numéro d’adresse et le port de réseau local a été attribué en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> will not return the locally assigned network address until after you have made a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> ne retourne pas l’adresse réseau assignée localement jusqu'à une fois que vous avez effectué un appel à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous aurez pas accès à ces informations jusqu'à ce que vous avez terminé un envoi ou de réception.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If a UDP socket wants to receive interface information on received packets,  the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method should be explicitly called with the socket option set to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> immediately after calling the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Si un socket UDP doit recevoir une interface plus d’informations sur les paquets reçus, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> méthode doit être appelée explicitement avec l’option de socket définie sur <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> immédiatement après l’appel la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you intend to receive multicast datagrams, you must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method with a multicast port number.</source>
          <target state="translated">Si vous souhaitez recevoir des datagrammes multicast, vous devez appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode avec un numéro de port de multidiffusion.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you intend to receive connectionless datagrams using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Vous devez appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode si vous souhaitez recevoir des datagrammes sans connexion à l’aide du <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> lors de l’appel du <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode), utilisez le <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The following code example binds a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the specified local endpoint.</source>
          <target state="translated">Le code suivant lie l’exemple un <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à l’aide du point de terminaison local spécifié.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="localEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="localEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>for accepting connections from the host defined by <ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>.</source>
          <target state="translated">pour accepter les connexions à partir de l’hôte défini par <ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>Gets or sets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is in blocking mode.</source>
          <target state="translated">Obtient ou définit une valeur qui indique si <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> est en mode blocage.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will block; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> est bloqué ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property indicates whether a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is in blocking mode.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriété indique si une <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> est en mode blocage.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</source>
          <target state="translated">Si vous êtes en mode blocage, et vous apportez une méthode qui ne se termine pas immédiatement, votre application bloque l’exécution jusqu'à la fin de l’opération demandée.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you want execution to continue even though the requested operation is not complete, change the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si vous souhaitez que l’exécution à continuer même si l’opération demandée n’est pas terminée, modifiez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriété <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property has no effect on asynchronous methods.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriété n’a aucun effet sur les méthodes asynchrones.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are sending and receiving data asynchronously and want to block execution, use the <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> class.</source>
          <target state="translated">Si vous envoyez et recevoir des données de façon asynchrone et à bloquer l’exécution, utilisez la <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object used to request the connection to the remote host by calling one of the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> methods.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> utilisé pour demander la connexion à l'hôte distant en appelant l'une des méthodes <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Cancels an asynchronous request for a remote host connection.</source>
          <target state="translated">Annule une requête asynchrone pour une connexion d'hôte distant.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> method cancels an asynchronous request for a remote host connection.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> méthode annule une demande asynchrone pour une connexion d’hôte distant.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="e" /&gt;</ph> ne peut pas être null et <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> ne peut pas être vide.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          <target state="translated">Ferme la connexion <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> et libère toutes les ressources associées.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          <target state="translated">Ferme la connexion <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> et libère toutes les ressources associées.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode ferme la connexion d’hôte distant et libère toutes les ressources managées et associés à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">À la clôture, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Pour les protocoles orientés connexion, il est recommandé d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">Cela garantit que toutes les données est envoyé et reçu sur le socket connecté avant sa fermeture.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">Si vous avez besoin d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> sans appeler d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, vous pouvez vous assurer que les données en attente pour la transmission sortante est envoyée en définissant le <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option <ph id="ph5">`false`</ph> et en spécifiant un intervalle de délai d’attente différente de zéro.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> puis bloque jusqu'à ce que ces données sont envoyées ou jusqu'à ce que le délai spécifié expire.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">Si vous définissez <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> à <ph id="ph2">`false`</ph> et spécifiez un intervalle de délai d’attente zéro, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> libère la connexion et ignore automatiquement les données en file d’attente sortantes.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time out period.</source>
          <target state="translated">Pour définir le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option de socket <ph id="ph2">`false`</ph>, créer un <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, définit la propriété enabled <ph id="ph4">`true`</ph>et définir le <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> propriété à la période d’expiration souhaitée.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Utilisez cette <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> avec la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> de socket permet d’appeler le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The following code example closes a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Les éléments suivants exemple de code ferme un <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Wait up to <bpt id="p1">&lt;c&gt;</bpt>timeout<ept id="p1">&lt;/c&gt;</ept> seconds to send any remaining data, then close the socket.</source>
          <target state="translated">Attendez jusqu’à <bpt id="p1">&lt;c&gt;</bpt>timeout<ept id="p1">&lt;/c&gt;</ept> en secondes pour envoyer toutes les données restantes, puis fermez le socket.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</source>
          <target state="translated">Ferme la connexion <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> et libère toutes les ressources associées avec un délai d’attente spécifié pour permettre l’envoi des données en file d’attente.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode ferme la connexion d’hôte distant et libère toutes les ressources managées et associés à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">À la clôture, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.</source>
          <target state="translated">Pour les protocoles orientés connexion, il est recommandé d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">Cela garantit que toutes les données est envoyé et reçu sur le socket connecté avant sa fermeture.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option to <ph id="ph4">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">Si vous avez besoin d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> sans appeler d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, vous pouvez vous assurer que les données en attente pour la transmission sortante est envoyée en définissant le <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option <ph id="ph4">`false`</ph> et en spécifiant un intervalle de délai d’attente différente de zéro.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> puis bloque jusqu'à ce que ces données sont envoyées ou jusqu'à ce que le délai spécifié expire.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">Si vous définissez <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> à <ph id="ph2">`false`</ph> et spécifiez un intervalle de délai d’attente zéro, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> libère la connexion et ignore automatiquement les données en file d’attente sortantes.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time-out period.</source>
          <target state="translated">Pour définir le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option de socket <ph id="ph2">`false`</ph>, créer un <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, définit la propriété enabled <ph id="ph4">`true`</ph>et définir le <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> propriété pour le délai d’expiration souhaitée.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Utilisez cette <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> avec la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> de socket permet d’appeler le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The following code example demonstrates how to close a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment fermer une <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Établit une connexion à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the remote device.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> qui représente l’appareil distant.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Établit une connexion à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, tels que TCP, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode établit de manière synchrone une connexion réseau entre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> et le point de terminaison distant spécifié.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> établit un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Après avoir appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, vous pouvez envoyer des données au périphérique distant avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’envoyer et recevoir des données.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> pour communiquer de manière synchrone avec un hôte distant.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Si vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, tous les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lèvera une <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode se bloque, sauf si vous définissez spécifiquement le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriété <ph id="ph3">`false`</ph> avant d’appeler <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> , car il a besoin de temps pour établir la connexion.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Protocoles sans connexion ne lève pas une exception car ils établissent simplement un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Si l’erreur retournée est WSAEWOULDBLOCK, la connexion d’hôte distant a été initiée par un orienté connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, mais n’est ne pas encore terminée correctement.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> méthode afin de déterminer quand le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> a terminé la connexion.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion et n’a pas appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, le fournisseur de service sous-jacent affecte le numéro d’adresse et le port de réseau local.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous effectuez un envoi ou opération de réception.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Si vous souhaitez changer l’hôte distant par défaut, appelez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> à nouveau avec le point de terminaison souhaité.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Si le socket a été déconnecté précédemment, vous ne pouvez pas utiliser cette méthode pour rétablir la connexion.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Utilisez une des asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthodes se reconnecter.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Il s’agit d’une limitation du fournisseur sous-jacent.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été mis dans un état d’écoute en appelant <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>for connecting to the remote host.</source>
          <target state="translated">pour la connexion à l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The IP address of the remote host.</source>
          <target state="translated">Adresse IP de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">Numéro de port de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Établit une connexion à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The host is specified by an IP address and a port number.</source>
          <target state="translated">L’hôte est spécifié par une adresse IP et un numéro de port.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, tels que TCP, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode établit de manière synchrone une connexion réseau entre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> et le point de terminaison distant spécifié.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> établit un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Après avoir appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> peut envoyer des données à l’appareil à distance avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’envoyer et recevoir des données.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> pour communiquer de manière synchrone avec un hôte distant.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Si vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lèvera une <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode se bloque, sauf si vous définissez spécifiquement le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriété <ph id="ph3">`false`</ph> avant d’appeler <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> , car il a besoin de temps pour établir la connexion.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Protocoles sans connexion ne lève pas une exception car ils établissent simplement un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Si l’erreur retournée est WSAEWOULDBLOCK, la connexion d’hôte distant a été initiée par un orienté connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, mais n’est ne pas encore terminée correctement.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> méthode afin de déterminer quand le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> a terminé la connexion.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion et n’a pas appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, le fournisseur de service sous-jacent affecte le numéro d’adresse et le port de réseau local.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous effectuez un envoi ou opération de réception.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Si vous souhaitez changer l’hôte distant par défaut, appelez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> à nouveau avec le point de terminaison souhaité.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Si le socket a été déconnecté précédemment, vous ne pouvez pas utiliser cette méthode pour rétablir la connexion.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Utilisez une des asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthodes se reconnecter.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Il s’agit d’une limitation du fournisseur sous-jacent.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">Le numéro de port n’est pas valide.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Cette méthode est valide pour les sockets appartenant aux familles <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="address" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été mis dans un état d’écoute en appelant <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The IP addresses of the remote host.</source>
          <target state="translated">Adresses IP de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">Numéro de port de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Établit une connexion à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The host is specified by an array of IP addresses and a port number.</source>
          <target state="translated">L’hôte est spécifié par un tableau d’adresses IP et un numéro de port.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is typically used immediately after a call to <ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, which can return multiple IP addresses for a single host.</source>
          <target state="translated">Cette méthode est généralement utilisée immédiatement après un appel à <ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, qui peut retourner plusieurs adresses IP pour un seul hôte.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, tels que TCP, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode établit de manière synchrone une connexion réseau entre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> et le point de terminaison distant spécifié.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> établit un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Après avoir appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> peut envoyer des données à l’appareil à distance avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’envoyer et recevoir des données.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> pour communiquer de manière synchrone avec un hôte distant.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Si vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lèvera une <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode se bloque, sauf si vous définissez spécifiquement le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriété <ph id="ph3">`false`</ph> avant d’appeler <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> , car il a besoin de temps pour établir la connexion.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Protocoles sans connexion ne lève pas une exception car ils établissent simplement un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Si l’erreur retournée est WSAEWOULDBLOCK, la connexion d’hôte distant a été initiée par un orienté connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, mais n’est ne pas encore terminée correctement.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> méthode afin de déterminer quand le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> a terminé la connexion.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion et n’a pas appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, le fournisseur de service sous-jacent affecte le numéro d’adresse et le port de réseau local.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous effectuez un envoi ou opération de réception.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Si vous souhaitez changer l’hôte distant par défaut, appelez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> à nouveau avec le point de terminaison souhaité.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Si le socket a été déconnecté précédemment, vous ne pouvez pas utiliser cette méthode pour rétablir la connexion.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Utilisez une des asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthodes se reconnecter.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Il s’agit d’une limitation du fournisseur sous-jacent.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">Le numéro de port n’est pas valide.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Cette méthode est valide pour les sockets appartenant aux familles <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="address" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été mis dans un état d’écoute en appelant <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The name of the remote host.</source>
          <target state="translated">Nom de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">Numéro de port de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Établit une connexion à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The host is specified by a host name and a port number.</source>
          <target state="translated">L’hôte est spécifié par un nom d’hôte et un numéro de port.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote host.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, tels que TCP, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode établit de manière synchrone une connexion réseau entre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> et l’hôte distant spécifié.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> établit un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Après avoir appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> peut envoyer des données à l’appareil à distance avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’envoyer et recevoir des données.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> pour communiquer de manière synchrone avec un hôte distant.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Si vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lèvera une <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode se bloque, sauf si vous définissez spécifiquement le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriété <ph id="ph3">`false`</ph> avant d’appeler <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> , car il a besoin de temps pour établir la connexion.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Protocoles sans connexion ne lève pas une exception car ils établissent simplement un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Si l’erreur retournée est WSAEWOULDBLOCK, la connexion d’hôte distant a été initiée par un orienté connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, mais n’est ne pas encore terminée correctement.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> méthode afin de déterminer quand le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> a terminé la connexion.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If IPv6 is enabled and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</source>
          <target state="translated">Si le protocole IPv6 est activé et le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> est appelée pour vous connecter à un hôte qui résout les deux IPv6 et des adresses IPv4, la connexion à l’adresse IPv6 sera tentée en premier avant l’adresse IPv4.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</source>
          <target state="translated">Cela peut avoir pour effet de retarder l’heure pour établir la connexion si l’hôte n’écoute pas sur l’adresse IPv6.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion et n’a pas appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, le fournisseur de service sous-jacent affecte le numéro d’adresse et le port de réseau local.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous effectuez un envoi ou opération de réception.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Si vous souhaitez changer l’hôte distant par défaut, appelez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> à nouveau avec le point de terminaison souhaité.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Si le socket a été déconnecté précédemment, vous ne pouvez pas utiliser cette méthode pour rétablir la connexion.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Utilisez une des asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthodes se reconnecter.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Il s’agit d’une limitation du fournisseur sous-jacent.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="host" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">Le numéro de port n’est pas valide.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Cette méthode est valide pour les sockets appartenant aux familles <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été mis dans un état d’écoute en appelant <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">Démarre une demande asynchrone pour une connexion à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">Démarre une demande asynchrone pour une connexion à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Dans ce cas, l'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode démarre une demande asynchrone pour une connexion à l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> établit un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; et l’attacher le rappel pour le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">L’appelant doit définir le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriété le <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> de l’hôte distant pour se connecter à.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">L’appelant peut affecter la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> avant d’envoyer et recevoir des données.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> pour communiquer avec un hôte distant.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Si vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, tous les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">Si vous souhaitez changer l’hôte distant par défaut, appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode avec le point de terminaison souhaité.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Si vous souhaitez définir l’hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> et la valeur diffusion <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si cela n’est pas fait, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">Les propriétés et événements suivants sur le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objet sont requises :</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">Si vous le souhaitez, une mémoire tampon peut être fournie qui sera envoyé atomiquement sur le socket après le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode réussit.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> propriété doit être définie dans la mémoire tampon qui contient les données à envoyer et <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> propriété doit être définie pour le nombre d’octets de données à envoyer à partir de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">Une fois qu’une connexion est établie, cette mémoire tampon de données est envoyé.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion et que vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, le fournisseur de service sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, le fournisseur de services assignera pas un réseau local IP adresse et numéro de port jusqu'à ce que vous appeliez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode lève une exception <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> si la famille d’adresses de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> ne sont pas la même famille d’adresses.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> lorsque vous appelez cette méthode, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">Un argument n’est pas valide.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">Cette exception se produit si plusieurs mémoires tampons sont spécifiées, la propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> n'est pas null.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="e" /&gt;</ph> ne peut pas être null et <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> ne peut pas être vide.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> est à l'écoute ou une opération de socket utilisant l'objet <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> spécifié dans le paramètre <ph id="ph3">&lt;paramref name="e" /&gt;</ph> spécifié était déjà en cours.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          <target state="translated">Cette exception se produit également si le point de terminaison local et les <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> ne sont pas la même famille d'adresses.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">Démarre une demande asynchrone pour une connexion à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Dans ce cas, l'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, la méthode System.NET.Sockets.ProtocolType démarre une demande asynchrone pour une connexion à l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host specified by the <ph id="ph2">`socketType`</ph> and <ph id="ph3">`protocolType`</ph> parameters.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> établit un hôte distant par défaut spécifié par le <ph id="ph2">`socketType`</ph> et <ph id="ph3">`protocolType`</ph> paramètres.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; et l’attacher le rappel pour le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">L’appelant doit définir le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriété le <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> de l’hôte distant pour se connecter à.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">L’appelant peut affecter la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> avant d’envoyer et recevoir des données.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> pour communiquer avec un hôte distant.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Si vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, tous les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">Si vous souhaitez changer l’hôte distant par défaut, appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode avec le point de terminaison souhaité.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Si vous souhaitez définir l’hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> et la valeur diffusion <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si cela n’est pas fait, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">Les propriétés et événements suivants sur le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objet sont requises :</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">Si vous le souhaitez, une mémoire tampon peut être fournie qui sera envoyé atomiquement sur le socket après le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode réussit.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> propriété doit être définie dans la mémoire tampon qui contient les données à envoyer et <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> propriété doit être définie pour le nombre d’octets de données à envoyer à partir de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">Une fois qu’une connexion est établie, cette mémoire tampon de données est envoyé.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion et que vous n’appelez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, le fournisseur de service sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, le fournisseur de services assignera pas un réseau local IP adresse et numéro de port jusqu'à ce que vous appeliez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode lève une exception <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> si la famille d’adresses de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> ne sont pas la même famille d’adresses.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> lorsque vous appelez cette méthode, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">Un argument n’est pas valide.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">Cette exception se produit si plusieurs mémoires tampons sont spécifiées, la propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> n'est pas null.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="e" /&gt;</ph> ne peut pas être null et <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> ne peut pas être vide.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> est à l'écoute ou une opération de socket utilisant l'objet <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> spécifié dans le paramètre <ph id="ph3">&lt;paramref name="e" /&gt;</ph> spécifié était déjà en cours.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          <target state="translated">Cette exception se produit également si le point de terminaison local et les <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> ne sont pas la même famille d'adresses.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Connected">
          <source>Gets a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is connected to a remote host as of the last <ph id="ph2">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> or <ph id="ph3">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> operation.</source>
          <target state="translated">Obtient une valeur qui indique si <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> est connecté à un hôte distant depuis la dernière opération <ph id="ph2">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> ou <ph id="ph3">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> was connected to a remote resource as of the most recent operation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> était connecté à une ressource distante lors de l'opération la plus récente ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The <ph id="ph1">`Connected`</ph> property gets the connection state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> as of the last I/O operation.</source>
          <target state="translated">Le <ph id="ph1">`Connected`</ph> propriété obtient l’état de connexion de la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> depuis la dernière opération d’e/s.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>When it returns <ph id="ph1">`false`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was either never connected, or is no longer connected.</source>
          <target state="translated">Lorsqu’elle retourne <ph id="ph1">`false`</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> n’a jamais été connecté, ou n’est plus connecté.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The value of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property reflects the state of the connection as of the most recent operation.</source>
          <target state="translated">La valeur de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriété reflète l’état de la connexion depuis la dernière opération.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</source>
          <target state="translated">Si vous avez besoin déterminer l’état actuel de la connexion, appeler un envoi non bloquant, zéro octet.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</source>
          <target state="translated">Si l’appel retourné avec succès ou lève un code d’erreur WAEWOULDBLOCK (10035), puis le socket est toujours connecté ; Sinon, le socket n’est plus connecté.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> on a User Datagram Protocol (UDP) socket, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property always returns <ph id="ph3">`true`</ph>; however, this action does not change the inherent connectionless nature of UDP.</source>
          <target state="translated">Si vous appelez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> sur un socket de protocole UDP (User Datagram), le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriété retourne toujours <ph id="ph3">`true`</ph>; Toutefois, cette action ne modifie pas la nature même sans connexion UDP.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The following code example connects to a remote endpoint, checks the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property, and checks the current state of the connection.</source>
          <target state="translated">L’exemple de code suivant se connecte à un point de terminaison distant, vérifie le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriété et vérifie l’état actuel de la connexion.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the current connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si ce socket peut être réutilisé après la fermeture de la connexion active ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>Closes the socket connection and allows reuse of the socket.</source>
          <target state="translated">Ferme la connexion de socket et autorise la réutilisation du socket.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you are using a connection-oriented protocol, you can use this method to close the socket.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous pouvez utiliser cette méthode pour fermer le socket.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method ends the connection and sets the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Cette méthode met fin à la connexion et affecte le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriété <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>However, if <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">Toutefois, si <ph id="ph1">`reuseSocket`</ph> est <ph id="ph2">`true`</ph>, vous pouvez réutiliser le socket.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>To ensure that all data is sent and received before the socket is closed, you should call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> method.</source>
          <target state="translated">Pour vous assurer que toutes les données envoyé et reçu avant que le socket est fermé, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can set the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</source>
          <target state="translated">Si vous avez besoin d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> sans appeler d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, vous pouvez définir le <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option <ph id="ph5">`false`</ph> et spécifiez un intervalle de délai d’attente différente de zéro pour vous assurer que les données en attente pour la transmission sortante est envoyé.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> then blocks until the data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> puis se bloque jusqu'à ce que les données sont envoyées ou jusqu'à ce que le délai spécifié expire.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">Si vous définissez <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> à <ph id="ph2">`false`</ph> et spécifiez un intervalle de délai d’attente zéro, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> libère la connexion et ignore automatiquement les données en file d’attente sortantes.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The following code example creates a socket for synchronous communication and sends some data to a remote host.</source>
          <target state="translated">L’exemple de code suivant crée un socket pour la communication synchrone et envoie des données à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>It then calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, to stop the send and receive activity, and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>, to close the socket connection.</source>
          <target state="translated">Il appelle ensuite <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>pour arrêter l’envoi et de réception d’activité, et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>pour fermer la connexion de socket.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method requires Windows 2000 or earlier, or the exception will be thrown.</source>
          <target state="translated">Cette méthode nécessite Windows 2000 ou version antérieure, ou l'exception sera levée.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          <target state="translated">Lance une demande asynchrone de déconnexion d'un point de terminaison distant.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Dans ce cas, l'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> method requests a disconnect from a remote endpoint.</source>
          <target state="translated">Lorsque vous utilisez un protocole orienté connexion, appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> méthode requiert la déconnexion d’un point de terminaison distant.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph> to <ph id="ph2">`true`</ph> in the <ph id="ph3">`e`</ph> parameter, the socket can be reused.</source>
          <target state="translated">Si vous définissez <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph> à <ph id="ph2">`true`</ph> dans le <ph id="ph3">`e`</ph> paramètre, le socket peut être réutilisé.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="e" /&gt;</ph> ne peut pas être Null.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Une opération de socket utilisant l'objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> spécifié dans le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> spécifié était déjà en cours.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de la classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de la classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Appelez la méthode <ph id="ph1">`Dispose`</ph> une fois que vous avez terminé d'utiliser <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in an unusable state.</source>
          <target state="translated">La méthode <ph id="ph1">`Dispose`</ph> rend le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> inutilisable.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was occupying.</source>
          <target state="translated">Après avoir appelé <ph id="ph1">`Dispose`</ph>, vous devez libérer toutes les références à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> pour que le garbage collector puisse récupérer la mémoire qui le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> occupée.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>de nettoyage des ressources non managées<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> et <bpt id="p2">[</bpt>implémentant une méthode de suppression<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Appelez toujours <ph id="ph1">`Dispose`</ph> avant de libérer votre dernière référence à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> de l'objet <ph id="ph2">`Finalize`</ph>.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to releases only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour libérer les ressources managées et non managées ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour libérer uniquement les ressources non managées.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, and optionally disposes of the managed resources.</source>
          <target state="translated">Libère les ressources non managées utilisées par <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> et supprime éventuellement les ressources managées.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">`Dispose()`</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode est appelée par le public <ph id="ph1">`Dispose()`</ph> (méthode) et le <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose()`</ph> appelle la méthode protégée <ph id="ph2">`Dispose(Boolean)`</ph> méthode avec la <ph id="ph3">`disposing`</ph> paramètre la valeur <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> appelle <ph id="ph2">`Dispose`</ph> avec <ph id="ph3">`disposing`</ph> la valeur <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> references.</source>
          <target state="translated">Si le paramètre <ph id="ph1">`disposing`</ph> a la valeur <ph id="ph2">`true`</ph>, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
          <target state="translated">Cette méthode appelle la méthode <ph id="ph1">`Dispose()`</ph> de chaque objet référencé.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> peut être appelée plusieurs fois par d'autres objets.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated">Lors de la substitution de <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’implémentation <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, consultez <bpt id="p1">[</bpt>implémentant une méthode de suppression<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Overriding the Finalize Method<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> et <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, consultez <bpt id="p1">[</bpt>de nettoyage des ressources non managées<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> et <bpt id="p2">[</bpt>substitution de la méthode Finalize<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows Internet Protocol (IP) datagrams to be fragmented.</source>
          <target state="translated">Obtient ou définit une valeur <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> qui spécifie si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> autorise la fragmentation des datagrammes IP (Internet Protocol).</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows datagram fragmentation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> autorise la fragmentation des datagrammes ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</source>
          <target state="translated">Les datagrammes exigent une fragmentation lorsque leur taille dépasse le Maximum unité de transfert (MTU) du support de transmission.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</source>
          <target state="translated">Les datagrammes peuvent être fragmentés par l’hôte d’envoi (toutes les versions d’Internet Protocol) ou un routeur intermédiaire (protocole Internet Version 4 uniquement).</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>If a datagram must be fragmented, and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</source>
          <target state="translated">Si un datagramme doit être fragmenté et le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> option est définie, le datagramme est ignoré et un message d’erreur de contrôle Message ICMP (Internet Protocol) est envoyé à l’expéditeur du datagramme.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">Définition de cette propriété sur un socket de protocole TCP (Transmission Control) n’aura aucun effet.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Cette propriété ne peut être définie que pour les sockets dans les familles <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a dual-mode socket used for both IPv4 and IPv6.</source>
          <target state="translated">Obtient ou définit une valeur <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> qui spécifie si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> est un socket en mode double utilisé pour IPv4 et IPv6.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a  dual-mode socket; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> est un socket en mode double ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The ID of the target process where a duplicate of the socket reference is created.</source>
          <target state="translated">ID du processus cible où un doublon de la référence de socket est créé.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplicates the socket reference for the target process, and closes the socket for this process.</source>
          <target state="translated">Duplique la référence de socket pour le processus cible et ferme le socket pour ce processus.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The socket reference to be passed to the target process.</source>
          <target state="translated">Référence de socket à passer au processus cible.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The target process should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> to create the duplicate socket instance.</source>
          <target state="translated">Le processus cible doit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> pour créer l’instance de socket en double.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances with the same underlying socket.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructeur plusieurs fois avec le même tableau d’octets comme argument pour chaque appel, vous créerez plusieurs gérés <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances avec le même socket sous-jacent.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">Cette pratique est fortement déconseillée.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If the process creating the socket uses asynchronous methods (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), the process must first set the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> to be thrown on the target process.</source>
          <target state="translated">Si le processus de création du socket utilise des méthodes asynchrones (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), le processus doit tout d’abord définir le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> propriété à true ; sinon, le socket est lié au port de terminaison du processus de création, ce qui peut entraîner une <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> levée sur le processus cible.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="targetProcessID" /&gt;</ph> is not a valid process id.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="targetProcessID" /&gt;</ph> n'est pas un ID de processus valide.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplication of the socket reference failed.</source>
          <target state="translated">La duplication de la référence de socket a échoué.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> can send or receive broadcast packets.</source>
          <target state="translated">Obtient ou définit une valeur <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> qui spécifie si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> peut envoyer ou recevoir des paquets de diffusion.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows broadcast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> autorise les paquets de diffusion ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</source>
          <target state="translated">Diffusion est limitée à un sous-réseau spécifique et doit utiliser User Datagram Protocol (UDP). Pour Internet Protocol version 4, vous pouvez diffuser sur votre sous-réseau local en envoyant un paquet à l’adresse 255.255.255.255 ; ou vous pouvez utiliser l’adresse de diffusion dirigée, qui est la partie du réseau d’une adresse IP (Internet Protocol) avec tous les bits définis dans la partie hôte.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</source>
          <target state="translated">Par exemple, si votre adresse IP est 192.168.1.40 (une adresse de classe C, avec un masque de sous-réseau de 255.255.255.0, la partie réseau étant les trois premiers octets et la partie hôte le dernier octet), votre adresse de diffusion dirigée est 192.168.1.255.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">Définition de cette propriété sur un socket de protocole TCP (Transmission Control) n’aura aucun effet.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>This option is valid for a datagram socket only.</source>
          <target state="translated">Cette option n'est valide que pour un socket datagramme.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Asynchronously accepts an incoming connection attempt.</source>
          <target state="translated">Accepte de manière asynchrone une tentative de connexion entrante.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les octets transférés.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui stocke les informations d'état pour cette opération asynchrone ainsi que toutes les données définies par l'utilisateur.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          <target state="translated">Accepte de manière asynchrone une tentative de connexion entrante et crée un nouvel objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> pour gérer les communications de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data transferred.</source>
          <target state="translated">Cette méthode retourne une mémoire tampon qui contient les données initiales transférées.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> pour gérer la communication avec l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> termine un appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, vous devez créer une méthode de rappel appelée par le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> retourne de la méthode.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">`asyncResult`</ph> paramètre pour obtenir le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sur lequel la tentative de connexion est effectuée.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode mener à bien la tentative de connexion.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated">Le <ph id="ph1">`buffer`</ph> paramètre de cette surcharge contient les données qui a été reçues dans l’appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> et <ph id="ph3">`bytesTransferred`</ph> paramètre contient le nombre d’octets qui ont été transférés dans l’appel.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode est bloquée jusqu'à ce qu’une connexion est en attente dans la file d’attente de connexion entrante.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode accepte la connexion entrante et retourne un nouveau <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> qui peut être utilisé pour envoyer et recevoir des données à partir de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">Le code suivant utilise des exemple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> pour créer et connecter un socket et accepte les 10 premiers octets de données.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">Le délégué de rappel appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> pour terminer la demande asynchrone.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">Le nombre d’octets transmis et les données sont retournées dans le <ph id="ph1">`buffer`</ph> et <ph id="ph2">`bytesTransferred`</ph> paramètres de cette méthode et sont affichés dans la console.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été créé par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> a été appelée au préalable.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph></source>
          <target state="translated">Une erreur s’est produite lors de la tentative d’accès à <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle remote host communication.</source>
          <target state="translated">Accepte de manière asynchrone une tentative de connexion entrante et crée un nouveau <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> pour gérer les communications de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle communication with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> pour gérer la communication avec l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> termine un appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, vous devez créer une méthode de rappel qui implémente le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> retourne de la méthode.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Elle doit accepter le <ph id="ph1">`asyncResult`</ph> paramètre retourné à partir de la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">`asyncResult`</ph> paramètre pour obtenir le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sur lequel la tentative de connexion est effectuée.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode mener à bien la tentative de connexion.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode est bloquée jusqu'à ce qu’une connexion est en attente dans la file d’attente de connexion entrante.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode accepte la connexion entrante et retourne un nouveau <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> qui peut être utilisé pour envoyer et recevoir des données à partir de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The following code example ends an asynchronous request and creates a new <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept an incoming connection request.</source>
          <target state="translated">L’exemple de code suivant met fin à une demande asynchrone et crée un <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à accepter une demande de connexion entrante.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">Pour obtenir un exemple complet illustrant des communications asynchrones avec les sockets, consultez <bpt id="p1">[</bpt>exemples de Code de Socket<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été créé par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>See the Remarks section for more information.</source>
          <target state="translated">Pour plus d'informations, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> a été appelée au préalable.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les octets transférés.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transferred.</source>
          <target state="translated">Nombre d'octets transférés.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui stocke les informations d'état pour cette opération asynchrone ainsi que toutes les données définies par l'utilisateur.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          <target state="translated">Accepte de manière asynchrone une tentative de connexion entrante et crée un nouvel objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> pour gérer les communications de l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data and the number of bytes transferred.</source>
          <target state="translated">Cette méthode retourne une mémoire tampon qui contient les données initiales et le nombre d'octets transférés.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> pour gérer la communication avec l'hôte distant.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> termine un appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, vous devez créer une méthode de rappel appelée par le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> retourne de la méthode.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Elle doit accepter le <ph id="ph1">`asyncResult`</ph> paramètre retourné à partir de la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">`asyncResult`</ph> paramètre pour obtenir le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sur lequel la tentative de connexion est effectuée.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode mener à bien la tentative de connexion.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated">Le <ph id="ph1">`buffer`</ph> paramètre de cette surcharge contient les données qui a été reçues dans l’appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> et <ph id="ph3">`bytesTransferred`</ph> paramètre contient le nombre d’octets qui ont été transférés dans l’appel.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode est bloquée jusqu'à ce qu’une connexion est en attente dans la file d’attente de connexion entrante.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> méthode accepte la connexion entrante et retourne un nouveau <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> qui peut être utilisé pour envoyer et recevoir des données à partir de l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">Le code suivant utilise des exemple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> pour créer et connecter un socket et accepte les 10 premiers octets de données.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">Le délégué de rappel appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> pour terminer la demande asynchrone.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">Le nombre d’octets transmis et les données sont retournées dans le <ph id="ph1">`buffer`</ph> et <ph id="ph2">`bytesTransferred`</ph> paramètres de cette méthode et sont affichés dans la console.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été créé par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> a été appelée au préalable.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Une erreur s'est produite lors de la tentative d'accès à <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous connection request.</source>
          <target state="translated">Met fin à une demande de connexion asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> is a blocking method that completes the asynchronous remote host connection request started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> est une méthode bloquante qui termine la demande de connexion d’hôte distant asynchrone démarrée le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, vous devez créer une méthode de rappel qui implémente le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> retourne.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">La méthode de rappel doit accepter le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retourné par la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> méthode en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> paramètre pour obtenir le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sur lequel la tentative de connexion est effectuée.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> méthode mener à bien la tentative de connexion.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The following code example ends the asynchronous connection attempt.</source>
          <target state="translated">L’exemple de code suivant met fin à la tentative de connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">Pour obtenir un exemple complet illustrant des communications asynchrones avec les sockets, consultez <bpt id="p1">[</bpt>exemples de Code de Socket<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /&gt;</ph> a été précédemment appelé pour la connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information and any user-defined data for this asynchronous operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous disconnect request.</source>
          <target state="translated">Met fin à une demande de déconnexion asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> termine un appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the disconnect completes.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> méthode est bloquée jusqu'à la fin de la déconnexion.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</source>
          <target state="translated">Pour plus d’informations sur les opérations asynchrones, consultez la rubrique de vue d’ensemble de programmation asynchrone dans la bibliothèque MSDN.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">L’exemple de code suivant crée un socket pour la communication asynchrone et envoie des données à un hôte distant.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">Lorsque les données ont été envoyées, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> est appelée pour arrêter l’envoi et l’activité de réception.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated">Puis <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> est appelé pour lancer une demande de déconnexion.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">Le délégué de rappel appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> pour terminer la demande asynchrone.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">Lorsque la demande est terminée, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriété est interrogée pour tester si le socket est déconnecté.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /&gt;</ph> a été précédemment appelé pour la connexion asynchrone.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The disconnect request has timed out.</source>
          <target state="translated">La demande de déconnexion a expiré.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">Met fin à une lecture asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">Met fin à une lecture asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode termine l’opération de lecture asynchrone démarrée dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, vous devez créer une méthode de rappel qui implémente le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> retourne.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">La méthode de rappel doit accepter le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retourné par la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> méthode en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> pour obtenir l’objet d’état passé à la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">Extraire la réception <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à partir de cet objet d’état.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> lira le premier datagramme en file d’attente disponible dans la mémoire tampon réseau entrante.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le <ph id="ph2">`size`</ph> paramètre de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">Pour obtenir les données reçues, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>et extrayez la mémoire tampon contenue dans l’objet d’état obtenu.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Pour annuler un en attente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous read.</source>
          <target state="translated">L’exemple de code suivant met fin à une lecture asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">Pour obtenir un exemple complet illustrant des communications asynchrones avec les sockets, consultez <bpt id="p1">[</bpt>exemples de Code de Socket<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> a été précédemment appelé pour la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> qui stocke l'erreur de socket.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">Met fin à une lecture asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode termine l’opération de lecture asynchrone démarrée dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, vous devez créer une méthode de rappel qui implémente le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> retourne.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">La méthode de rappel doit accepter le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retourné par la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> méthode en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> pour obtenir l’objet d’état passé à la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">Extraire la réception <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à partir de cet objet d’état.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> lira le premier datagramme en file d’attente disponible dans la mémoire tampon réseau entrante.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le <ph id="ph2">`size`</ph> paramètre de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">Pour obtenir les données reçues, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>et extrayez la mémoire tampon contenue dans l’objet d’état obtenu.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> a été précédemment appelé pour la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          <target state="translated">Met fin à une lecture asynchrone en attente à partir d'un point de terminaison spécifique.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If successful, the number of bytes received.</source>
          <target state="translated">En cas de réussite, nombre d'octets reçus.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If unsuccessful, returns 0.</source>
          <target state="translated">En cas d'échec, retourne 0.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> méthode termine l’opération de lecture asynchrone démarrée dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, vous devez créer une méthode de rappel qui implémente le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> retourne.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">La méthode de rappel doit accepter le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retourné par la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> méthode en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> pour obtenir l’objet d’état passé à la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">Extraire la réception <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à partir de cet objet d’état.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> lira le premier datagramme en file d’attente disponible dans la mémoire tampon réseau entrante.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le <ph id="ph2">`size`</ph> paramètre de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> object, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">Pour obtenir les données reçues, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> de l’objet et l’extraction de la mémoire tampon contenue dans l’objet d’état obtenu.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To identify the originating host, extract the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> and cast it to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>.</source>
          <target state="translated">Pour identifier l’hôte d’origine, vous devez extraire le <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> et effectuer un cast en un <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to obtain the IP address and the <ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to obtain the port number.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> méthode pour obtenir l’adresse IP et le <ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> méthode pour obtenir le numéro de port.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The following code example ends a pending asynchronous read from a specific <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant met fin à une lecture asynchrone en attente à partir d’un spécifique <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> a été précédemment appelé pour la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values for the received packet.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> pour le paquet reçu.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> source.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and interface of the received packet.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> et interface du paquet reçu.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          <target state="translated">Met fin à une lecture asynchrone en attente à partir d'un point de terminaison spécifique.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method also reveals more information about the packet than <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph>.</source>
          <target state="translated">Cette méthode révèle également davantage d'informations sur le paquet que <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If successful, the number of bytes received.</source>
          <target state="translated">En cas de réussite, nombre d'octets reçus.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If unsuccessful, returns 0.</source>
          <target state="translated">En cas d'échec, retourne 0.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If the operation has not completed, this method blocks until it does.</source>
          <target state="translated">Si l’opération n’est pas terminée, cette méthode est bloquée jusqu'à ce qu’il effectue.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To perform this operation synchronously, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Pour effectuer cette opération de manière synchrone, utilisez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Examine <ph id="ph1">`ipPacketInformation`</ph> if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">Examinez <ph id="ph1">`ipPacketInformation`</ph> si vous devez savoir si le datagramme a été envoyé à l’aide d’une adresse de multidiffusion ou de diffusion, de monodiffusion.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="endPoint" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="endPoint" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /&gt;</ph> a été précédemment appelé pour la lecture asynchrone.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">Met fin à un envoi asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">Met fin à un envoi asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">En cas de réussite, nombre d'octets envoyés à <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ; sinon, erreur de <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> non valide.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> termine l’opération d’envoi asynchrone démarrée dans <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, vous devez créer une méthode de rappel qui implémente le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> retourne.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">La méthode de rappel doit accepter le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retourné par la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> paramètre pour obtenir de l’envoi <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> se bloque jusqu'à ce que le datagramme est envoyé.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> se bloque jusqu'à ce que la mémoire tampon a été envoyée.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">Si la valeur de retour à partir de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indique que la mémoire tampon n’a pas complètement envoyée, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode là encore, la modification de la mémoire tampon pour stocker les données non envoyées.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous send.</source>
          <target state="translated">L’exemple de code suivant met fin à un envoi asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> a été précédemment appelé pour l'envoi asynchrone.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information for this asynchronous operation.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> stockant les informations d'état de cette demande asynchrone.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> qui stocke l'erreur de socket.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">Met fin à un envoi asynchrone en attente.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">En cas de réussite, nombre d'octets envoyés à <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ; sinon, erreur de <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> non valide.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> termine l’opération d’envoi asynchrone démarrée dans <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, vous devez créer une méthode de rappel qui implémente le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> retourne.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">La méthode de rappel doit accepter le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retourné par la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> paramètre pour obtenir de l’envoi <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> se bloque jusqu'à ce que le datagramme est envoyé.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> se bloque jusqu'à ce que la mémoire tampon a été envoyée.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">Si la valeur de retour à partir de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indique que la mémoire tampon n’a pas complètement envoyée, appelez le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode là encore, la modification de la mémoire tampon pour stocker les données non envoyées.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> a été précédemment appelé pour l'envoi asynchrone.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> stockant les informations d'état de cette opération asynchrone.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Ends a pending asynchronous send of a file.</source>
          <target state="translated">Met fin à un envoi asynchrone en attente d'un fichier.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> termine l’opération d’envoi asynchrone démarrée dans <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, you must create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, vous devez créer une méthode de rappel qui implémente le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> retourne.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">La méthode de rappel doit accepter le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> objet retourné par la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> méthode en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> paramètre pour obtenir de l’envoi <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method to successfully complete the send operation.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> méthode mener à bien l’opération d’envoi.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the datagram is sent.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> bloque jusqu'à ce que le datagramme est envoyé.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> bloque jusqu'à ce que le fichier entier est envoyé.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">L’exemple de code suivant crée et connecte à un socket pour la communication asynchrone et commence à envoyer le fichier « text.txt » en mode asynchrone à l’hôte distant.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">Le délégué de rappel appelle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> pour terminer la transmission.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /&gt;</ph> a été précédemment appelé pour <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> asynchrone.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>See remarks section below.</source>
          <target state="translated">Consultez la section Notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Ends a pending asynchronous send to a specific location.</source>
          <target state="translated">Met fin à un envoi asynchrone en attente vers un emplacement spécifique.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If successful, the number of bytes sent; otherwise, an invalid <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">En cas de réussite, nombre d'octets envoyés ; sinon, erreur de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> non valide.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> termine l’opération d’envoi asynchrone démarrée dans <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, vous devez créer une méthode de rappel qui implémente le <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> retourne.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">La méthode de rappel doit accepter le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retourné par la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> méthode en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Dans la méthode de rappel, appelez le <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> paramètre pour obtenir de l’envoi <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">Après avoir obtenu le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> se bloque jusqu'à ce que le datagramme est envoyé.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the requested number of bytes are sent.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> se bloque jusqu'à ce que le nombre d’octets demandés est envoyé.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The following code example ends an asynchronous send to a specific location.</source>
          <target state="translated">L’exemple de code suivant met fin à un envoi asynchrone à un emplacement spécifique.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> n'a pas été retourné par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /&gt;</ph> a été précédemment appelé pour l'envoi asynchrone.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one process to bind to a port.</source>
          <target state="translated">Obtient ou définit une valeur <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> qui spécifie si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> n'autorise qu'un seul processus à se lier à un port.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one socket to bind to a specific port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> n'autorise qu'un seul socket à se lier à un port spécifique ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph> for Windows Server 2003 and Windows XP Service Pack 2, and <ph id="ph2">&lt;see langword="false" /&gt;</ph> for all other versions.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="true" /&gt;</ph> pour Windows Server 2003 et Windows XP Service Pack 2 et <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour toutes les autres versions.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`false`</ph>, multiple sockets can use the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> est <ph id="ph2">`false`</ph>, plusieurs sockets peuvent utiliser la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode à lier à un port spécifique ; Cependant, un seul des sockets peut effectuer des opérations sur le trafic réseau envoyé au port.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If more than one socket attempts to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</source>
          <target state="translated">Si plus d’un socket tente d’utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> méthode à lier à un port spécifique, puis celui doté de l’adresse IP plus spécifique gère le trafic réseau envoyé à ce port.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the first use of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to that port will fail until the original bound socket is destroyed.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> est <ph id="ph2">`true`</ph>, la première utilisation de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode à essayer de se lier à un port particulier, quel que soit l’adresse IP (Internet Protocol) réussit ; toutes les autres utilisations de la <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode à essayer de se lier à ce port sera échouer jusqu'à ce que le socket lié d’origine est détruit.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>This property must be set before <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> is called; otherwise an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown.</source>
          <target state="translated">Cette propriété doit être définie avant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> est appelée ; sinon une <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> has been called for this <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> a été appelé pour ce <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>Frees resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Libère les ressources utilisées par la classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class finalizer calls the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to close the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and free resources associated with the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe finaliseur appelle la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode pour fermer le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> et libérer les ressources associées à la <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Returns the value of a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          <target state="translated">Retourne la valeur d'une option <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Returns the value of a specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option, represented as an object.</source>
          <target state="translated">Retourne la valeur d'une option <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> spécifiée, représentée sous la forme d'un objet.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An object that represents the value of the option.</source>
          <target state="translated">Objet représentant la valeur de l'option.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When the <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> parameter is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.Linger" /&gt;</ph> the return value is an instance of the <ph id="ph3">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> class.</source>
          <target state="translated">Si le paramètre <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> a la valeur du champ <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.Linger" /&gt;</ph>, la valeur de retour est une instance de la classe <ph id="ph3">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /&gt;</ph>, the return value is an instance of the <ph id="ph4">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> class.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> a la valeur du champ <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /&gt;</ph>, la valeur de retour est une instance de la classe <ph id="ph4">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is any other value, the return value is an integer.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> a une autre valeur, la valeur de retour est un entier.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options déterminent le comportement d’actuel <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Use this overload to get the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">Utilisez cette surcharge pour obtenir le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, et <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated">Pour le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> pour la <ph id="ph3">`optionLevel`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated">Pour <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, utilisez <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you want to set the value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez définir la valeur d’une des options ci-dessus, utilisez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">Le code suivant exemple récupère la <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> les valeurs de délai d’expiration et les affiche dans la console.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> was set to the unsupported value <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> avait la valeur <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /&gt;</ph> non prise en charge.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is to receive the option setting.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> devant recevoir la valeur de l'option.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Returns the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option setting, represented as a byte array.</source>
          <target state="translated">Retourne la valeur de l'option <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> spécifiée sous la forme d'un tableau d'octets.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options déterminent le comportement d’actuel <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Upon successful completion of this method, the array specified by the <ph id="ph1">`optionValue`</ph> parameter contains the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option.</source>
          <target state="translated">En cas de réussite de cette méthode, le tableau spécifié par le <ph id="ph1">`optionValue`</ph> paramètre contient la valeur de l’objet <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>When the length of the <ph id="ph1">`optionValue`</ph> array is smaller than the number of bytes required to store the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Lorsque la longueur de la <ph id="ph1">`optionValue`</ph> tableau est inférieure au nombre d’octets requis pour stocker la valeur de l’objet <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> lèvera une <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">Utilisez cette surcharge pour tous les sockets qui sont représentés par des valeurs booléennes ou des entiers.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">Le code suivant exemple récupère la <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> les valeurs de délai d’expiration et les affiche dans la console.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          <target state="translated">Dans les applications .NET Compact Framework, l'espace de mémoire tampon par défaut de Windows CE est de 32 768 octets.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          <target state="translated">Vous pouvez modifier l'espace de mémoire tampon de chaque socket en appelant <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The length, in bytes, of the expected return value.</source>
          <target state="translated">Longueur (en octets) de la valeur de retour attendue.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Returns the value of the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option in an array.</source>
          <target state="translated">Retourne la valeur de l'option <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> spécifiée dans un tableau.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the value of the socket option.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant la valeur de l'option de socket.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">`optionLength`</ph> parameter sets the maximum size of the returned byte array.</source>
          <target state="translated">Le <ph id="ph1">`optionLength`</ph> paramètre définit la taille maximale du tableau d’octets retourné.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires fewer bytes, the array will contain only that many bytes.</source>
          <target state="translated">Si la valeur de l’option nécessite moins d’octets, le tableau contient uniquement le nombre d’octets.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires more bytes, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de l’option nécessite davantage d’octets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">Utilisez cette surcharge pour tous les sockets qui sont représentés par des valeurs booléennes ou des entiers.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">Le code suivant exemple récupère la <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> les valeurs de délai d’expiration et les affiche dans la console.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          <target state="translated">Dans les applications .NET Compact Framework, l'espace de mémoire tampon par défaut de Windows CE est de 32 768 octets.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          <target state="translated">Vous pouvez modifier l'espace de mémoire tampon de chaque socket en appelant <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Handle">
          <source>Gets the operating system handle for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtient le handle du système d'exploitation pour <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Handle">
          <source>An <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that represents the operating system handle for the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> qui représente le handle du système d'exploitation pour <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Définit les modes de fonctionnement de bas niveau de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          <target state="translated">Valeur <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> qui spécifie le code de contrôle de l'opération à exécuter.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the input data required by the operation.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant les données d'entrée requises par l'opération.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the output data returned by the operation.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant les données de sortie retournées par l'opération.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using numerical control codes.</source>
          <target state="translated">Définit les modes de fonctionnement de bas niveau de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> à l'aide de codes de contrôle numériques.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          <target state="translated">Nombre d'octets dans le paramètre <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> method provides low-level access to the operating system <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> méthode fournit un accès de bas niveau du système d’exploitation <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sous-jacent de l’instance actuelle de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">Pour plus d’informations, consultez la documentation de WSAIoctl dans MSDN library.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of FIONREAD and the Available property.</source>
          <target state="translated">L’exemple de code suivant compare les résultats de FIONREAD et la propriété disponible.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          <target state="translated">Une tentative de modification du mode blocage sans utiliser la propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> a été effectuée.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">Pour exécuter du code non managé.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          <target state="translated">Valeur <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> qui spécifie le code de contrôle de l'opération à exécuter.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the input data required by the operation.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant les données d'entrée requises par l'opération.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the output data returned by the operation.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant les données de sortie retournées par l'opération.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> enumeration to specify control codes.</source>
          <target state="translated">Définit les modes de fonctionnement de bas niveau de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> à l'aide de l'énumération <ph id="ph2">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> afin de spécifier les codes de contrôle.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          <target state="translated">Nombre d'octets dans le paramètre <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This method provides low-level access to the operating system <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">Cette méthode fournit l’accès au système d’exploitation de bas niveau <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sous-jacent de l’instance actuelle de la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">Pour plus d’informations, consultez la documentation de WSAIoctl dans MSDN library.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> with <ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph> and the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant compare les résultats de l’appel de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> avec <ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph> et <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          <target state="translated">Une tentative de modification du mode blocage sans utiliser la propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> a été effectuée.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">Pour exécuter du code non managé.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a specific local port.</source>
          <target state="translated">Obtient une valeur qui indique si <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> est lié à un port local spécifique.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a local port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> est lié à un port local ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>A socket is considered bound to a local port if it is explicitly bound by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or implicitly bound by calling members like <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a well-known port so that clients may connect to them.</source>
          <target state="translated">Un socket est considéré comme lié à un port local s’il est lié explicitement en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode), ou lié implicitement en appelant des membres comme <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, qui utilisent un port local éphémère (port libre supérieur à 1024, sélectionné par le système d’exploitation.) Les serveurs utilisent la <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode pour lier à un port connu afin que les clients peuvent se connecter à ceux-ci.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Gets or sets a value that specifies whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will delay closing a socket in an attempt to send all pending data.</source>
          <target state="translated">Obtient ou définit une valeur qui spécifie si <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> doit différer la fermeture d'un socket lors d'une tentative d'envoi de l'ensemble des données en attente.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> that specifies how to linger while closing a socket.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> qui spécifie comment maintenir un socket lors de sa fermeture.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property changes the way <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method behaves.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriété modifie la façon dont <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> se comporte de la méthode.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property when set modifies the conditions under which the connection can be reset by Winsock.</source>
          <target state="translated">Cette propriété lorsque le jeu modifie les conditions sous lesquelles la connexion peut être réinitialisée par Winsock.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Connection resets can still occur based on the IP protocol behavior.</source>
          <target state="translated">Les réinitialisations de connexion peuvent encore se produire en fonction du comportement du protocole IP.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property controls the length of time that a connection-oriented connection will remain open after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> when data remains to be sent.</source>
          <target state="translated">Cette propriété contrôle la durée pendant laquelle une connexion orientée connexion restera ouverte après un appel à <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> lorsqu’il reste des données à envoyer.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</source>
          <target state="translated">Lorsque vous appelez des méthodes pour envoyer des données à un homologue, ces données sont placées dans le tampon réseau sortant.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property can be used to ensure that this data is sent to the remote host before the <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> method drops the connection.</source>
          <target state="translated">Cette propriété peut être utilisée pour vous assurer que ces données sont envoyées à l’hôte distant avant du <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> méthode supprime la connexion.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>To enable lingering, create a <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> instance containing the desired values, and set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property to this instance.</source>
          <target state="translated">Pour activer le maintien, créez un <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> d’instance qui contient les valeurs souhaitées et définir le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriété à cette instance.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following table describes the behavior of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method for the possible values of the <ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> property and the <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">Le tableau suivant décrit le comportement de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode pour les valeurs possibles de la <ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> propriété et la <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> propriété stockée dans le <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.Enabled</source>
          <target state="translated">LingerState.Enabled</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.LingerTime</source>
          <target state="translated">LingerState.LingerTime</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Behavior</source>
          <target state="translated">Comportement</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`false`</ph> (disabled), the default value</source>
          <target state="translated"><ph id="ph1">`false`</ph> (désactivé), la valeur par défaut</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The time-out is not applicable, (default).</source>
          <target state="translated">Le délai d’attente n’est pas applicable, (par défaut).</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the default IP protocol time-out expires.</source>
          <target state="translated">Essaie d’envoyer les données en attente jusqu'à ce que le délai expire.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> (activé)</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A nonzero time-out</source>
          <target state="translated">Un délai d’attente différente de zéro</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</source>
          <target state="translated">Essaie d’envoyer les données en attente jusqu'à ce que le délai spécifié expire, et si la tentative échoue, Winsock réinitialise la connexion.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> (activé)</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A zero timeout.</source>
          <target state="translated">Un délai d’attente nulle.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Discards any pending data.</source>
          <target state="translated">Ignore toutes les données en attente.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>For connection-oriented socket (TCP, for example), Winsock resets the connection.</source>
          <target state="translated">Pour un socket orienté connexion (TCP, par exemple), Winsock réinitialise la connexion.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</source>
          <target state="translated">La pile IP calcule le délai par défaut protocole IP à utiliser en fonction du temps d’aller-retour de la connexion.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>In most cases, the time-out computed by the stack is more relevant than one defined by an application.</source>
          <target state="translated">Dans la plupart des cas, le délai d’attente calculé par la pile est plus pertinent que celui défini par une application.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This is the default behavior for a socket when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is not set.</source>
          <target state="translated">Il s’agit du comportement par défaut pour un socket lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriété n’est pas définie.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> propriété stockée dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriété est supérieure au délai par défaut, le délai par défaut sera toujours appliquer et remplacer.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The maximum length of the pending connections queue.</source>
          <target state="translated">Longueur maximale de la file d'attente des connexions en attente.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Places a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in a listening state.</source>
          <target state="translated">Met <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> dans un état d'écoute.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> causes a connection-oriented <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connection attempts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> provoque un orienté connexion <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> pour écouter les tentatives de connexion entrante.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">`backlog`</ph> parameter specifies the number of incoming connections that can be queued for acceptance.</source>
          <target state="translated">Le <ph id="ph1">`backlog`</ph> paramètre spécifie le nombre de connexions entrantes qui peut être mise en attente d’acceptation.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>To determine the maximum number of connections you can specify, retrieve the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> value.</source>
          <target state="translated">Pour déterminer le nombre maximal de connexions que vous pouvez spécifier, récupérez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> does not block.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> ne bloque pas.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to accept a connection from the queue.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> pour accepter une connexion à partir de la file d’attente.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Vous devez appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> lèvera une <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The backlog parameter is limited to different values depending on the Operating System.</source>
          <target state="translated">Le paramètre backlog est limité à des valeurs différentes selon le système d’exploitation.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You may specify a higher value, but the backlog will be limited based on the Operating System.</source>
          <target state="translated">Vous pouvez spécifier une valeur plus élevée, mais le backlog sera limité en fonction du système d’exploitation.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connections.</source>
          <target state="translated">Le code suivant utilise des exemple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> pour écouter les connexions entrantes.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>Gets the local endpoint.</source>
          <target state="translated">Obtient le point de terminaison local.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using for communications.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> que <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> utilise pour les communications.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property gets an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the local IP address and port number to which your <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is bound.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriété obtient un <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> qui contient le numéro de port et adresse IP local auquel votre <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> est lié.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">Vous devez effectuer un cast <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> à un <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> avant d’extraire des informations.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local port number.</source>
          <target state="translated">Vous pouvez ensuite appeler la <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> méthode pour récupérer l’ordinateur local <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>et le <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> pour récupérer le numéro de port local.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property is usually set after you make a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriété est généralement définie une fois que vous effectuez un appel à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you allow the system to assign your socket's local IP address and port number, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property will be set after the first I/O operation.</source>
          <target state="translated">Si vous permettez au système d’assigner l’adresse IP locale de votre socket et numéro de port, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriété sera définie après la première opération d’e/s.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connection-oriented protocols, the first I/O operation would be a call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Pour les protocoles orientés connexion, la première opération d’e/s est un appel à la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connectionless protocols, the first I/O operation would be any of the send or receive calls.</source>
          <target state="translated">Pour les protocoles sans connexion, la première opération d’e/s est un de l’envoyer ou recevoir des appels.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">L’exemple de code suivant récupère et affiche les points de terminaison locaux et distants.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</source>
          <target state="translated">Obtient ou définit une valeur spécifiant si les paquets multicast sortants sont remis à l'application émettrice.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> receives outgoing multicast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> reçoit les paquets multicast sortants ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Multicast is a scalable method for many-to-many communication on the Internet.</source>
          <target state="translated">La multidiffusion est une méthode évolutive pour les communications de type plusieurs-à-plusieurs sur Internet.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</source>
          <target state="translated">Un processus s’abonne à une adresse de multidiffusion ; Ensuite, tous les paquets envoyés par un processus abonné sont reçus par chaque autre processus abonné à l’adresse de multidiffusion.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">Définition de cette propriété sur un socket de protocole TCP (Transmission Control) n’aura aucun effet.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the stream <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using the Nagle algorithm.</source>
          <target state="translated">Obtient ou définit une valeur <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> spécifiant si le flux de données <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> utilise l'algorithme Nagle.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses the Nagle algorithm; otherwise, <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> utilise l'algorithme Nagle ; sinon, <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</source>
          <target state="translated">L’algorithme Nagle est conçu pour réduire le trafic réseau en obligeant le socket de petits paquets de la mémoire tampon et de combiner et de les envoyer dans un paquet dans certaines circonstances.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>A TCP packet consists of 40 bytes of header plus the data being sent.</source>
          <target state="translated">Un paquet TCP se compose de 40 octets d’en-tête plus les données envoyées.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</source>
          <target state="translated">Lorsque de petits paquets de données sont envoyés avec TCP, la surcharge résultant de l’en-tête TCP peut devenir une partie significative du trafic réseau. Sur les réseaux très chargés, la congestion résultant de cette surcharge peut entraîner de perte de datagrammes et retransmissions, ainsi que les temps de propagation excessive provoquée par la congestion.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</source>
          <target state="translated">L’algorithme Nagle empêche l’émission de nouveaux TCP segmentswhen nouvelles données arrivent de l’utilisateur si toutes les données sur la connexion restent sans accusé de réception.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The majority of network applications should use the Nagle algorithm.</source>
          <target state="translated">La plupart des applications réseau doit utiliser l’algorithme Nagle.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</source>
          <target state="translated">Définition de cette propriété sur un socket de protocole UDP (User Datagram) n’aura aucun effet.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Une erreur s'est produite lors de la tentative d'accès à <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</source>
          <target state="translated">Indique si le système d'exploitation et les cartes réseau sous-jacents prennent en charge le protocole IPv4 (Internet Protocol version 4).</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le système d'exploitation et les cartes réseau prennent en charge le protocole IPv4 ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</source>
          <target state="translated">Indique si le système d'exploitation et les cartes réseau sous-jacents prennent en charge le protocole IPv6 (Internet Protocol version 6).</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv6 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le système d'exploitation et les cartes réseau prennent en charge le protocole IPv6 ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The time to wait for a response, in microseconds.</source>
          <target state="translated">Temps d'attente (en microsecondes) d'une réponse.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Determines the status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Détermine l'état de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> based on the polling mode value passed in the <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> parameter.</source>
          <target state="translated">État du <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> basé sur la valeur de mode d'appel passée dans le paramètre <ph id="ph2">&lt;paramref name="mode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Mode</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Mode</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Return Value</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Valeur de retour</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> has been called and a connection is pending;</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> si la méthode <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> a été appelée et si une connexion est en attente ;</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data is available for reading;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si des données sont disponibles pour la lecture ;</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the connection has been closed, reset, or terminated;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la connexion a été fermée, réinitialisée ou terminée ;</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">sinon, retourne <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>, if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph>, and the connection has succeeded;</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> si une méthode <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> a été utilisée et si la connexion a abouti ;</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data can be sent;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si des données peuvent être envoyées ;</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">sinon, retourne <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> that does not block, and the connection has failed;</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> si une méthode <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> sans blocage a été utilisée et si la connexion a échoué ;</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> is not set and out-of-band data is available;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le champ <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> n'est pas défini et si des données hors bande sont disponibles ;</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">sinon, retourne <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method will check the state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> méthode vérifie l’état de la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`selectMode`</ph> parameter to determine if the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is readable.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph> pour le <ph id="ph2">`selectMode`</ph> paramètre pour déterminer si le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> est accessible en lecture.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph> to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is writable.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph> pour déterminer si le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> est accessible en écriture.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph> to detect an error condition.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph> pour détecter une condition d’erreur.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> will block execution until the specified time period, measured in <ph id="ph2">`microseconds`</ph>, elapses.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> bloque l’exécution jusqu'à ce que la période spécifiée, mesurée en <ph id="ph2">`microseconds`</ph>, s’écoule.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Set the <ph id="ph1">`microSeconds`</ph> parameter to a negative integer if you would like to wait indefinitely for a response.</source>
          <target state="translated">Définir le <ph id="ph1">`microSeconds`</ph> paramètre à un entier négatif si vous souhaitez que d’attendre indéfiniment une réponse.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you want to check the status of multiple sockets, you might prefer to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez vérifier l’état de plusieurs sockets, vous préférerez peut-être utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">Cette méthode ne peut pas détecter certains types de problèmes de connexion, comme un câble réseau rompu, ou que l’hôte distant a été arrêté de manière anormale.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">Vous devez essayer d’envoyer ou recevoir des données pour détecter ces types d’erreurs.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The following code example creates a socket, connects to a server, and uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> to check the status of the socket.</source>
          <target state="translated">L’exemple de code suivant crée un socket, se connecte à un serveur et utilise <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> pour vérifier l’état du socket.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> ne fait pas partie des valeurs <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>See remarks below.</source>
          <target state="translated">Consultez la section Notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>Gets the protocol type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtient le type de protocole de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> property is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created, and specifies the protocol used by that <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> propriété est définie lorsque le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> est créé et spécifie le protocole utilisé par cette <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">Le code suivant exemple affiche la <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> à la console.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Reçoit des données d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> lié.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer.</source>
          <target state="translated">Reçoit les données d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> lié dans une mémoire tampon de réception.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus correctement.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Vous pouvez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> à partir de sockets orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This overload only requires you to provide a receive buffer.</source>
          <target state="translated">Cette surcharge nécessite uniquement de fournir un mémoire tampon de réception.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">Valeur par défaut est 0, la taille équivaut à la longueur du paramètre de mémoire tampon, offset de mémoire tampon et la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valeur par défaut, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> vous permettra de recevoir des données en provenance de n’importe quel hôte.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Si vous utilisez une connexion orientée <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit autant de données n’est disponible, jusqu'à la taille de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez une connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de la <ph id="ph1">`buffer`</ph> paramètre, <ph id="ph2">`buffer`</ph> est rempli avec la première partie du message, les données excédentaires sont perdues et un <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The following code example receives data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant reçoit des données sur un connecté <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">Liste des <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s de type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données reçues.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers.</source>
          <target state="translated">Reçoit les données d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> lié dans la liste des mémoires tampon de réception.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This method reads data into the buffers parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Cette méthode lit les données dans le paramètre de mémoires tampons et retourne le nombre d’octets lus correctement.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Vous pouvez appeler à partir de sockets orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">Cette surcharge, vous devez fournir une ou plusieurs mémoires tampons de réception.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit uniquement les données qui arrivent de la connexion d’hôte distant établie dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> vous permettra de recevoir des données en provenance de n’importe quel hôte.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Si vous utilisez une connexion orientée <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit autant de données n’est disponible, jusqu'à la taille de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez une connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de la <ph id="ph1">`buffers`</ph> paramètre, <ph id="ph2">`buffers`</ph> est rempli avec la première partie du message, les données excédentaires sont perdues et un <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated"><bpt id="p1">**</bpt>Remarque<ept id="p1">**</ept> ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">Une erreur s'est produite lors de la tentative d'accès au socket.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Reçoit les données d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> lié dans une mémoire tampon de réception, à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus correctement.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Vous pouvez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> à partir de sockets orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Cette surcharge nécessite uniquement à fournir un mémoire tampon de réception et nécessaires <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</source>
          <target state="translated">Offset de mémoire tampon par défaut, 0, et la taille par défaut est la longueur du paramètre d’octet.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> vous permettra de recevoir des données en provenance de n’importe quel hôte.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, puis réessayez votre opération de réception.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available up to the size of the buffer.</source>
          <target state="translated">Si vous utilisez une connexion orientée <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit autant de données est disponible jusqu'à la taille de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez une connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de la <ph id="ph1">`buffer`</ph> paramètre, <ph id="ph2">`buffer`</ph> est rempli avec la première partie du message, les données excédentaires sont perdues et un <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for receiving data on a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant spécifie une mémoire tampon de données, et <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> pour recevoir des données sur un connecté <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">Liste des <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s de type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données reçues.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Reçoit les données d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> lié dans la liste des mémoires tampon de réception, à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Cette méthode lit les données dans le <ph id="ph1">`buffers`</ph> paramètre et retourne le nombre d’octets lus correctement.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Vous pouvez appeler à partir de sockets orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">Cette surcharge, vous devez fournir une ou plusieurs mémoires tampons de réception.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valeur par défaut, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit uniquement les données qui arrivent de la connexion d’hôte distant établie dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> vous permettra de recevoir des données en provenance de n’importe quel hôte.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> appeler lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Si vous utilisez une connexion orientée <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit autant de données n’est disponible, jusqu'à la taille de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez une connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de la <ph id="ph1">`buffers`</ph> paramètre, <ph id="ph2">`buffers`</ph> est rempli avec la première partie du message, les données excédentaires sont perdues et un <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates how to receive data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment recevoir des données sur un connecté <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count est égal à zéro.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">Une erreur s'est produite lors de la tentative d'accès au socket.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes of data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Reçoit le nombre spécifié d'octets de données d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> lié dans une mémoire tampon de réception, à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit les données dans le <ph id="ph2">`buffer`</ph> paramètre et retourne le nombre d’octets lus correctement.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Vous pouvez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> à partir de sockets orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Cette surcharge nécessite uniquement de disposer d’un mémoire tampon de réception, le nombre d’octets à recevoir et nécessaires <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> vous permettra de recevoir des données en provenance de n’importe quel hôte.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, puis réessayez votre opération de réception.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the <ph id="ph3">`size`</ph> parameter.</source>
          <target state="translated">Si vous utilisez une connexion orientée <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le <ph id="ph3">`size`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez une connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de la <ph id="ph1">`buffer`</ph> paramètre, <ph id="ph2">`buffer`</ph> est rempli avec la première partie du message, les données excédentaires sont perdues et un <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following receives the data found into <ph id="ph1">`buffer`</ph>, and specifies <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">L’exemple suivant reçoit les données se trouvant dans <ph id="ph1">`buffer`</ph>et spécifie <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> pour <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> dépasse la taille de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">Liste des <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s de type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données reçues.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> qui stocke l'erreur de socket.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Reçoit les données d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> lié dans la liste des mémoires tampon de réception, à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Cette méthode lit les données dans le <ph id="ph1">`buffers`</ph> paramètre et retourne le nombre d’octets lus correctement.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Vous pouvez appeler à partir de sockets orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">Cette surcharge, vous devez fournir une ou plusieurs mémoires tampons de réception.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valeur par défaut, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit uniquement les données qui arrivent de la connexion d’hôte distant établie dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> vous permettra de recevoir des données en provenance de n’importe quel hôte.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> appeler lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Si vous utilisez une connexion orientée <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit autant de données n’est disponible, jusqu'à la taille de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez une connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de la <ph id="ph1">`buffers`</ph> paramètre, <ph id="ph2">`buffers`</ph> est rempli avec la première partie du message, les données excédentaires sont perdues et un <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count est égal à zéro.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">Une erreur s'est produite lors de la tentative d'accès au socket.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l’emplacement de stockage des données reçues.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          <target state="translated">Emplacement dans <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> où stocker les données reçues.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the specified offset position of the receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Reçoit le nombre spécifié d'octets d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> lié dans la position d'offset spécifiée de la mémoire tampon de réception, à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus correctement.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Vous pouvez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> à partir de sockets orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> vous permettra de recevoir des données en provenance de n’importe quel hôte.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>See Remarks below.</source>
          <target state="translated">Consultez les notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">Si vous utilisez une connexion orientée <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le paramètre de taille.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez une connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de la <ph id="ph1">`buffer`</ph> paramètre, <ph id="ph2">`buffer`</ph> est rempli avec la première partie du message, les données excédentaires sont perdues et un <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant spécifie une mémoire tampon, un offset, une taille et un indicateur de socket avant la réception de données sur un connecté <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> n’est pas une combinaison valide de valeurs.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> n'a pas été définie.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Une erreur du système d’exploitation se produit pendant l’accès au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">Position dans le paramètre <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> où stocker les données reçues.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> qui stocke l'erreur de socket.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Reçoit les données d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> lié dans une mémoire tampon de réception, à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus correctement.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Vous pouvez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> à partir de sockets orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante avant d’appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> vous permettra de recevoir des données en provenance de n’importe quel hôte.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>See Remarks below.</source>
          <target state="translated">Consultez les notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">Si vous utilisez une connexion orientée <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le paramètre de taille.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez une connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de la <ph id="ph1">`buffer`</ph> paramètre, <ph id="ph2">`buffer`</ph> est rempli avec la première partie du message, les données excédentaires sont perdues et un <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> n’est pas une combinaison valide de valeurs.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property is not set.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> n'est pas définie.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Une erreur du système d’exploitation se produit pendant l’accès au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Démarre une demande asynchrone pour recevoir les données d'un objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Dans ce cas, l'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> méthode est utilisée sur les sockets connectés ou les sockets sans connexion liés et est utilisée pour lire des données entrantes.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">L’adresse de local doit être connu.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</source>
          <target state="translated">Pour les sockets sans connexion liés, cette fonction restreint les adresses à partir de laquelle les messages reçus sont acceptés.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The function only returns messages from the remote address specified in the connection.</source>
          <target state="translated">La fonction retourne uniquement les messages à partir de l’adresse distante spécifiée dans la connexion.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Messages from other addresses are silently discarded.</source>
          <target state="translated">Les messages à partir d’autres adresses sont ignorés.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> propriété sur le <ph id="ph2">`e`</ph> paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur la demande de lecture.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Les propriétés et événements suivants sur le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objet sont requis pour appeler cette méthode avec succès :</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> Si <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> a la valeur</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> Si <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> a la valeur</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">L’appelant peut affecter la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">Pour les sockets de flux d’octets, les données entrantes sont placées dans la mémoire tampon jusqu'à ce que la mémoire tampon est remplie, la connexion est fermée ou les données en mémoire tampon en interne sont épuisées.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the <ph id="ph1">`e`</ph> parameter.</source>
          <target state="translated">Pour les sockets orientés message, un message entrant est placé dans la mémoire tampon jusqu'à la taille totale de la mémoire tampon associée à la <ph id="ph1">`e`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the message is larger than the buffer, the buffer is filled with the first part of the message.</source>
          <target state="translated">Si le message est supérieur à la mémoire tampon, la mémoire tampon est remplie avec la première partie du message.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For connection-oriented sockets, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</source>
          <target state="translated">Pour les sockets orientés connexion, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> méthode peut indiquer l’arrêt normal du circuit virtuel de l’une des deux façons qui varient selon que le socket est orienté flux d’octets ou message.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</source>
          <target state="translated">Pour les flux d’octets, zéro octets lus indique une fermeture normale et que plus aucun octet ne sera lu.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, where a zero byte message is often allowable, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</source>
          <target state="translated">Pour les sockets orientés message, où un message de zéro octet est souvent autorisé, un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> avec la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> ensemble pour le code d’erreur Winsock WSAEDISCON natif (10101) est utilisé pour indiquer une fermeture normale.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In any case, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</source>
          <target state="translated">Dans tous les cas, un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> avec le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> défini sur le WSAECONNRESET natif Winsock code d’erreur (10054) indique que la fermeture s’est produite.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument was invalid.</source>
          <target state="translated">Un argument n'était pas valide.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> ou <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> sur le paramètre de <ph id="ph3">&lt;paramref name="e" /&gt;</ph> doit référencer des mémoires tampon valides.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          <target state="translated">L'une ou l'autre de ces propriétés peut être définie, mais pas les deux à la fois.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Une opération de socket utilisant l'objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> spécifié dans le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> spécifié était déjà en cours.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Gets or sets a value that specifies the size of the receive buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit une valeur spécifiant la taille de la mémoire tampon de réception de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the receive buffer.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> contenant la taille de la mémoire tampon de réception en octets.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">La valeur par défaut est 8192.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</source>
          <target state="translated">Une plus grande taille de mémoire tampon est potentiellement réduit le nombre d’accusés de réception vides (paquets TCP sans partie données), mais peut également retarder la reconnaissance des difficultés de connexion.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">Envisagez d’augmenter la taille de la mémoire tampon si vous transférez des fichiers volumineux, ou si vous utilisez une bande passante élevée, la latence élevée de la connexion (par exemple, un fournisseur large bande satellite).</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          <target state="translated">La valeur spécifiée pour une opération ensembliste est inférieure à 0.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives a datagram and stores the source endpoint.</source>
          <target state="translated">Reçoit un datagramme et stocke le point de terminaison source.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l’emplacement de stockage des données reçues.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passé par référence, qui représente le serveur distant.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer and stores the endpoint.</source>
          <target state="translated">Reçoit un datagramme dans la mémoire tampon de données et stocke le point de terminaison.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode lit les données dans le <ph id="ph2">`buffer`</ph> paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données ont été envoyées.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive <ph id="ph1">`buffer`</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">Cette surcharge exige uniquement que vous permet de fournir une réception <ph id="ph1">`buffer`</ph>et un <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> qui représente l’hôte distant.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">Offset de mémoire tampon par défaut 0.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The size defaults to the length of the <ph id="ph1">`buffer`</ph> parameter and the <ph id="ph2">`socketFlags`</ph> value defaults to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">La taille par défaut est la longueur de la <ph id="ph1">`buffer`</ph> paramètre et le <ph id="ph2">`socketFlags`</ph> valeur par défaut, <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, vous devez lier explicitement la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à un point de terminaison local à l’aide de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous ne le faites pas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Avec les protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de <ph id="ph1">`buffer`</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode remplira <ph id="ph3">`buffer`</ph> avec autant de messages et lève un <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode avec une mémoire tampon insuffisante.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles.</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Bien que <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode ou acceptez une distant entrantes connexion d’hôte en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous n’établissez ou accepter une connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode), vous obtenez un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Dans les deux cas, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode ignore la <ph id="ph2">`remoteEP`</ph> paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Avec des sockets orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lira autant de données est disponible jusqu'à la taille de <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> doit correspondre à la <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l'emplacement de stockage pour les données reçues.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passé par référence, qui représente le serveur distant.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">Reçoit un datagramme dans la mémoire tampon de données à l'aide du <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié et stocke le point de terminaison.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode lit les données dans le <ph id="ph2">`buffer`</ph> paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données ont été envoyées.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">Cette surcharge exige uniquement que vous permet de fournir une mémoire tampon de réception nécessaires <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>et un <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> qui représente l’hôte distant.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset defaults to 0 and the size defaults to the length of the buffer parameter.</source>
          <target state="translated">Le décalage par défaut, 0 et la taille équivaut à la longueur du paramètre de mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, vous devez lier explicitement la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à un point de terminaison local à l’aide de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous ne le faites pas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Avec les protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de <ph id="ph1">`buffer`</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode remplira <ph id="ph3">`buffer`</ph> avec autant de messages et lève un <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode avec une mémoire tampon insuffisante.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Bien que <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode ou acceptez une distant entrantes connexion d’hôte en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous n’établissez ou accepter une connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode), vous obtenez un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Dans les deux cas, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode ignore la <ph id="ph2">`remoteEP`</ph> paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Avec des sockets orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lira autant de données est disponible jusqu'à la taille de <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> doit correspondre à la <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> sont passés à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l’emplacement de stockage des données reçues.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passé par référence, qui représente le serveur distant.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">Reçoit le nombre spécifié d'octets dans la mémoire tampon de données, à l'aide du <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié et stocke le point de terminaison.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode lit les données dans le <ph id="ph2">`buffer`</ph> paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données ont été envoyées.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">Cette surcharge exige uniquement que vous permet de fournir une mémoire tampon de réception, le nombre d’octets que vous souhaitez recevoir, nécessaires <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>et un <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> qui représente l’hôte distant.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">Offset de mémoire tampon par défaut 0.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Avec les protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de <ph id="ph1">`buffer`</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode remplira <ph id="ph3">`buffer`</ph> avec autant de messages et lève un <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode avec une mémoire tampon insuffisante.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles.</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Bien que <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode ou acceptez une distant entrantes connexion d’hôte en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous n’établissez ou accepter une connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode), vous obtenez un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Dans les deux cas, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode ignore la <ph id="ph2">`remoteEP`</ph> paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Avec des sockets orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lira autant de données est disponible jusqu’au nombre d’octets spécifié par le <ph id="ph2">`size`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, vous devez lier explicitement la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à un point de terminaison local à l’aide de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous ne le faites pas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> doit correspondre à la <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">La taille du tampon et <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> sont passés à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> n’est pas une combinaison valide de valeurs.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> n'a pas été définie.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Une erreur du système d’exploitation se produit pendant l’accès au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l’emplacement de stockage des données reçues.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">Position dans le paramètre <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> où stocker les données reçues.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passé par référence, qui représente le serveur distant.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">Reçoit le nombre d’octets de données spécifié dans l’emplacement de la mémoire tampon spécifié à l’aide des <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> et stocke le point de terminaison.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode lit les données dans le <ph id="ph2">`buffer`</ph> paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données ont été envoyées.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Avec les protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si le datagramme reçu est supérieur à la taille de <ph id="ph1">`buffer`</ph>, le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode remplira <ph id="ph3">`buffer`</ph> avec autant de messages et lève un <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode avec une mémoire tampon insuffisante.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Si aucune donnée n’est disponible pour la lecture, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se bloque jusqu'à ce que les données sont disponibles.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se termine immédiatement et lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriété pour déterminer si les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> est différente de zéro, recommencez l’opération de réception.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Bien que <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode ou acceptez une distant entrantes connexion d’hôte en appelant le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous n’établissez ou accepter une connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode), vous obtenez un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Dans les deux cas, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode ignore la <ph id="ph2">`remoteEP`</ph> paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the amount of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Avec des sockets orientés connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lira autant de données est disponible à concurrence du nombre d’octets spécifié par le <ph id="ph2">`size`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Si l’hôte distant arrête la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connexion avec le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode) et toutes les données disponibles ont été reçues, le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> méthode se termine immédiatement et zéro octet.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, vous devez lier explicitement la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> à un point de terminaison local à l’aide de la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous ne le faites pas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> doit correspondre à la <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset, buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">L’offset, la taille de mémoire tampon, et <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> sont passés à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre de décalage.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> n’est pas une combinaison valide de valeurs.</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> n'a pas été définie.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          <target state="translated">Démarre la réception asynchrone de données à partir d'un périphérique réseau spécifié.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Dans ce cas, l'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method is used primarily to receive data on a connectionless socket.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> méthode est utilisée principalement pour recevoir des données sur un socket sans connexion.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">L’adresse de local doit être connu.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">L’appelant doit définir le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriété le <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> de l’hôte distant à partir de laquelle les données doit être reçu.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> propriété sur le <ph id="ph2">`e`</ph> paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur la demande de lecture.</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Les propriétés et événements suivants sur le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objet sont requis pour appeler cette méthode avec succès :</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">L’appelant peut affecter la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">Pour les sockets orientés message, un message entrant est placé dans la mémoire tampon jusqu'à la taille totale de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> propriétés déterminent où les données sont placées dans la mémoire tampon et la quantité de données.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">Pour les sockets de flux de style octets, données entrantes sont placées dans la mémoire tampon jusqu'à ce que la mémoire tampon est remplie, la connexion est fermée ou les données en mémoire tampon en interne sont épuisées.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> propriétés déterminent où les données sont placées dans la mémoire tampon et la quantité de données.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> ne peut pas être Null.</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Une opération de socket utilisant l'objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> spécifié dans le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> spécifié était déjà en cours.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui est l’emplacement de stockage des données reçues.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">Position dans le paramètre <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> où stocker les données reçues.</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Nombre d'octets à recevoir.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passé par référence, qui représente le serveur distant.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IPPacketInformation" /&gt;</ph> holding address and interface information.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.IPPacketInformation" /&gt;</ph> contenant des informations d’adresse et d’interface.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          <target state="translated">Reçoit le nombre d’octets de données spécifié à l’emplacement de la mémoire tampon spécifié à l’aide des <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifiés, puis stocke les informations de paquet et de point de terminaison.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes received.</source>
          <target state="translated">Nombre d’octets reçus.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> méthode lit les données dans le <ph id="ph2">`buffer`</ph> paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle l’envoi des données, ainsi que des informations sur le paquet reçu.</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> méthode est utilisée principalement pour recevoir des données de message sur un socket sans connexion.</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket's local address must be known.</source>
          <target state="translated">L’adresse de local doit être connu.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">Cette méthode peut uniquement être utilisée avec le datagramme et des sockets bruts.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">Le socket doit être initialisé avec le type de socket défini sur <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">Cela est possible lorsque le socket est construit à l’aide de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For message-oriented sockets, an incoming message is placed into the <ph id="ph1">`buffer`</ph> parameter up to the total size specified in the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Pour les sockets orientés message, un message entrant est placé dans le <ph id="ph1">`buffer`</ph> paramètre jusqu'à la taille totale spécifiée dans le <ph id="ph2">`size`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">`offset`</ph> parameter determines where in the <ph id="ph2">`buffer`</ph> the data is placed.</source>
          <target state="translated">Le <ph id="ph1">`offset`</ph> paramètre détermine où, dans le <ph id="ph2">`buffer`</ph> les données sont placées.</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The actual amount of data placed into the <ph id="ph1">`buffer`</ph> is returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">La quantité réelle de données placée dans le <ph id="ph1">`buffer`</ph> est retourné par la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method automatically method sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> méthode affecte automatiquement la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> option de socket <ph id="ph3">`true`</ph> la première fois qu’elle est appelée pour une donnée <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>However, the returned <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">Toutefois, le texte retourné <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objet n’est valide que pour les paquets qui arrivent à l’ordinateur local une fois que l’option de socket a été définie.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and its first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method will return invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">Si un socket est envoyé entre des paquets lorsqu’il est lié à un point de terminaison local (explicitement par le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode) ou implicitement par l’une de le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> méthodes) et son premier appel à la <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> appels de méthode, à <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> méthode retournera non valide <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objets à ces paquets.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">Pour vous assurer que tous les <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> les objets sont valides, une application doit affecter la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> option de socket <ph id="ph3">`true`</ph> avant qu’il est lié à un point de terminaison local à l’aide de la <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An application can examine the <ph id="ph1">`ipPacketInformation`</ph> parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">Une application peut examiner le <ph id="ph1">`ipPacketInformation`</ph> paramètre si elle a besoin de savoir si le datagramme a été envoyé à l’aide d’une adresse de multidiffusion ou de diffusion, de monodiffusion.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> doit correspondre à la <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> de la <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> utilisé dans <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">\-</ph> or-</source>
          <target state="translated"><ph id="ph1">\-</ph> - ou -</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre de décalage.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> n’est pas une combinaison valide de valeurs.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> n'a pas été définie.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The .NET Framework is running on an AMD 64-bit processor.</source>
          <target state="translated">Le .NET Framework s'exécute sur un processeur AMD 64 bits.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">pour accepter les connexions à partir du réseau.</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          <target state="translated">Démarre la réception asynchrone du nombre spécifié d'octets de données dans l'emplacement spécifié de la mémoire tampon de données, à l'aide du <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /&gt;</ph> spécifié et stocke le point de terminaison ainsi que les informations sur le paquet.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Dans ce cas, l'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> méthode est utilisée principalement pour recevoir des données de message sur un socket sans connexion.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">L’adresse de local doit être connu.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">Cette méthode peut uniquement être utilisée avec le datagramme et des sockets bruts.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">Le socket doit être initialisé avec le type de socket défini sur <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">Cela est possible lorsque le socket est construit à l’aide de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">L’appelant doit définir le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriété le <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> de l’hôte distant à partir de laquelle les données doit être reçu.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Les propriétés et événements suivants sur le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objet sont requis pour appeler cette méthode avec succès :</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">L’appelant peut affecter la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">Pour les sockets orientés message, un message entrant est placé dans la mémoire tampon jusqu'à la taille totale de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> propriétés déterminent où les données sont placées dans la mémoire tampon et la quantité de données.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method automatically sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> méthode définit automatiquement le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> option de socket <ph id="ph3">`true`</ph> la première fois qu’elle est appelée pour une donnée <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>However, the <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">Toutefois, le <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objet n’est valide que pour les paquets qui arrivent à l’ordinateur local une fois que l’option de socket a été définie.</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and the first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method will result in invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">Si un socket est envoyé entre des paquets lorsque le socket est lié à un point de terminaison local (explicitement par le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> méthode ou implicitement par l’une de le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> méthodes) et le premier appel à la <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>(méthode), appels à <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> méthode entraîne n’est pas valide <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objets à ces paquets.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to<ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">Pour vous assurer que tous les <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> les objets sont valides, une application doit affecter la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> option de socket<ph id="ph3">`true`</ph> avant qu’il est lié à un point de terminaison local à l’aide de la <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An application can examine the resulting <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">Une application peut examiner les résultats <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objets s’il doit savoir si le datagramme a été envoyé à l’aide d’une adresse de multidiffusion ou de diffusion, de monodiffusion.</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> ne peut pas être Null.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> call will time out.</source>
          <target state="translated">Obtient ou définit une valeur spécifiant la durée après laquelle un appel <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> synchrone doit expirer.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">Valeur du délai d'expiration exprimée en millisecondes.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">La valeur par défaut est 0, ce qui indique un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">La valeur -1 indique également un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> calls only.</source>
          <target state="translated">Cette option s’applique à synchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> uniquement les appels.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si le délai d’expiration est dépassé, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          <target state="translated">La valeur spécifiée pour une opération ensembliste est inférieure à -1.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>Gets the remote endpoint.</source>
          <target state="translated">Obtient le point de terminaison distant.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> with which the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is communicating.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> avec lequel <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> communique.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property gets the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the remote IP address and port number to which the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is connected.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> propriété obtient le <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> qui contient le distant IP adresse et numéro de port auquel le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> est connecté.</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> contains the default remote IP address and port number with which the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will communicate.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> contient l’adresse IP de l’à distance par défaut et le numéro de port avec lequel le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> communiquera.</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">Vous devez effectuer un cast <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> à un <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> avant d’extraire des informations.</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote port number.</source>
          <target state="translated">Vous pouvez ensuite appeler la <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> méthode pour récupérer l’élément distant <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>et le <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> pour récupérer le numéro de port distant.</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> is set after a call to either <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> est défini après un appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you try to access this property earlier, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous essayez d’accéder à cette propriété plus tôt, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">L’exemple de code suivant récupère et affiche les points de terminaison locaux et distants.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for readability.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> sur <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances à vérifier en ce qui concerne la lisibilité.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for writability.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> sur <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances à vérifier en ce qui concerne la capacité d’écriture.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for errors.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> sur <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances à vérifier en ce qui concerne les erreurs.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The time-out value, in microseconds.</source>
          <target state="translated">La valeur du délai d’expiration exprimée en microsecondes.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>A -1 value indicates an infinite time-out.</source>
          <target state="translated">Une valeur de -1 indique un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Determines the status of one or more sockets.</source>
          <target state="translated">Détermine l’état d’un ou plusieurs sockets.</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> is a static method that determines the status of one or more <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> est une méthode statique qui détermine l’état d’un ou plusieurs <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must place one or more sockets into an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> before you can use the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">Vous devez placer un ou plusieurs sockets dans un <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> avant de pouvoir utiliser le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Check for readability by calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> as the <ph id="ph3">`checkRead`</ph> parameter.</source>
          <target state="translated">Recherchez la lisibilité en appelant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> avec la <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> en tant que le <ph id="ph3">`checkRead`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>To check your sockets for writability, use the <ph id="ph1">`checkWrite`</ph> parameter.</source>
          <target state="translated">Pour vérifier vos sockets pour l’accessibilité en écriture, utilisez la <ph id="ph1">`checkWrite`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>For detecting error conditions, use <ph id="ph1">`checkError`</ph>.</source>
          <target state="translated">Pour détecter les conditions d’erreur, utilisez <ph id="ph1">`checkError`</ph>.</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> will be filled with only those sockets that satisfy the conditions.</source>
          <target state="translated">Après avoir appelé <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>, le <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> sera remplie avec les sockets qui satisfont les conditions.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you are in a listening state, readability means that a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> will succeed without blocking.</source>
          <target state="translated">Si vous êtes dans un état d’écoute, une meilleure lisibilité signifie qu’un appel à <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> réussira sans se bloquer.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have already accepted the connection, readability means that data is available for reading.</source>
          <target state="translated">Si vous avez déjà accepté la connexion, une meilleure lisibilité signifie que les données sont disponibles pour la lecture.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>In these cases, all receive operations will succeed without blocking.</source>
          <target state="translated">Dans ce cas, toutes les opérations de réception aboutiront sans blocage.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Readability can also indicate whether the remote <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> has shut down the connection; in that case a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will return immediately, with zero bytes returned.</source>
          <target state="translated">Lecture peut également indiquer si l’élément distant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> a été fermé la connexion ; dans ce cas d’un appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> est retourné immédiatement, avec zéro octet.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> returns when at least one of the sockets of interest (the sockets in the <ph id="ph2">`checkRead`</ph>, <ph id="ph3">`checkWrite`</ph>, and <ph id="ph4">`checkError`</ph> lists) meets its specified criteria, or the <ph id="ph5">`microSeconds`</ph> parameter is exceeded, whichever comes first.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> Renvoie lorsqu’au moins un des sockets d’intérêt (les sockets dans les <ph id="ph2">`checkRead`</ph>, <ph id="ph3">`checkWrite`</ph>, et <ph id="ph4">`checkError`</ph> répertorie) répond aux critères spécifiés, ou le <ph id="ph5">`microSeconds`</ph> paramètre est dépassé, selon ce qui se produit en premier.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Setting <ph id="ph1">`microSeconds`</ph> to -1 specifies an infinite time-out.</source>
          <target state="translated">Paramètre <ph id="ph1">`microSeconds`</ph> -1 spécifie un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you make a nonblocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, writability means that you have connected successfully.</source>
          <target state="translated">Si vous effectuez un appel non bloquant à <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, accessibilité en écriture signifie que vous êtes connecté avec succès.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you already have a connection established, writability means that all send operations will succeed without blocking.</source>
          <target state="translated">Si vous avez déjà établi une connexion, l’accessibilité en écriture signifie que tous les enverront des opérations réussissent sans se bloquer.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have made a non-blocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the <ph id="ph2">`checkerror`</ph> parameter identifies sockets that have not connected successfully.</source>
          <target state="translated">Si vous avez effectué un appel de non bloquant à <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, le <ph id="ph2">`checkerror`</ph> paramètre identifie les sockets qui n’ont pas été connectés avec succès.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method if you only want to determine the status of a single <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> méthode si vous souhaitez uniquement déterminer l’état d’un seul <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">Cette méthode ne peut pas détecter certains types de problèmes de connexion, comme un câble réseau rompu, ou que l’hôte distant a été arrêté de manière anormale.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">Vous devez essayer d’envoyer ou recevoir des données pour détecter ces types d’erreurs.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> to determine which listening sockets have a connection request.</source>
          <target state="translated">Le code suivant utilise des exemple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> pour déterminer les sockets à l’écoute ayant une demande de connexion.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkRead" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="checkRead" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou est vide.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkWrite" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="checkWrite" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou est vide.</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkError" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="checkError" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou est vide.</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envoie des données à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envoie des données à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’octets envoyés au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envoie des données de façon synchrone à l’hôte distant spécifié dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> méthode et retourne le nombre d’octets envoyé avec succès.</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut être utilisé pour les protocoles orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This overload requires a buffer that contains the data you want to send.</source>
          <target state="translated">Cette surcharge requiert une mémoire tampon qui contient les données que vous souhaitez envoyer.</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valeur par défaut est 0, valeur par défaut est 0 et le nombre d’octets à envoyer équivaut à la taille de la mémoire tampon de décalage de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Si vous n’utilisez pas le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode), vous devez appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant chaque appel à <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant illustre l’envoi de données sur un connecté <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Liste de <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> de type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envoie le jeu de mémoires tampon dans la liste à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’octets envoyés au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut être utilisé pour les protocoles orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">Cette surcharge requiert au moins une mémoire tampon qui contient les données que vous souhaitez envoyer.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Si vous n’utilisez pas le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode), vous devez appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant chaque appel à <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>See remarks section below.</source>
          <target state="translated">Consultez la section Notes ci-dessous.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envoie des données à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’octets envoyés au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envoie des données de façon synchrone à l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> méthode et retourne le nombre d’octets envoyé avec succès.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode peut être utilisée pour les protocoles orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Cette surcharge requiert une mémoire tampon qui contient les données que vous souhaitez envoyer et une combinaison d’opérations de <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated">Offset de mémoire tampon par défaut, 0 et le nombre d’octets à envoyer équivaut à la taille de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter value, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> la valeur du paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Si vous n’utilisez pas le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode), vous devez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant chaque appel à <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Vous devez vous assurer que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant illustre l’envoi de données sur un connecté <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Liste de <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> de type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envoie le jeu de mémoires tampon dans la liste à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté, à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’octets envoyés au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">Cette surcharge requiert au moins une mémoire tampon qui contient les données que vous souhaitez envoyer.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valeur par défaut 0.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketFlags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Si vous n’utilisez pas le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode), vous devez appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant chaque appel à <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          <target state="translated">Le nombre d’octets à envoyer.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Reçoit le nombre spécifié d'octets de données à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté, à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’octets envoyés au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envoie des données de façon synchrone à l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> méthode et retourne le nombre d’octets envoyé avec succès.</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut être utilisé pour les protocoles orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Cette surcharge requiert une mémoire tampon qui contient les données que vous souhaitez envoyer, le nombre d’octets à envoyer et une combinaison d’opérations de bits de n’importe quel <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Si vous n’utilisez pas le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode), vous devez appeler la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant chaque appel à la <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>With a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Avec un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> se bloque jusqu'à ce que le nombre d’octets demandés est envoyé, sauf si un délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets demandé.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Vous devez vous assurer que la taille ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example sends the data found in buffer, and specifies <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant envoie les données de la mémoire tampon et spécifie <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> pour <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0 or exceeds the size of the buffer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0 ou dépasse la taille de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> n’est pas une combinaison valide de valeurs.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the socket.</source>
          <target state="translated">Une erreur du système d'exploitation s'est produite lors de l'accès au socket.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Liste de <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> de type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> qui stocke l'erreur de socket.</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envoie le jeu de mémoires tampon dans la liste à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté, à l'aide du <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’octets envoyés au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">Cette surcharge requiert au moins une mémoire tampon qui contient les données que vous souhaitez envoyer.</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valeur par défaut 0.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketFlags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Si vous n’utilisez pas le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode), vous devez appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant chaque appel à <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">La position dans le tampon de données par laquelle doit commencer l’envoi des données.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          <target state="translated">Le nombre d’octets à envoyer.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envoie le nombre spécifié d’octets de données à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté, à part de l’offset spécifié et avec le <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’octets envoyés au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envoie des données de façon synchrone à l’hôte distant spécifié dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> méthode et retourne le nombre d’octets envoyé avec succès.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut être utilisé pour les protocoles orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Dans cette surcharge, si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Si vous n’utilisez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, vous devez appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant chaque appel à <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Il est OK à utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Vous devez également être sûr que la taille ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> se bloque jusqu'à ce que le nombre d’octets demandés est envoyé, sauf si un délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets demandé.</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant spécifie la mémoire tampon de données, un offset, une taille, et <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> pour l’envoi de données connectée <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> n’est pas une combinaison valide de valeurs.</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Une erreur du système d’exploitation se produit pendant l’accès au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">La position dans le tampon de données par laquelle doit commencer l’envoi des données.</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to send.</source>
          <target state="translated">Le nombre d’octets à envoyer.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> qui stocke l'erreur de socket.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph></source>
          <target state="translated">Envoie le nombre spécifié d'octets de données d'un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté, en démarrant à l'offset spécifié et en utilisant le <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’octets envoyés au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envoie des données de façon synchrone à l’hôte distant spécifié dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> méthode et retourne le nombre d’octets envoyé avec succès.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut être utilisé pour les protocoles orientés connexion et sans connexion.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Dans cette surcharge, si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Si vous n’utilisez pas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, vous devez appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant chaque appel à <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Il est OK à utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> même après avoir établi un hôte distant par défaut avec <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> en effectuant un autre appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Vous devez également être sûr que la taille ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> se bloque jusqu'à ce que le nombre d’octets demandés est envoyé, sauf si un délai d’attente a été définie à l’aide de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la valeur de délai d’attente a été dépassée, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> appel lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets demandé.</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant spécifie la mémoire tampon de données, un offset, une taille, et <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> pour l’envoi de données connectée <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> n’est pas une combinaison valide de valeurs.</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Une erreur du système d’exploitation se produit pendant l’accès au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Envoie des données de façon asynchrone à un objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Dans ce cas, l'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> méthode est utilisée pour écrire des données sortantes à partir d’un ou plusieurs tampons sur un socket orienté connexion.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</source>
          <target state="translated">Cette méthode peut également être utilisée, toutefois, sur les sockets sans connexion que vous ont spécifié un hôte distant sur une opération de connexion.</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Les propriétés et événements suivants sur le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objet sont requis pour appeler cette méthode avec succès :</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> Si <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> a la valeur</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> Si <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> a la valeur</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">L’appelant peut affecter la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph><ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> méthode lève une exception si vous n’appelez pas tout d’abord <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</source>
          <target state="translated">Pour les sockets orientés message, ne dépassez pas la taille maximale du message du fournisseur de services Windows sockets sous-jacent.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEMSGSIZE error code (10040).</source>
          <target state="translated">Si les données sont trop longues à traverser atomiquement le fournisseur de service sous-jacent, aucune donnée n’est transmise et la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> méthode lève une exception un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> avec le <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> défini sur le code d’erreur Winsock WSAEMSGSIZE natif (10040).</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that the successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">Notez que l’achèvement réussi de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> méthode n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> ou <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> sur le paramètre de <ph id="ph3">&lt;paramref name="e" /&gt;</ph> doit référencer des mémoires tampon valides.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          <target state="translated">L'une ou l'autre de ces propriétés peut être définie, mais pas les deux à la fois.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Une opération de socket utilisant l'objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> spécifié dans le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> spécifié était déjà en cours.</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected or was not obtained via an <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>,or <ph id="ph4">&lt;see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /&gt;</ph>, method.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> n'est pas encore connecté ou n'a pas été obtenu via une méthode <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>ou <ph id="ph4">&lt;see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Gets or sets a value that specifies the size of the send buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit une valeur spécifiant la taille de la mémoire tampon d'envoi de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the send buffer.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> contenant la taille de la mémoire tampon d'envoi en octets.</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">La valeur par défaut est 8192.</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>A larger buffer size might delay the recognition of connection difficulties.</source>
          <target state="translated">Une plus grande taille de mémoire tampon peut retarder la reconnaissance des difficultés de connexion.</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">Envisagez d’augmenter la taille de la mémoire tampon si vous transférez des fichiers volumineux, ou si vous utilisez une bande passante élevée, la latence élevée de la connexion (par exemple, un fournisseur large bande satellite).</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          <target state="translated">La valeur spécifiée pour une opération ensembliste est inférieure à 0.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file and optional data synchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envoie de façon synchrone un fichier et des données facultatives à un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> contenant le chemin d’accès et le nom du fichier à envoyer.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object with the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> transmit flag.</source>
          <target state="translated">Envoie le fichier <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> à un objet <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté avec l'indicateur de transmission <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">Cette surcharge envoie le fichier <ph id="ph1">`fileName`</ph> au socket connecté.</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">`flags`</ph> parameter defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0), and the <ph id="ph3">`preBuffer`</ph> and <ph id="ph4">`postBuffer`</ph> parameters default to <ph id="ph5">`null`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`flags`</ph> paramètre par défaut est <ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0) et le <ph id="ph3">`preBuffer`</ph> et <ph id="ph4">`postBuffer`</ph> les paramètres par défaut <ph id="ph5">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Si <ph id="ph1">`fileName`</ph> est dans le répertoire local, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Les caractères génériques («.. <ph id="ph1">\\</ph>\myfile.txt ») et les noms de partage UNC («<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared active<ph id="ph5">\\</ph>\myfile.txt ») sont pris en charge.</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Si le fichier est introuvable, l’exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Cette méthode utilise le <ph id="ph1">`TransmitFile`</ph> de trouver la fonction dans l’API Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur la <ph id="ph1">`TransmitFile`</ph> fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> envoie de façon synchrone un fichier à l’hôte distant spécifié dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> peut être utilisé pour les orientés connexion et les protocoles sans connexion.</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode, sinon <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> lève une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the file is sent.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> bloque jusqu'à ce que le fichier est envoyé.</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> peut se terminer correctement avant de l’intégralité du fichier a été envoyé.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The following code example creates and connects a socket and then sends a file to the remote host.</source>
          <target state="translated">L’exemple de code suivant crée et connecte à un socket et envoie ensuite un fichier à l’hôte distant.</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">Le fichier « test.txt » se trouve dans le répertoire racine de l’ordinateur local.</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">Le socket n’est pas connecté à un hôte distant.</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> n’est pas en mode blocage et ne peut pas accepter cet appel synchrone.</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">Le fichier <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> contenant le chemin d’accès et le nom du fichier à envoyer.</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant les données à envoyer avant l’envoi du fichier.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant les données à envoyer après l’envoi du fichier.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ce paramètre peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>One or more of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          <target state="translated">Une ou plusieurs des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> and buffers of data to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the specified <ph id="ph3">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> value.</source>
          <target state="translated">Envoie le <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> et les tampons de données du fichier à un objet <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté à l’aide de la valeur <ph id="ph3">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">Cette surcharge requiert le nom du fichier à envoyer et une combinaison d’opérations de <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated">Le <ph id="ph1">`preBuffer`</ph> paramètre contient les données que vous voulez faire précéder le fichier.</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> contient des données que vous souhaitez suivre le fichier.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If <ph id="ph1">`fileName`</ph> is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Si <ph id="ph1">`fileName`</ph> est dans le répertoire de travail actuel, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Les caractères génériques («.. <ph id="ph1">\\</ph>\myfile.txt ») et les noms de partage UNC («<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared active<ph id="ph5">\\</ph>\myfile.txt ») sont pris en charge.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated">Le <ph id="ph1">`flags`</ph> paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur le transfert de fichiers.</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Cette méthode utilise le <ph id="ph1">`TransmitFile`</ph> de trouver la fonction dans l’API Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur la <ph id="ph1">`TransmitFile`</ph> fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> envoie de façon synchrone un fichier à l’hôte distant spécifié dans le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> peut être utilisé pour les orientés connexion et les protocoles sans connexion.</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method; otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous devez appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> avant d’appeler cette méthode ; sinon <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> lève une <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> pour établir une connexion d’hôte distant ou utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> pour accepter une connexion entrante.</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> bloque jusqu'à ce que le fichier entier est envoyé.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">En mode non bloquant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> peut se terminer correctement avant de l’intégralité du fichier a été envoyé.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The following code example creates and connects a socket.</source>
          <target state="translated">L’exemple de code suivant crée et connecte à un socket.</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">Le fichier « test.txt » se trouve dans le répertoire racine de l’ordinateur local.</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</source>
          <target state="translated">Dans cet exemple, nous créer un prebuffer et une post-mémoire tampon de données et les envoyer à l’hôte distant avec le fichier.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The default <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> are used.</source>
          <target state="translated">La valeur par défaut <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> sont utilisés.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The operating system is not Windows NT or later.</source>
          <target state="translated">Le système d'exploitation n'est pas Windows NT ou une version ultérieure.</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">Le socket n’est pas connecté à un hôte distant.</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> n’est pas en mode blocage et ne peut pas accepter cet appel synchrone.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">Le fichier <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends a collection of files or in memory data buffers asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Envoie une collection de fichiers ou des données mises en mémoire tampon de façon asynchrone à un objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connecté.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Dans ce cas, l'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is used to send a collection of files or in memory data buffers to remote host.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> méthode est utilisée pour envoyer des tampons de données de collection de fichiers ou dans la mémoire à l’hôte distant.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> must already be connected to the remote host.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> doit déjà être connecté à l’hôte distant.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a <ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph> références à un fichier dans le répertoire de travail, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Wildcards and UNC share names are supported.</source>
          <target state="translated">Les caractères génériques et les noms de partage UNC sont pris en charge.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Si le fichier est introuvable, <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; et l’attacher le rappel pour le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> propriété sur le <ph id="ph2">`e`</ph> paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur le transfert de fichiers.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Les propriétés et événements suivants sur le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objet sont requis pour appeler cette méthode avec succès :</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">L’appelant peut affecter la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method uses the TransmitPackets function found in the Windows Sockets 2 API.</source>
          <target state="translated">Cette méthode utilise la fonction TransmitPackets détectée dans l’API Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur la fonction TransmitPackets et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although intended for connection-oriented protocols, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Bien que destiné à des protocoles orientés connexion, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> méthode fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode pour établir un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre fichier ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Dans ce cas, le datagramme n’est pas envoyé et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> lève une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized according to the operating system on which it is used.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> méthode est optimisée selon le système d’exploitation sur lequel il est utilisé.</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows server editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for high performance.</source>
          <target state="translated">Sur les éditions de Windows server, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> méthode est optimisée pour des performances élevées.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows client editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for minimum memory and resource utilization.</source>
          <target state="translated">Sur les éditions client Windows, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> méthode est optimisée pour une utilisation minimale de mémoire et de ressources.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use of the <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph> flag in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph3">`e`</ph> parameter can deliver significant performance benefits.</source>
          <target state="translated">Utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph> indicateur dans le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> propriété sur le <ph id="ph3">`e`</ph> paramètre peut fournir des gains de performance significatifs.</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the thread initiating the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</source>
          <target state="translated">Si l’initialisation du thread du <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> appel de méthode est utilisé pour les calculs lourds, il est possible, bien que peu probable, qu’appel de procédure asynchrone ne soient pas lancer.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that there is a difference between kernel and user-mode APCs.</source>
          <target state="translated">Notez qu’il existe une différence entre l’appel de procédure asynchrone en mode utilisateur et de noyau.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Kernel APCs launch when a thread is in a wait state.</source>
          <target state="translated">Noyau sont lancés lorsqu’un thread est dans un état d’attente.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>User-mode APCs launch when a thread is in an alertable wait state</source>
          <target state="translated">En mode utilisateur sont lancés lorsqu’un thread est dans un état d’une attente</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The file specified in the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /&gt;</ph> property was not found.</source>
          <target state="translated">Le fichier spécifié dans la propriété <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Une opération de socket utilisant l'objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> spécifié dans le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> spécifié était déjà en cours.</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not connected to a remote host.</source>
          <target state="translated">Cette exception se produit également si le <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> n'est pas connecté à un hôte distant.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A connectionless <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> sans connexion est utilisé et le fichier qui est envoyé dépasse la taille maximale du paquet du transport sous-jacent.</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> call will time out.</source>
          <target state="translated">Obtient ou définit une valeur spécifiant la durée après laquelle un appel <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> synchrone doit expirer.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">Valeur du délai d'expiration exprimée en millisecondes.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If you set the property with a value between 1 and 499, the value will be changed to 500.</source>
          <target state="translated">Si vous affectez à la propriété une valeur comprise entre 1 et 499, cette valeur est remplacée par 500.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">La valeur par défaut est 0, ce qui indique un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">La valeur -1 indique également un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> calls only.</source>
          <target state="translated">Cette option s’applique à synchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> uniquement les appels.</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si le délai d’expiration est dépassé, le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> méthode lève un <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          <target state="translated">La valeur spécifiée pour une opération ensembliste est inférieure à -1.</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a specific endpoint.</source>
          <target state="translated">Envoie les données à un point de terminaison spécifique.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination for the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> qui représente la destination des données.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Sends data to the specified endpoint.</source>
          <target state="translated">Envoie les données au point de terminaison spécifié.</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">Nombre d’octets envoyés.</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph> parameter, and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">Dans cette surcharge, offset de mémoire tampon par défaut, 0, le nombre d’octets à envoyer équivaut à la taille de la <ph id="ph1">`buffer`</ph> paramètre et le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valeur par défaut 0.</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez procéder ainsi si vous voulez appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, le <ph id="ph3">`remoteEP`</ph> paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Vous ne devez pas également pour appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriété après la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> terminée.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Bien que destiné aux protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> fonctionne également avec les protocoles orientés connexion.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode ou acceptez une demande de connexion entrante à l’aide du <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous n’établissez ou accepter une connexion d’hôte distant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">Dans les deux cas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignorera le <ph id="ph2">`remoteEP`</ph> paramètre et uniquement envoyer les données vers le connectée ou un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Blocking sockets will block until the all of the bytes in the buffer are sent.</source>
          <target state="translated">Sockets bloquants se bloquent jusqu'à ce que tous les octets de la mémoire tampon sont envoyés.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Dans la mesure où un non bloquant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> se termine immédiatement, il peut ne pas envoyer tous les octets dans le <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie tous les octets dans le <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion en mode blocage, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> se bloque jusqu'à ce que le datagramme est envoyé.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Vous devez également être sûr que le nombre d’octets envoyés ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> qui représente l'emplacement de destination des données.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends data to a specific endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envoie des données à un point de terminaison spécifique à l'aide du <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">Nombre d’octets envoyés.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">Dans cette surcharge, offset de mémoire tampon par défaut, 0 et le nombre d’octets à envoyer équivaut à la taille de la <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez procéder ainsi si vous voulez appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, le <ph id="ph3">`remoteEP`</ph> paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Vous ne devez pas également pour appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriété après la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> terminée.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Bien que destiné aux protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> fonctionne également avec les protocoles orientés connexion.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode ou acceptez une demande de connexion entrante à l’aide du <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous n’établissez ou accepter une connexion d’hôte distant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">Dans les deux cas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignorera le <ph id="ph2">`remoteEP`</ph> paramètre et uniquement envoyer les données vers le connectée ou un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested all of the bytes in the <ph id="ph1">`buffer`</ph> are sent.</source>
          <target state="translated">Sockets bloquants se bloquent jusqu'à ce que demandé tous les octets dans le <ph id="ph1">`buffer`</ph> sont envoyés.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Dans la mesure où un non bloquant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> se termine immédiatement, il peut ne pas envoyer tous les octets dans le <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie tous les octets dans le <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion en mode blocage, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> se bloque jusqu'à ce que le datagramme est envoyé.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Vous devez également être sûr que le nombre d’octets envoyés ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> sont passés à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          <target state="translated">Le nombre d’octets à envoyer.</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> qui représente l'emplacement de destination des données.</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envoie le nombre spécifié d'octets de données au point de terminaison spécifié à l'aide du <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">Nombre d’octets envoyés.</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0.</source>
          <target state="translated">Dans cette surcharge, offset de mémoire tampon par défaut 0.</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez procéder ainsi si vous voulez appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, le <ph id="ph3">`remoteEP`</ph> paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Vous ne devez pas également pour appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié.</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriété après la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> terminée.</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Bien que destiné aux protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> fonctionne également avec les protocoles orientés connexion.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode ou acceptez une demande de connexion entrante à l’aide du <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous n’établissez ou accepter une connexion d’hôte distant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">Dans les deux cas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignorera le <ph id="ph2">`remoteEP`</ph> paramètre et uniquement envoyer les données vers le connectée ou un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">Sockets bloquants se bloquent jusqu'à ce que le nombre d’octets demandés est envoyé.</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">Dans la mesure où un non bloquant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> se termine immédiatement, il peut ne pas envoyer tous les octets demandés en une seule opération.</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion en mode blocage, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> se bloque jusqu'à ce que le datagramme est envoyé.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Vous devez également être sûr que le nombre d’octets envoyés ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié.</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The size and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">La taille et <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> sont passés à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The specified <ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;paramref name="size" /&gt;</ph> spécifié dépasse la taille de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> qui contient les données à envoyer.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">La position dans le tampon de données par laquelle doit commencer l’envoi des données.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          <target state="translated">Le nombre d’octets à envoyer.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> qui représente l'emplacement de destination des données.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envoie le nombre spécifié d'octets de données au point de terminaison spécifié, en commençant à l'emplacement spécifié dans la mémoire tampon et en utilisant le <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">Nombre d’octets envoyés.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Dans cette surcharge, si vous spécifiez la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> doivent être signalées comme le <ph id="ph2">`socketflags`</ph> paramètre, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez procéder ainsi si vous voulez appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode avant d’appeler <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, le <ph id="ph3">`remoteEP`</ph> paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Vous ne devez pas également pour appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriété après la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> terminée.</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Bien que destiné aux protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> fonctionne également avec les protocoles orientés connexion.</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> méthode ou acceptez une demande de connexion entrante à l’aide du <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si vous n’établissez ou accepter une connexion d’hôte distant, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">Dans les deux cas, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignorera le <ph id="ph2">`remoteEP`</ph> paramètre et uniquement envoyer les données vers le connectée ou un hôte distant par défaut.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">Sockets bloquants se bloquent jusqu'à ce que le nombre d’octets demandés est envoyé.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">Depuis un non bloquant <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> se termine immédiatement, il peut ne pas envoyer tous les octets demandés en une seule opération.</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Il vous incombe applications pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Un état de réussite de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion en mode blocage, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> se bloque jusqu'à ce que le datagramme est envoyé.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Vous devez également être sûr que la taille ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié.</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The offset, size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">L’offset, la taille et <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> sont passés à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est supérieur à la longueur de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> moins la valeur du paramètre <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> n’est pas une combinaison valide de valeurs.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Une erreur du système d’exploitation se produit pendant l’accès au <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Un appelant de la pile des appels ne dispose pas des autorisations requises.</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> à utiliser pour cette opération de socket asynchrone.</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a specific remote host.</source>
          <target state="translated">Envoie des données de façon asynchrone à un hôte distant spécifique.</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération d'E/S est en attente.</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">L'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> sera déclenché une fois l'opération terminée.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retourne la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> si l'opération d'E/S a été terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Dans ce cas, l'événement <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> sur le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> ne sera pas déclenché et l'objet <ph id="ph3">&lt;paramref name="e" /&gt;</ph> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph3">`e`</ph> parameter.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> méthode démarre une opération d’envoi asynchrone à l’hôte distant spécifié dans le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriété de le <ph id="ph3">`e`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although this method is intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">Bien que cette méthode est conçue pour les protocoles sans connexion, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> fonctionne avec les protocoles orientés connexion.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; et l’attacher le rappel pour le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Les propriétés et événements suivants sur le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objet sont requis pour appeler cette méthode avec succès :</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">L’appelant peut affecter la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Otherwise <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans le cas contraire <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method will ignore the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque vous utilisez un protocole orienté connexion, la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> ignore (méthode) le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriété et envoyer des données à la <ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph> établie dans le <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> , ou <ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode avant d’appeler <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> methods.</source>
          <target state="translated">Vous pouvez procéder ainsi si vous voulez appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, the <ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property will override the specified default remote host for that send operation only.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> méthode avant d’appeler <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, le <ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriété remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Vous ne devez pas également pour appeler le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</source>
          <target state="translated">Dans ce cas, le fournisseur de service sous-jacent affecte le plus approprié réseau local IP adresse et numéro de port.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">Utiliser un numéro de port de zéro si vous souhaitez que le fournisseur de service sous-jacent pour sélectionner un port libre.</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you need to identify the assigned local network IP address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event is signaled and the associated delegates are called.</source>
          <target state="translated">Si vous avez besoin identifier le réseau local attribué IP adresse et numéro de port, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriété après la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> événement est signalé et que les délégués associés sont appelés.</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph> to true.</source>
          <target state="translated">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> (méthode) et définir le socket option pour <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph> sur true.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Vous devez également être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le datagramme n’enverra pas et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you specify the DontRoute flag in the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property, the data you are sending will not be routed.</source>
          <target state="translated">Si vous spécifiez l’indicateur DontRoute dans le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> propriété, les données que vous envoyez ne sera pas routé.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</source>
          <target state="translated">Pour les sockets orientés message, être vigilant pour ne pas dépasser la taille maximale du message du transport sous-jacent.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Si la taille de la mémoire tampon dépasse la taille de paquet maximale du fournisseur de services sous-jacent, le datagramme n’est pas envoyé et <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> lèvera une <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The successful completion of a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">La réussite d’une <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> méthode n’indique pas que les données a été remises avec succès.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> ne peut pas être Null.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Une opération de socket utilisant l'objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> spécifié dans le paramètre <ph id="ph2">&lt;paramref name="e" /&gt;</ph> spécifié était déjà en cours.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Windows XP ou version ultérieure est requis pour cette méthode.</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The protocol specified is connection-oriented, but the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected.</source>
          <target state="translated">Le protocole spécifié est orienté connexion, mais le <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> n'est pas encore connecté.</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level to set on this socket.</source>
          <target state="translated">Niveau de protection IP à définir sur ce socket.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Set the IP protection level on a socket.</source>
          <target state="translated">Définit le niveau de protection IP sur un socket.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> méthode permet de restreindre un socket IPv6 ou IP à l’écoute d’une portée spécifiée, telle que les adresses avec le même lien locales préfixe ou de site local.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option enables applications to place access restrictions on IPv6 or IP sockets.</source>
          <target state="translated">Cette option de socket permet aux applications de placer des restrictions d’accès sur les sockets IPv6 ou IP.</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</source>
          <target state="translated">Ces restrictions permettent à une application qui s'exécute sur un réseau local privé de se renforcer facilement et efficacement contre les attaques externes.</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option can also be used to remove access restrictions if the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.</source>
          <target state="translated">Cette option de socket peut également être utilisée pour supprimer des restrictions d’accès si le <ph id="ph1">`level`</ph> paramètre est défini sur <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</source>
          <target state="translated">Cette option de socket élargit ou limite la portée d'un socket en écoute, permettant l'accès illimité des utilisateurs publics et privés le cas échéant ou restreignant éventuellement l'accès au même site.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option has defined protection levels specified in the <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph> enumeration.</source>
          <target state="translated">Cette option de socket utilise les niveaux de protection définis spécifiés dans l'énumération <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method is used to enable or disable Network Address Traversal (NAT) for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> méthode est utilisée pour activer ou désactiver la traversée d’adresses réseau (NAT) pour un <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</source>
          <target state="translated">Parcours NAT peut être fourni à l’aide d’un tunnel ISATAP, 6to4 ou Teredo.</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, this explicitly disables NAT traversal for a <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated">Lorsque le <ph id="ph1">`level`</ph> paramètre est défini sur <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, cela désactive explicitement la traversée NAT pour une <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, this may allow NAT traversal for a <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> depending on firewall rules in place on the system.</source>
          <target state="translated">Lorsque le <ph id="ph1">`level`</ph> paramètre est défini sur <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, cela peut permettre de parcours NAT pour une <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> selon les règles de pare-feu en place sur le système.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;paramref name="level" /&gt;</ph> parameter cannot be <ph id="ph2">&lt;see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="level" /&gt;</ph> ne peut pas avoir la valeur <ph id="ph2">&lt;see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level cannot be set to unspecified.</source>
          <target state="translated">Le niveau de protection IP ne peut pas être non spécifié.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> of the socket must be either <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> du socket doit être <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          <target state="translated">Définit une option <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The value of the option, represented as a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'option, représentée en tant que <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph> value.</source>
          <target state="translated">Affecte la valeur <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> spécifiée à l'option <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options déterminent le comportement d’actuel <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Set <ph id="ph1">`optionValue`</ph> to <ph id="ph2">`true`</ph> to enable the option, or to <ph id="ph3">`false`</ph> to disable the option.</source>
          <target state="translated">Définissez <ph id="ph1">`optionValue`</ph> à <ph id="ph2">`true`</ph> pour activer l’option, ou la valeur <ph id="ph3">`false`</ph> pour désactiver l’option.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options sont regroupées par niveau de prise en charge du protocole.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">Vous trouverez ci-dessous les différentes <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value.</source>
          <target state="translated">Ces options sont regroupées par approprié <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">Si vous envisagez de définir l’une de ces options, veillez à utiliser les <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> la valeur pour le <ph id="ph2">`optionLevel`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">L’option que vous choisissez de définir doit être spécifiée dans le <ph id="ph1">`optionName`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez obtenir la valeur actuelle d’une des options répertoriées, utilisez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>For more information on these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">Pour plus d’informations sur ces options, reportez-vous à la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, utilisez la <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The following code example opens a socket and enables the <ph id="ph1">`DontLinger`</ph> and the <ph id="ph2">`OutOfBandInline`</ph> socket options.</source>
          <target state="translated">L’exemple de code suivant ouvre un socket et Active le <ph id="ph1">`DontLinger`</ph> et <ph id="ph2">`OutOfBandInline`</ph> options de socket.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that represents the value of the option.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> représentant la valeur de l'option.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as a byte array.</source>
          <target state="translated">Affecte la valeur spécifiée à l'option <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> spécifiée représentée sous la forme d'un tableau d'octets.</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options déterminent le comportement d’actuel <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload to set those <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that require a byte array as an option value.</source>
          <target state="translated">Utilisez cette surcharge pour définir les <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options qui nécessitent un tableau d’octets comme valeur d’option.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">Le code suivant exemple définit le <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> les valeurs de délai d’attente.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>A value of the option.</source>
          <target state="translated">Valeur de l'option.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified integer value.</source>
          <target state="translated">Affecte la valeur entière spécifiée à l'option <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options déterminent le comportement d’actuel <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</source>
          <target state="translated">Pour une option avec un <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> de type de données, spécifiez une valeur différente de zéro pour activer l’option et une valeur zéro pour désactiver l’option.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with an integer data type, specify the appropriate value.</source>
          <target state="translated">Pour une option avec un type de données integer, spécifiez la valeur appropriée.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options sont regroupées par niveau de prise en charge du protocole.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">Vous trouverez ci-dessous les différentes <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.</source>
          <target state="translated">Ces options sont regroupées par approprié <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">Si vous envisagez de définir l’une de ces options, veillez à utiliser les <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> pour la <ph id="ph2">`optionLevel`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">L’option que vous choisissez de définir doit être spécifiée dans le <ph id="ph1">`optionName`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez obtenir la valeur actuelle d’une des options répertoriées, utilisez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> options qui peuvent être définies à l’aide de cette surcharge.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information about these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">Pour plus d’informations sur ces options, reportez-vous à la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">Le code suivant exemple définit le <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> les valeurs de délai d’attente.</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> that contains the value of the option.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> qui contient la valeur de l'option.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as an object.</source>
          <target state="translated">Affecte la valeur spécifiée à l'option <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> spécifiée représentée sous la forme d'un objet.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options déterminent le comportement d’actuel <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Use this overload to set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">Utilisez cette surcharge pour définir le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, et <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated">Pour le <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, utilisez <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> pour la <ph id="ph3">`optionLevel`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated">Pour <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, utilisez <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you want to get the current value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez obtenir la valeur actuelle d’une des options ci-dessus, utilisez la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time out values.</source>
          <target state="translated">Le code suivant exemple définit le <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> et <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> les valeurs de délai d’attente.</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;paramref name="optionValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionValue" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketShutdown" /&gt;</ph> values that specifies the operation that will no longer be allowed.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketShutdown" /&gt;</ph> spécifiant l'opération qui ne sera plus autorisée.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disables sends and receives on a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Désactive les envois et les réceptions sur un <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>When using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, always call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method before closing the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Lorsque vous utilisez une connexion orientée <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, appelez toujours la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> méthode avant de fermer le <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">Cela garantit que toutes les données est envoyé et reçu sur le socket connecté avant sa fermeture.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to free all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> méthode pour libérer toutes les ressources managées et associés à la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Do not attempt to reuse the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> after closing.</source>
          <target state="translated">N’essayez pas de réutiliser le <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> après la fermeture.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following table shows the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> enumeration values that are valid for the <ph id="ph2">`how`</ph> parameter.</source>
          <target state="translated">Le tableau suivant présente la <ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> des valeurs d’énumération qui sont valides pour le <ph id="ph2">`how`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Value</source>
          <target state="translated">Value</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Send</source>
          <target state="translated">Envoyer</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable sending on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Désactiver l’envoi sur ce <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Receive</source>
          <target state="translated">Receive</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Désactive la réception sur ce <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Both</source>
          <target state="translated">Both</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable both sending and receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Désactiver l’envoi et la réception sur ce <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> are not allowed.</source>
          <target state="translated">Paramètre <ph id="ph1">`how`</ph> à <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> spécifie suivantes qui appelle à <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> ne sont pas autorisés.</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, specifying <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> will have no effect.</source>
          <target state="translated">Si vous utilisez une connexion <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, en spécifiant <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> are not allowed.</source>
          <target state="translated">Paramètre <ph id="ph1">`how`</ph> à <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> spécifie suivantes qui appelle à <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> ne sont pas autorisés.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This has no effect on lower protocol layers.</source>
          <target state="translated">Cela n’a aucun effet sur les couches de protocole inférieures.</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :</source>
          <target state="translated">Si vous utilisez un protocole orienté connexion, la connexion est interrompue si une des conditions suivantes existe après un appel à <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Data is in the incoming network buffer waiting to be received.</source>
          <target state="translated">Les données sont dans la mémoire tampon réseau entrante en attente de réception.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>More data has arrived.</source>
          <target state="translated">Plus de données est arrivé.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless protocol, datagrams are accepted and queued.</source>
          <target state="translated">Si vous utilisez un protocole sans connexion, les datagrammes sont acceptés et en file d’attente.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</source>
          <target state="translated">Toutefois, si aucun espace tampon n’est disponible pour les datagrammes entrants supplémentaires, elles seront ignorées et aucune erreur ne s’affichera à l’expéditeur.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> on a connectionless <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is not recommended.</source>
          <target state="translated">À l’aide de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> sur une connexion <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> n’est pas recommandée.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> disables both sends and receives as described above.</source>
          <target state="translated">Paramètre <ph id="ph1">`how`</ph> à <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> désactive les envois et réceptions tel que décrit ci-dessus.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> lors de l’appel du <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> (méthode), utilisez le <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>traçage réseau dans le .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Le code suivant utilise des exemple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> pour désactiver la <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>Gets the type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtient le type de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> is read-only and is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> est en lecture seule et est définie lorsque le <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> est créé.</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">Le code suivant exemple affiche la <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> à la console.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>Gets a value indicating whether IPv4 support is available and enabled on the current host.</source>
          <target state="translated">Obtient une valeur indiquant si la prise en charge d'IPv4 est disponible et active sur l'hôte en cours.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current host supports the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'hôte en cours prend en charge le protocole IPv4 ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <ph id="ph1">&lt;see cref="T:System.Net.Dns" /&gt;</ph> members.</source>
          <target state="translated">Obtient une valeur qui indique si le Framework prend en charge le protocole IPv6 pour certains membres <ph id="ph1">&lt;see cref="T:System.Net.Dns" /&gt;</ph> obsolètes.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the Framework supports IPv6 for certain obsolete <ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph> methods; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le Framework prend en charge le protocole IPv6 pour certaines méthodes <ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph> obsolètes ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit une valeur qui spécifie la durée de vie des paquets IP (Internet Protocol) envoyés par <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value.</source>
          <target state="translated">Durée de vie.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</source>
          <target state="translated">La valeur de durée de vie indique le nombre maximal de routeurs que le paquet peut parcourir avant que le routeur n’ignore le paquet et un Message de protocole ICMP (Internet Control) « Durée de vie dépassée » message d’erreur est renvoyé à l’expéditeur.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value may be set to a value from 0 to 255.</source>
          <target state="translated">La valeur de durée de vie peut être définie à une valeur comprise entre 0 et 255.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>When this property is not set, the default TTL value for a socket is 32.</source>
          <target state="translated">Lorsque cette propriété n’est pas définie, la valeur de durée de vie par défaut pour un socket est 32.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</source>
          <target state="translated">Définition de cette propriété sur un socket de protocole TCP (Transmission Control) est ignorée par la pile TCP/IP si une connexion réussie a été établie à l’aide du socket.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Si vous recevez un <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriété pour obtenir le code d’erreur spécifique.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value can't be set to a negative number.</source>
          <target state="translated">La valeur TTL ne peut pas être un nombre négatif.</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Cette propriété ne peut être définie que pour les sockets dans les familles <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Une erreur s’est produite pendant la tentative d’accès au socket.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This error is also returned when an attempt was made to set TTL to a value higher than 255.</source>
          <target state="translated">Cette erreur est également retournée lorsqu'une tentative a été faite pour affecter à TTL une valeur supérieure à 255.</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a été fermé.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Specifies whether the socket should only use Overlapped I/O mode.</source>
          <target state="translated">Spécifie si le socket doit utiliser uniquement le mode d'E/S avec chevauchement.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses only overlapped I/O; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> utilise uniquement le mode d'E/S avec chevauchement ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Set this property to <ph id="ph1">`true`</ph> for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> you intend to call <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">Définissez cette propriété sur <ph id="ph1">`true`</ph> pour un <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> vous voulez appeler <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">Sinon, le Framework peut assigner un port de terminaison au socket, interdisant ainsi l’utilisation de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The socket has been bound to a completion port.</source>
          <target state="translated">Le socket est lié à un port de terminaison.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>