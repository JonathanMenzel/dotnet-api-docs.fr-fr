<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="3a270-101">Implémente l'interface de sockets Berkeley.</span><span class="sxs-lookup"><span data-stu-id="3a270-101">Implements the Berkeley sockets interface.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-102">La <xref:System.Net.Sockets.Socket> classe fournit un ensemble complet de méthodes et propriétés pour les communications réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="3a270-103">Le <xref:System.Net.Sockets.Socket> classe vous permet d’effectuer des synchrone et de transfert de données asynchrone à l’aide d’un des protocoles de communication répertoriées dans le <xref:System.Net.Sockets.ProtocolType> énumération.</span><span class="sxs-lookup"><span data-stu-id="3a270-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="3a270-104">La <xref:System.Net.Sockets.Socket> classe suit le modèle d’affectation de noms du .NET Framework pour les méthodes asynchrones.</span><span class="sxs-lookup"><span data-stu-id="3a270-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="3a270-105">Par exemple, synchrones <xref:System.Net.Sockets.Socket.Receive%2A> méthode correspond à asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> et <xref:System.Net.Sockets.Socket.EndReceive%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="3a270-106">Si votre application requiert uniquement un seul thread pendant l’exécution, utilisez les méthodes suivantes, qui sont conçues pour le mode de fonctionnement synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="3a270-107">Si vous utilisez un protocole orienté connexion, tels que TCP, votre serveur peut écouter les connexions à l’aide de la <xref:System.Net.Sockets.Socket.Listen%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="3a270-108">Le <xref:System.Net.Sockets.Socket.Accept%2A> méthode traite toutes les connexions entrantes des demandes et retourne un <xref:System.Net.Sockets.Socket> que vous pouvez utiliser pour communiquer des données avec l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="3a270-109">Utilisez cette retourné <xref:System.Net.Sockets.Socket> pour appeler le <xref:System.Net.Sockets.Socket.Send%2A> ou <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="3a270-110">Appelez le <xref:System.Net.Sockets.Socket.Bind%2A> méthode avant d’appeler le <xref:System.Net.Sockets.Socket.Listen%2A> méthode si vous souhaitez spécifier le nombre d’adresse et le port IP local.</span><span class="sxs-lookup"><span data-stu-id="3a270-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="3a270-111">Utiliser un numéro de port de zéro si vous souhaitez que le fournisseur de service sous-jacent pour affecter un port disponible pour vous.</span><span class="sxs-lookup"><span data-stu-id="3a270-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="3a270-112">Si vous souhaitez vous connecter à un hôte à l’écoute, appelez le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="3a270-113">Pour communiquer des données, appelez le <xref:System.Net.Sockets.Socket.Send%2A> ou <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="3a270-114">Si vous utilisez un protocole sans connexion tel que UDP, il est inutile écouter les connexions du tout.</span><span class="sxs-lookup"><span data-stu-id="3a270-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="3a270-115">Appelez le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode accepter tous les datagrammes entrants.</span><span class="sxs-lookup"><span data-stu-id="3a270-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="3a270-116">Utilisez la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode pour envoyer des datagrammes à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="3a270-117">Pour traiter les communications à l’aide de threads distincts au cours de l’exécution, utilisez les méthodes suivantes, qui sont conçues pour le mode d’opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="3a270-118">Si vous utilisez un protocole orienté connexion, tels que TCP, utilisez le <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, et <xref:System.Net.Sockets.Socket.EndConnect%2A> méthodes pour se connecter à un hôte à l’écoute.</span><span class="sxs-lookup"><span data-stu-id="3a270-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="3a270-119">Utilisez le <xref:System.Net.Sockets.Socket.BeginSend%2A> et <xref:System.Net.Sockets.Socket.EndSend%2A> ou <xref:System.Net.Sockets.Socket.BeginReceive%2A> et <xref:System.Net.Sockets.Socket.EndReceive%2A> méthodes pour communiquer des données de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="3a270-120">Demandes de connexion entrantes peuvent être traitées à l’aide de <xref:System.Net.Sockets.Socket.BeginAccept%2A> et <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="3a270-121">Si vous utilisez un protocole sans connexion tel que UDP, vous pouvez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> et <xref:System.Net.Sockets.Socket.EndSendTo%2A> pour envoyer des datagrammes, et <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> et <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> pour recevoir des datagrammes.</span><span class="sxs-lookup"><span data-stu-id="3a270-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="3a270-122">Si vous effectuez plusieurs opérations asynchrones sur un socket, elles n’est pas nécessairement effectuez dans l’ordre dans lequel ils sont démarrés.</span><span class="sxs-lookup"><span data-stu-id="3a270-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="3a270-123">Lorsque vous avez fini d’envoyer et de recevoir des données, utilisez la <xref:System.Net.Sockets.Socket.Shutdown%2A> méthode permettant de désactiver le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-124">Après avoir appelé <xref:System.Net.Sockets.Socket.Shutdown%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> méthode pour libérer toutes les ressources associées à la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="3a270-125">Le <xref:System.Net.Sockets.Socket> classe vous permet de configurer votre <xref:System.Net.Sockets.Socket> à l’aide de la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="3a270-126">Récupérez ces paramètres à l’aide de la <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-127">Si vous écrivez une application relativement simple et ne nécessitent pas d’optimiser les performances, envisagez d’utiliser <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, et <xref:System.Net.Sockets.UdpClient>.</span><span class="sxs-lookup"><span data-stu-id="3a270-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="3a270-128">Ces classes fournissent une interface plus simple et plus conviviale à <xref:System.Net.Sockets.Socket> communications.</span><span class="sxs-lookup"><span data-stu-id="3a270-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-129">Le code suivant exemple montre comment la <xref:System.Net.Sockets.Socket> classe peut être utilisée pour envoyer des données à un serveur HTTP et recevoir la réponse.</span><span class="sxs-lookup"><span data-stu-id="3a270-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="3a270-130">Cet exemple est bloquée jusqu'à la page entière est reçue.</span><span class="sxs-lookup"><span data-stu-id="3a270-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-131">Pour établir une connexion sortante ou accepter une demande entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-131">To establish an outgoing connection or accept an incoming request.</span></span></permission>
    <threadsafe><span data-ttu-id="3a270-132">Les instances de cette classe sont thread-safe.</span><span class="sxs-lookup"><span data-stu-id="3a270-132">Instances of this class are thread safe.</span></span></threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-133">Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-133">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><span data-ttu-id="3a270-134">Informations de socket retournées par <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-134">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="3a270-135">Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.Socket" /> avec la valeur spécifiée retournée par <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-135">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-136">Si vous appelez le <xref:System.Net.Sockets.Socket.%23ctor%2A> constructeur plusieurs fois avec le même tableau d’octets comme argument pour chaque appel, vous créerez plusieurs gérés <xref:System.Net.Sockets.Socket>s avec le même socket sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-136">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="3a270-137">Cette pratique est fortement déconseillée.</span><span class="sxs-lookup"><span data-stu-id="3a270-137">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="3a270-138">Une des valeurs de <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-138">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="3a270-139">Une des valeurs de <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-139">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-140">Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.Socket" /> à l'aide du type de socket et du protocole spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3a270-140">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-141">Le `socketType` paramètre spécifie le type de la <xref:System.Net.Sockets.Socket> classe et le `protocolType` paramètre spécifie le protocole utilisé par <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-141">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-142">Les deux paramètres ne sont pas indépendants.</span><span class="sxs-lookup"><span data-stu-id="3a270-142">The two parameters are not independent.</span></span> <span data-ttu-id="3a270-143">Fréquence à laquelle le <xref:System.Net.Sockets.Socket> type est implicite dans le protocole.</span><span class="sxs-lookup"><span data-stu-id="3a270-143">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="3a270-144">Si la combinaison de <xref:System.Net.Sockets.Socket> type et protocole type se traduit par un non valide <xref:System.Net.Sockets.Socket>, ce constructeur lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-144">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-145">Si ce constructeur lève une <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-145">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-146">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-146">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-147">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-147">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-148">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-148">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-149">La combinaison de <paramref name="socketType" /> et <paramref name="protocolType" /> aboutit à un socket non valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-149">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><span data-ttu-id="3a270-150">Une des valeurs de <see cref="T:System.Net.Sockets.AddressFamily" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-150">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></param>
        <param name="socketType"><span data-ttu-id="3a270-151">Une des valeurs de <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-151">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="3a270-152">Une des valeurs de <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-152">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-153">Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.Socket" /> en utilisant la famille d'adresses, le type de socket et le protocole spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3a270-153">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-154">Le `addressFamily` paramètre spécifie le schéma d’adressage la <xref:System.Net.Sockets.Socket> classe utilise, le `socketType` paramètre spécifie le type de la <xref:System.Net.Sockets.Socket> (classe) et le `protocolType` paramètre spécifie le protocole utilisé par <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-154">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-155">Les trois paramètres ne sont pas indépendants.</span><span class="sxs-lookup"><span data-stu-id="3a270-155">The three parameters are not independent.</span></span> <span data-ttu-id="3a270-156">Certaines familles d’adresses restreindre les protocoles peuvent être utilisés avec eux et souvent la <xref:System.Net.Sockets.Socket> type est implicite dans le protocole.</span><span class="sxs-lookup"><span data-stu-id="3a270-156">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="3a270-157">Si la combinaison de la famille d’adresses, <xref:System.Net.Sockets.Socket> type et le protocole de type se traduit par un non valide <xref:System.Net.Sockets.Socket>, ce constructeur lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-157">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-158">Si ce constructeur lève une <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-158">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-159">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-159">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-160">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-160">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-161">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-161">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-162">L’exemple de code suivant montre comment créer une instance de la <xref:System.Net.Sockets.Socket> classe.</span><span class="sxs-lookup"><span data-stu-id="3a270-162">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-163">La combinaison de <paramref name="addressFamily" />, <paramref name="socketType" /> et <paramref name="protocolType" /> crée un socket non valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-163">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a270-164">Crée un nouveau <see cref="T:System.Net.Sockets.Socket" /> pour une connexion nouvellement créée.</span><span class="sxs-lookup"><span data-stu-id="3a270-164">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></summary>
        <returns><span data-ttu-id="3a270-165"><see cref="T:System.Net.Sockets.Socket" /> pour une connexion nouvellement créée.</span><span class="sxs-lookup"><span data-stu-id="3a270-165">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-166"><xref:System.Net.Sockets.Socket.Accept%2A> mode synchrone extrait la première demande de connexion en attente à partir de la file d’attente de demande de connexion de socket en écoute, puis crée et retourne un nouveau <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-166"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-167">Vous ne pouvez pas utiliser cette retourné <xref:System.Net.Sockets.Socket> à accepter des connexions supplémentaires à partir de la file d’attente de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-167">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="3a270-168">Toutefois, vous pouvez appeler la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> méthode retourné <xref:System.Net.Sockets.Socket> pour identifier le numéro d’adresse et le port réseau de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-168">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="3a270-169">En mode blocage, <xref:System.Net.Sockets.Socket.Accept%2A> bloque jusqu'à ce qu’une tentative de connexion entrante est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-169">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="3a270-170">Une fois qu’une connexion est acceptée, la version d’origine <xref:System.Net.Sockets.Socket> continue de file d’attente demandes de connexion entrantes jusqu'à ce que vous fermez il.</span><span class="sxs-lookup"><span data-stu-id="3a270-170">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="3a270-171">Si vous appelez cette méthode à l’aide d’un non bloquant <xref:System.Net.Sockets.Socket>et aucune connexion de demandes sont en attente, <xref:System.Net.Sockets.Socket.Accept%2A> lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-171">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-172">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-172">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-173">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-173">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-174">Avant d’appeler le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode), vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-174">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-175">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-175">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-176">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-176">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-177">L’exemple de code suivant accepte un simple <xref:System.Net.Sockets.Socket> connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-177">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-178">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-178">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-179"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-179">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-180">Le socket acceptant n'écoute pas les connexions.</span><span class="sxs-lookup"><span data-stu-id="3a270-180">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="3a270-181">Vous devez appeler <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler <see cref="M:System.Net.Sockets.Socket.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-181">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-182">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-182">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-183">Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-183">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="3a270-184">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-184">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-185">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-185">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-186">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-186">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-187">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-187">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-188">Les protocoles orientés connexion peuvent utiliser le <xref:System.Net.Sockets.Socket.AcceptAsync%2A> tente de méthode pour traiter de manière asynchrone une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-188">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="3a270-189">Accepter les connexions en mode asynchrone, vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-189">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="3a270-190">Avant d’appeler le <xref:System.Net.Sockets.Socket.AcceptAsync%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-190">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="3a270-191">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler\<SocketAsyncEventArgs > délégué et la connecter à la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.</span><span class="sxs-lookup"><span data-stu-id="3a270-191">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="3a270-192">Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requises :</span><span class="sxs-lookup"><span data-stu-id="3a270-192">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="3a270-193">L’appelant peut éventuellement spécifier un existant <xref:System.Net.Sockets.Socket> à utiliser pour la connexion entrante en spécifiant le <xref:System.Net.Sockets.Socket> à utiliser avec le <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-193">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="3a270-194">Si le <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriété est null, un nouveau <xref:System.Net.Sockets.Socket> est construit avec les mêmes <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, et <xref:System.Net.Sockets.Socket.ProtocolType%2A> en cours <xref:System.Net.Sockets.Socket> et défini en tant que le <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-194">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="3a270-195">L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.AcceptAsync%2A> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-195">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="3a270-196">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</span><span class="sxs-lookup"><span data-stu-id="3a270-196">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="3a270-197">Si vous le souhaitez, une mémoire tampon peut-être être fournie qui recevra le bloc initial de données sur le socket après le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode réussit.</span><span class="sxs-lookup"><span data-stu-id="3a270-197">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="3a270-198">Dans ce cas, le <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriété doit être définie dans la mémoire tampon qui contient les données à recevoir et le <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriété doit être définie pour le nombre maximal d’octets de données à recevoir dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-198">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="3a270-199">Ces propriétés peuvent être définies à l’aide de la <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-199">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a270-200">Partie de la mémoire tampon passé est utilisé en interne pour une utilisation par l’appel de Winsock AcceptEx sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-200">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="3a270-201">Cela signifie que la quantité de données retournées sera toujours inférieure à la valeur de la <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriété sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance fournie.</span><span class="sxs-lookup"><span data-stu-id="3a270-201">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="3a270-202">La quantité de la mémoire tampon utilisée en interne varie en fonction de la famille d’adresses du socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-202">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="3a270-203">La taille de mémoire tampon minimale requise est 288 octets.</span><span class="sxs-lookup"><span data-stu-id="3a270-203">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="3a270-204">Si une plus grande taille de mémoire tampon est spécifiée, le <xref:System.Net.Sockets.Socket> attendra quelques données supplémentaires autres que les données d’adresse reçues par l’appel de Winsock AcceptEx et attend que ces données supplémentaires sont reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-204">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="3a270-205">Si un délai d’attente se produit, la connexion est rétablie.</span><span class="sxs-lookup"><span data-stu-id="3a270-205">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="3a270-206">Donc si des données supplémentaires sont attendues d’un montant spécifique, la taille du tampon doit être définie à la taille minimale de mémoire tampon plus cette quantité.</span><span class="sxs-lookup"><span data-stu-id="3a270-206">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="3a270-207">La méthode de rappel d’exécution doit examiner la <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propriété pour déterminer si le <xref:System.Net.Sockets.Socket.AcceptAsync%2A> opération a réussi.</span><span class="sxs-lookup"><span data-stu-id="3a270-207">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="3a270-208">Le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement peut se produire dans certains cas, lorsque aucune connexion n’a pas été acceptée et entraîner la <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propriété à définir <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span><span class="sxs-lookup"><span data-stu-id="3a270-208">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="3a270-209">Cela peut se produire suite à l’analyse des ports à l’aide d’une analyse de type ouvert SYN (un SYN -> SYN ACK-> séquence RST).</span><span class="sxs-lookup"><span data-stu-id="3a270-209">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="3a270-210">Les applications à l’aide de la <xref:System.Net.Sockets.Socket.AcceptAsync%2A> méthode doit être préparée à gérer cette condition.</span><span class="sxs-lookup"><span data-stu-id="3a270-210">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-211">Un argument n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-211">An argument is not valid.</span></span> <span data-ttu-id="3a270-212">Cette exception se produit si la mémoire tampon fournie n'est pas assez grande.</span><span class="sxs-lookup"><span data-stu-id="3a270-212">This exception occurs if the buffer provided is not large enough.</span></span> <span data-ttu-id="3a270-213">La mémoire tampon doit être d'au moins 2 \* (taille de (SOCKADDR_STORAGE + 16) octets.</span><span class="sxs-lookup"><span data-stu-id="3a270-213">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span></span>  
  
 <span data-ttu-id="3a270-214">Cette exception se produit également si plusieurs mémoires tampons sont spécifiées, la propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> n'est pas null.</span><span class="sxs-lookup"><span data-stu-id="3a270-214">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-215">Un argument est hors limites.</span><span class="sxs-lookup"><span data-stu-id="3a270-215">An argument is out of range.</span></span> <span data-ttu-id="3a270-216">L'exception se produit si <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-216">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-217">Une opération incorrecte a été demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-217">An invalid operation was requested.</span></span> <span data-ttu-id="3a270-218">Cette exception se produit si le <see cref="T:System.Net.Sockets.Socket" /> acceptant n'écoute pas les connexions ou si le socket accepté est lié.</span><span class="sxs-lookup"><span data-stu-id="3a270-218">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span></span>  
  
 <span data-ttu-id="3a270-219">Vous devez appeler les méthodes <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler la méthode <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-219">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span>  
  
 <span data-ttu-id="3a270-220">Cette exception se produit également si le socket est déjà connecté ou si une opération de socket utilisait déjà le paramètre de <paramref name="e" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-220">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-221">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-221">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-222">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-222">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-223"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-223">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-224">Obtient la famille d'adresses de <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-224">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="3a270-225">Une des valeurs de <see cref="T:System.Net.Sockets.AddressFamily" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-225">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-226">Le <xref:System.Net.Sockets.AddressFamily> Spécifie le schéma d’adressage une instance de la <xref:System.Net.Sockets.Socket> classe peut utiliser.</span><span class="sxs-lookup"><span data-stu-id="3a270-226">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="3a270-227">Cette propriété est en lecture seule et est définie lorsque le <xref:System.Net.Sockets.Socket> est créé.</span><span class="sxs-lookup"><span data-stu-id="3a270-227">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-228">Le code suivant exemple affiche la <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, et <xref:System.Net.Sockets.ProtocolType> à la console.</span><span class="sxs-lookup"><span data-stu-id="3a270-228">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-229">Obtient la quantité de données reçues du réseau et disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-229">Gets the amount of data that has been received from the network and is available to be read.</span></span></summary>
        <value><span data-ttu-id="3a270-230">Nombre d'octets de données reçus du réseau et disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-230">The number of bytes of data received from the network and available to be read.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-231">Si vous utilisez un non bloquant <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> est un bon moyen pour déterminer si les données sont en file d’attente pour la lecture, avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-231">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="3a270-232">Les données disponibles seront que la quantité totale de données en file d’attente dans le tampon réseau pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-232">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="3a270-233">Si aucune donnée n’est en attente dans la mémoire tampon réseau, <xref:System.Net.Sockets.Socket.Available%2A> retourne 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-233">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="3a270-234">Si l’hôte distant arrête ou ferme la connexion, <xref:System.Net.Sockets.Socket.Available%2A> peut lever un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-234">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-235">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-235">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-236">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-236">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-237">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-237">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-238">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-238">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-239">L’exemple de code suivant compare les résultats de l’appel de IOControl avec FIONREAD et la propriété disponible.</span><span class="sxs-lookup"><span data-stu-id="3a270-239">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-240">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-240">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-241"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-241">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-242">Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-242">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="3a270-243">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-243">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-244">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-244">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-245">Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-245">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="3a270-246"><see cref="T:System.IAsyncResult" /> qui fait référence à la création asynchrone de <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-246">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-247">Les protocoles orientés connexion peuvent utiliser le <xref:System.Net.Sockets.Socket.BeginAccept%2A> tente de méthode pour traiter de manière asynchrone une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-247">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="3a270-248">Accepter les connexions en mode asynchrone, vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-248">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="3a270-249">Avant d’appeler le <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-249">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="3a270-250">Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-250">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="3a270-251">Pour ce faire, au minimum, vous devez passer à l’écoute <xref:System.Net.Sockets.Socket> objet <xref:System.Net.Sockets.Socket.BeginAccept%2A> via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-251">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="3a270-252">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-252">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-253">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-253">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-254">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-254">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="3a270-255">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginAccept%2A>, généralement, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndAccept%2A> jusqu'à ce qu’une connexion en attente est extraite.</span><span class="sxs-lookup"><span data-stu-id="3a270-255">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="3a270-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> Retourne un nouveau <xref:System.Net.Sockets.Socket> de l’objet que vous pouvez utiliser pour envoyer et recevoir des données avec l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="3a270-257">Vous ne pouvez pas utiliser cette retourné <xref:System.Net.Sockets.Socket> à accepter des connexions supplémentaires à partir de la file d’attente de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-257">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="3a270-258">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode, utilisez <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-258">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-259">Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-259">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="3a270-260">Le système peut également utiliser le thread appelant pour appeler la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-260">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="3a270-261">Dans ce cas, le <xref:System.IAsyncResult.CompletedSynchronously%2A> propriété retourné <xref:System.IAsyncResult> sera configuré pour indiquer que le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode terminé de façon synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-261">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="3a270-262">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-262">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-263">Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-263">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-264">Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="3a270-264">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="3a270-265">Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode lève un <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.</span><span class="sxs-lookup"><span data-stu-id="3a270-265">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-266">Vous pouvez utiliser la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété retourné <xref:System.Net.Sockets.Socket> pour identifier le numéro d’adresse et le port réseau de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-266">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-267">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-267">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-268">Une fois que vous avez obtenu ce code, consultez la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-268">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-269">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-269">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-270">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-270">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-271">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-271">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-272">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-272">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-273">L’exemple de code suivant tente de recevoir une connexion entrante de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-273">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-274">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-274">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-275">Windows NT est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-275">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-276">Le socket acceptant n'écoute pas les connexions.</span><span class="sxs-lookup"><span data-stu-id="3a270-276">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="3a270-277">Vous devez appeler <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-277">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
 <span data-ttu-id="3a270-278">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-278">-or-</span></span>  
  
 <span data-ttu-id="3a270-279">Le socket accepté est lié.</span><span class="sxs-lookup"><span data-stu-id="3a270-279">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-280"><paramref name="receiveSize" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-280"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-281">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-281">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize"><span data-ttu-id="3a270-282">Nombre d'octets à accepter de l'expéditeur.</span><span class="sxs-lookup"><span data-stu-id="3a270-282">The number of bytes to accept from the sender.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-283">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-283">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-284">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-284">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-285">Lance une opération asynchrone d'acceptation d'une tentative de connexion entrante et reçoit le premier bloc de données envoyé par l'application cliente.</span><span class="sxs-lookup"><span data-stu-id="3a270-285">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="3a270-286"><see cref="T:System.IAsyncResult" /> qui fait référence à la création asynchrone de <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-286">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-287">Les protocoles orientés connexion peuvent utiliser le <xref:System.Net.Sockets.Socket.BeginAccept%2A> tente de méthode pour traiter de manière asynchrone une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-287">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="3a270-288">Acceptant les connexions de manière asynchrone vous permet d’envoyer et recevoir des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-288">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="3a270-289">Cette surcharge vous permet de spécifier le nombre d’octets à accepter dans le transfert initial dans le `receiveSize` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-289">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="3a270-290">Avant d’appeler le <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-290">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="3a270-291">Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-291">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="3a270-292">Pour ce faire, au minimum, vous devez passer à l’écoute <xref:System.Net.Sockets.Socket> objet <xref:System.Net.Sockets.Socket.BeginAccept%2A> via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-292">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="3a270-293">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-293">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-294">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-294">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-295">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-295">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="3a270-296">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginAccept%2A>, généralement, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndAccept%2A> jusqu'à ce qu’une connexion en attente est extraite.</span><span class="sxs-lookup"><span data-stu-id="3a270-296">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="3a270-297"><xref:System.Net.Sockets.Socket.EndAccept%2A> Retourne un nouveau <xref:System.Net.Sockets.Socket> que vous pouvez utiliser pour envoyer et recevoir des données avec l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-297"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="3a270-298">Vous ne pouvez pas utiliser cette retourné <xref:System.Net.Sockets.Socket> à accepter des connexions supplémentaires à partir de la file d’attente de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-298">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="3a270-299">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode, utilisez <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-299">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-300">Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-300">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="3a270-301">Le système peut également utiliser le thread appelant pour appeler la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-301">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="3a270-302">Dans ce cas, le <xref:System.IAsyncResult.CompletedSynchronously%2A> propriété retourné <xref:System.IAsyncResult> sera configuré pour indiquer que le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode terminé de façon synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-302">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="3a270-303">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-303">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-304">Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-304">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="3a270-305">Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="3a270-305">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="3a270-306">Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode lève un <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.</span><span class="sxs-lookup"><span data-stu-id="3a270-306">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-307">Vous pouvez appeler à utiliser le <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété retourné <xref:System.Net.Sockets.Socket> objet pour identifier le numéro d’adresse et le port réseau de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-307">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-308">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-308">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-309">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-309">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-310">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-310">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-311">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-311">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-312">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-312">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-313">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-313">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-314">L’exemple de code suivant ouvre un socket et accepte une connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-314">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="3a270-315">Dans cet exemple, le socket accepte les 10 premiers octets de données.</span><span class="sxs-lookup"><span data-stu-id="3a270-315">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="3a270-316">Le nombre d’octets reçus et les données sont affichées sur la console par le délégué de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-316">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="3a270-317">Consultez <xref:System.Net.Sockets.Socket.BeginReceive%2A> pour obtenir une description de la façon dont les données restantes sont reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-317">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-318">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-318">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-319">Windows NT est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-319">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-320">Le socket acceptant n'écoute pas les connexions.</span><span class="sxs-lookup"><span data-stu-id="3a270-320">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="3a270-321">Vous devez appeler <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-321">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
 <span data-ttu-id="3a270-322">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-322">-or-</span></span>  
  
 <span data-ttu-id="3a270-323">Le socket accepté est lié.</span><span class="sxs-lookup"><span data-stu-id="3a270-323">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-324"><paramref name="receiveSize" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-324"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-325">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-325">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket"><span data-ttu-id="3a270-326">Objet <see cref="T:System.Net.Sockets.Socket" /> accepté.</span><span class="sxs-lookup"><span data-stu-id="3a270-326">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span></span> <span data-ttu-id="3a270-327">Cette valeur peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-327">This value may be <see langword="null" />.</span></span></param>
        <param name="receiveSize"><span data-ttu-id="3a270-328">Nombre maximal d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-328">The maximum number of bytes to receive.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-329">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-329">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-330">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-330">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-331">Lance une opération asynchrone d'acceptation d'une tentative de connexion entrante provenant d'un socket spécifié et reçoit le premier bloc de données envoyé par l'application cliente.</span><span class="sxs-lookup"><span data-stu-id="3a270-331">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="3a270-332">Objet <see cref="T:System.IAsyncResult" /> qui fait référence à la création d'un objet <see cref="T:System.Net.Sockets.Socket" /> asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-332">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-333">Les protocoles orientés connexion peuvent utiliser le <xref:System.Net.Sockets.Socket.BeginAccept%2A> tente de méthode pour traiter de manière asynchrone une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-333">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="3a270-334">Accepter les connexions en mode asynchrone, vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-334">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="3a270-335">Cette surcharge vous permet de spécifier le socket accepté dans le `acceptSocket` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-335">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="3a270-336">Si ce paramètre est `null`, le socket accepté est créé par le <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-336">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="3a270-337">Vous pouvez spécifier le nombre d’octets à accepter dans le transfert initial dans le `receiveSize` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-337">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="3a270-338">Avant d’appeler le <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et de file d’attente de demandes de connexion entrantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-338">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="3a270-339">Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-339">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="3a270-340">Pour ce faire, au minimum, vous devez passer à l’écoute <xref:System.Net.Sockets.Socket> objet <xref:System.Net.Sockets.Socket.BeginAccept%2A> via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-340">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="3a270-341">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-341">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-342">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-342">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-343">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-343">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="3a270-344">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginAccept%2A>, généralement, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndAccept%2A> jusqu'à ce qu’une connexion en attente est extraite.</span><span class="sxs-lookup"><span data-stu-id="3a270-344">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="3a270-345"><xref:System.Net.Sockets.Socket.EndAccept%2A> Retourne un nouveau <xref:System.Net.Sockets.Socket> de l’objet que vous pouvez utiliser pour envoyer et recevoir des données avec l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-345"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="3a270-346">Vous ne pouvez pas utiliser cette retourné <xref:System.Net.Sockets.Socket> à accepter des connexions supplémentaires à partir de la file d’attente de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-346">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="3a270-347">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode, utilisez <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-347">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-348">Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-348">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="3a270-349">Le système peut également utiliser le thread appelant pour appeler la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-349">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="3a270-350">Dans ce cas, le <xref:System.IAsyncResult.CompletedSynchronously%2A> propriété retourné <xref:System.IAsyncResult> sera configuré pour indiquer que le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode terminé de façon synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-350">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="3a270-351">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-351">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-352">Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-352">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-353">Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="3a270-353">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="3a270-354">Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode lève un <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.</span><span class="sxs-lookup"><span data-stu-id="3a270-354">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-355">Vous pouvez utiliser la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété retourné <xref:System.Net.Sockets.Socket> objet pour identifier le numéro d’adresse et le port réseau de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-355">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-356">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-356">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-357">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-357">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-358">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-358">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-359">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-359">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-360">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-360">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-361">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-361">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-362">L’exemple de code suivant ouvre un socket et accepte une connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-362">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="3a270-363">Dans cet exemple, le socket accepte les 10 premiers octets de données et la `acceptSocket` paramètre est `null`, qui force le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode pour créer le socket accepté.</span><span class="sxs-lookup"><span data-stu-id="3a270-363">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="3a270-364">Le nombre d’octets reçus et les données sont affichées sur la console par le délégué de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-364">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="3a270-365">Consultez <xref:System.Net.Sockets.Socket.BeginReceive%2A> pour obtenir une description de la façon dont les données restantes sont reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-365">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-366">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-366">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-367">Windows NT est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-367">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-368">Le socket acceptant n'écoute pas les connexions.</span><span class="sxs-lookup"><span data-stu-id="3a270-368">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="3a270-369">Vous devez appeler <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-369">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
 <span data-ttu-id="3a270-370">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-370">-or-</span></span>  
  
 <span data-ttu-id="3a270-371">Le socket accepté est lié.</span><span class="sxs-lookup"><span data-stu-id="3a270-371">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-372"><paramref name="receiveSize" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-372"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-373">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-373">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-374">Démarre une demande asynchrone pour une connexion d'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-374">Begins an asynchronous request for a remote host connection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">To be added.</param>
        <param name="end_point">To be added.</param>
        <param name="callback"><span data-ttu-id="3a270-375">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-375">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-376">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-376">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-377">Démarre une demande asynchrone pour une connexion d'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-377">Begins an asynchronous request for a remote host connection.</span></span></summary>
        <returns><span data-ttu-id="3a270-378"><see cref="T:System.IAsyncResult" /> qui fait référence à la connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-378">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-379">Si vous utilisez un protocole orienté connexion, la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode démarre une demande asynchrone pour une connexion à la `remoteEP` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-379">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="3a270-380">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.BeginConnect%2A> établit un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-380">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="3a270-381">Connexion ou la définition de façon asynchrone l’hôte distant par défaut vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-381">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="3a270-382">Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-382">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="3a270-383">Au minimum, vous devez passer le <xref:System.Net.Sockets.Socket> à <xref:System.Net.Sockets.Socket.BeginConnect%2A> via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-383">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="3a270-384">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket>et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-384">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="3a270-385">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-385">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-386">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-386">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="3a270-387">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginConnect%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndConnect%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> se connecte correctement ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-387">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="3a270-388">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode, utilisez <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-388">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="3a270-389">Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-389">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="3a270-390">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-390">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-391">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.BeginConnect%2A> avant d’envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-391">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="3a270-392">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> et <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> pour communiquer avec un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-392">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="3a270-393">Si vous n’appelez pas <xref:System.Net.Sockets.Socket.BeginConnect%2A>, tous les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</span><span class="sxs-lookup"><span data-stu-id="3a270-393">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="3a270-394">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler <xref:System.Net.Sockets.Socket.SetSocketOption%2A> et la valeur diffusion `true`.</span><span class="sxs-lookup"><span data-stu-id="3a270-394">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="3a270-395">Si vous ne pouvez pas, <xref:System.Net.Sockets.Socket.BeginConnect%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-395">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-396">Si vous utilisez un protocole orienté connexion et que vous n’appelez pas <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.BeginConnect%2A>, le fournisseur de service sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.</span><span class="sxs-lookup"><span data-stu-id="3a270-396">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="3a270-397">Si vous utilisez un protocole sans connexion, le fournisseur de services assignera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous appeliez la <xref:System.Net.Sockets.Socket.BeginSend%2A> ou <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-397">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-398">Si vous souhaitez changer l’hôte distant par défaut, appelez le <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode avec le point de terminaison souhaité.</span><span class="sxs-lookup"><span data-stu-id="3a270-398">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="3a270-399">Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-399">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-400">Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="3a270-400">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="3a270-401">Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode lève un <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.</span><span class="sxs-lookup"><span data-stu-id="3a270-401">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-402">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-402">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-403">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-403">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-404">Si ce socket a été déconnecté précédemment, puis <xref:System.Net.Sockets.Socket.BeginConnect%2A> doit être appelé sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-404">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="3a270-405">Il s’agit d’une limitation du fournisseur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-405">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-406">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-406">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-407">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-407">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-408">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-408">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-409">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-409">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-410">L’exemple de code suivant lance une tentative de connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-410">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-411"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-411"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-412">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-412">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-413"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-413">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-414">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-414">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-415"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou une opération asynchrone est déjà en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-415">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3a270-416">Élément <see cref="T:System.Net.IPAddress" /> de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-416">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="3a270-417">Numéro de port de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-417">The port number of the remote host.</span></span></param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state"><span data-ttu-id="3a270-418">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-418">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="3a270-419">Cet objet est passé au délégué <c>requestCallback</c> quand l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-419">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="3a270-420">Démarre une demande asynchrone pour une connexion d'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-420">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="3a270-421">L’hôte est spécifié par <see cref="T:System.Net.IPAddress" /> et un numéro de port.</span><span class="sxs-lookup"><span data-stu-id="3a270-421">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span></span></summary>
        <returns><span data-ttu-id="3a270-422"><see cref="T:System.IAsyncResult" /> qui fait référence à la connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-422">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-423">Asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-423">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="3a270-424">En règle générale, la méthode est appelée par le `requestCallback` déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-424">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="3a270-425">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-425">This method does not block until the operation is complete.</span></span> <span data-ttu-id="3a270-426">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Connect%2A> surcharges de méthode, ou <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-426">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="3a270-427">Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-427">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-428">Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="3a270-428">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="3a270-429">Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode lève un <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.</span><span class="sxs-lookup"><span data-stu-id="3a270-429">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="3a270-430">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="3a270-430">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-431">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-431">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-432">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-432">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-433">Si ce socket a été déconnecté précédemment, puis <xref:System.Net.Sockets.Socket.BeginConnect%2A> doit être appelé sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-433">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="3a270-434">Il s’agit d’une limitation du fournisseur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-434">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="3a270-435">Également le <xref:System.Net.EndPoint> qui est utilisé doit être différent.</span><span class="sxs-lookup"><span data-stu-id="3a270-435">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-436">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-436">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-437">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-437">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-438">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-438">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-439">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-439">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-440">L’exemple de code suivant lance une tentative de connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-440">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-441"><paramref name="address" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-441"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-442">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-442">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-443"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-443">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-444"><see cref="T:System.Net.Sockets.Socket" /> n’est pas dans la famille des sockets.</span><span class="sxs-lookup"><span data-stu-id="3a270-444">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-445">Le numéro de port n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-445">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-446">La longueur de <paramref name="address" /> est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="3a270-446">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-447"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou une opération asynchrone est déjà en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-447">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="3a270-448">Au moins un <see cref="T:System.Net.IPAddress" />, désignant l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-448">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="3a270-449">Numéro de port de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-449">The port number of the remote host.</span></span></param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state"><span data-ttu-id="3a270-450">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-450">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="3a270-451">Cet objet est passé au délégué <c>requestCallback</c> quand l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-451">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="3a270-452">Démarre une demande asynchrone pour une connexion d'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-452">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="3a270-453">L’hôte est spécifié par un tableau <see cref="T:System.Net.IPAddress" /> et un numéro de port.</span><span class="sxs-lookup"><span data-stu-id="3a270-453">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span></span></summary>
        <returns><span data-ttu-id="3a270-454"><see cref="T:System.IAsyncResult" /> qui fait référence aux connexions asynchrones.</span><span class="sxs-lookup"><span data-stu-id="3a270-454">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-455">Asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-455">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="3a270-456">En règle générale, la méthode est appelée par le `requestCallback` déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-456">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="3a270-457">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-457">This method does not block until the operation is complete.</span></span> <span data-ttu-id="3a270-458">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Connect%2A> surcharges de méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-458">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="3a270-459">Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-459">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-460">Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="3a270-460">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="3a270-461">Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode lève un <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.</span><span class="sxs-lookup"><span data-stu-id="3a270-461">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="3a270-462">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-462">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-463">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-463">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-464">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-464">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-465">Si ce socket a été déconnecté précédemment, puis <xref:System.Net.Sockets.Socket.BeginConnect%2A> doit être appelé sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-465">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="3a270-466">Il s’agit d’une limitation du fournisseur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-466">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="3a270-467">Également le <xref:System.Net.EndPoint> qui est utilisé doit être différent.</span><span class="sxs-lookup"><span data-stu-id="3a270-467">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-468">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-468">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-469">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-469">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-470">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-470">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-471">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-471">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-472">L’exemple de code suivant lance une tentative de connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-472">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-473"><paramref name="addresses" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-473"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-474">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-474">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-475"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-475">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-476">Cette méthode est valide pour les sockets qui utilisent <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-476">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-477">Le numéro de port n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-477">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-478">La longueur de <paramref name="address" /> est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="3a270-478">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-479"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou une opération asynchrone est déjà en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-479">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="3a270-480">Nom de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-480">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="3a270-481">Numéro de port de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-481">The port number of the remote host.</span></span></param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state"><span data-ttu-id="3a270-482">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-482">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="3a270-483">Cet objet est passé au délégué <c>requestCallback</c> quand l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-483">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="3a270-484">Démarre une demande asynchrone pour une connexion d'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-484">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="3a270-485">L’hôte est spécifié par un nom d’hôte et un numéro de port.</span><span class="sxs-lookup"><span data-stu-id="3a270-485">The host is specified by a host name and a port number.</span></span></summary>
        <returns><span data-ttu-id="3a270-486"><see cref="T:System.IAsyncResult" /> qui fait référence à la connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-486">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-487">Asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-487">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="3a270-488">En règle générale, la méthode est appelée par le `requestCallback` déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-488">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="3a270-489">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-489">This method does not block until the operation is complete.</span></span> <span data-ttu-id="3a270-490">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Connect%2A> surcharges de méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-490">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="3a270-491">Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-491">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-492">Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="3a270-492">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="3a270-493">Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode lève un <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.</span><span class="sxs-lookup"><span data-stu-id="3a270-493">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="3a270-494">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="3a270-494">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-495">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-495">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-496">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-496">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-497">Si ce socket a été déconnecté précédemment, puis <xref:System.Net.Sockets.Socket.BeginConnect%2A> doit être appelé sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-497">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="3a270-498">Il s’agit d’une limitation du fournisseur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-498">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="3a270-499">Également le <xref:System.Net.EndPoint> qui est utilisé doit être différent.</span><span class="sxs-lookup"><span data-stu-id="3a270-499">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-500">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-500">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-501">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-501">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-502">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-502">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-503">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-503">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-504">L’exemple de code suivant lance une tentative de connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-504">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-505"><paramref name="host" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-505"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-506"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-506">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-507">Cette méthode est valide pour les sockets appartenant aux familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-507">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-508">Le numéro de port n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-508">The port number is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-509"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou une opération asynchrone est déjà en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-509">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="3a270-510"><see langword="true" /> si ce socket peut être réutilisé après la fermeture de la connexion ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-510"><see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-511">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-511">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-512">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-512">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-513">Lance une demande asynchrone de déconnexion d'un point de terminaison distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-513">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="3a270-514">Objet <see cref="T:System.IAsyncResult" /> qui fait référence à l'opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-514">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-515">Si vous utilisez un protocole orienté connexion, vous pouvez appeler la <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> méthode pour demander la déconnexion d’un point de terminaison distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-515">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="3a270-516">Si `reuseSocket` est `true`, vous pouvez réutiliser le socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-516">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="3a270-517">Le <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> méthode utilise un thread séparé pour appeler la méthode de rappel spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3a270-517">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="3a270-518">Le <xref:System.Net.Sockets.Socket.EndDisconnect%2A> méthode s’interrompt jusqu'à ce que la déconnexion en attente est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-518">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="3a270-519">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-519">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-520">Si vous recevez un <xref:System.Net.Sockets.SocketException> exception, utilisez la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-520">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-521">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-521">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-522">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-522">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-523">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-523">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-524">L’exemple de code suivant crée un socket pour la communication asynchrone et envoie des données à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-524">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="3a270-525">Lorsque les données ont été envoyées, <xref:System.Net.Sockets.Socket.Shutdown%2A> est appelée pour arrêter l’envoi et l’activité de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-525">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="3a270-526">Puis <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> est appelé pour lancer une demande de déconnexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-526">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="3a270-527">Lorsque la demande est terminée, le <xref:System.Net.Sockets.Socket.Connected%2A> propriété est interrogée pour tester si le socket est déconnecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-527">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-528">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</span><span class="sxs-lookup"><span data-stu-id="3a270-528">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-529">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-529">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-530">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-530">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-531">Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-531">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-532">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-532">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-533">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-533">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-534">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-534">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-535">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-535">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="3a270-536">Cet objet est passé au délégué <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quand l'opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-536">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="3a270-537">Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-537">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-538"><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-538">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-539">Asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-539">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="3a270-540">En règle générale, la méthode est appelée par le `callback` déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-540">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="3a270-541">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-541">This method does not block until the operation is complete.</span></span> <span data-ttu-id="3a270-542">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Receive%2A> surcharges de méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-542">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="3a270-543">Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-543">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-544">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-544">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-545">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-545">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-546">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-546">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-547">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-547">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-548">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-548">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-549">`state` est une instanciation d’une classe définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-549">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-550">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-550">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-551">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-551">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-552">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-552">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-553">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-553">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-554"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-554"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-555">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-555">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="3a270-556"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-556"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-557">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-557">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-558">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-558">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="3a270-559">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-559">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-560">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-560">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-561">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-561">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="3a270-562">Cet objet est passé au délégué <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quand l'opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-562">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="3a270-563">Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-563">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-564"><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-564">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-565">Asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-565">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="3a270-566">En règle générale, la méthode est appelée par le `callback` déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-566">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="3a270-567">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-567">This method does not block until the operation is complete.</span></span> <span data-ttu-id="3a270-568">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Receive%2A> surcharges de méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-568">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="3a270-569">Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-569">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-570">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-570">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-571">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-571">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-572">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-572">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-573">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-573">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-574">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-574">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-575">`state` est une instanciation d’une classe définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-575">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-576">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-576">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-577">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-577">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-578">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-578">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-579">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-579">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-580"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-580"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-581">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-581">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="3a270-582"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-582"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-583">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-583">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-584">Position de base zéro dans le paramètre <c>buffer</c> à laquelle stocker les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-584">The zero-based position in the <c>buffer</c> parameter at which to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-585">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-585">The number of bytes to receive.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback"><span data-ttu-id="3a270-586">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-586">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-587">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-587">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="3a270-588">Cet objet est passé au délégué <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quand l'opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-588">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="3a270-589">Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-589">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-590"><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-590">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-591">Asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-591">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="3a270-592">En règle générale, la méthode est appelée par le `callback` déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-592">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="3a270-593">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-593">This method does not block until the operation is complete.</span></span> <span data-ttu-id="3a270-594">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Receive%2A> surcharges de méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-594">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="3a270-595">Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-595">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-596">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-596">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-597">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-597">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-598">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-598">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-599">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-599">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-600">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-600">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-601">`state` est une instanciation d’une classe définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-601">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-602">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-602">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-603">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-603">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-604">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-604">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-605">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-605">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-606">L’exemple de code suivant commence à la réception asynchrone de données à partir d’un connecté <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-606">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-607"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-607"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-608">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-608">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="3a270-609"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-609"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-610"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-610"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-611">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-611">-or-</span></span>  
  
 <span data-ttu-id="3a270-612"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-612"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-613">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-613">-or-</span></span>  
  
 <span data-ttu-id="3a270-614"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-614"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-615">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-615">-or-</span></span>  
  
 <span data-ttu-id="3a270-616"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-616"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-617">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-617">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-618">Emplacement dans <c>buffer</c> où stocker les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-618">The location in <c>buffer</c> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-619">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-619">The number of bytes to receive.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback"><span data-ttu-id="3a270-620">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-620">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-621">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-621">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="3a270-622">Cet objet est passé au délégué <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quand l'opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-622">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="3a270-623">Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-623">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-624"><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-624">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-625">Asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-625">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="3a270-626">En règle générale, la méthode est appelée par le `callback` déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-626">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="3a270-627">Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-627">This method does not block until the operation is complete.</span></span> <span data-ttu-id="3a270-628">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Receive%2A> surcharges de méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-628">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="3a270-629">Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-629">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-630">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-630">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-631">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-631">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-632">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-632">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-633">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-633">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-634">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-634">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-635">`state` est une instanciation d’une classe définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-635">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-636">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-636">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-637">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-637">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-638">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-638">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-639">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-639">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-640"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-640"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-641">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-641">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="3a270-642"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-642"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-643"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-643"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-644">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-644">-or-</span></span>  
  
 <span data-ttu-id="3a270-645"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-645"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-646">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-646">-or-</span></span>  
  
 <span data-ttu-id="3a270-647"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-647"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-648">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-648">-or-</span></span>  
  
 <span data-ttu-id="3a270-649"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-649"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-650">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-650">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-651">Position de base zéro dans le paramètre <c>buffer</c> à laquelle stocker les données.</span><span class="sxs-lookup"><span data-stu-id="3a270-651">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-652">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-652">The number of bytes to receive.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback"><span data-ttu-id="3a270-653">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-653">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-654">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-654">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-655">Démarre la réception asynchrone de données à partir d'un périphérique réseau spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-655">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="3a270-656"><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-656">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-657">Le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode démarre la lecture asynchrone des datagrammes sans connexion à partir d’un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-657">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="3a270-658">Appel de la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode vous donne la possibilité de recevoir des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-658">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="3a270-659">Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-659">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-660">Pour ce faire, au minimum, votre `state` paramètre doit contenir le connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication.</span><span class="sxs-lookup"><span data-stu-id="3a270-660">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="3a270-661">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-661">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-662">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-662">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-663">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-663">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-664">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et il se bloque sur <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> lit les données ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-664">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="3a270-665">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode, utilisez <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-665">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-666">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-666">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="3a270-667">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-667">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-668">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, vous devez lier explicitement la <xref:System.Net.Sockets.Socket> à un point de terminaison local à l’aide de la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), ou <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-668">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-669">Cette méthode lit les données dans le `buffer` de paramètre et de capture à partir de laquelle les données sont envoyées de point de terminaison de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-669">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="3a270-670">Pour plus d’informations sur la récupération de ce point de terminaison, consultez <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-670">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="3a270-671">Cette méthode est particulièrement utile si vous avez l’intention de réception asynchrone des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</span><span class="sxs-lookup"><span data-stu-id="3a270-671">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="3a270-672">Dans ce cas, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</span><span class="sxs-lookup"><span data-stu-id="3a270-672">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="3a270-673">Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-673">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-674">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</span><span class="sxs-lookup"><span data-stu-id="3a270-674">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="3a270-675">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode avec une mémoire tampon insuffisante.</span><span class="sxs-lookup"><span data-stu-id="3a270-675">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="3a270-676">Pour garantir que le point de terminaison d’hôte distant est toujours retourné, une application doit lier explicitement la <xref:System.Net.Sockets.Socket> à un point de terminaison local à l’aide la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), puis appelez le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> méthode avec le `optionLevel` paramètre la valeur <xref:System.Net.Sockets.SocketOptionLevel.IP>ou <xref:System.Net.Sockets.SocketOptionLevel.IPv6> selon le cas, le `optionName` paramètre la valeur <xref:System.Net.Sockets.SocketOptionName.PacketInformation>et le `optionValue` paramètre pour activer cette option avant d’appeler le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-676">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-677">Sinon, il est possible que le point de terminaison d’hôte distant ne soit ne pas retourné lorsque l’émetteur a envoyé plusieurs datagrammes avant que le récepteur a appelé le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-677">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-678">Bien que <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-678">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="3a270-679">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode ou acceptez une demande de connexion entrante en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-679">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="3a270-680">Si vous appelez le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode avant l’établissement ou l’acceptation d’une connexion, vous obtiendrez un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-680">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-681">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-681">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-682">Dans les deux cas, le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-682">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="3a270-683">Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lira autant de données est disponible jusqu’au nombre d’octets spécifié par le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-683">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="3a270-684">Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-684">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-685">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-685">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-686">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-686">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-687">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-687">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-688">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-688">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-689">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-689">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-690">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-690">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-691">L’exemple de code suivant reçoit de façon asynchrone des datagrammes sans connexion à partir d’un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-691">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-692"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-692"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-693">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-693">-or-</span></span>  
  
 <span data-ttu-id="3a270-694"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-694"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-695">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-695">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-696"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-696"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-697">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-697">-or-</span></span>  
  
 <span data-ttu-id="3a270-698"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-698"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-699">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-699">-or-</span></span>  
  
 <span data-ttu-id="3a270-700"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-700"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-701">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-701">-or-</span></span>  
  
 <span data-ttu-id="3a270-702"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-702"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-703"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-703">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-704">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-704">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-705">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-705">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-706">Position de base zéro dans le paramètre <c>buffer</c> à laquelle stocker les données.</span><span class="sxs-lookup"><span data-stu-id="3a270-706">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-707">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-707">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-708">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-708">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-709"><see cref="T:System.Net.EndPoint" /> qui représente la source des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-709">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-710">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-710">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-711">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-711">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-712">Démarre la réception asynchrone du nombre spécifié d'octets de données dans l'emplacement spécifié de la mémoire tampon de données, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié et stocke le point de terminaison ainsi que les informations sur le paquet.</span><span class="sxs-lookup"><span data-stu-id="3a270-712">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information..</span></span></summary>
        <returns><span data-ttu-id="3a270-713"><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-713">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-714">Opération de réception asynchrone doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-714">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="3a270-715">En règle générale, la méthode est appelée par le `asyncCallback` déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-715">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="3a270-716">Cette méthode ne bloque pas jusqu'à ce que l’opération se termine.</span><span class="sxs-lookup"><span data-stu-id="3a270-716">This method does not block until the operation completes.</span></span> <span data-ttu-id="3a270-717">Pour bloquer jusqu'à ce que l’opération est terminée, utilisez le <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-717">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-718">Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-718">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-719">Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="3a270-719">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="3a270-720">Cette méthode lit les données dans le `buffer` paramètre et capture le point de terminaison à partir de laquelle les données sont envoyées de l’hôte distant, ainsi que les informations sur le paquet reçu.</span><span class="sxs-lookup"><span data-stu-id="3a270-720">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="3a270-721">Pour plus d’informations sur la récupération de ce point de terminaison, consultez <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-721">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="3a270-722">Cette méthode est particulièrement utile si vous avez l’intention de réception asynchrone des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</span><span class="sxs-lookup"><span data-stu-id="3a270-722">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-723">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-723">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-724">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-724">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-725">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-725">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-726">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-726">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-727">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-727">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-728">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-728">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-729"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-729"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-730">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-730">-or-</span></span>  
  
 <span data-ttu-id="3a270-731"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-731"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-732">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-732">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-733"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-733"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-734">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-734">-or-</span></span>  
  
 <span data-ttu-id="3a270-735"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-735"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-736">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-736">-or-</span></span>  
  
 <span data-ttu-id="3a270-737"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-737"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-738">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-738">-or-</span></span>  
  
 <span data-ttu-id="3a270-739"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-739"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-740"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-740">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-741">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</span><span class="sxs-lookup"><span data-stu-id="3a270-741">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-742">Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-742">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-743">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-743">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-744">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-744">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-745">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-745">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-746">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-746">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-747">Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-747">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-748"><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-748">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-749">Le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-749">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="3a270-750"><xref:System.Net.Sockets.Socket.BeginSend%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-750"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-751">Appel de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-751">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="3a270-752">Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-752">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="3a270-753">Pour ce faire, au minimum, votre `state` paramètre doit contenir le connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication.</span><span class="sxs-lookup"><span data-stu-id="3a270-753">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="3a270-754">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-754">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-755">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-755">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-756">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-756">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="3a270-757">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSend%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSend%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-757">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="3a270-758">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-758">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a270-759">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-759">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="3a270-760">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-760">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-761">Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSend%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-761">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="3a270-762">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-762">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="3a270-763">Il est OK à utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-763">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-764">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-764">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-765">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-765">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-766">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.BeginSend%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-766">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-767">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-767">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-768">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-768">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-769">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-769">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-770">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-770">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-771">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-771">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-772">`state` est une instanciation d’une classe définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-772">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-773">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-773">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-774">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-774">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-775">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-775">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-776">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-776">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-777">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-777">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-778">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-778">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-779"><paramref name="buffers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-779"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-780"><paramref name="buffers" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-780"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-781">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-781">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-782">Consultez la section Notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-782">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-783"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-783">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-784">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-784">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-785">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-785">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="3a270-786">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-786">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-787">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-787">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-788">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-788">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-789">Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-789">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-790"><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-790">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-791">Le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-791">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="3a270-792"><xref:System.Net.Sockets.Socket.BeginSend%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-792"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-793">Appel de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-793">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="3a270-794">Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-794">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="3a270-795">Pour ce faire, au minimum, votre `state` paramètre doit contenir le connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication.</span><span class="sxs-lookup"><span data-stu-id="3a270-795">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="3a270-796">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-796">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-797">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-797">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-798">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-798">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="3a270-799">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSend%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSend%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-799">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="3a270-800">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-800">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a270-801">Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-801">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="3a270-802">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-802">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-803">Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSend%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-803">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="3a270-804">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-804">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="3a270-805">Il est OK à utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-805">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-806">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-806">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-807">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-807">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-808">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.BeginSend%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-808">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-809">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-809">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-810">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-810">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-811">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-811">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-812">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-812">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-813">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-813">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-814">`state` est une instanciation d’une classe définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-814">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-815">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-815">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-816">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-816">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-817">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-817">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-818">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-818">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-819">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-819">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-820">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-820">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-821"><paramref name="buffers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-821"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-822"><paramref name="buffers" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-822"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-823">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-823">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-824">Consultez la section Notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-824">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-825"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-825">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-826">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-826">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-827">Position de base zéro dans le paramètre <c>buffer</c> à laquelle commencer l’envoi des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-827">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-828">Le nombre d’octets à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-828">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-829">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-829">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="3a270-830">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-830">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-831">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-831">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-832">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-832">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-833">Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-833">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-834"><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-834">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-835">Le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-835">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="3a270-836"><xref:System.Net.Sockets.Socket.BeginSend%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-836"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-837">Appel de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-837">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="3a270-838">Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-838">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="3a270-839">Pour ce faire, au minimum, votre `state` paramètre doit contenir le connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication.</span><span class="sxs-lookup"><span data-stu-id="3a270-839">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="3a270-840">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-840">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-841">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-841">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-842">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-842">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="3a270-843">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSend%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSend%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-843">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="3a270-844">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-844">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a270-845">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-845">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="3a270-846">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-846">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-847">Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSend%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-847">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="3a270-848">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-848">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="3a270-849">Il est OK à utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-849">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-850">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-850">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-851">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-851">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-852">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.BeginSend%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-852">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-853">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-853">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-854">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-854">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-855">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-855">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-856">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-856">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-857">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-857">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-858">`state` est une instanciation d’une classe définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-858">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-859">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-859">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-860">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-860">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-861">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-861">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-862">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-862">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-863">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-863">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-864">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-864">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-865"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-865"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-866">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-866">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-867">Consultez la section Notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-867">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-868"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-868"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-869">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-869">-or-</span></span>  
  
 <span data-ttu-id="3a270-870"><paramref name="offset" /> est inférieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-870"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-871">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-871">-or-</span></span>  
  
 <span data-ttu-id="3a270-872"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-872"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-873">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-873">-or-</span></span>  
  
 <span data-ttu-id="3a270-874"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-874"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-875"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-875">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-876">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-876">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-877">Position de base zéro dans le paramètre <c>buffer</c> à laquelle commencer l’envoi des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-877">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-878">Le nombre d’octets à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-878">The number of bytes to send.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback"><span data-ttu-id="3a270-879">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-879">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-880">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-880">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-881">Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-881">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-882"><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-882">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-883">Le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-883">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="3a270-884"><xref:System.Net.Sockets.Socket.BeginSend%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-884"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-885">Appel de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-885">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="3a270-886">Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-886">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="3a270-887">Pour ce faire, au minimum, votre `state` paramètre doit contenir le connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication.</span><span class="sxs-lookup"><span data-stu-id="3a270-887">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="3a270-888">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-888">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-889">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-889">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-890">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-890">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="3a270-891">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSend%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSend%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-891">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="3a270-892">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-892">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a270-893">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-893">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="3a270-894">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-894">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-895">Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSend%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-895">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="3a270-896">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-896">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="3a270-897">Il est OK à utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-897">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-898">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-898">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-899">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-899">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-900">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.BeginSend%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-900">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-901">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-901">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-902">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-902">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-903">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-903">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-904">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-904">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-905">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-905">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-906">`state` est une instanciation d’une classe définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-906">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-907">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-907">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-908">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-908">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-909">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-909">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-910">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-910">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-911">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-911">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-912">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-912">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-913">L’exemple de code suivant démarre l’envoi asynchrone des données à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-913">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-914"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-914"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-915">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-915">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-916">Consultez la section Notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-916">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-917"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-917"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-918">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-918">-or-</span></span>  
  
 <span data-ttu-id="3a270-919"><paramref name="offset" /> est inférieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-919"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-920">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-920">-or-</span></span>  
  
 <span data-ttu-id="3a270-921"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-921"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-922">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-922">-or-</span></span>  
  
 <span data-ttu-id="3a270-923"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-923"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-924"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-924">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-925">Envoie un fichier de façon asynchrone à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-925">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="3a270-926">Chaîne qui contient le chemin d'accès et le nom du fichier à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-926">A string that contains the path and name of the file to send.</span></span> <span data-ttu-id="3a270-927">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-927">This parameter can be <see langword="null" />.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-928">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-928">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-929">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-929">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-930">Envoie le fichier <paramref name="fileName" /> à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté à l'aide de l'indicateur <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-930">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span></span></summary>
        <returns><span data-ttu-id="3a270-931">Objet <see cref="T:System.IAsyncResult" /> qui représente l'envoi asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-931">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-932">Cette surcharge envoie le fichier `fileName` au socket connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-932">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="3a270-933">Si `fileName` est dans le répertoire local, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3a270-933">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="3a270-934">Les caractères génériques («.. \\\myfile.txt ») et les noms de partage UNC («\\\\\\\shared active\\\myfile.txt ») sont pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3a270-934">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="3a270-935">Si le fichier est introuvable, l’exception <xref:System.IO.FileNotFoundException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-935">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="3a270-936">Cette méthode utilise le `TransmitFile` de trouver la fonction dans l’API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="3a270-936">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="3a270-937">Pour plus d’informations sur la `TransmitFile` fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3a270-937">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="3a270-938">Le <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-938">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="3a270-939"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-939"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-940">Appel de la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode vous permet d’envoyer un fichier dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-940">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="3a270-941">Pour terminer l’opération, vous pouvez créer une méthode de rappel appelée par le <xref:System.AsyncCallback> paramètre de délégué.</span><span class="sxs-lookup"><span data-stu-id="3a270-941">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="3a270-942">Pour ce faire, au minimum, le `state` paramètre doit contenir le <xref:System.Net.Sockets.Socket> de l’objet utilisé pour la communication.</span><span class="sxs-lookup"><span data-stu-id="3a270-942">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="3a270-943">Si votre rappel a besoin de plus d’informations, vous pouvez créer une classe ou une structure contenant les <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-943">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-944">Passez une instance de cet objet personnalisé à la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-944">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-945">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSendFile%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-945">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="3a270-946">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSendFile%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie l’intégralité du fichier ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-946">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="3a270-947">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-947">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-948">Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-948">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="3a270-949">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre fichier ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-949">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-950">Dans ce cas, le datagramme n’est pas envoyé et <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lève une <xref:System.Net.Sockets.SocketException> exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-950">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-951">Si vous recevez un <xref:System.Net.Sockets.SocketException> exception, utilisez la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-951">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-952">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-952">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-953">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-953">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-954">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-954">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-955">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-955">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-956">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-956">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-957">L’exemple de code suivant crée et connecte à un socket pour la communication asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-957">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="3a270-958">Tout d’abord, le fichier « text.txt » est envoyé de manière asynchrone à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-958">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="3a270-959">Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndSendFile%2A> pour terminer la transmission.</span><span class="sxs-lookup"><span data-stu-id="3a270-959">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-960">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-960">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-961">Le socket n’est pas connecté à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-961">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="3a270-962">Le fichier <paramref name="fileName" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3a270-962">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-963">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-963">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-964">Consultez la section Notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-964">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="3a270-965">Chaîne qui contient le chemin d'accès et le nom du fichier à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-965">A string that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="3a270-966">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-966">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="3a270-967">Tableau <see cref="T:System.Byte" /> contenant les données à envoyer avant l’envoi du fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-967">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="3a270-968">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-968">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="3a270-969">Tableau <see cref="T:System.Byte" /> contenant les données à envoyer après l’envoi du fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-969">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="3a270-970">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-970">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="3a270-971">Combinaison d'opérations de bits de valeurs <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-971">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="3a270-972">Délégué <see cref="T:System.AsyncCallback" /> à appeler une fois cette opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-972">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span></span> <span data-ttu-id="3a270-973">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-973">This parameter can be <see langword="null" />.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-974">Objet défini par l'utilisateur contenant les informations d'état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-974">A user-defined object that contains state information for this request.</span></span> <span data-ttu-id="3a270-975">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-975">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3a270-976">Envoie de façon asynchrone un fichier et des mémoires tampon de données à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-976">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="3a270-977">Objet <see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-977">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-978">Cette surcharge requiert le nom du fichier à envoyer et une combinaison d’opérations de <xref:System.Net.Sockets.TransmitFileOptions> valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-978">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="3a270-979">Le `preBuffer` paramètre contient les données que vous voulez faire précéder le fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-979">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="3a270-980">`postBuffer` contient des données que vous souhaitez suivre le fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-980">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="3a270-981">Si `fileName` est dans le répertoire local, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3a270-981">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="3a270-982">Les caractères génériques («.. \\\myfile.txt ») et les noms de partage UNC («\\\\\\\shared active\\\myfile.txt ») sont pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3a270-982">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="3a270-983">Si le fichier est introuvable, l’exception <xref:System.IO.FileNotFoundException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-983">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="3a270-984">Le `flags` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur le transfert de fichiers.</span><span class="sxs-lookup"><span data-stu-id="3a270-984">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="3a270-985">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="3a270-985">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="3a270-986">Cette méthode utilise le `TransmitFile` de trouver la fonction dans l’API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="3a270-986">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="3a270-987">Pour plus d’informations sur la `TransmitFile` fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3a270-987">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="3a270-988">Le <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-988">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="3a270-989"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-989"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="3a270-990">Appel de la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode vous donne la possibilité d’envoyer un fichier dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-990">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="3a270-991">Pour terminer l’opération, vous pouvez créer une méthode de rappel appelée par le <xref:System.AsyncCallback> paramètre de délégué.</span><span class="sxs-lookup"><span data-stu-id="3a270-991">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="3a270-992">Pour ce faire, au minimum, le `state` paramètre doit contenir le <xref:System.Net.Sockets.Socket> de l’objet utilisé pour la communication.</span><span class="sxs-lookup"><span data-stu-id="3a270-992">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="3a270-993">Si votre rappel a besoin de plus d’informations, vous pouvez créer une classe ou une structure contenant les <xref:System.Net.Sockets.Socket> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-993">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="3a270-994">Passez une instance de cet objet personnalisé à la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-994">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-995">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSendFile%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-995">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="3a270-996">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSendFile%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie l’intégralité du fichier ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-996">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="3a270-997">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-997">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-998">Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-998">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="3a270-999">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre fichier ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-999">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-1000">Dans ce cas, le datagramme n’est pas envoyé et <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lève une <xref:System.Net.Sockets.SocketException> exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-1000">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1001">Si vous recevez un <xref:System.Net.Sockets.SocketException> exception, utilisez la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1001">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1002">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1002">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1003">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1003">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1004">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1004">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1005">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-1005">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-1006">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-1006">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1007">L’exemple de code suivant crée et connecte à un socket pour la communication asynchrone et commence à envoyer le fichier « text.txt » en mode asynchrone à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1007">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="3a270-1008">Dans cet exemple, un `preBuffer` et un `postBuffer` de données est créé pour envoyer le fichier et la valeur par défaut <xref:System.Net.Sockets.TransmitFileOptions> valeur est utilisée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1008">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="3a270-1009">Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndSendFile%2A> pour terminer la transmission.</span><span class="sxs-lookup"><span data-stu-id="3a270-1009">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1010">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1010">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1011">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1011">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-1012">Consultez la section Notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-1012">See remarks section below.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1013">Le système d'exploitation n'est pas Windows NT ou une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="3a270-1013">The operating system is not Windows NT or later.</span></span>  
  
 <span data-ttu-id="3a270-1014">\- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1014">\- or -</span></span>  
  
 <span data-ttu-id="3a270-1015">Le socket n’est pas connecté à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1015">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="3a270-1016">Le fichier <paramref name="fileName" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3a270-1016">The file <paramref name="fileName" /> was not found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-1017">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1017">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-1018">Position de base zéro dans <c>buffer</c> à laquelle commencer l’envoi des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1018">The zero-based position in <c>buffer</c> at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-1019">Le nombre d’octets à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1019">The number of bytes to send.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback"><span data-ttu-id="3a270-1020">Délégué <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1020">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="3a270-1021">Objet qui contient les informations d’état de cette demande.</span><span class="sxs-lookup"><span data-stu-id="3a270-1021">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="3a270-1022">Envoie des données de façon asynchrone à un hôte distant spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1022">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="3a270-1023"><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1023">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1024">Le <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant spécifié dans le `remoteEP` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1024">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="3a270-1025">Appel de la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-1025">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="3a270-1026">Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> fonctionne avec les protocoles orientés connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1026">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="3a270-1027">Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1027">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="3a270-1028">Pour ce faire, au minimum, votre `state` paramètre doit contenir le connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication.</span><span class="sxs-lookup"><span data-stu-id="3a270-1028">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="3a270-1029">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket>et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-1029">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="3a270-1030">Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1030">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="3a270-1031">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1031">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="3a270-1032">Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSendTo%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-1032">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="3a270-1033">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1033">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a270-1034">Appelez la méthode Set sur un.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3a270-1034">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="3a270-1035">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1035">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="3a270-1036">Si vous utilisez un protocole orienté connexion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), ou <xref:System.Net.Sockets.Socket.BeginSendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1036">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-1037"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> ignore le `remoteEP` paramètre et envoyer des données à la <xref:System.Net.EndPoint> établie dans le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1037"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1038">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1038">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="3a270-1039">Vous pouvez procéder ainsi si vous voulez appeler le <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1039">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="3a270-1040">Si vous appelez le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</span><span class="sxs-lookup"><span data-stu-id="3a270-1040">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="3a270-1041">Vous ne devez pas également pour appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1041">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="3a270-1042">Dans ce cas, le fournisseur de service sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.</span><span class="sxs-lookup"><span data-stu-id="3a270-1042">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="3a270-1043">Utiliser un numéro de port de zéro si vous souhaitez que le fournisseur de service sous-jacent pour sélectionner un port libre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1043">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="3a270-1044">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.EndSendTo%2A> terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1044">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="3a270-1045">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1045">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-1046">-Vous devez également vous assurer de que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-1046">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-1047">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.EndSendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1047">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-1048">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1048">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1049">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1049">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1050">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1050">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1051">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1051">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1052">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1052">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1053">Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mis en cache pour asynchrone <xref:System.Net.Sockets.Socket> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-1053">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="3a270-1054">Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations ultérieures de ce contexte seront affiche une amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="3a270-1054">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1055">L’exemple de code suivant envoie de façon asynchrone à l’hôte distant spécifié les données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1055">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1056"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1056"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-1057">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1057">-or-</span></span>  
  
 <span data-ttu-id="3a270-1058"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1058"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1059">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1059">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-1060"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-1060"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-1061">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1061">-or-</span></span>  
  
 <span data-ttu-id="3a270-1062"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1062"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-1063">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1063">-or-</span></span>  
  
 <span data-ttu-id="3a270-1064"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-1064"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-1065">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1065">-or-</span></span>  
  
 <span data-ttu-id="3a270-1066"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1066"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1067"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1067">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-1068">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1068">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><span data-ttu-id="3a270-1069"><see cref="T:System.Net.EndPoint" /> local à associer à <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1069">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <summary><span data-ttu-id="3a270-1070">Associe <see cref="T:System.Net.Sockets.Socket" /> à un point de terminaison local.</span><span class="sxs-lookup"><span data-stu-id="3a270-1070">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1071">Utilisez la <xref:System.Net.Sockets.Socket.Bind%2A> méthode si vous devez utiliser un point de terminaison local spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1071">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="3a270-1072">Vous devez appeler <xref:System.Net.Sockets.Socket.Bind%2A> avant de pouvoir appeler le <xref:System.Net.Sockets.Socket.Listen%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1072">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="3a270-1073">Vous n’avez pas besoin d’appeler <xref:System.Net.Sockets.Socket.Bind%2A> avant d’utiliser le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode), sauf si vous devez utiliser un point de terminaison local spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1073">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="3a270-1074">Vous pouvez utiliser la <xref:System.Net.Sockets.Socket.Bind%2A> méthode sur les protocoles orientés connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1074">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="3a270-1075">Avant d’appeler <xref:System.Net.Sockets.Socket.Bind%2A>, vous devez d’abord créer local <xref:System.Net.IPEndPoint> à partir de laquelle vous souhaitez communiquer des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1075">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="3a270-1076">Si vous ne souhaitez pas quelle adresse locale est affectée, vous pouvez créer un <xref:System.Net.IPEndPoint> à l’aide de <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> en tant que le paramètre d’adresse et le service sous-jacent fournisseur assigne l’adresse réseau la plus appropriée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1076">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="3a270-1077">Cela peut vous aider à simplifier votre application si vous avez plusieurs interfaces réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1077">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="3a270-1078">Si vous ne souhaitez pas de port local est utilisé, vous pouvez créer un <xref:System.Net.IPEndPoint> à l’aide de 0 pour le numéro de port.</span><span class="sxs-lookup"><span data-stu-id="3a270-1078">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="3a270-1079">Dans ce cas, le fournisseur de services affecte un numéro de port disponible entre 1024 et 5000.</span><span class="sxs-lookup"><span data-stu-id="3a270-1079">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="3a270-1080">Si vous utilisez l’approche ci-dessus, vous pouvez découvrir le numéro d’adresse et le port de réseau local a été attribué en appelant le <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1080">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="3a270-1081">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> ne retourne pas l’adresse réseau assignée localement jusqu'à une fois que vous avez effectué un appel à la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1081">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="3a270-1082">Si vous utilisez un protocole sans connexion, vous aurez pas accès à ces informations jusqu'à ce que vous avez terminé un envoi ou de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-1082">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="3a270-1083">Si un socket UDP doit recevoir une interface plus d’informations sur les paquets reçus, le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> méthode doit être appelée explicitement avec l’option de socket définie sur <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immédiatement après l’appel la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1083">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1084">Si vous souhaitez recevoir des datagrammes multicast, vous devez appeler la <xref:System.Net.Sockets.Socket.Bind%2A> méthode avec un numéro de port de multidiffusion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1084">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1085">Vous devez appeler la <xref:System.Net.Sockets.Socket.Bind%2A> méthode si vous souhaitez recevoir des datagrammes sans connexion à l’aide du <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1085">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1086">Si vous recevez un <xref:System.Net.Sockets.SocketException> lors de l’appel du <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1086">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1087">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1087">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1088">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1088">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1089">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1089">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1090">Le code suivant lie l’exemple un <xref:System.Net.Sockets.Socket> à l’aide du point de terminaison local spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-1090">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1091"><paramref name="localEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1091"><paramref name="localEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1092">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1092">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1093"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1093">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-1094">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1094">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-1095">pour accepter les connexions à partir de l’hôte défini par <paramref name="localEP" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1095">for accepting connections from the host defined by <paramref name="localEP" />.</span></span> <span data-ttu-id="3a270-1096">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" /></span><span class="sxs-lookup"><span data-stu-id="3a270-1096">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span></span></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1097">Obtient ou définit une valeur qui indique si <see cref="T:System.Net.Sockets.Socket" /> est en mode blocage.</span><span class="sxs-lookup"><span data-stu-id="3a270-1097">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1098"><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> est bloqué ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1098"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3a270-1099">La valeur par défaut est <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1099">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1100">Le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété indique si une <xref:System.Net.Sockets.Socket> est en mode blocage.</span><span class="sxs-lookup"><span data-stu-id="3a270-1100">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="3a270-1101">Si vous êtes en mode blocage, et vous apportez une méthode qui ne se termine pas immédiatement, votre application bloque l’exécution jusqu'à la fin de l’opération demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1101">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="3a270-1102">Si vous souhaitez que l’exécution à continuer même si l’opération demandée n’est pas terminée, modifiez le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false`.</span><span class="sxs-lookup"><span data-stu-id="3a270-1102">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="3a270-1103">Le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété n’a aucun effet sur les méthodes asynchrones.</span><span class="sxs-lookup"><span data-stu-id="3a270-1103">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="3a270-1104">Si vous envoyez et recevoir des données de façon asynchrone et à bloquer l’exécution, utilisez la <xref:System.Threading.ManualResetEvent> classe.</span><span class="sxs-lookup"><span data-stu-id="3a270-1104">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1105">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1105">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1106">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1106">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1107">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1107">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1108">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1108">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1109">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1109">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1110"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1110">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-1111">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> utilisé pour demander la connexion à l'hôte distant en appelant l'une des méthodes <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1111">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span></span></param>
        <summary><span data-ttu-id="3a270-1112">Annule une requête asynchrone pour une connexion d'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1112">Cancels an asynchronous request for a remote host connection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1113">Le <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> méthode annule une demande asynchrone pour une connexion d’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1113">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a270-1114">Le paramètre <paramref name="e" /> ne peut pas être null et <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1114">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1115">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1115">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1116"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1116">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-1117">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1117">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-1118">Ferme la connexion <see cref="T:System.Net.Sockets.Socket" /> et libère toutes les ressources associées.</span><span class="sxs-lookup"><span data-stu-id="3a270-1118">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a270-1119">Ferme la connexion <see cref="T:System.Net.Sockets.Socket" /> et libère toutes les ressources associées.</span><span class="sxs-lookup"><span data-stu-id="3a270-1119">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1120">Le <xref:System.Net.Sockets.Socket.Close%2A> méthode ferme la connexion d’hôte distant et libère toutes les ressources managées et associés à la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1120">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1121">À la clôture, le <xref:System.Net.Sockets.Socket.Connected%2A> est définie sur `false`.</span><span class="sxs-lookup"><span data-stu-id="3a270-1121">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="3a270-1122">Pour les protocoles orientés connexion, il est recommandé d’appeler <xref:System.Net.Sockets.Socket.Shutdown%2A> avant d’appeler le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1122">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="3a270-1123">Cela garantit que toutes les données est envoyé et reçu sur le socket connecté avant sa fermeture.</span><span class="sxs-lookup"><span data-stu-id="3a270-1123">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="3a270-1124">Si vous avez besoin d’appeler <xref:System.Net.Sockets.Socket.Close%2A> sans appeler d’abord <xref:System.Net.Sockets.Socket.Shutdown%2A>, vous pouvez vous assurer que les données en attente pour la transmission sortante est envoyée en définissant le <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> option `false` et en spécifiant un intervalle de délai d’attente différente de zéro.</span><span class="sxs-lookup"><span data-stu-id="3a270-1124">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="3a270-1125"><xref:System.Net.Sockets.Socket.Close%2A> puis bloque jusqu'à ce que ces données sont envoyées ou jusqu'à ce que le délai spécifié expire.</span><span class="sxs-lookup"><span data-stu-id="3a270-1125"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="3a270-1126">Si vous définissez <xref:System.Net.Sockets.SocketOptionName.DontLinger> à `false` et spécifiez un intervalle de délai d’attente zéro, <xref:System.Net.Sockets.Socket.Close%2A> libère la connexion et ignore automatiquement les données en file d’attente sortantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-1126">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1127">Pour définir le <xref:System.Net.Sockets.SocketOptionName.DontLinger> option de socket `false`, créer un <xref:System.Net.Sockets.LingerOption>, définit la propriété enabled `true`et définir le <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété à la période d’expiration souhaitée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1127">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="3a270-1128">Utilisez cette <xref:System.Net.Sockets.LingerOption> avec la <xref:System.Net.Sockets.SocketOptionName.DontLinger> de socket permet d’appeler le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1128">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1129">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1129">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1130">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1130">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1131">Les éléments suivants exemple de code ferme un <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1131">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3a270-1132">Attendez jusqu’à <c>timeout</c> en secondes pour envoyer toutes les données restantes, puis fermez le socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1132">Wait up to <c>timeout</c> seconds to send any remaining data, then close the socket.</span></span></param>
        <summary><span data-ttu-id="3a270-1133">Ferme la connexion <see cref="T:System.Net.Sockets.Socket" /> et libère toutes les ressources associées avec un délai d’attente spécifié pour permettre l’envoi des données en file d’attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1133">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1134">Le <xref:System.Net.Sockets.Socket.Close%2A> méthode ferme la connexion d’hôte distant et libère toutes les ressources managées et associés à la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1134">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1135">À la clôture, le <xref:System.Net.Sockets.Socket.Connected%2A> est définie sur `false`.</span><span class="sxs-lookup"><span data-stu-id="3a270-1135">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="3a270-1136">Pour les protocoles orientés connexion, il est recommandé d’appeler <xref:System.Net.Sockets.Socket.Shutdown%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1136">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="3a270-1137">Cela garantit que toutes les données est envoyé et reçu sur le socket connecté avant sa fermeture.</span><span class="sxs-lookup"><span data-stu-id="3a270-1137">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="3a270-1138">Si vous avez besoin d’appeler <xref:System.Net.Sockets.Socket.Close%2A> sans appeler d’abord <xref:System.Net.Sockets.Socket.Shutdown%2A>, vous pouvez vous assurer que les données en attente pour la transmission sortante est envoyée en définissant le <xref:System.Net.Sockets.SocketOptionName.DontLinger> option `false` et en spécifiant un intervalle de délai d’attente différente de zéro.</span><span class="sxs-lookup"><span data-stu-id="3a270-1138">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="3a270-1139"><xref:System.Net.Sockets.Socket.Close%2A> puis bloque jusqu'à ce que ces données sont envoyées ou jusqu'à ce que le délai spécifié expire.</span><span class="sxs-lookup"><span data-stu-id="3a270-1139"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="3a270-1140">Si vous définissez <xref:System.Net.Sockets.SocketOptionName.DontLinger> à `false` et spécifiez un intervalle de délai d’attente zéro, <xref:System.Net.Sockets.Socket.Close%2A> libère la connexion et ignore automatiquement les données en file d’attente sortantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-1140">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1141">Pour définir le <xref:System.Net.Sockets.SocketOptionName.DontLinger> option de socket `false`, créer un <xref:System.Net.Sockets.LingerOption>, définit la propriété enabled `true`et définir le <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété pour le délai d’expiration souhaitée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1141">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="3a270-1142">Utilisez cette <xref:System.Net.Sockets.LingerOption> avec la <xref:System.Net.Sockets.SocketOptionName.DontLinger> de socket permet d’appeler le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1142">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1143">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1143">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1144">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1144">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1145">L’exemple de code suivant montre comment fermer une <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1145">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-1146">Établit une connexion à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1146">Establishes a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="3a270-1147"><see cref="T:System.Net.EndPoint" /> qui représente l’appareil distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1147">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <summary><span data-ttu-id="3a270-1148">Établit une connexion à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1148">Establishes a connection to a remote host.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1149">Si vous utilisez un protocole orienté connexion, tels que TCP, la <xref:System.Net.Sockets.Socket.Connect%2A> méthode établit de manière synchrone une connexion réseau entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> et le point de terminaison distant spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-1149">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="3a270-1150">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.Connect%2A> établit un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-1150">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="3a270-1151">Après avoir appelé <xref:System.Net.Sockets.Socket.Connect%2A>, vous pouvez envoyer des données au périphérique distant avec le <xref:System.Net.Sockets.Socket.Send%2A> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1151">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1152">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1152">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="3a270-1153">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> et <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> pour communiquer de manière synchrone avec un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1153">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="3a270-1154">Si vous n’appelez pas <xref:System.Net.Sockets.Socket.Connect%2A>, tous les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1154">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="3a270-1155">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1155">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-1156">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1156">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1157">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1157">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="3a270-1158">Le <xref:System.Net.Sockets.Socket.Connect%2A> méthode se bloque, sauf si vous définissez spécifiquement le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false` avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1158">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-1159">Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException> , car il a besoin de temps pour établir la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1159">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="3a270-1160">Protocoles sans connexion ne lève pas une exception car ils établissent simplement un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-1160">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="3a270-1161">Vous pouvez utiliser <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1161">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1162">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1162">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="3a270-1163">Si l’erreur retournée est WSAEWOULDBLOCK, la connexion d’hôte distant a été initiée par un orienté connexion <xref:System.Net.Sockets.Socket>, mais n’est ne pas encore terminée correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-1163">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="3a270-1164">Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode afin de déterminer quand le <xref:System.Net.Sockets.Socket> a terminé la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1164">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1165">Si vous utilisez un protocole orienté connexion et n’a pas appelé <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>, le fournisseur de service sous-jacent affecte le numéro d’adresse et le port de réseau local.</span><span class="sxs-lookup"><span data-stu-id="3a270-1165">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="3a270-1166">Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous effectuez un envoi ou opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-1166">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="3a270-1167">Si vous souhaitez changer l’hôte distant par défaut, appelez <xref:System.Net.Sockets.Socket.Connect%2A> à nouveau avec le point de terminaison souhaité.</span><span class="sxs-lookup"><span data-stu-id="3a270-1167">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1168">Si le socket a été déconnecté précédemment, vous ne pouvez pas utiliser cette méthode pour rétablir la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1168">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="3a270-1169">Utilisez une des asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthodes se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="3a270-1169">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="3a270-1170">Il s’agit d’une limitation du fournisseur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-1170">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1171">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1171">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1172">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1172">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1173">L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1173">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1174"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1174"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1175">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1175">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1176"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1176">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-1177">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1177">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-1178"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1178">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-1179">pour la connexion à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1179">for connecting to the remote host.</span></span> <span data-ttu-id="3a270-1180">Énumération associée : <see cref="F:System.Net.NetworkAccess.Connect" /></span><span class="sxs-lookup"><span data-stu-id="3a270-1180">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3a270-1181">Adresse IP de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1181">The IP address of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="3a270-1182">Numéro de port de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1182">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="3a270-1183">Établit une connexion à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1183">Establishes a connection to a remote host.</span></span> <span data-ttu-id="3a270-1184">L’hôte est spécifié par une adresse IP et un numéro de port.</span><span class="sxs-lookup"><span data-stu-id="3a270-1184">The host is specified by an IP address and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1185">Si vous utilisez un protocole orienté connexion, tels que TCP, la <xref:System.Net.Sockets.Socket.Connect%2A> méthode établit de manière synchrone une connexion réseau entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> et le point de terminaison distant spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-1185">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="3a270-1186">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.Connect%2A> établit un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-1186">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="3a270-1187">Après avoir appelé <xref:System.Net.Sockets.Socket.Connect%2A> peut envoyer des données à l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Send%2A> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1187">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1188">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1188">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="3a270-1189">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> et <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> pour communiquer de manière synchrone avec un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1189">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="3a270-1190">Si vous n’appelez pas <xref:System.Net.Sockets.Socket.Connect%2A> les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1190">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="3a270-1191">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1191">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-1192">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1192">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1193">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1193">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="3a270-1194"><xref:System.Net.Sockets.Socket.Connect%2A> méthode se bloque, sauf si vous définissez spécifiquement le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false` avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1194"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-1195">Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException> , car il a besoin de temps pour établir la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1195">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="3a270-1196">Protocoles sans connexion ne lève pas une exception car ils établissent simplement un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-1196">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="3a270-1197">Vous pouvez utiliser <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1197">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1198">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1198">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="3a270-1199">Si l’erreur retournée est WSAEWOULDBLOCK, la connexion d’hôte distant a été initiée par un orienté connexion <xref:System.Net.Sockets.Socket>, mais n’est ne pas encore terminée correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-1199">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="3a270-1200">Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode afin de déterminer quand le <xref:System.Net.Sockets.Socket> a terminé la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1200">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1201">Si vous utilisez un protocole orienté connexion et n’a pas appelé <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>, le fournisseur de service sous-jacent affecte le numéro d’adresse et le port de réseau local.</span><span class="sxs-lookup"><span data-stu-id="3a270-1201">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="3a270-1202">Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous effectuez un envoi ou opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-1202">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="3a270-1203">Si vous souhaitez changer l’hôte distant par défaut, appelez <xref:System.Net.Sockets.Socket.Connect%2A> à nouveau avec le point de terminaison souhaité.</span><span class="sxs-lookup"><span data-stu-id="3a270-1203">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1204">Si le socket a été déconnecté précédemment, vous ne pouvez pas utiliser cette méthode pour rétablir la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1204">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="3a270-1205">Utilisez une des asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthodes se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="3a270-1205">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="3a270-1206">Il s’agit d’une limitation du fournisseur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-1206">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1207">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1207">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1208">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1208">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1209">L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1209">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1210"><paramref name="address" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1210"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-1211">Le numéro de port n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1211">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1212">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1212">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1213"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1213">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1214">Cette méthode est valide pour les sockets appartenant aux familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1214">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-1215">La longueur de <paramref name="address" /> est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="3a270-1215">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-1216"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1216">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="3a270-1217">Adresses IP de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1217">The IP addresses of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="3a270-1218">Numéro de port de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1218">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="3a270-1219">Établit une connexion à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1219">Establishes a connection to a remote host.</span></span> <span data-ttu-id="3a270-1220">L’hôte est spécifié par un tableau d’adresses IP et un numéro de port.</span><span class="sxs-lookup"><span data-stu-id="3a270-1220">The host is specified by an array of IP addresses and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1221">Cette méthode est généralement utilisée immédiatement après un appel à <xref:System.Net.Dns.GetHostAddresses%2A>, qui peut retourner plusieurs adresses IP pour un seul hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-1221">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="3a270-1222">Si vous utilisez un protocole orienté connexion, tels que TCP, la <xref:System.Net.Sockets.Socket.Connect%2A> méthode établit de manière synchrone une connexion réseau entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> et le point de terminaison distant spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-1222">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="3a270-1223">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.Connect%2A> établit un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-1223">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="3a270-1224">Après avoir appelé <xref:System.Net.Sockets.Socket.Connect%2A> peut envoyer des données à l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Send%2A> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1224">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1225">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1225">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="3a270-1226">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> et <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> pour communiquer de manière synchrone avec un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1226">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="3a270-1227">Si vous n’appelez pas <xref:System.Net.Sockets.Socket.Connect%2A> les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1227">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="3a270-1228">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1228">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-1229">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1229">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1230">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1230">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="3a270-1231"><xref:System.Net.Sockets.Socket.Connect%2A> méthode se bloque, sauf si vous définissez spécifiquement le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false` avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1231"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-1232">Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException> , car il a besoin de temps pour établir la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1232">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="3a270-1233">Protocoles sans connexion ne lève pas une exception car ils établissent simplement un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-1233">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="3a270-1234">Vous pouvez utiliser <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1234">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1235">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1235">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="3a270-1236">Si l’erreur retournée est WSAEWOULDBLOCK, la connexion d’hôte distant a été initiée par un orienté connexion <xref:System.Net.Sockets.Socket>, mais n’est ne pas encore terminée correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-1236">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="3a270-1237">Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode afin de déterminer quand le <xref:System.Net.Sockets.Socket> a terminé la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1237">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1238">Si vous utilisez un protocole orienté connexion et n’a pas appelé <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>, le fournisseur de service sous-jacent affecte le numéro d’adresse et le port de réseau local.</span><span class="sxs-lookup"><span data-stu-id="3a270-1238">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="3a270-1239">Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous effectuez un envoi ou opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-1239">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="3a270-1240">Si vous souhaitez changer l’hôte distant par défaut, appelez <xref:System.Net.Sockets.Socket.Connect%2A> à nouveau avec le point de terminaison souhaité.</span><span class="sxs-lookup"><span data-stu-id="3a270-1240">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1241">Si le socket a été déconnecté précédemment, vous ne pouvez pas utiliser cette méthode pour rétablir la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1241">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="3a270-1242">Utilisez une des asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthodes se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="3a270-1242">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="3a270-1243">Il s’agit d’une limitation du fournisseur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-1243">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1244">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1244">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1245">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1245">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1246">L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1246">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1247"><paramref name="addresses" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1247"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-1248">Le numéro de port n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1248">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1249">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1249">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1250"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1250">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1251">Cette méthode est valide pour les sockets appartenant aux familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1251">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-1252">La longueur de <paramref name="address" /> est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="3a270-1252">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-1253"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1253">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="3a270-1254">Nom de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1254">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="3a270-1255">Numéro de port de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1255">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="3a270-1256">Établit une connexion à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1256">Establishes a connection to a remote host.</span></span> <span data-ttu-id="3a270-1257">L’hôte est spécifié par un nom d’hôte et un numéro de port.</span><span class="sxs-lookup"><span data-stu-id="3a270-1257">The host is specified by a host name and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1258">Si vous utilisez un protocole orienté connexion, tels que TCP, la <xref:System.Net.Sockets.Socket.Connect%2A> méthode établit de manière synchrone une connexion réseau entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> et l’hôte distant spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-1258">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="3a270-1259">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.Connect%2A> établit un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-1259">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="3a270-1260">Après avoir appelé <xref:System.Net.Sockets.Socket.Connect%2A> peut envoyer des données à l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Send%2A> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1260">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1261">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1261">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="3a270-1262">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> et <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> pour communiquer de manière synchrone avec un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1262">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="3a270-1263">Si vous n’appelez pas <xref:System.Net.Sockets.Socket.Connect%2A> les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1263">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="3a270-1264">Si vous souhaitez affecter à une adresse de diffusion votre hôte distant par défaut, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1264">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-1265">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1265">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1266">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1266">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="3a270-1267"><xref:System.Net.Sockets.Socket.Connect%2A> méthode se bloque, sauf si vous définissez spécifiquement le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false` avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1267"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-1268">Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException> , car il a besoin de temps pour établir la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1268">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="3a270-1269">Protocoles sans connexion ne lève pas une exception car ils établissent simplement un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-1269">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="3a270-1270">Vous pouvez utiliser <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1270">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1271">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1271">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="3a270-1272">Si l’erreur retournée est WSAEWOULDBLOCK, la connexion d’hôte distant a été initiée par un orienté connexion <xref:System.Net.Sockets.Socket>, mais n’est ne pas encore terminée correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-1272">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="3a270-1273">Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode afin de déterminer quand le <xref:System.Net.Sockets.Socket> a terminé la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1273">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="3a270-1274">Si le protocole IPv6 est activé et le <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> est appelée pour vous connecter à un hôte qui résout les deux IPv6 et des adresses IPv4, la connexion à l’adresse IPv6 sera tentée en premier avant l’adresse IPv4.</span><span class="sxs-lookup"><span data-stu-id="3a270-1274">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="3a270-1275">Cela peut avoir pour effet de retarder l’heure pour établir la connexion si l’hôte n’écoute pas sur l’adresse IPv6.</span><span class="sxs-lookup"><span data-stu-id="3a270-1275">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1276">Si vous utilisez un protocole orienté connexion et n’a pas appelé <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>, le fournisseur de service sous-jacent affecte le numéro d’adresse et le port de réseau local.</span><span class="sxs-lookup"><span data-stu-id="3a270-1276">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="3a270-1277">Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un nombre d’adresse et le port de réseau local jusqu'à ce que vous effectuez un envoi ou opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-1277">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="3a270-1278">Si vous souhaitez changer l’hôte distant par défaut, appelez <xref:System.Net.Sockets.Socket.Connect%2A> à nouveau avec le point de terminaison souhaité.</span><span class="sxs-lookup"><span data-stu-id="3a270-1278">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1279">Si le socket a été déconnecté précédemment, vous ne pouvez pas utiliser cette méthode pour rétablir la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1279">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="3a270-1280">Utilisez une des asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthodes se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="3a270-1280">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="3a270-1281">Il s’agit d’une limitation du fournisseur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-1281">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1282">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1282">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1283">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1283">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1284">L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1284">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1285"><paramref name="host" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1285"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-1286">Le numéro de port n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1286">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1287">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1287">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1288"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1288">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1289">Cette méthode est valide pour les sockets appartenant aux familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1289">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-1290"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1290">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-1291">Démarre une demande asynchrone pour une connexion à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1291">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-1292">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1292">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-1293">Démarre une demande asynchrone pour une connexion à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1293">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="3a270-1294">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1294">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-1295">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1295">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-1296">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1296">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-1297">Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1297">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1298">Si vous utilisez un protocole orienté connexion, la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode démarre une demande asynchrone pour une connexion à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1298">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="3a270-1299">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> établit un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-1299">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="3a270-1300">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler\<SocketAsyncEventArgs > et l’attacher le rappel pour le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.</span><span class="sxs-lookup"><span data-stu-id="3a270-1300">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="3a270-1301">L’appelant doit définir le <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété le <xref:System.Net.IPEndPoint> de l’hôte distant pour se connecter à.</span><span class="sxs-lookup"><span data-stu-id="3a270-1301">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="3a270-1302">L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-1302">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="3a270-1303">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</span><span class="sxs-lookup"><span data-stu-id="3a270-1303">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="3a270-1304">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.ConnectAsync%2A> avant d’envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1304">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="3a270-1305">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendToAsync%2A> et <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> pour communiquer avec un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1305">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="3a270-1306">Si vous n’appelez pas <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, tous les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1306">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="3a270-1307">Si vous souhaitez changer l’hôte distant par défaut, appelez le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode avec le point de terminaison souhaité.</span><span class="sxs-lookup"><span data-stu-id="3a270-1307">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="3a270-1308">Si vous souhaitez définir l’hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler <xref:System.Net.Sockets.Socket.SetSocketOption%2A> et la valeur diffusion `true`.</span><span class="sxs-lookup"><span data-stu-id="3a270-1308">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="3a270-1309">Si cela n’est pas fait, le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode lève un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1309">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-1310">Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requises :</span><span class="sxs-lookup"><span data-stu-id="3a270-1310">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="3a270-1311">Si vous le souhaitez, une mémoire tampon peut être fournie qui sera envoyé atomiquement sur le socket après le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode réussit.</span><span class="sxs-lookup"><span data-stu-id="3a270-1311">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="3a270-1312">Dans ce cas, le <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriété doit être définie dans la mémoire tampon qui contient les données à envoyer et <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriété doit être définie pour le nombre d’octets de données à envoyer à partir de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-1312">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="3a270-1313">Une fois qu’une connexion est établie, cette mémoire tampon de données est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1313">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="3a270-1314">Si vous utilisez un protocole orienté connexion et que vous n’appelez pas <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, le fournisseur de service sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.</span><span class="sxs-lookup"><span data-stu-id="3a270-1314">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="3a270-1315">Si vous utilisez un protocole sans connexion, le fournisseur de services assignera pas un réseau local IP adresse et numéro de port jusqu'à ce que vous appeliez la <xref:System.Net.Sockets.Socket.SendAsync%2A> ou <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-1315">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="3a270-1316">Le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode lève une exception <xref:System.NotSupportedException> si la famille d’adresses de la <xref:System.Net.Sockets.Socket> et <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> ne sont pas la même famille d’adresses.</span><span class="sxs-lookup"><span data-stu-id="3a270-1316">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1317">Si vous recevez un <xref:System.Net.Sockets.SocketException> lorsque vous appelez cette méthode, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1317">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1318">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1318">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-1319">Un argument n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1319">An argument is not valid.</span></span> <span data-ttu-id="3a270-1320">Cette exception se produit si plusieurs mémoires tampons sont spécifiées, la propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> n'est pas null.</span><span class="sxs-lookup"><span data-stu-id="3a270-1320">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a270-1321">Le paramètre <paramref name="e" /> ne peut pas être null et <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1321">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-1322"><see cref="T:System.Net.Sockets.Socket" /> est à l'écoute ou une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</span><span class="sxs-lookup"><span data-stu-id="3a270-1322">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1323">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1323">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1324">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1324">Windows XP or later is required for this method.</span></span> <span data-ttu-id="3a270-1325">Cette exception se produit également si le point de terminaison local et les <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne sont pas la même famille d'adresses.</span><span class="sxs-lookup"><span data-stu-id="3a270-1325">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1326"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1326">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-1327">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1327">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="3a270-1328">Une des valeurs de <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1328">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="3a270-1329">Une des valeurs de <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1329">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <param name="e"><span data-ttu-id="3a270-1330">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1330">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-1331">Démarre une demande asynchrone pour une connexion à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1331">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="3a270-1332">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1332">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-1333">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1333">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-1334">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1334">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-1335">Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1335">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1336">Si vous utilisez un protocole orienté connexion, la méthode System.NET.Sockets.ProtocolType démarre une demande asynchrone pour une connexion à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1336">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="3a270-1337">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> établit un hôte distant par défaut spécifié par le `socketType` et `protocolType` paramètres.</span><span class="sxs-lookup"><span data-stu-id="3a270-1337">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="3a270-1338">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler\<SocketAsyncEventArgs > et l’attacher le rappel pour le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.</span><span class="sxs-lookup"><span data-stu-id="3a270-1338">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="3a270-1339">L’appelant doit définir le <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété le <xref:System.Net.IPEndPoint> de l’hôte distant pour se connecter à.</span><span class="sxs-lookup"><span data-stu-id="3a270-1339">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="3a270-1340">L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-1340">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="3a270-1341">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</span><span class="sxs-lookup"><span data-stu-id="3a270-1341">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="3a270-1342">Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.ConnectAsync%2A> avant d’envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1342">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="3a270-1343">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendToAsync%2A> et <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> pour communiquer avec un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1343">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="3a270-1344">Si vous n’appelez pas <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, tous les datagrammes provenant d’une adresse autre que celle par défaut spécifiée seront ignorés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1344">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="3a270-1345">Si vous souhaitez changer l’hôte distant par défaut, appelez le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode avec le point de terminaison souhaité.</span><span class="sxs-lookup"><span data-stu-id="3a270-1345">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="3a270-1346">Si vous souhaitez définir l’hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler <xref:System.Net.Sockets.Socket.SetSocketOption%2A> et la valeur diffusion `true`.</span><span class="sxs-lookup"><span data-stu-id="3a270-1346">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="3a270-1347">Si cela n’est pas fait, le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode lève un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1347">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-1348">Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requises :</span><span class="sxs-lookup"><span data-stu-id="3a270-1348">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="3a270-1349">Si vous le souhaitez, une mémoire tampon peut être fournie qui sera envoyé atomiquement sur le socket après le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode réussit.</span><span class="sxs-lookup"><span data-stu-id="3a270-1349">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="3a270-1350">Dans ce cas, le <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriété doit être définie dans la mémoire tampon qui contient les données à envoyer et <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriété doit être définie pour le nombre d’octets de données à envoyer à partir de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-1350">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="3a270-1351">Une fois qu’une connexion est établie, cette mémoire tampon de données est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1351">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="3a270-1352">Si vous utilisez un protocole orienté connexion et que vous n’appelez pas <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, le fournisseur de service sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.</span><span class="sxs-lookup"><span data-stu-id="3a270-1352">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="3a270-1353">Si vous utilisez un protocole sans connexion, le fournisseur de services assignera pas un réseau local IP adresse et numéro de port jusqu'à ce que vous appeliez la <xref:System.Net.Sockets.Socket.SendAsync%2A> ou <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-1353">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="3a270-1354">Le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode lève une exception <xref:System.NotSupportedException> si la famille d’adresses de la <xref:System.Net.Sockets.Socket> et <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> ne sont pas la même famille d’adresses.</span><span class="sxs-lookup"><span data-stu-id="3a270-1354">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1355">Si vous recevez un <xref:System.Net.Sockets.SocketException> lorsque vous appelez cette méthode, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1355">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1356">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1356">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-1357">Un argument n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1357">An argument is not valid.</span></span> <span data-ttu-id="3a270-1358">Cette exception se produit si plusieurs mémoires tampons sont spécifiées, la propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> n'est pas null.</span><span class="sxs-lookup"><span data-stu-id="3a270-1358">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a270-1359">Le paramètre <paramref name="e" /> ne peut pas être null et <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1359">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-1360"><see cref="T:System.Net.Sockets.Socket" /> est à l'écoute ou une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</span><span class="sxs-lookup"><span data-stu-id="3a270-1360">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1361">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1361">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1362">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1362">Windows XP or later is required for this method.</span></span> <span data-ttu-id="3a270-1363">Cette exception se produit également si le point de terminaison local et les <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne sont pas la même famille d'adresses.</span><span class="sxs-lookup"><span data-stu-id="3a270-1363">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1364"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1364">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-1365">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1365">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1366">Obtient une valeur qui indique si <see cref="T:System.Net.Sockets.Socket" /> est connecté à un hôte distant depuis la dernière opération <see cref="Overload:System.Net.Sockets.Socket.Send" /> ou <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1366">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1367"><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> était connecté à une ressource distante lors de l'opération la plus récente ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1367"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1368">Le `Connected` propriété obtient l’état de connexion de la <xref:System.Net.Sockets.Socket> depuis la dernière opération d’e/s.</span><span class="sxs-lookup"><span data-stu-id="3a270-1368">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="3a270-1369">Lorsqu’elle retourne `false`, le <xref:System.Net.Sockets.Socket> n’a jamais été connecté, ou n’est plus connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-1369">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="3a270-1370">La valeur de la <xref:System.Net.Sockets.Socket.Connected%2A> propriété reflète l’état de la connexion depuis la dernière opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1370">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="3a270-1371">Si vous avez besoin déterminer l’état actuel de la connexion, appeler un envoi non bloquant, zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1371">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="3a270-1372">Si l’appel retourné avec succès ou lève un code d’erreur WAEWOULDBLOCK (10035), puis le socket est toujours connecté ; Sinon, le socket n’est plus connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-1372">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="3a270-1373">Si vous appelez <xref:System.Net.Sockets.Socket.Connect%2A> sur un socket de protocole UDP (User Datagram), le <xref:System.Net.Sockets.Socket.Connected%2A> propriété retourne toujours `true`; Toutefois, cette action ne modifie pas la nature même sans connexion UDP.</span><span class="sxs-lookup"><span data-stu-id="3a270-1373">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1374">L’exemple de code suivant se connecte à un point de terminaison distant, vérifie le <xref:System.Net.Sockets.Socket.Connected%2A> propriété et vérifie l’état actuel de la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1374">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="3a270-1375"><see langword="true" /> si ce socket peut être réutilisé après la fermeture de la connexion active ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1375"><see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3a270-1376">Ferme la connexion de socket et autorise la réutilisation du socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1376">Closes the socket connection and allows reuse of the socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1377">Si vous utilisez un protocole orienté connexion, vous pouvez utiliser cette méthode pour fermer le socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1377">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="3a270-1378">Cette méthode met fin à la connexion et affecte le <xref:System.Net.Sockets.Socket.Connected%2A> propriété `false`.</span><span class="sxs-lookup"><span data-stu-id="3a270-1378">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="3a270-1379">Toutefois, si `reuseSocket` est `true`, vous pouvez réutiliser le socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1379">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="3a270-1380">Pour vous assurer que toutes les données envoyé et reçu avant que le socket est fermé, vous devez appeler <xref:System.Net.Sockets.Socket.Shutdown%2A> avant d’appeler le <xref:System.Net.Sockets.Socket.Disconnect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1380">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1381">Si vous avez besoin d’appeler <xref:System.Net.Sockets.Socket.Disconnect%2A> sans appeler d’abord <xref:System.Net.Sockets.Socket.Shutdown%2A>, vous pouvez définir le <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> option `false` et spécifiez un intervalle de délai d’attente différente de zéro pour vous assurer que les données en attente pour la transmission sortante est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1381">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="3a270-1382"><xref:System.Net.Sockets.Socket.Disconnect%2A> puis se bloque jusqu'à ce que les données sont envoyées ou jusqu'à ce que le délai spécifié expire.</span><span class="sxs-lookup"><span data-stu-id="3a270-1382"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="3a270-1383">Si vous définissez <xref:System.Net.Sockets.SocketOptionName.DontLinger> à `false` et spécifiez un intervalle de délai d’attente zéro, <xref:System.Net.Sockets.Socket.Close%2A> libère la connexion et ignore automatiquement les données en file d’attente sortantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-1383">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1384">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1384">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1385">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1385">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1386">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1386">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1387">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1387">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1388">L’exemple de code suivant crée un socket pour la communication synchrone et envoie des données à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1388">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="3a270-1389">Il appelle ensuite <xref:System.Net.Sockets.Socket.Shutdown%2A>pour arrêter l’envoi et de réception d’activité, et <xref:System.Net.Sockets.Socket.Disconnect%2A>pour fermer la connexion de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1389">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="3a270-1390">Cette méthode nécessite Windows 2000 ou version antérieure, ou l'exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1390">This method requires Windows 2000 or earlier, or the exception will be thrown.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1391">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1391">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1392">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1392">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-1393">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1393">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-1394">Lance une demande asynchrone de déconnexion d'un point de terminaison distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1394">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="3a270-1395">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1395">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-1396">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1396">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-1397">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1397">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-1398">Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1398">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1399">Lorsque vous utilisez un protocole orienté connexion, appelant le <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> méthode requiert la déconnexion d’un point de terminaison distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1399">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="3a270-1400">Si vous définissez <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> à `true` dans le `e` paramètre, le socket peut être réutilisé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1400">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a270-1401">Le paramètre <paramref name="e" /> ne peut pas être Null.</span><span class="sxs-lookup"><span data-stu-id="3a270-1401">The <paramref name="e" /> parameter cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-1402">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</span><span class="sxs-lookup"><span data-stu-id="3a270-1402">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1403">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1403">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1404"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1404">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1405">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1405">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-1406">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1406">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a270-1407">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1407">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1408">Appelez la méthode `Dispose` une fois que vous avez terminé d'utiliser <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1408">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1409">La méthode `Dispose` rend le <xref:System.Net.Sockets.Socket> inutilisable.</span><span class="sxs-lookup"><span data-stu-id="3a270-1409">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="3a270-1410">Après avoir appelé `Dispose`, vous devez libérer toutes les références à la <xref:System.Net.Sockets.Socket> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Net.Sockets.Socket> occupée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1410">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="3a270-1411">Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1411">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1412">Appelez toujours `Dispose` avant de libérer votre dernière référence à <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1412">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1413">Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Net.Sockets.Socket> de l'objet `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="3a270-1413">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="3a270-1414"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="3a270-1414"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="3a270-1415">Libère les ressources non managées utilisées par <see cref="T:System.Net.Sockets.Socket" /> et supprime éventuellement les ressources managées.</span><span class="sxs-lookup"><span data-stu-id="3a270-1415">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1416">Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1416">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="3a270-1417">`Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec la `disposing` paramètre la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="3a270-1417">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="3a270-1418"><xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="3a270-1418"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="3a270-1419">Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1419">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="3a270-1420">Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1420">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1421">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1421">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1422">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1422">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="3a270-1423"><see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets.</span><span class="sxs-lookup"><span data-stu-id="3a270-1423"><see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="3a270-1424">Lors de la substitution de <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1424">When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="3a270-1425">Pour plus d’informations sur l’implémentation <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1425">For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
 <span data-ttu-id="3a270-1426">Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span><span class="sxs-lookup"><span data-stu-id="3a270-1426">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1427">Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> autorise la fragmentation des datagrammes IP (Internet Protocol).</span><span class="sxs-lookup"><span data-stu-id="3a270-1427">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1428"><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> autorise la fragmentation des datagrammes ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1428"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3a270-1429">La valeur par défaut est <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1429">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1430">Les datagrammes exigent une fragmentation lorsque leur taille dépasse le Maximum unité de transfert (MTU) du support de transmission.</span><span class="sxs-lookup"><span data-stu-id="3a270-1430">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="3a270-1431">Les datagrammes peuvent être fragmentés par l’hôte d’envoi (toutes les versions d’Internet Protocol) ou un routeur intermédiaire (protocole Internet Version 4 uniquement).</span><span class="sxs-lookup"><span data-stu-id="3a270-1431">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="3a270-1432">Si un datagramme doit être fragmenté et le <xref:System.Net.Sockets.Socket.DontFragment%2A> option est définie, le datagramme est ignoré et un message d’erreur de contrôle Message ICMP (Internet Protocol) est envoyé à l’expéditeur du datagramme.</span><span class="sxs-lookup"><span data-stu-id="3a270-1432">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="3a270-1433">Définition de cette propriété sur un socket de protocole TCP (Transmission Control) n’aura aucun effet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1433">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1434">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.DontFragment%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-1434">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1435">Cette propriété ne peut être définie que pour les sockets dans les familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1435">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1436">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1436">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1437"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1437">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1438">Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> est un socket en mode double utilisé pour IPv4 et IPv6.</span><span class="sxs-lookup"><span data-stu-id="3a270-1438">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1439"><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> est un socket en mode double ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1439"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3a270-1440">La valeur par défaut est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1440">The default is <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId"><span data-ttu-id="3a270-1441">ID du processus cible où un doublon de la référence de socket est créé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1441">The ID of the target process where a duplicate of the socket reference is created.</span></span></param>
        <summary><span data-ttu-id="3a270-1442">Duplique la référence de socket pour le processus cible et ferme le socket pour ce processus.</span><span class="sxs-lookup"><span data-stu-id="3a270-1442">Duplicates the socket reference for the target process, and closes the socket for this process.</span></span></summary>
        <returns><span data-ttu-id="3a270-1443">Référence de socket à passer au processus cible.</span><span class="sxs-lookup"><span data-stu-id="3a270-1443">The socket reference to be passed to the target process.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1444">Le processus cible doit utiliser <xref:System.Net.Sockets.Socket.%23ctor%2A> pour créer l’instance de socket en double.</span><span class="sxs-lookup"><span data-stu-id="3a270-1444">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="3a270-1445">Si vous appelez le <xref:System.Net.Sockets.Socket.%23ctor%2A> constructeur plusieurs fois avec le même tableau d’octets comme argument pour chaque appel, vous créerez plusieurs gérés <xref:System.Net.Sockets.Socket> instances avec le même socket sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-1445">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="3a270-1446">Cette pratique est fortement déconseillée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1446">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="3a270-1447">Si le processus de création du socket utilise des méthodes asynchrones (<xref:System.Net.Sockets.Socket.BeginReceive%2A> ou <xref:System.Net.Sockets.Socket.BeginSend%2A>), le processus doit tout d’abord définir le <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> propriété à true ; sinon, le socket est lié au port de terminaison du processus de création, ce qui peut entraîner une <xref:System.ArgumentNullException> levée sur le processus cible.</span><span class="sxs-lookup"><span data-stu-id="3a270-1447">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-1448"><paramref name="targetProcessID" /> n'est pas un ID de processus valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1448"><paramref name="targetProcessID" /> is not a valid process id.</span></span>  
  
 <span data-ttu-id="3a270-1449">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1449">-or-</span></span>  
  
 <span data-ttu-id="3a270-1450">La duplication de la référence de socket a échoué.</span><span class="sxs-lookup"><span data-stu-id="3a270-1450">Duplication of the socket reference failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1451">Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> peut envoyer ou recevoir des paquets de diffusion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1451">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1452"><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> autorise les paquets de diffusion ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1452"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3a270-1453">La valeur par défaut est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1453">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1454">Diffusion est limitée à un sous-réseau spécifique et doit utiliser User Datagram Protocol (UDP). Pour Internet Protocol version 4, vous pouvez diffuser sur votre sous-réseau local en envoyant un paquet à l’adresse 255.255.255.255 ; ou vous pouvez utiliser l’adresse de diffusion dirigée, qui est la partie du réseau d’une adresse IP (Internet Protocol) avec tous les bits définis dans la partie hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-1454">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="3a270-1455">Par exemple, si votre adresse IP est 192.168.1.40 (une adresse de classe C, avec un masque de sous-réseau de 255.255.255.0, la partie réseau étant les trois premiers octets et la partie hôte le dernier octet), votre adresse de diffusion dirigée est 192.168.1.255.</span><span class="sxs-lookup"><span data-stu-id="3a270-1455">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="3a270-1456">Définition de cette propriété sur un socket de protocole TCP (Transmission Control) n’aura aucun effet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1456">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1457">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-1457">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1458">Cette option n'est valide que pour un socket datagramme.</span><span class="sxs-lookup"><span data-stu-id="3a270-1458">This option is valid for a datagram socket only.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1459"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1459">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-1460">Accepte de manière asynchrone une tentative de connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-1460">Asynchronously accepts an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-1461">Tableau de type <see cref="T:System.Byte" /> qui contient les octets transférés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1461">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="3a270-1462">Objet <see cref="T:System.IAsyncResult" /> qui stocke les informations d'état pour cette opération asynchrone ainsi que toutes les données définies par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1462">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="3a270-1463">Accepte de manière asynchrone une tentative de connexion entrante et crée un nouvel objet <see cref="T:System.Net.Sockets.Socket" /> pour gérer les communications de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1463">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="3a270-1464">Cette méthode retourne une mémoire tampon qui contient les données initiales transférées.</span><span class="sxs-lookup"><span data-stu-id="3a270-1464">This method returns a buffer that contains the initial data transferred.</span></span></summary>
        <returns><span data-ttu-id="3a270-1465">Objet <see cref="T:System.Net.Sockets.Socket" /> pour gérer la communication avec l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1465">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1466"><xref:System.Net.Sockets.Socket.EndAccept%2A> termine un appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1466"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="3a270-1467">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginAccept%2A>, vous devez créer une méthode de rappel appelée par le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1467">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1468">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après la <xref:System.Net.Sockets.Socket.BeginAccept%2A> retourne de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1468">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="3a270-1469">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la `asyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.Socket> sur lequel la tentative de connexion est effectuée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1469">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="3a270-1470">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode mener à bien la tentative de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1470">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="3a270-1471">Le `buffer` paramètre de cette surcharge contient les données qui a été reçues dans l’appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A> et `bytesTransferred` paramètre contient le nombre d’octets qui ont été transférés dans l’appel.</span><span class="sxs-lookup"><span data-stu-id="3a270-1471">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="3a270-1472">Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode est bloquée jusqu'à ce qu’une connexion est en attente dans la file d’attente de connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-1472">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="3a270-1473">Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode accepte la connexion entrante et retourne un nouveau <xref:System.Net.Sockets.Socket> qui peut être utilisé pour envoyer et recevoir des données à partir de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1473">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1474">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1474">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1475">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1475">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1476">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1476">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1477">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1477">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1478">Le code suivant utilise des exemple <xref:System.Net.Sockets.Socket.BeginAccept%2A> pour créer et connecter un socket et accepte les 10 premiers octets de données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1478">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="3a270-1479">Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndAccept%2A> pour terminer la demande asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1479">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="3a270-1480">Le nombre d’octets transmis et les données sont retournées dans le `buffer` et `bytesTransferred` paramètres de cette méthode et sont affichés dans la console.</span><span class="sxs-lookup"><span data-stu-id="3a270-1480">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1481">Windows NT est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1481">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1482">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1482">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1483"><paramref name="asyncResult" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1483"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1484"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1484"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1485">La méthode <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> a été appelée au préalable.</span><span class="sxs-lookup"><span data-stu-id="3a270-1485"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1486">Une erreur s’est produite lors de la tentative d’accès à <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="3a270-1486">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="3a270-1487">Accepte de manière asynchrone une tentative de connexion entrante et crée un nouveau <see cref="T:System.Net.Sockets.Socket" /> pour gérer les communications de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1487">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span></span></summary>
        <returns><span data-ttu-id="3a270-1488"><see cref="T:System.Net.Sockets.Socket" /> pour gérer la communication avec l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1488">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1489"><xref:System.Net.Sockets.Socket.EndAccept%2A> termine un appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1489"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="3a270-1490">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginAccept%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1490">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1491">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après la <xref:System.Net.Sockets.Socket.BeginAccept%2A> retourne de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1491">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="3a270-1492">Elle doit accepter le `asyncResult` paramètre retourné à partir de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1492">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1493">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la `asyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.Socket> sur lequel la tentative de connexion est effectuée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1493">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="3a270-1494">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode mener à bien la tentative de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1494">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="3a270-1495">Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode est bloquée jusqu'à ce qu’une connexion est en attente dans la file d’attente de connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-1495">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="3a270-1496">Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode accepte la connexion entrante et retourne un nouveau <xref:System.Net.Sockets.Socket> qui peut être utilisé pour envoyer et recevoir des données à partir de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1496">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1497">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1497">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1498">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1498">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1499">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1499">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1500">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1500">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1501">L’exemple de code suivant met fin à une demande asynchrone et crée un <xref:System.Net.Sockets.Socket> à accepter une demande de connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-1501">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="3a270-1502">Pour obtenir un exemple complet illustrant des communications asynchrones avec les sockets, consultez [exemples de Code de Socket](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1502">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1503"><paramref name="asyncResult" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1503"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1504"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1504"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1505">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1505">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-1506">Pour plus d'informations, consultez la section Notes.</span><span class="sxs-lookup"><span data-stu-id="3a270-1506">See the Remarks section for more information.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1507"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1507">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1508">La méthode <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> a été appelée au préalable.</span><span class="sxs-lookup"><span data-stu-id="3a270-1508"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1509">Windows NT est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1509">Windows NT is required for this method.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-1510">Tableau de type <see cref="T:System.Byte" /> qui contient les octets transférés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1510">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="bytesTransferred"><span data-ttu-id="3a270-1511">Nombre d'octets transférés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1511">The number of bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="3a270-1512">Objet <see cref="T:System.IAsyncResult" /> qui stocke les informations d'état pour cette opération asynchrone ainsi que toutes les données définies par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1512">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="3a270-1513">Accepte de manière asynchrone une tentative de connexion entrante et crée un nouvel objet <see cref="T:System.Net.Sockets.Socket" /> pour gérer les communications de l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1513">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="3a270-1514">Cette méthode retourne une mémoire tampon qui contient les données initiales et le nombre d'octets transférés.</span><span class="sxs-lookup"><span data-stu-id="3a270-1514">This method returns a buffer that contains the initial data and the number of bytes transferred.</span></span></summary>
        <returns><span data-ttu-id="3a270-1515">Objet <see cref="T:System.Net.Sockets.Socket" /> pour gérer la communication avec l'hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1515">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1516"><xref:System.Net.Sockets.Socket.EndAccept%2A> termine un appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1516"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="3a270-1517">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginAccept%2A>, vous devez créer une méthode de rappel appelée par le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1517">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1518">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après la <xref:System.Net.Sockets.Socket.BeginAccept%2A> retourne de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1518">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="3a270-1519">Elle doit accepter le `asyncResult` paramètre retourné à partir de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1519">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1520">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la `asyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.Socket> sur lequel la tentative de connexion est effectuée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1520">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="3a270-1521">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode mener à bien la tentative de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1521">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="3a270-1522">Le `buffer` paramètre de cette surcharge contient les données qui a été reçues dans l’appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A> et `bytesTransferred` paramètre contient le nombre d’octets qui ont été transférés dans l’appel.</span><span class="sxs-lookup"><span data-stu-id="3a270-1522">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="3a270-1523">Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode est bloquée jusqu'à ce qu’une connexion est en attente dans la file d’attente de connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-1523">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="3a270-1524">Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode accepte la connexion entrante et retourne un nouveau <xref:System.Net.Sockets.Socket> qui peut être utilisé pour envoyer et recevoir des données à partir de l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1524">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1525">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1525">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1526">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1526">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1527">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1527">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1528">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1528">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1529">Le code suivant utilise des exemple <xref:System.Net.Sockets.Socket.BeginAccept%2A> pour créer et connecter un socket et accepte les 10 premiers octets de données.</span><span class="sxs-lookup"><span data-stu-id="3a270-1529">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="3a270-1530">Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndAccept%2A> pour terminer la demande asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1530">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="3a270-1531">Le nombre d’octets transmis et les données sont retournées dans le `buffer` et `bytesTransferred` paramètres de cette méthode et sont affichés dans la console.</span><span class="sxs-lookup"><span data-stu-id="3a270-1531">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1532">Windows NT est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1532">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1533">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1533">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1534"><paramref name="asyncResult" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1534"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1535"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1535"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1536">La méthode <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> a été appelée au préalable.</span><span class="sxs-lookup"><span data-stu-id="3a270-1536"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1537">Une erreur s'est produite lors de la tentative d'accès à <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1537">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="3a270-1538">Met fin à une demande de connexion asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1538">Ends a pending asynchronous connection request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1539"><xref:System.Net.Sockets.Socket.EndConnect%2A> est une méthode bloquante qui termine la demande de connexion d’hôte distant asynchrone démarrée le <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1539"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1540">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginConnect%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1540">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1541">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginConnect%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="3a270-1541">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="3a270-1542">La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1542">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="3a270-1543">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir le <xref:System.Net.Sockets.Socket> sur lequel la tentative de connexion est effectuée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1543">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="3a270-1544">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode mener à bien la tentative de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1544">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1545">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1545">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1546">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1546">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1547">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1547">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1548">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1548">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1549">L’exemple de code suivant met fin à la tentative de connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1549">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="3a270-1550">Pour obtenir un exemple complet illustrant des communications asynchrones avec les sockets, consultez [exemples de Code de Socket](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1550">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1551"><paramref name="asyncResult" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1551"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1552"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1552"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1553"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> a été précédemment appelé pour la connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1553"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1554">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1554">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1555"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1555">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="3a270-1556">Objet <see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1556">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="3a270-1557">Met fin à une demande de déconnexion asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1557">Ends a pending asynchronous disconnect request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1558"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> termine un appel à <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1558"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="3a270-1559">Le <xref:System.Net.Sockets.Socket.EndDisconnect%2A> méthode est bloquée jusqu'à la fin de la déconnexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1559">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="3a270-1560">Pour plus d’informations sur les opérations asynchrones, consultez la rubrique de vue d’ensemble de programmation asynchrone dans la bibliothèque MSDN.</span><span class="sxs-lookup"><span data-stu-id="3a270-1560">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1561">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1561">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1562">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1562">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1563">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1563">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1564">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1564">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1565">L’exemple de code suivant crée un socket pour la communication asynchrone et envoie des données à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1565">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="3a270-1566">Lorsque les données ont été envoyées, <xref:System.Net.Sockets.Socket.Shutdown%2A> est appelée pour arrêter l’envoi et l’activité de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-1566">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="3a270-1567">Puis <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> est appelé pour lancer une demande de déconnexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1567">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="3a270-1568">Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndDisconnect%2A> pour terminer la demande asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1568">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="3a270-1569">Lorsque la demande est terminée, le <xref:System.Net.Sockets.Socket.Connected%2A> propriété est interrogée pour tester si le socket est déconnecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-1569">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1570">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</span><span class="sxs-lookup"><span data-stu-id="3a270-1570">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1571">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1571">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1572"><paramref name="asyncResult" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1572"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1573"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1573"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1574"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> a été précédemment appelé pour la connexion asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1574"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1575">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1575">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.Net.WebException"><span data-ttu-id="3a270-1576">La demande de déconnexion a expiré.</span><span class="sxs-lookup"><span data-stu-id="3a270-1576">The disconnect request has timed out.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-1577">Met fin à une lecture asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1577">Ends a pending asynchronous read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="3a270-1578">Met fin à une lecture asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1578">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="3a270-1579">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-1579">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1580">Le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode termine l’opération de lecture asynchrone démarrée dans le <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1580">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1581">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginReceive%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1581">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1582">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginReceive%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="3a270-1582">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="3a270-1583">La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginReceive%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1583">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="3a270-1584">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1584">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="3a270-1585">Extraire la réception <xref:System.Net.Sockets.Socket> à partir de cet objet d’état.</span><span class="sxs-lookup"><span data-stu-id="3a270-1585">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="3a270-1586">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.</span><span class="sxs-lookup"><span data-stu-id="3a270-1586">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="3a270-1587">Le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode se bloque jusqu'à ce que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="3a270-1587">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="3a270-1588">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndReceive%2A> lira le premier datagramme en file d’attente disponible dans la mémoire tampon réseau entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-1588">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="3a270-1589">Si vous utilisez un protocole orienté connexion, la <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1589">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="3a270-1590">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1590">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-1591">Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult>et extrayez la mémoire tampon contenue dans l’objet d’état obtenu.</span><span class="sxs-lookup"><span data-stu-id="3a270-1591">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="3a270-1592">Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1592">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1593">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1593">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1594">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1594">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1595">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-1595">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-1596">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1596">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1597">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1597">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1598">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1598">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1599">L’exemple de code suivant met fin à une lecture asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1599">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="3a270-1600">Pour obtenir un exemple complet illustrant des communications asynchrones avec les sockets, consultez [exemples de Code de Socket](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1600">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1601"><paramref name="asyncResult" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1601"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1602"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1602"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1603"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> a été précédemment appelé pour la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1603"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1604">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1604">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1605"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1605">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="3a270-1606"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1606">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="3a270-1607">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1607">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="3a270-1608">Met fin à une lecture asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1608">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="3a270-1609">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-1609">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1610">Le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode termine l’opération de lecture asynchrone démarrée dans le <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1610">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1611">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginReceive%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1611">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1612">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginReceive%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="3a270-1612">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="3a270-1613">La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginReceive%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1613">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="3a270-1614">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1614">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="3a270-1615">Extraire la réception <xref:System.Net.Sockets.Socket> à partir de cet objet d’état.</span><span class="sxs-lookup"><span data-stu-id="3a270-1615">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="3a270-1616">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.</span><span class="sxs-lookup"><span data-stu-id="3a270-1616">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="3a270-1617">Le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode se bloque jusqu'à ce que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="3a270-1617">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="3a270-1618">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndReceive%2A> lira le premier datagramme en file d’attente disponible dans la mémoire tampon réseau entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-1618">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="3a270-1619">Si vous utilisez un protocole orienté connexion, la <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1619">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="3a270-1620">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1620">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-1621">Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult>et extrayez la mémoire tampon contenue dans l’objet d’état obtenu.</span><span class="sxs-lookup"><span data-stu-id="3a270-1621">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1622">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1622">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1623">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1623">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1624">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-1624">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-1625">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1625">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1626">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1626">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1627">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1627">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1628"><paramref name="asyncResult" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1628"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1629"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1629"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1630"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> a été précédemment appelé pour la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1630"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1631">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1631">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1632"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1632">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <param name="endPoint">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary><span data-ttu-id="3a270-1633">Met fin à une lecture asynchrone en attente à partir d'un point de terminaison spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1633">Ends a pending asynchronous read from a specific endpoint.</span></span></summary>
        <returns><span data-ttu-id="3a270-1634">En cas de réussite, nombre d'octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-1634">If successful, the number of bytes received.</span></span> <span data-ttu-id="3a270-1635">En cas d'échec, retourne 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-1635">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1636">Le <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode termine l’opération de lecture asynchrone démarrée dans le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1636">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1637">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1637">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1638">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="3a270-1638">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="3a270-1639">La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1639">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="3a270-1640">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1640">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-1641">Extraire la réception <xref:System.Net.Sockets.Socket> à partir de cet objet d’état.</span><span class="sxs-lookup"><span data-stu-id="3a270-1641">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="3a270-1642">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.</span><span class="sxs-lookup"><span data-stu-id="3a270-1642">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="3a270-1643">Le <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="3a270-1643">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="3a270-1644">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> lira le premier datagramme en file d’attente disponible dans la mémoire tampon réseau entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-1644">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="3a270-1645">Si vous utilisez un protocole orienté connexion, la <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1645">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-1646">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1646">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="3a270-1647">Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> de l’objet et l’extraction de la mémoire tampon contenue dans l’objet d’état obtenu.</span><span class="sxs-lookup"><span data-stu-id="3a270-1647">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="3a270-1648">Pour identifier l’hôte d’origine, vous devez extraire le <xref:System.Net.EndPoint> et effectuer un cast en un <xref:System.Net.IPEndPoint>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1648">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="3a270-1649">Utilisez le <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> méthode pour obtenir l’adresse IP et le <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> méthode pour obtenir le numéro de port.</span><span class="sxs-lookup"><span data-stu-id="3a270-1649">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1650">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1650">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1651">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1651">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1652">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1652">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1653">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1653">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1654">L’exemple de code suivant met fin à une lecture asynchrone en attente à partir d’un spécifique <xref:System.Net.EndPoint>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1654">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1655"><paramref name="asyncResult" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1655"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1656"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1656"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1657"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> a été précédemment appelé pour la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1657"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1658">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1658">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1659"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1659">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="3a270-1660"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1660">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-1661">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" /> pour le paquet reçu.</span><span class="sxs-lookup"><span data-stu-id="3a270-1661">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span></span></param>
        <param name="endPoint"><span data-ttu-id="3a270-1662"><see cref="T:System.Net.EndPoint" /> source.</span><span class="sxs-lookup"><span data-stu-id="3a270-1662">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="3a270-1663"><see cref="T:System.Net.IPAddress" /> et interface du paquet reçu.</span><span class="sxs-lookup"><span data-stu-id="3a270-1663">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span></span></param>
        <summary><span data-ttu-id="3a270-1664">Met fin à une lecture asynchrone en attente à partir d'un point de terminaison spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1664">Ends a pending asynchronous read from a specific endpoint.</span></span> <span data-ttu-id="3a270-1665">Cette méthode révèle également davantage d'informations sur le paquet que <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1665">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-1666">En cas de réussite, nombre d'octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-1666">If successful, the number of bytes received.</span></span> <span data-ttu-id="3a270-1667">En cas d'échec, retourne 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-1667">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1668">Si l’opération n’est pas terminée, cette méthode est bloquée jusqu'à ce qu’il effectue.</span><span class="sxs-lookup"><span data-stu-id="3a270-1668">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="3a270-1669">Pour effectuer cette opération de manière synchrone, utilisez la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1669">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-1670">Examinez `ipPacketInformation` si vous devez savoir si le datagramme a été envoyé à l’aide d’une adresse de multidiffusion ou de diffusion, de monodiffusion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1670">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1671"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1671"><paramref name="asyncResult" /> is <see langword="null" /></span></span>  
  
 <span data-ttu-id="3a270-1672">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1672">-or-</span></span>  
  
 <span data-ttu-id="3a270-1673"><paramref name="endPoint" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1673"><paramref name="endPoint" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1674"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1674"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1675"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> a été précédemment appelé pour la lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1675"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1676">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1676">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1677"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1677">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-1678">Met fin à un envoi asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1678">Ends a pending asynchronous send.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="3a270-1679">Met fin à un envoi asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1679">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="3a270-1680">En cas de réussite, nombre d'octets envoyés à <see cref="T:System.Net.Sockets.Socket" /> ; sinon, erreur de <see cref="T:System.Net.Sockets.Socket" /> non valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1680">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1681"><xref:System.Net.Sockets.Socket.EndSend%2A> termine l’opération d’envoi asynchrone démarrée dans <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1681"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="3a270-1682">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1682">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1683">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginSend%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="3a270-1683">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="3a270-1684">La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1684">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="3a270-1685">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir de l’envoi <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1685">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1686">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-1686">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="3a270-1687">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloque jusqu'à ce que le datagramme est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1687">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="3a270-1688">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloque jusqu'à ce que la mémoire tampon a été envoyée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1688">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="3a270-1689">Si la valeur de retour à partir de <xref:System.Net.Sockets.Socket.EndSend%2A> indique que la mémoire tampon n’a pas complètement envoyée, appelez le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode là encore, la modification de la mémoire tampon pour stocker les données non envoyées.</span><span class="sxs-lookup"><span data-stu-id="3a270-1689">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="3a270-1690">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1690">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-1691">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1691">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-1692">Un état de réussite de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1692">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1693">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1693">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1694">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1694">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1695">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-1695">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-1696">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1696">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1697">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-1697">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-1698">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1698">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1699">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1699">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1700">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1700">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1701">L’exemple de code suivant met fin à un envoi asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1701">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1702"><paramref name="asyncResult" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1702"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1703"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1703"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1704"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> a été précédemment appelé pour l'envoi asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1704"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1705">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1705">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1706"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1706">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="3a270-1707"><see cref="T:System.IAsyncResult" /> stockant les informations d'état de cette demande asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1707">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="3a270-1708">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1708">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="3a270-1709">Met fin à un envoi asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1709">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="3a270-1710">En cas de réussite, nombre d'octets envoyés à <see cref="T:System.Net.Sockets.Socket" /> ; sinon, erreur de <see cref="T:System.Net.Sockets.Socket" /> non valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1710">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1711"><xref:System.Net.Sockets.Socket.EndSend%2A> termine l’opération d’envoi asynchrone démarrée dans <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1711"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="3a270-1712">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1712">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1713">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginSend%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="3a270-1713">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="3a270-1714">La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1714">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="3a270-1715">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir de l’envoi <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1715">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1716">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-1716">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="3a270-1717">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloque jusqu'à ce que le datagramme est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1717">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="3a270-1718">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloque jusqu'à ce que la mémoire tampon a été envoyée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1718">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="3a270-1719">Si la valeur de retour à partir de <xref:System.Net.Sockets.Socket.EndSend%2A> indique que la mémoire tampon n’a pas complètement envoyée, appelez le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode là encore, la modification de la mémoire tampon pour stocker les données non envoyées.</span><span class="sxs-lookup"><span data-stu-id="3a270-1719">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="3a270-1720">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1720">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-1721">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1721">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-1722">Un état de réussite de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1722">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1723">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1723">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1724">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1724">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1725">Toutes les e/s initialisées par un thread donné est annulée lors de la sortie du thread.</span><span class="sxs-lookup"><span data-stu-id="3a270-1725">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="3a270-1726">Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1726">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1727">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-1727">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-1728">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1728">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1729">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1729">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1730">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1730">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1731"><paramref name="asyncResult" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1731"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1732"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1732"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1733"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> a été précédemment appelé pour l'envoi asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1733"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1734">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1734">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1735"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1735">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="3a270-1736">Objet <see cref="T:System.IAsyncResult" /> stockant les informations d'état de cette opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1736">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="3a270-1737">Met fin à un envoi asynchrone en attente d'un fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-1737">Ends a pending asynchronous send of a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1738"><xref:System.Net.Sockets.Socket.EndSendFile%2A> termine l’opération d’envoi asynchrone démarrée dans <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1738"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="3a270-1739">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1739">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1740">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginSendFile%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="3a270-1740">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="3a270-1741">La méthode de rappel doit accepter le <xref:System.IAsyncResult> objet retourné par la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1741">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="3a270-1742">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir de l’envoi <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1742">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1743">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndSendFile%2A> méthode mener à bien l’opération d’envoi.</span><span class="sxs-lookup"><span data-stu-id="3a270-1743">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="3a270-1744">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloque jusqu'à ce que le datagramme est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1744">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="3a270-1745">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloque jusqu'à ce que le fichier entier est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1745">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="3a270-1746">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1746">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-1747">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1747">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-1748">Un état de réussite de la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1748">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1749">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1749">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1750">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1750">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1751">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1751">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1752">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1752">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1753">L’exemple de code suivant crée et connecte à un socket pour la communication asynchrone et commence à envoyer le fichier « text.txt » en mode asynchrone à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1753">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="3a270-1754">Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndSendFile%2A> pour terminer la transmission.</span><span class="sxs-lookup"><span data-stu-id="3a270-1754">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-1755">Windows NT est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1755">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1756">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1756">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1757"><paramref name="asyncResult" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1757"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1758"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1758"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1759"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> a été précédemment appelé pour <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1759"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1760">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1760">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-1761">Consultez la section Notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-1761">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="3a270-1762">Met fin à un envoi asynchrone en attente vers un emplacement spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1762">Ends a pending asynchronous send to a specific location.</span></span></summary>
        <returns><span data-ttu-id="3a270-1763">En cas de réussite, nombre d'octets envoyés ; sinon, erreur de <see cref="T:System.Net.Sockets.Socket" /> non valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-1763">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1764"><xref:System.Net.Sockets.Socket.EndSendTo%2A> termine l’opération d’envoi asynchrone démarrée dans <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1764"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="3a270-1765">Avant d’appeler <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1765">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="3a270-1766">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginReceive%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="3a270-1766">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="3a270-1767">La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1767">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="3a270-1768">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir de l’envoi <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1768">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1769">Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndSendTo%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-1769">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="3a270-1770">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndSendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1770">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="3a270-1771">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.EndSendTo%2A> se bloque jusqu'à ce que le nombre d’octets demandés est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1771">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="3a270-1772">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1772">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-1773">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1773">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-1774">Un état de réussite de la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1774">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1775">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1775">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1776">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1776">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1777">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1777">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1778">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1778">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1779">L’exemple de code suivant met fin à un envoi asynchrone à un emplacement spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1779">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-1780"><paramref name="asyncResult" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1780"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-1781"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1781"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1782"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> a été précédemment appelé pour l'envoi asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-1782"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1783">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1783">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1784"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1784">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1785">Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> n'autorise qu'un seul processus à se lier à un port.</span><span class="sxs-lookup"><span data-stu-id="3a270-1785">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1786"><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> n'autorise qu'un seul socket à se lier à un port spécifique ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1786"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3a270-1787">La valeur par défaut est <see langword="true" /> pour Windows Server 2003 et Windows XP Service Pack 2 et <see langword="false" /> pour toutes les autres versions.</span><span class="sxs-lookup"><span data-stu-id="3a270-1787">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1788">Si <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> est `false`, plusieurs sockets peuvent utiliser la <xref:System.Net.Sockets.Socket.Bind%2A> méthode à lier à un port spécifique ; Cependant, un seul des sockets peut effectuer des opérations sur le trafic réseau envoyé au port.</span><span class="sxs-lookup"><span data-stu-id="3a270-1788">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="3a270-1789">Si plus d’un socket tente d’utiliser le <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> méthode à lier à un port spécifique, puis celui doté de l’adresse IP plus spécifique gère le trafic réseau envoyé à ce port.</span><span class="sxs-lookup"><span data-stu-id="3a270-1789">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="3a270-1790">Si <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> est `true`, la première utilisation de la <xref:System.Net.Sockets.Socket.Bind%2A> méthode à essayer de se lier à un port particulier, quel que soit l’adresse IP (Internet Protocol) réussit ; toutes les autres utilisations de la <xref:System.Net.Sockets.Socket.Bind%2A> méthode à essayer de se lier à ce port sera échouer jusqu'à ce que le socket lié d’origine est détruit.</span><span class="sxs-lookup"><span data-stu-id="3a270-1790">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="3a270-1791">Cette propriété doit être définie avant <xref:System.Net.Sockets.Socket.Bind%2A> est appelée ; sinon une <xref:System.InvalidOperationException> sera levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1791">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1792">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-1792">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1793">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1793">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1794"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1794">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a270-1795"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> a été appelé pour ce <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1795"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a270-1796">Libère les ressources utilisées par la classe <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1796">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1797">Le <xref:System.Net.Sockets.Socket> classe finaliseur appelle la <xref:System.Net.Sockets.Socket.Close%2A> méthode pour fermer le <xref:System.Net.Sockets.Socket> et libérer les ressources associées à la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1797">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-1798">Retourne la valeur d'une option <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1798">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="3a270-1799">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1799">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="3a270-1800">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1800">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-1801">Retourne la valeur d'une option <see cref="T:System.Net.Sockets.Socket" /> spécifiée, représentée sous la forme d'un objet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1801">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span></span></summary>
        <returns><span data-ttu-id="3a270-1802">Objet représentant la valeur de l'option.</span><span class="sxs-lookup"><span data-stu-id="3a270-1802">An object that represents the value of the option.</span></span> <span data-ttu-id="3a270-1803">Si le paramètre <paramref name="optionName" /> a la valeur du champ <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, la valeur de retour est une instance de la classe <see cref="T:System.Net.Sockets.LingerOption" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1803">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span></span> <span data-ttu-id="3a270-1804">Si <paramref name="optionName" /> a la valeur du champ <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> ou <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, la valeur de retour est une instance de la classe <see cref="T:System.Net.Sockets.MulticastOption" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1804">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span></span> <span data-ttu-id="3a270-1805">Si <paramref name="optionName" /> a une autre valeur, la valeur de retour est un entier.</span><span class="sxs-lookup"><span data-stu-id="3a270-1805">When <paramref name="optionName" /> is any other value, the return value is an integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1806"><xref:System.Net.Sockets.Socket> options déterminent le comportement d’actuel <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1806"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1807">Utilisez cette surcharge pour obtenir le <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, et <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> options.</span><span class="sxs-lookup"><span data-stu-id="3a270-1807">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="3a270-1808">Pour le <xref:System.Net.Sockets.SocketOptionName.Linger> option, utilisez <xref:System.Net.Sockets.Socket> pour la `optionLevel` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-1808">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="3a270-1809">Pour <xref:System.Net.Sockets.SocketOptionName.AddMembership> et <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilisez <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1809">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="3a270-1810">Si vous souhaitez définir la valeur d’une des options ci-dessus, utilisez la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1810">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1811">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1811">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1812">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1812">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1813">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1813">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1814">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1814">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1815">Le code suivant exemple récupère la <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> les valeurs de délai d’expiration et les affiche dans la console.</span><span class="sxs-lookup"><span data-stu-id="3a270-1815">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1816">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1816">An error occurred when attempting to access the socket.</span></span>  
  
 <span data-ttu-id="3a270-1817">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1817">-or-</span></span>  
  
 <span data-ttu-id="3a270-1818"><paramref name="optionName" /> avait la valeur <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> non prise en charge.</span><span class="sxs-lookup"><span data-stu-id="3a270-1818"><paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1819"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1819">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="3a270-1820">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1820">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="3a270-1821">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1821">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="3a270-1822">Tableau de type <see cref="T:System.Byte" /> devant recevoir la valeur de l'option.</span><span class="sxs-lookup"><span data-stu-id="3a270-1822">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span></span></param>
        <summary><span data-ttu-id="3a270-1823">Retourne la valeur de l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée sous la forme d'un tableau d'octets.</span><span class="sxs-lookup"><span data-stu-id="3a270-1823">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1824"><xref:System.Net.Sockets.Socket> options déterminent le comportement d’actuel <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1824"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-1825">En cas de réussite de cette méthode, le tableau spécifié par le `optionValue` paramètre contient la valeur de l’objet <xref:System.Net.Sockets.Socket> option.</span><span class="sxs-lookup"><span data-stu-id="3a270-1825">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="3a270-1826">Lorsque la longueur de la `optionValue` tableau est inférieure au nombre d’octets requis pour stocker la valeur de l’objet <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1826">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-1827">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1827">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1828">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1828">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="3a270-1829">Utilisez cette surcharge pour tous les sockets qui sont représentés par des valeurs booléennes ou des entiers.</span><span class="sxs-lookup"><span data-stu-id="3a270-1829">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1830">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1830">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1831">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1831">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1832">Le code suivant exemple récupère la <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> les valeurs de délai d’expiration et les affiche dans la console.</span><span class="sxs-lookup"><span data-stu-id="3a270-1832">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1833">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1833">An error occurred when attempting to access the socket.</span></span>  
  
 <span data-ttu-id="3a270-1834">\- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1834">\- or -</span></span>  
  
 <span data-ttu-id="3a270-1835">Dans les applications .NET Compact Framework, l'espace de mémoire tampon par défaut de Windows CE est de 32 768 octets.</span><span class="sxs-lookup"><span data-stu-id="3a270-1835">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="3a270-1836">Vous pouvez modifier l'espace de mémoire tampon de chaque socket en appelant <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1836">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1837"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1837">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="3a270-1838">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1838">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="3a270-1839">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1839">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionLength"><span data-ttu-id="3a270-1840">Longueur (en octets) de la valeur de retour attendue.</span><span class="sxs-lookup"><span data-stu-id="3a270-1840">The length, in bytes, of the expected return value.</span></span></param>
        <summary><span data-ttu-id="3a270-1841">Retourne la valeur de l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée dans un tableau.</span><span class="sxs-lookup"><span data-stu-id="3a270-1841">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span></span></summary>
        <returns><span data-ttu-id="3a270-1842">Tableau de type <see cref="T:System.Byte" /> contenant la valeur de l'option de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1842">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1843">Le `optionLength` paramètre définit la taille maximale du tableau d’octets retourné.</span><span class="sxs-lookup"><span data-stu-id="3a270-1843">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="3a270-1844">Si la valeur de l’option nécessite moins d’octets, le tableau contient uniquement le nombre d’octets.</span><span class="sxs-lookup"><span data-stu-id="3a270-1844">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="3a270-1845">Si la valeur de l’option nécessite davantage d’octets, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1845">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-1846">Utilisez cette surcharge pour tous les sockets qui sont représentés par des valeurs booléennes ou des entiers.</span><span class="sxs-lookup"><span data-stu-id="3a270-1846">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1847">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1847">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1848">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1848">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1849">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1849">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1850">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1850">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1851">Le code suivant exemple récupère la <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> les valeurs de délai d’expiration et les affiche dans la console.</span><span class="sxs-lookup"><span data-stu-id="3a270-1851">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1852">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1852">An error occurred when attempting to access the socket.</span></span>  
  
 <span data-ttu-id="3a270-1853">\- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1853">\- or -</span></span>  
  
 <span data-ttu-id="3a270-1854">Dans les applications .NET Compact Framework, l'espace de mémoire tampon par défaut de Windows CE est de 32 768 octets.</span><span class="sxs-lookup"><span data-stu-id="3a270-1854">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="3a270-1855">Vous pouvez modifier l'espace de mémoire tampon de chaque socket en appelant <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1855">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1856"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1856">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1857">Obtient le handle du système d'exploitation pour <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1857">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="3a270-1858"><see cref="T:System.IntPtr" /> qui représente le handle du système d'exploitation pour <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1858">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-1859">Définit les modes de fonctionnement de bas niveau de <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1859">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="3a270-1860">Valeur <see cref="T:System.Int32" /> qui spécifie le code de contrôle de l'opération à exécuter.</span><span class="sxs-lookup"><span data-stu-id="3a270-1860">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="3a270-1861">Tableau <see cref="T:System.Byte" /> contenant les données d'entrée requises par l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1861">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="3a270-1862">Tableau <see cref="T:System.Byte" /> contenant les données de sortie retournées par l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1862">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="3a270-1863">Définit les modes de fonctionnement de bas niveau de <see cref="T:System.Net.Sockets.Socket" /> à l'aide de codes de contrôle numériques.</span><span class="sxs-lookup"><span data-stu-id="3a270-1863">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span></span></summary>
        <returns><span data-ttu-id="3a270-1864">Nombre d'octets dans le paramètre <paramref name="optionOutValue" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1864">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1865">Le <xref:System.Net.Sockets.Socket.IOControl%2A> méthode fournit un accès de bas niveau du système d’exploitation <xref:System.Net.Sockets.Socket> sous-jacent de l’instance actuelle de la <xref:System.Net.Sockets.Socket> classe.</span><span class="sxs-lookup"><span data-stu-id="3a270-1865">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="3a270-1866">Pour plus d’informations, consultez la documentation de WSAIoctl dans MSDN library.</span><span class="sxs-lookup"><span data-stu-id="3a270-1866">For more information, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1867">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1867">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1868">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1868">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1869">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1869">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1870">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1870">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1871">L’exemple de code suivant compare les résultats de FIONREAD et la propriété disponible.</span><span class="sxs-lookup"><span data-stu-id="3a270-1871">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1872">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1872">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1873"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1873">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-1874">Une tentative de modification du mode blocage sans utiliser la propriété <see cref="P:System.Net.Sockets.Socket.Blocking" /> a été effectuée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1874">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-1875">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-1875">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3a270-1876">Pour exécuter du code non managé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1876">to execute unmanaged code.</span></span> <span data-ttu-id="3a270-1877">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1877">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="3a270-1878">Valeur <see cref="T:System.Net.Sockets.IOControlCode" /> qui spécifie le code de contrôle de l'opération à exécuter.</span><span class="sxs-lookup"><span data-stu-id="3a270-1878">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="3a270-1879">Tableau de type <see cref="T:System.Byte" /> contenant les données d'entrée requises par l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1879">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="3a270-1880">Tableau de type <see cref="T:System.Byte" /> contenant les données de sortie retournées par l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-1880">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="3a270-1881">Définit les modes de fonctionnement de bas niveau de <see cref="T:System.Net.Sockets.Socket" /> à l'aide de l'énumération <see cref="T:System.Net.Sockets.IOControlCode" /> afin de spécifier les codes de contrôle.</span><span class="sxs-lookup"><span data-stu-id="3a270-1881">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span></span></summary>
        <returns><span data-ttu-id="3a270-1882">Nombre d'octets dans le paramètre <paramref name="optionOutValue" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1882">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1883">Cette méthode fournit l’accès au système d’exploitation de bas niveau <xref:System.Net.Sockets.Socket> sous-jacent de l’instance actuelle de la <xref:System.Net.Sockets.Socket> classe.</span><span class="sxs-lookup"><span data-stu-id="3a270-1883">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="3a270-1884">Pour plus d’informations, consultez la documentation de WSAIoctl dans MSDN library.</span><span class="sxs-lookup"><span data-stu-id="3a270-1884">For more, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1885">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1885">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1886">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1886">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1887">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1887">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1888">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1888">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1889">L’exemple de code suivant compare les résultats de l’appel de <xref:System.Net.Sockets.Socket.IOControl%2A> avec <xref:System.Net.Sockets.IOControlCode.DataToRead> et <xref:System.Net.Sockets.Socket.Available%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-1889">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1890">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1890">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1891"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1891">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-1892">Une tentative de modification du mode blocage sans utiliser la propriété <see cref="P:System.Net.Sockets.Socket.Blocking" /> a été effectuée.</span><span class="sxs-lookup"><span data-stu-id="3a270-1892">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3a270-1893">Pour exécuter du code non managé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1893">to execute unmanaged code.</span></span> <span data-ttu-id="3a270-1894">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1894">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1895">Obtient une valeur qui indique si <see cref="T:System.Net.Sockets.Socket" /> est lié à un port local spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1895">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1896"><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> est lié à un port local ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1896"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1897">Un socket est considéré comme lié à un port local s’il est lié explicitement en appelant le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), ou lié implicitement en appelant des membres comme <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, qui utilisent un port local éphémère (port libre supérieur à 1024, sélectionné par le système d’exploitation.) Les serveurs utilisent la <xref:System.Net.Sockets.Socket.Bind%2A> méthode pour lier à un port connu afin que les clients peuvent se connecter à ceux-ci.</span><span class="sxs-lookup"><span data-stu-id="3a270-1897">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1898">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.IsBound%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-1898">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1899">Obtient ou définit une valeur qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> doit différer la fermeture d'un socket lors d'une tentative d'envoi de l'ensemble des données en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1899">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span></span></summary>
        <value><span data-ttu-id="3a270-1900"><see cref="T:System.Net.Sockets.LingerOption" /> qui spécifie comment maintenir un socket lors de sa fermeture.</span><span class="sxs-lookup"><span data-stu-id="3a270-1900">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1901">Le <xref:System.Net.Sockets.Socket.LingerState%2A> propriété modifie la façon dont <xref:System.Net.Sockets.Socket.Close%2A> se comporte de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-1901">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="3a270-1902">Cette propriété lorsque le jeu modifie les conditions sous lesquelles la connexion peut être réinitialisée par Winsock.</span><span class="sxs-lookup"><span data-stu-id="3a270-1902">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="3a270-1903">Les réinitialisations de connexion peuvent encore se produire en fonction du comportement du protocole IP.</span><span class="sxs-lookup"><span data-stu-id="3a270-1903">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="3a270-1904">Cette propriété contrôle la durée pendant laquelle une connexion orientée connexion restera ouverte après un appel à <xref:System.Net.Sockets.Socket.Close%2A> lorsqu’il reste des données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1904">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="3a270-1905">Lorsque vous appelez des méthodes pour envoyer des données à un homologue, ces données sont placées dans le tampon réseau sortant.</span><span class="sxs-lookup"><span data-stu-id="3a270-1905">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="3a270-1906">Cette propriété peut être utilisée pour vous assurer que ces données sont envoyées à l’hôte distant avant du <xref:System.Net.Sockets.TcpClient.Close%2A> méthode supprime la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1906">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="3a270-1907">Pour activer le maintien, créez un <xref:System.Net.Sockets.LingerOption> d’instance qui contient les valeurs souhaitées et définir le <xref:System.Net.Sockets.Socket.LingerState%2A> propriété à cette instance.</span><span class="sxs-lookup"><span data-stu-id="3a270-1907">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="3a270-1908">Le tableau suivant décrit le comportement de la <xref:System.Net.Sockets.Socket.Close%2A> méthode pour les valeurs possibles de la <xref:System.Net.Sockets.LingerOption.Enabled%2A> propriété et la <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété stockée dans le <xref:System.Net.Sockets.Socket.LingerState%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-1908">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="3a270-1909">LingerState.Enabled</span><span class="sxs-lookup"><span data-stu-id="3a270-1909">LingerState.Enabled</span></span>|<span data-ttu-id="3a270-1910">LingerState.LingerTime</span><span class="sxs-lookup"><span data-stu-id="3a270-1910">LingerState.LingerTime</span></span>|<span data-ttu-id="3a270-1911">Comportement</span><span class="sxs-lookup"><span data-stu-id="3a270-1911">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="3a270-1912">`false` (désactivé), la valeur par défaut</span><span class="sxs-lookup"><span data-stu-id="3a270-1912">`false` (disabled), the default value</span></span>|<span data-ttu-id="3a270-1913">Le délai d’attente n’est pas applicable, (par défaut).</span><span class="sxs-lookup"><span data-stu-id="3a270-1913">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="3a270-1914">Essaie d’envoyer les données en attente jusqu'à ce que le délai expire.</span><span class="sxs-lookup"><span data-stu-id="3a270-1914">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="3a270-1915">`true` (activé)</span><span class="sxs-lookup"><span data-stu-id="3a270-1915">`true` (enabled)</span></span>|<span data-ttu-id="3a270-1916">Un délai d’attente différente de zéro</span><span class="sxs-lookup"><span data-stu-id="3a270-1916">A nonzero time-out</span></span>|<span data-ttu-id="3a270-1917">Essaie d’envoyer les données en attente jusqu'à ce que le délai spécifié expire, et si la tentative échoue, Winsock réinitialise la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1917">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="3a270-1918">`true` (activé)</span><span class="sxs-lookup"><span data-stu-id="3a270-1918">`true` (enabled)</span></span>|<span data-ttu-id="3a270-1919">Un délai d’attente nulle.</span><span class="sxs-lookup"><span data-stu-id="3a270-1919">A zero timeout.</span></span>|<span data-ttu-id="3a270-1920">Ignore toutes les données en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1920">Discards any pending data.</span></span> <span data-ttu-id="3a270-1921">Pour un socket orienté connexion (TCP, par exemple), Winsock réinitialise la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1921">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="3a270-1922">La pile IP calcule le délai par défaut protocole IP à utiliser en fonction du temps d’aller-retour de la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1922">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="3a270-1923">Dans la plupart des cas, le délai d’attente calculé par la pile est plus pertinent que celui défini par une application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1923">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="3a270-1924">Il s’agit du comportement par défaut pour un socket lorsque le <xref:System.Net.Sockets.Socket.LingerState%2A> propriété n’est pas définie.</span><span class="sxs-lookup"><span data-stu-id="3a270-1924">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="3a270-1925">Lorsque le <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété stockée dans le <xref:System.Net.Sockets.Socket.LingerState%2A> propriété est supérieure au délai par défaut, le délai par défaut sera toujours appliquer et remplacer.</span><span class="sxs-lookup"><span data-stu-id="3a270-1925">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1926">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.LingerState%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-1926">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1927">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1927">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1928"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1928">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog"><span data-ttu-id="3a270-1929">Longueur maximale de la file d'attente des connexions en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1929">The maximum length of the pending connections queue.</span></span></param>
        <summary><span data-ttu-id="3a270-1930">Met <see cref="T:System.Net.Sockets.Socket" /> dans un état d'écoute.</span><span class="sxs-lookup"><span data-stu-id="3a270-1930">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1931"><xref:System.Net.Sockets.Socket.Listen%2A> provoque un orienté connexion <xref:System.Net.Sockets.Socket> pour écouter les tentatives de connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-1931"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="3a270-1932">Le `backlog` paramètre spécifie le nombre de connexions entrantes qui peut être mise en attente d’acceptation.</span><span class="sxs-lookup"><span data-stu-id="3a270-1932">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="3a270-1933">Pour déterminer le nombre maximal de connexions que vous pouvez spécifier, récupérez la <xref:System.Net.Sockets.SocketOptionName.MaxConnections> valeur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1933">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="3a270-1934"><xref:System.Net.Sockets.Socket.Listen%2A> ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="3a270-1934"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="3a270-1935">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1935">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1936">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1936">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="3a270-1937">Utilisez <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> pour accepter une connexion à partir de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-1937">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1938">Vous devez appeler la <xref:System.Net.Sockets.Socket.Bind%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.Listen%2A>, ou <xref:System.Net.Sockets.Socket.Listen%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-1938">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1939">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1939">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1940">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1940">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1941">Le paramètre backlog est limité à des valeurs différentes selon le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="3a270-1941">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="3a270-1942">Vous pouvez spécifier une valeur plus élevée, mais le backlog sera limité en fonction du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="3a270-1942">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1943">Le code suivant utilise des exemple <xref:System.Net.Sockets.Socket> pour écouter les connexions entrantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-1943">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1944">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1944">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1945"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1945">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1946">Obtient le point de terminaison local.</span><span class="sxs-lookup"><span data-stu-id="3a270-1946">Gets the local endpoint.</span></span></summary>
        <value><span data-ttu-id="3a270-1947"><see cref="T:System.Net.EndPoint" /> que <see cref="T:System.Net.Sockets.Socket" /> utilise pour les communications.</span><span class="sxs-lookup"><span data-stu-id="3a270-1947">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1948">Le <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété obtient un <xref:System.Net.EndPoint> qui contient le numéro de port et adresse IP local auquel votre <xref:System.Net.Sockets.Socket> est lié.</span><span class="sxs-lookup"><span data-stu-id="3a270-1948">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="3a270-1949">Vous devez effectuer un cast <xref:System.Net.EndPoint> à un <xref:System.Net.IPEndPoint> avant d’extraire des informations.</span><span class="sxs-lookup"><span data-stu-id="3a270-1949">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="3a270-1950">Vous pouvez ensuite appeler la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> méthode pour récupérer l’ordinateur local <xref:System.Net.IPAddress>et le <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> pour récupérer le numéro de port local.</span><span class="sxs-lookup"><span data-stu-id="3a270-1950">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="3a270-1951">Le <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété est généralement définie une fois que vous effectuez un appel à la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1951">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="3a270-1952">Si vous permettez au système d’assigner l’adresse IP locale de votre socket et numéro de port, le <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété sera définie après la première opération d’e/s.</span><span class="sxs-lookup"><span data-stu-id="3a270-1952">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="3a270-1953">Pour les protocoles orientés connexion, la première opération d’e/s est un appel à la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-1953">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-1954">Pour les protocoles sans connexion, la première opération d’e/s est un de l’envoyer ou recevoir des appels.</span><span class="sxs-lookup"><span data-stu-id="3a270-1954">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1955">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-1955">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-1956">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-1956">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-1957">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-1957">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-1958">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-1958">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1959">L’exemple de code suivant récupère et affiche les points de terminaison locaux et distants.</span><span class="sxs-lookup"><span data-stu-id="3a270-1959">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1960">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1960">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1961"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1961">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1962">Obtient ou définit une valeur spécifiant si les paquets multicast sortants sont remis à l'application émettrice.</span><span class="sxs-lookup"><span data-stu-id="3a270-1962">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1963"><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> reçoit les paquets multicast sortants ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1963"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1964">La multidiffusion est une méthode évolutive pour les communications de type plusieurs-à-plusieurs sur Internet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1964">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="3a270-1965">Un processus s’abonne à une adresse de multidiffusion ; Ensuite, tous les paquets envoyés par un processus abonné sont reçus par chaque autre processus abonné à l’adresse de multidiffusion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1965">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="3a270-1966">Définition de cette propriété sur un socket de protocole TCP (Transmission Control) n’aura aucun effet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1966">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1967">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-1967">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1968">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-1968">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1969"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1969">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1970">Obtient ou définit une valeur <see cref="T:System.Boolean" /> spécifiant si le flux de données <see cref="T:System.Net.Sockets.Socket" /> utilise l'algorithme Nagle.</span><span class="sxs-lookup"><span data-stu-id="3a270-1970">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1971"><see langword="false" /> si <see cref="T:System.Net.Sockets.Socket" /> utilise l'algorithme Nagle ; sinon, <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1971"><see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span></span> <span data-ttu-id="3a270-1972">La valeur par défaut est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1972">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1973">L’algorithme Nagle est conçu pour réduire le trafic réseau en obligeant le socket de petits paquets de la mémoire tampon et de combiner et de les envoyer dans un paquet dans certaines circonstances.</span><span class="sxs-lookup"><span data-stu-id="3a270-1973">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="3a270-1974">Un paquet TCP se compose de 40 octets d’en-tête plus les données envoyées.</span><span class="sxs-lookup"><span data-stu-id="3a270-1974">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="3a270-1975">Lorsque de petits paquets de données sont envoyés avec TCP, la surcharge résultant de l’en-tête TCP peut devenir une partie significative du trafic réseau. Sur les réseaux très chargés, la congestion résultant de cette surcharge peut entraîner de perte de datagrammes et retransmissions, ainsi que les temps de propagation excessive provoquée par la congestion.</span><span class="sxs-lookup"><span data-stu-id="3a270-1975">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="3a270-1976">L’algorithme Nagle empêche l’émission de nouveaux TCP segmentswhen nouvelles données arrivent de l’utilisateur si toutes les données sur la connexion restent sans accusé de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-1976">The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="3a270-1977">La plupart des applications réseau doit utiliser l’algorithme Nagle.</span><span class="sxs-lookup"><span data-stu-id="3a270-1977">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="3a270-1978">Définition de cette propriété sur un socket de protocole UDP (User Datagram) n’aura aucun effet.</span><span class="sxs-lookup"><span data-stu-id="3a270-1978">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-1979">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.NoDelay%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-1979">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-1980">Une erreur s'est produite lors de la tentative d'accès à <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1980">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-1981"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-1981">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1982">Indique si le système d'exploitation et les cartes réseau sous-jacents prennent en charge le protocole IPv4 (Internet Protocol version 4).</span><span class="sxs-lookup"><span data-stu-id="3a270-1982">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1983"><see langword="true" /> si le système d'exploitation et les cartes réseau prennent en charge le protocole IPv4 ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1983"><see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1984">Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.</span><span class="sxs-lookup"><span data-stu-id="3a270-1984">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-1985">Indique si le système d'exploitation et les cartes réseau sous-jacents prennent en charge le protocole IPv6 (Internet Protocol version 6).</span><span class="sxs-lookup"><span data-stu-id="3a270-1985">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span></span></summary>
        <value>
          <span data-ttu-id="3a270-1986"><see langword="true" /> si le système d'exploitation et les cartes réseau prennent en charge le protocole IPv6 ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1986"><see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-1987">Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.</span><span class="sxs-lookup"><span data-stu-id="3a270-1987">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds"><span data-ttu-id="3a270-1988">Temps d'attente (en microsecondes) d'une réponse.</span><span class="sxs-lookup"><span data-stu-id="3a270-1988">The time to wait for a response, in microseconds.</span></span></param>
        <param name="mode"><span data-ttu-id="3a270-1989">Une des valeurs de <see cref="T:System.Net.Sockets.SelectMode" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1989">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-1990">Détermine l'état de <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1990">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-1991">État du <see cref="T:System.Net.Sockets.Socket" /> basé sur la valeur de mode d'appel passée dans le paramètre <paramref name="mode" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1991">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span></span>  
  
 <span data-ttu-id="3a270-1992"><list type="table"><listheader><term> Mode</span><span class="sxs-lookup"><span data-stu-id="3a270-1992"><list type="table"><listheader><term> Mode</span></span>  
  
 <span data-ttu-id="3a270-1993"></term><description> Valeur de retour</span><span class="sxs-lookup"><span data-stu-id="3a270-1993"></term><description> Return Value</span></span>  
  
 <span data-ttu-id="3a270-1994"></description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> si la méthode <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> a été appelée et si une connexion est en attente ;</span><span class="sxs-lookup"><span data-stu-id="3a270-1994"></description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;</span></span>  
  
 <span data-ttu-id="3a270-1995">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1995">-or-</span></span>  
  
 <span data-ttu-id="3a270-1996"><see langword="true" /> si des données sont disponibles pour la lecture ;</span><span class="sxs-lookup"><span data-stu-id="3a270-1996"><see langword="true" /> if data is available for reading;</span></span>  
  
 <span data-ttu-id="3a270-1997">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-1997">-or-</span></span>  
  
 <span data-ttu-id="3a270-1998"><see langword="true" /> si la connexion a été fermée, réinitialisée ou terminée ;</span><span class="sxs-lookup"><span data-stu-id="3a270-1998"><see langword="true" /> if the connection has been closed, reset, or terminated;</span></span>  
  
 <span data-ttu-id="3a270-1999">sinon, retourne <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-1999">otherwise, returns <see langword="false" />.</span></span>  
  
 <span data-ttu-id="3a270-2000"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" /> si une méthode <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> a été utilisée et si la connexion a abouti ;</span><span class="sxs-lookup"><span data-stu-id="3a270-2000"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;</span></span>  
  
 <span data-ttu-id="3a270-2001">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2001">-or-</span></span>  
  
 <span data-ttu-id="3a270-2002"><see langword="true" /> si des données peuvent être envoyées ;</span><span class="sxs-lookup"><span data-stu-id="3a270-2002"><see langword="true" /> if data can be sent;</span></span>  
  
 <span data-ttu-id="3a270-2003">sinon, retourne <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2003">otherwise, returns <see langword="false" />.</span></span>  
  
 <span data-ttu-id="3a270-2004"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" /> si une méthode <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> sans blocage a été utilisée et si la connexion a échoué ;</span><span class="sxs-lookup"><span data-stu-id="3a270-2004"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;</span></span>  
  
 <span data-ttu-id="3a270-2005">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2005">-or-</span></span>  
  
 <span data-ttu-id="3a270-2006"><see langword="true" /> si le champ <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> n'est pas défini et si des données hors bande sont disponibles ;</span><span class="sxs-lookup"><span data-stu-id="3a270-2006"><see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;</span></span>  
  
 <span data-ttu-id="3a270-2007">sinon, retourne <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2007">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2008">Le <xref:System.Net.Sockets.Socket.Poll%2A> méthode vérifie l’état de la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2008">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-2009">Spécifiez <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> pour le `selectMode` paramètre pour déterminer si le <xref:System.Net.Sockets.Socket> est accessible en lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2009">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="3a270-2010">Spécifiez <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> pour déterminer si le <xref:System.Net.Sockets.Socket> est accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2010">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="3a270-2011">Utilisez <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> pour détecter une condition d’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2011">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="3a270-2012"><xref:System.Net.Sockets.Socket.Poll%2A> bloque l’exécution jusqu'à ce que la période spécifiée, mesurée en `microseconds`, s’écoule.</span><span class="sxs-lookup"><span data-stu-id="3a270-2012"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="3a270-2013">Définir le `microSeconds` paramètre à un entier négatif si vous souhaitez que d’attendre indéfiniment une réponse.</span><span class="sxs-lookup"><span data-stu-id="3a270-2013">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="3a270-2014">Si vous souhaitez vérifier l’état de plusieurs sockets, vous préférerez peut-être utiliser le <xref:System.Net.Sockets.Socket.Select%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2014">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2015">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2015">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2016">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2016">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2017">Cette méthode ne peut pas détecter certains types de problèmes de connexion, comme un câble réseau rompu, ou que l’hôte distant a été arrêté de manière anormale.</span><span class="sxs-lookup"><span data-stu-id="3a270-2017">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="3a270-2018">Vous devez essayer d’envoyer ou recevoir des données pour détecter ces types d’erreurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2018">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2019">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2019">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2020">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2020">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2021">L’exemple de code suivant crée un socket, se connecte à un serveur et utilise <xref:System.Net.Sockets.Socket.Poll%2A> pour vérifier l’état du socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2021">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-2022">Le paramètre <paramref name="mode" /> ne fait pas partie des valeurs <see cref="T:System.Net.Sockets.SelectMode" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2022">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2023">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2023">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-2024">Consultez la section Notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-2024">See remarks below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2025"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2025">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-2026">Obtient le type de protocole de <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2026">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="3a270-2027">Une des valeurs de <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2027">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2028">Le <xref:System.Net.Sockets.Socket.ProtocolType%2A> propriété est définie lorsque le <xref:System.Net.Sockets.Socket> est créé et spécifie le protocole utilisé par cette <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2028">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2029">Le code suivant exemple affiche la <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, et <xref:System.Net.Sockets.ProtocolType> à la console.</span><span class="sxs-lookup"><span data-stu-id="3a270-2029">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-2030">Reçoit des données d'un <see cref="T:System.Net.Sockets.Socket" /> lié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2030">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2031">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2031">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="3a270-2032">Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans une mémoire tampon de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2032">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="3a270-2033">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2033">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2034">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-2034">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="3a270-2035">Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2035">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="3a270-2036">Cette surcharge nécessite uniquement de fournir un mémoire tampon de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2036">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="3a270-2037">Valeur par défaut est 0, la taille équivaut à la longueur du paramètre de mémoire tampon, offset de mémoire tampon et la <xref:System.Net.Sockets.SocketFlags> valeur par défaut, <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2037">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="3a270-2038">Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2038">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="3a270-2039">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2039">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2040">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2040">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2041"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-2041"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="3a270-2042">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2042">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2043">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2043">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2044">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2044">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2045">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2045">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2046">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2046">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2047">Si vous utilisez une connexion orientée <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données n’est disponible, jusqu'à la taille de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2047">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="3a270-2048">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2048">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-2049">Si vous utilisez une connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2049">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="3a270-2050">Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est rempli avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2050">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2051">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2051">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2052">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2052">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2053">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2053">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2054">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2054">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2055">L’exemple de code suivant reçoit des données sur un connecté <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2055">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2056"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2056"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2057">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2057">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2058"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2058">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-2059">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-2059">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2060">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2060">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2061">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2061">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-2062">Liste des <see cref="T:System.ArraySegment`1" />s de type <see cref="T:System.Byte" /> qui contient les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2062">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <summary><span data-ttu-id="3a270-2063">Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans la liste des mémoires tampon de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2063">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span></span></summary>
        <returns><span data-ttu-id="3a270-2064">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2064">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2065">Cette méthode lit les données dans le paramètre de mémoires tampons et retourne le nombre d’octets lus correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-2065">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="3a270-2066">Vous pouvez appeler à partir de sockets orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2066">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="3a270-2067">Cette surcharge, vous devez fournir une ou plusieurs mémoires tampons de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2067">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="3a270-2068">Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2068">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="3a270-2069">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données qui arrivent de la connexion d’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2069">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2070">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2070">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2071"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-2071"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="3a270-2072">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2072">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2073">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2073">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2074">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2074">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2075">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2075">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2076">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2076">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2077">Si vous utilisez une connexion orientée <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données n’est disponible, jusqu'à la taille de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2077">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="3a270-2078">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2078">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-2079">Si vous utilisez une connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2079">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="3a270-2080">Si le datagramme reçu est supérieur à la taille de la `buffers` paramètre, `buffers` est rempli avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2080">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2081">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2081">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2082">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2082">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="3a270-2083">**Remarque** ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2083">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2084">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2084">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a270-2085">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2085">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2086">Une erreur s'est produite lors de la tentative d'accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2086">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2087"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2087">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2088">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2088">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2089">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2089">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-2090">Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans une mémoire tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2090">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2091">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2091">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2092">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-2092">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="3a270-2093">Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2093">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="3a270-2094">Cette surcharge nécessite uniquement à fournir un mémoire tampon de réception et nécessaires <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2094">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="3a270-2095">Offset de mémoire tampon par défaut, 0, et la taille par défaut est la longueur du paramètre d’octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2095">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="3a270-2096">Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2096">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="3a270-2097">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2097">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2098">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2098">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2099"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-2099"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="3a270-2100">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="3a270-2100">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="3a270-2101">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2101">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2102">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2102">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2103">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, puis réessayez votre opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2103">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2104">Si vous utilisez une connexion orientée <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données est disponible jusqu'à la taille de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2104">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="3a270-2105">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2105">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-2106">Si vous utilisez une connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2106">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="3a270-2107">Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est rempli avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2107">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2108">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2108">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2109">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2109">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2110">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2110">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2111">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2111">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2112">L’exemple de code suivant spécifie une mémoire tampon de données, et <xref:System.Net.Sockets.SocketFlags> pour recevoir des données sur un connecté <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2112">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2113"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2113"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2114">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2114">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2115"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2115">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-2116">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-2116">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2117">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2117">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2118">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2118">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-2119">Liste des <see cref="T:System.ArraySegment`1" />s de type <see cref="T:System.Byte" /> qui contient les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2119">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2120">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2120">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-2121">Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans la liste des mémoires tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2121">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2122">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2122">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2123">Cette méthode lit les données dans le `buffers` paramètre et retourne le nombre d’octets lus correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-2123">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="3a270-2124">Vous pouvez appeler à partir de sockets orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2124">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="3a270-2125">Cette surcharge, vous devez fournir une ou plusieurs mémoires tampons de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2125">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="3a270-2126">Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut, <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2126">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="3a270-2127">Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2127">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="3a270-2128">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données qui arrivent de la connexion d’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2128">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2129">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2129">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2130"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-2130"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="3a270-2131">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2131">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2132">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Receive%2A> appeler lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2132">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2133">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2133">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2134">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2134">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2135">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2135">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2136">Si vous utilisez une connexion orientée <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données n’est disponible, jusqu'à la taille de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2136">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="3a270-2137">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2137">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-2138">Si vous utilisez une connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2138">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="3a270-2139">Si le datagramme reçu est supérieur à la taille de la `buffers` paramètre, `buffers` est rempli avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2139">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2140">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2140">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2141">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2141">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2142">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2142">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2143">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2143">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2144">L’exemple de code suivant montre comment recevoir des données sur un connecté <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2144">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2145"><paramref name="buffers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2145"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-2146">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2146">-or-</span></span>  
  
 <span data-ttu-id="3a270-2147"><paramref name="buffers" />.Count est égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="3a270-2147"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2148">Une erreur s'est produite lors de la tentative d'accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2148">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2149"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2149">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2150">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2150">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2151">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2151">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2152">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2152">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-2153">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-2153">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2154">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2154">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-2155">Reçoit le nombre spécifié d'octets de données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans une mémoire tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2155">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2156">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2156">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2157">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le `buffer` paramètre et retourne le nombre d’octets lus correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-2157">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="3a270-2158">Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2158">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="3a270-2159">Cette surcharge nécessite uniquement de disposer d’un mémoire tampon de réception, le nombre d’octets à recevoir et nécessaires <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2159">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="3a270-2160">Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2160">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="3a270-2161">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2161">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2162">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2162">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2163"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-2163"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="3a270-2164">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2164">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2165">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2165">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2166">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2166">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2167">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2167">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2168">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, puis réessayez votre opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2168">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2169">Si vous utilisez une connexion orientée <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-2169">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="3a270-2170">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2170">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-2171">Si vous utilisez une connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2171">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="3a270-2172">Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est rempli avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2172">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2173">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2173">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2174">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2174">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2175">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2175">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2176">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2176">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2177">L’exemple suivant reçoit les données se trouvant dans `buffer`et spécifie <xref:System.Net.Sockets.SocketFlags.None> pour <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2177">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2178"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2178"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-2179"><paramref name="size" /> dépasse la taille de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2179"><paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2180">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2180">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2181"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2181">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-2182">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-2182">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2183">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2183">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2184">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2184">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-2185">Liste des <see cref="T:System.ArraySegment`1" />s de type <see cref="T:System.Byte" /> qui contient les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2185">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2186">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2186">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="3a270-2187">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2187">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="3a270-2188">Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans la liste des mémoires tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2188">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2189">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2189">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2190">Cette méthode lit les données dans le `buffers` paramètre et retourne le nombre d’octets lus correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-2190">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="3a270-2191">Vous pouvez appeler à partir de sockets orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2191">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="3a270-2192">Cette surcharge, vous devez fournir une ou plusieurs mémoires tampons de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2192">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="3a270-2193">Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut, <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2193">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="3a270-2194">Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2194">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="3a270-2195">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données qui arrivent de la connexion d’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2195">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2196">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2196">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2197"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-2197"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="3a270-2198">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2198">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2199">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Receive%2A> appeler lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2199">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2200">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2200">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2201">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2201">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2202">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2202">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2203">Si vous utilisez une connexion orientée <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données n’est disponible, jusqu'à la taille de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2203">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="3a270-2204">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2204">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-2205">Si vous utilisez une connexion <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2205">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="3a270-2206">Si le datagramme reçu est supérieur à la taille de la `buffers` paramètre, `buffers` est rempli avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2206">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2207">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2207">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2208">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2208">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2209">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2209">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2210">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2210">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2211"><paramref name="buffers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2211"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-2212">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2212">-or-</span></span>  
  
 <span data-ttu-id="3a270-2213"><paramref name="buffers" />.Count est égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="3a270-2213"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2214">Une erreur s'est produite lors de la tentative d'accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2214">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2215"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2215">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2216">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2216">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2217">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2217">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2218">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2218">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-2219">Emplacement dans <c>buffer</c> où stocker les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2219">The location in <c>buffer</c> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-2220">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-2220">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2221">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2221">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-2222">Reçoit le nombre spécifié d'octets d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans la position d'offset spécifiée de la mémoire tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2222">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2223">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2223">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2224">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-2224">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="3a270-2225">Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2225">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="3a270-2226">Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2226">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="3a270-2227">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2227">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2228">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2228">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2229"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-2229"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="3a270-2230">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2230">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2231">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2231">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2232">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2232">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2233">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2233">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-2234">Consultez les notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-2234">See Remarks below.</span></span> <span data-ttu-id="3a270-2235">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2235">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2236">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2236">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2237">Si vous utilisez une connexion orientée <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le paramètre de taille.</span><span class="sxs-lookup"><span data-stu-id="3a270-2237">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="3a270-2238">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2238">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-2239">Si vous utilisez une connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2239">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="3a270-2240">Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est rempli avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2240">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2241">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2241">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2242">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2242">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2243">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2243">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2244">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2244">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2245">L’exemple de code suivant spécifie une mémoire tampon, un offset, une taille et un indicateur de socket avant la réception de données sur un connecté <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2245">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2246"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2246"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-2247"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2247"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2248">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2248">-or-</span></span>  
  
 <span data-ttu-id="3a270-2249"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2249"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-2250">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2250">-or-</span></span>  
  
 <span data-ttu-id="3a270-2251"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2251"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2252">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2252">-or-</span></span>  
  
 <span data-ttu-id="3a270-2253"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2253"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-2254"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2254"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="3a270-2255">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2255">-or-</span></span>  
  
 <span data-ttu-id="3a270-2256">La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'a pas été définie.</span><span class="sxs-lookup"><span data-stu-id="3a270-2256">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="3a270-2257">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2257">-or-</span></span>  
  
 <span data-ttu-id="3a270-2258">Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2258">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2259"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2259">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-2260">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-2260">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2261">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2261">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2262">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2262">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2263">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2263">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-2264">Position dans le paramètre <c>buffer</c> où stocker les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2264">The position in the <c>buffer</c> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-2265">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-2265">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2266">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2266">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="3a270-2267">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2267">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="3a270-2268">Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans une mémoire tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2268">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2269">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2269">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2270">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus correctement.</span><span class="sxs-lookup"><span data-stu-id="3a270-2270">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="3a270-2271">Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2271">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="3a270-2272">Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2272">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="3a270-2273">Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données qui arrivent de l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2273">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2274">Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2274">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2275"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.</span><span class="sxs-lookup"><span data-stu-id="3a270-2275"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="3a270-2276">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2276">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2277">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2277">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2278">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2278">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2279">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2279">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-2280">Consultez les notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-2280">See Remarks below.</span></span> <span data-ttu-id="3a270-2281">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2281">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2282">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2282">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2283">Si vous utilisez une connexion orientée <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le paramètre de taille.</span><span class="sxs-lookup"><span data-stu-id="3a270-2283">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="3a270-2284">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2284">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="3a270-2285">Si vous utilisez une connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2285">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="3a270-2286">Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est rempli avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2286">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2287">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2287">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2288">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2288">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2289">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2289">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2290">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2290">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2291"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2291"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-2292"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2292"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2293">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2293">-or-</span></span>  
  
 <span data-ttu-id="3a270-2294"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2294"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-2295">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2295">-or-</span></span>  
  
 <span data-ttu-id="3a270-2296"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2296"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2297">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2297">-or-</span></span>  
  
 <span data-ttu-id="3a270-2298"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2298"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-2299"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2299"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="3a270-2300">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2300">-or-</span></span>  
  
 <span data-ttu-id="3a270-2301">La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'est pas définie.</span><span class="sxs-lookup"><span data-stu-id="3a270-2301">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span></span>  
  
 <span data-ttu-id="3a270-2302">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2302">-or-</span></span>  
  
 <span data-ttu-id="3a270-2303">Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2303">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2304"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2304">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-2305">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-2305">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2306">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2306">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2307">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2307">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-2308">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-2308">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-2309">Démarre une demande asynchrone pour recevoir les données d'un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-2309">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="3a270-2310">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-2310">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-2311">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2311">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-2312">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-2312">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-2313">Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-2313">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2314">Le <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> méthode est utilisée sur les sockets connectés ou les sockets sans connexion liés et est utilisée pour lire des données entrantes.</span><span class="sxs-lookup"><span data-stu-id="3a270-2314">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="3a270-2315">L’adresse de local doit être connu.</span><span class="sxs-lookup"><span data-stu-id="3a270-2315">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="3a270-2316">Pour les sockets sans connexion liés, cette fonction restreint les adresses à partir de laquelle les messages reçus sont acceptés.</span><span class="sxs-lookup"><span data-stu-id="3a270-2316">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="3a270-2317">La fonction retourne uniquement les messages à partir de l’adresse distante spécifiée dans la connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2317">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="3a270-2318">Les messages à partir d’autres adresses sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="3a270-2318">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="3a270-2319">Le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriété sur le `e` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur la demande de lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2319">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="3a270-2320">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2320">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a270-2321">Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :</span><span class="sxs-lookup"><span data-stu-id="3a270-2321">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="3a270-2322"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ou <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3a270-2322"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="3a270-2323"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> a la valeur</span><span class="sxs-lookup"><span data-stu-id="3a270-2323"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="3a270-2324"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> a la valeur</span><span class="sxs-lookup"><span data-stu-id="3a270-2324"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="3a270-2325">L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-2325">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="3a270-2326">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</span><span class="sxs-lookup"><span data-stu-id="3a270-2326">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="3a270-2327">Pour les sockets de flux d’octets, les données entrantes sont placées dans la mémoire tampon jusqu'à ce que la mémoire tampon est remplie, la connexion est fermée ou les données en mémoire tampon en interne sont épuisées.</span><span class="sxs-lookup"><span data-stu-id="3a270-2327">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="3a270-2328">Pour les sockets orientés message, un message entrant est placé dans la mémoire tampon jusqu'à la taille totale de la mémoire tampon associée à la `e` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-2328">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="3a270-2329">Si le message est supérieur à la mémoire tampon, la mémoire tampon est remplie avec la première partie du message.</span><span class="sxs-lookup"><span data-stu-id="3a270-2329">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="3a270-2330">Pour les sockets orientés connexion, la <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> méthode peut indiquer l’arrêt normal du circuit virtuel de l’une des deux façons qui varient selon que le socket est orienté flux d’octets ou message.</span><span class="sxs-lookup"><span data-stu-id="3a270-2330">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="3a270-2331">Pour les flux d’octets, zéro octets lus indique une fermeture normale et que plus aucun octet ne sera lu.</span><span class="sxs-lookup"><span data-stu-id="3a270-2331">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="3a270-2332">Pour les sockets orientés message, où un message de zéro octet est souvent autorisé, un <xref:System.Net.Sockets.SocketException> avec la <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> ensemble pour le code d’erreur Winsock WSAEDISCON natif (10101) est utilisé pour indiquer une fermeture normale.</span><span class="sxs-lookup"><span data-stu-id="3a270-2332">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="3a270-2333">Dans tous les cas, un <xref:System.Net.Sockets.SocketException> avec le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> défini sur le WSAECONNRESET natif Winsock code d’erreur (10054) indique que la fermeture s’est produite.</span><span class="sxs-lookup"><span data-stu-id="3a270-2333">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-2334">Un argument n'était pas valide.</span><span class="sxs-lookup"><span data-stu-id="3a270-2334">An argument was invalid.</span></span> <span data-ttu-id="3a270-2335">La propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> ou <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> sur le paramètre de <paramref name="e" /> doit référencer des mémoires tampon valides.</span><span class="sxs-lookup"><span data-stu-id="3a270-2335">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="3a270-2336">L'une ou l'autre de ces propriétés peut être définie, mais pas les deux à la fois.</span><span class="sxs-lookup"><span data-stu-id="3a270-2336">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-2337">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</span><span class="sxs-lookup"><span data-stu-id="3a270-2337">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-2338">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-2338">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2339"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2339">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2340">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2340">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-2341">Obtient ou définit une valeur spécifiant la taille de la mémoire tampon de réception de <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2341">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="3a270-2342"><see cref="T:System.Int32" /> contenant la taille de la mémoire tampon de réception en octets.</span><span class="sxs-lookup"><span data-stu-id="3a270-2342">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span></span> <span data-ttu-id="3a270-2343">La valeur par défaut est 8192.</span><span class="sxs-lookup"><span data-stu-id="3a270-2343">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2344">Une plus grande taille de mémoire tampon est potentiellement réduit le nombre d’accusés de réception vides (paquets TCP sans partie données), mais peut également retarder la reconnaissance des difficultés de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2344">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="3a270-2345">Envisagez d’augmenter la taille de la mémoire tampon si vous transférez des fichiers volumineux, ou si vous utilisez une bande passante élevée, la latence élevée de la connexion (par exemple, un fournisseur large bande satellite).</span><span class="sxs-lookup"><span data-stu-id="3a270-2345">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2346">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-2346">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2347">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2347">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2348"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2348">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-2349">La valeur spécifiée pour une opération ensembliste est inférieure à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2349">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-2350">Reçoit un datagramme et stocke le point de terminaison source.</span><span class="sxs-lookup"><span data-stu-id="3a270-2350">Receives a datagram and stores the source endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2351">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2351">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-2352"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2352">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="3a270-2353">Reçoit un datagramme dans la mémoire tampon de données et stocke le point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="3a270-2353">Receives a datagram into the data buffer and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="3a270-2354">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2354">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2355">Le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données ont été envoyées.</span><span class="sxs-lookup"><span data-stu-id="3a270-2355">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="3a270-2356">Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</span><span class="sxs-lookup"><span data-stu-id="3a270-2356">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="3a270-2357">Cette surcharge exige uniquement que vous permet de fournir une réception `buffer`et un <xref:System.Net.EndPoint> qui représente l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2357">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="3a270-2358">Offset de mémoire tampon par défaut 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2358">The buffer offset defaults to 0.</span></span> <span data-ttu-id="3a270-2359">La taille par défaut est la longueur de la `buffer` paramètre et le `socketFlags` valeur par défaut, <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2359">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2360">Avant d’appeler <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, vous devez lier explicitement la <xref:System.Net.Sockets.Socket> à un point de terminaison local à l’aide de la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2360">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="3a270-2361">Si vous ne le faites pas, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2361">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-2362">Avec les protocoles sans connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</span><span class="sxs-lookup"><span data-stu-id="3a270-2362">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="3a270-2363">Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2363">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2364">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2364">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="3a270-2365">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode avec une mémoire tampon insuffisante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2365">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="3a270-2366">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="3a270-2366">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="3a270-2367">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2367">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2368">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2368">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2369">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2369">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2370">Bien que <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2370">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="3a270-2371">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou acceptez une distant entrantes connexion d’hôte en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2371">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2372">Si vous n’établissez ou accepter une connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode), vous obtenez un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2372">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2373">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2373">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2374">Dans les deux cas, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-2374">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="3a270-2375">Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira autant de données est disponible jusqu'à la taille de `buffer`.</span><span class="sxs-lookup"><span data-stu-id="3a270-2375">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="3a270-2376">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2376">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2377">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2377">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2378">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2378">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2379">Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2379">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2380">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2380">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2381">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2381">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2382">L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2382">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2383"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2383"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-2384">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2384">-or-</span></span>  
  
 <span data-ttu-id="3a270-2385"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2385"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2386">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2386">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2387"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2387">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-2388">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-2388">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2389">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2389">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2390">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2390">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2391">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2391">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2392">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2392">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-2393"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2393">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="3a270-2394">Reçoit un datagramme dans la mémoire tampon de données à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié et stocke le point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="3a270-2394">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="3a270-2395">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2395">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2396">Le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données ont été envoyées.</span><span class="sxs-lookup"><span data-stu-id="3a270-2396">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="3a270-2397">Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</span><span class="sxs-lookup"><span data-stu-id="3a270-2397">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="3a270-2398">Cette surcharge exige uniquement que vous permet de fournir une mémoire tampon de réception nécessaires <xref:System.Net.Sockets.SocketFlags>et un <xref:System.Net.EndPoint> qui représente l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2398">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="3a270-2399">Le décalage par défaut, 0 et la taille équivaut à la longueur du paramètre de mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2399">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2400">Avant d’appeler <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, vous devez lier explicitement la <xref:System.Net.Sockets.Socket> à un point de terminaison local à l’aide de la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2400">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="3a270-2401">Si vous ne le faites pas, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2401">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-2402">Avec les protocoles sans connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</span><span class="sxs-lookup"><span data-stu-id="3a270-2402">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="3a270-2403">Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2403">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2404">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2404">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="3a270-2405">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode avec une mémoire tampon insuffisante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2405">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="3a270-2406">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="3a270-2406">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="3a270-2407">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2407">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2408">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2408">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2409">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2409">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2410">Bien que <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2410">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="3a270-2411">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou acceptez une distant entrantes connexion d’hôte en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2411">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2412">Si vous n’établissez ou accepter une connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode), vous obtenez un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2412">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2413">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2413">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2414">Dans les deux cas, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-2414">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="3a270-2415">Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira autant de données est disponible jusqu'à la taille de `buffer`.</span><span class="sxs-lookup"><span data-stu-id="3a270-2415">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="3a270-2416">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2416">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2417">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2417">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2418">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2418">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2419">Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2419">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2420">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2420">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2421">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2421">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2422">L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2422">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="3a270-2423"><xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2423"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2424"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2424"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-2425">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2425">-or-</span></span>  
  
 <span data-ttu-id="3a270-2426"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2426"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2427">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2427">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2428"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2428">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-2429">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-2429">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2430">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2430">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2431">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2431">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2432">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2432">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-2433">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-2433">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2434">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2434">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-2435"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2435">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="3a270-2436">Reçoit le nombre spécifié d'octets dans la mémoire tampon de données, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié et stocke le point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="3a270-2436">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="3a270-2437">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2437">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2438">Le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données ont été envoyées.</span><span class="sxs-lookup"><span data-stu-id="3a270-2438">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="3a270-2439">Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</span><span class="sxs-lookup"><span data-stu-id="3a270-2439">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="3a270-2440">Cette surcharge exige uniquement que vous permet de fournir une mémoire tampon de réception, le nombre d’octets que vous souhaitez recevoir, nécessaires <xref:System.Net.Sockets.SocketFlags>et un <xref:System.Net.EndPoint> qui représente l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2440">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="3a270-2441">Offset de mémoire tampon par défaut 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2441">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="3a270-2442">Avec les protocoles sans connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</span><span class="sxs-lookup"><span data-stu-id="3a270-2442">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="3a270-2443">Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2443">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2444">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2444">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="3a270-2445">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode avec une mémoire tampon insuffisante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2445">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="3a270-2446">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="3a270-2446">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="3a270-2447">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2447">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2448">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2448">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2449">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2449">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2450">Bien que <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2450">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="3a270-2451">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou acceptez une distant entrantes connexion d’hôte en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2451">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2452">Si vous n’établissez ou accepter une connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode), vous obtenez un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2452">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2453">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2453">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2454">Dans les deux cas, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-2454">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="3a270-2455">Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira autant de données est disponible jusqu’au nombre d’octets spécifié par le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-2455">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="3a270-2456">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2456">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2457">Avant d’appeler <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, vous devez lier explicitement la <xref:System.Net.Sockets.Socket> à un point de terminaison local à l’aide de la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2457">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="3a270-2458">Si vous ne le faites pas, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2458">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2459">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2459">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2460">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2460">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2461">Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2461">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2462">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2462">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2463">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2463">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2464">L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2464">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="3a270-2465">La taille du tampon et <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2465">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2466"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2466"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-2467">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2467">-or-</span></span>  
  
 <span data-ttu-id="3a270-2468"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2468"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-2469"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2469"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2470">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2470">-or-</span></span>  
  
 <span data-ttu-id="3a270-2471"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2471"><paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-2472"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2472"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="3a270-2473">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2473">-or-</span></span>  
  
 <span data-ttu-id="3a270-2474">La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'a pas été définie.</span><span class="sxs-lookup"><span data-stu-id="3a270-2474">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="3a270-2475">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2475">-or-</span></span>  
  
 <span data-ttu-id="3a270-2476">Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2476">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2477"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2477">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-2478">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-2478">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2479">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2479">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2480">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2480">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2481">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2481">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-2482">Position dans le paramètre <c>buffer</c> où stocker les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2482">The position in the <c>buffer</c> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-2483">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-2483">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2484">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2484">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-2485"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2485">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="3a270-2486">Reçoit le nombre d’octets de données spécifié dans l’emplacement de la mémoire tampon spécifié à l’aide des <see cref="T:System.Net.Sockets.SocketFlags" /> et stocke le point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="3a270-2486">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="3a270-2487">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2487">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2488">Le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données ont été envoyées.</span><span class="sxs-lookup"><span data-stu-id="3a270-2488">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="3a270-2489">Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs ordinateurs hôtes.</span><span class="sxs-lookup"><span data-stu-id="3a270-2489">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="3a270-2490">Avec les protocoles sans connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local.</span><span class="sxs-lookup"><span data-stu-id="3a270-2490">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="3a270-2491">Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2491">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2492">Si vous utilisez un protocole non fiable, les données excédentaires seront perdues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2492">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="3a270-2493">Si vous utilisez un protocole fiable, les données excédentaires sont conservées par le fournisseur de service et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode avec une mémoire tampon insuffisante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2493">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="3a270-2494">Si aucune donnée n’est disponible pour la lecture, la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="3a270-2494">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="3a270-2495">Si vous êtes en mode de non bloquant, et aucune donnée n’est disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2495">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2496">Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2496">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="3a270-2497">Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-2497">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="3a270-2498">Bien que <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2498">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="3a270-2499">Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou acceptez une distant entrantes connexion d’hôte en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2499">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-2500">Si vous n’établissez ou accepter une connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode), vous obtenez un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2500">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2501">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2501">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="3a270-2502">Dans les deux cas, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et reçoive uniquement les données de la connecté ou hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-2502">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="3a270-2503">Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira autant de données est disponible à concurrence du nombre d’octets spécifié par le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-2503">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="3a270-2504">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2504">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2505">Avant d’appeler <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, vous devez lier explicitement la <xref:System.Net.Sockets.Socket> à un point de terminaison local à l’aide de la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2505">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="3a270-2506">Si vous ne le faites pas, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2506">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2507">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2507">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2508">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2508">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2509">Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2509">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2510">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2510">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2511">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2511">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2512">L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2512">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="3a270-2513">L’offset, la taille de mémoire tampon, et <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2513">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2514"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2514"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-2515">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2515">-or-</span></span>  
  
 <span data-ttu-id="3a270-2516"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2516"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-2517"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2517"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2518">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2518">-or-</span></span>  
  
 <span data-ttu-id="3a270-2519"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2519"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-2520">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2520">-or-</span></span>  
  
 <span data-ttu-id="3a270-2521"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2521"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2522">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2522">-or-</span></span>  
  
 <span data-ttu-id="3a270-2523"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre de décalage.</span><span class="sxs-lookup"><span data-stu-id="3a270-2523"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-2524"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2524"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="3a270-2525">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2525">-or-</span></span>  
  
 <span data-ttu-id="3a270-2526">La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'a pas été définie.</span><span class="sxs-lookup"><span data-stu-id="3a270-2526">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="3a270-2527">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2527">-or-</span></span>  
  
 <span data-ttu-id="3a270-2528">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2528">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2529"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2529">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2530">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2530">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2531">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2531">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-2532">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-2532">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-2533">Démarre la réception asynchrone de données à partir d'un périphérique réseau spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2533">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="3a270-2534">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-2534">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-2535">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2535">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-2536">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-2536">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-2537">Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-2537">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2538">Le <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> méthode est utilisée principalement pour recevoir des données sur un socket sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2538">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="3a270-2539">L’adresse de local doit être connu.</span><span class="sxs-lookup"><span data-stu-id="3a270-2539">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="3a270-2540">L’appelant doit définir le <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété le <xref:System.Net.IPEndPoint> de l’hôte distant à partir de laquelle les données doit être reçu.</span><span class="sxs-lookup"><span data-stu-id="3a270-2540">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="3a270-2541">Le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriété sur le `e` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur la demande de lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2541">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="3a270-2542">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2542">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a270-2543">Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :</span><span class="sxs-lookup"><span data-stu-id="3a270-2543">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="3a270-2544">L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-2544">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="3a270-2545">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</span><span class="sxs-lookup"><span data-stu-id="3a270-2545">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="3a270-2546">Pour les sockets orientés message, un message entrant est placé dans la mémoire tampon jusqu'à la taille totale de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2546">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="3a270-2547">Le <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> et <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriétés déterminent où les données sont placées dans la mémoire tampon et la quantité de données.</span><span class="sxs-lookup"><span data-stu-id="3a270-2547">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="3a270-2548">Pour les sockets de flux de style octets, données entrantes sont placées dans la mémoire tampon jusqu'à ce que la mémoire tampon est remplie, la connexion est fermée ou les données en mémoire tampon en interne sont épuisées.</span><span class="sxs-lookup"><span data-stu-id="3a270-2548">For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="3a270-2549">Le <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> et <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriétés déterminent où les données sont placées dans la mémoire tampon et la quantité de données.</span><span class="sxs-lookup"><span data-stu-id="3a270-2549">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a270-2550"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être Null.</span><span class="sxs-lookup"><span data-stu-id="3a270-2550">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-2551">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</span><span class="sxs-lookup"><span data-stu-id="3a270-2551">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-2552">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-2552">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2553"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2553">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2554">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2554">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2555">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2555">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-2556">Position dans le paramètre <c>buffer</c> où stocker les données reçues.</span><span class="sxs-lookup"><span data-stu-id="3a270-2556">The position in the <c>buffer</c> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-2557">Nombre d'octets à recevoir.</span><span class="sxs-lookup"><span data-stu-id="3a270-2557">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2558">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2558">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-2559"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2559">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="3a270-2560"><see cref="T:System.Net.Sockets.IPPacketInformation" /> contenant des informations d’adresse et d’interface.</span><span class="sxs-lookup"><span data-stu-id="3a270-2560">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span></span></param>
        <summary><span data-ttu-id="3a270-2561">Reçoit le nombre d’octets de données spécifié à l’emplacement de la mémoire tampon spécifié à l’aide des <see cref="T:System.Net.Sockets.SocketFlags" /> spécifiés, puis stocke les informations de paquet et de point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="3a270-2561">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="3a270-2562">Nombre d’octets reçus.</span><span class="sxs-lookup"><span data-stu-id="3a270-2562">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2563">Le <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle l’envoi des données, ainsi que des informations sur le paquet reçu.</span><span class="sxs-lookup"><span data-stu-id="3a270-2563">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="3a270-2564">Le <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> méthode est utilisée principalement pour recevoir des données de message sur un socket sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2564">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="3a270-2565">L’adresse de local doit être connu.</span><span class="sxs-lookup"><span data-stu-id="3a270-2565">The socket's local address must be known.</span></span> <span data-ttu-id="3a270-2566">Cette méthode peut uniquement être utilisée avec le datagramme et des sockets bruts.</span><span class="sxs-lookup"><span data-stu-id="3a270-2566">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="3a270-2567">Le socket doit être initialisé avec le type de socket défini sur <xref:System.Net.Sockets.SocketType.Dgram> ou <xref:System.Net.Sockets.SocketType.Raw> avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-2567">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="3a270-2568">Cela est possible lorsque le socket est construit à l’aide de <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2568">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2569">Pour les sockets orientés message, un message entrant est placé dans le `buffer` paramètre jusqu'à la taille totale spécifiée dans le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-2569">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="3a270-2570">Le `offset` paramètre détermine où, dans le `buffer` les données sont placées.</span><span class="sxs-lookup"><span data-stu-id="3a270-2570">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="3a270-2571">La quantité réelle de données placée dans le `buffer` est retourné par la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2571">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-2572">Le <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> méthode affecte automatiquement la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> option de socket `true` la première fois qu’elle est appelée pour une donnée <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2572">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-2573">Toutefois, le texte retourné <xref:System.Net.Sockets.IPPacketInformation> objet n’est valide que pour les paquets qui arrivent à l’ordinateur local une fois que l’option de socket a été définie.</span><span class="sxs-lookup"><span data-stu-id="3a270-2573">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="3a270-2574">Si un socket est envoyé entre des paquets lorsqu’il est lié à un point de terminaison local (explicitement par le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode) ou implicitement par l’une de le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthodes) et son premier appel à la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> appels de méthode, à <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> méthode retournera non valide <xref:System.Net.Sockets.IPPacketInformation> objets à ces paquets.</span><span class="sxs-lookup"><span data-stu-id="3a270-2574">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="3a270-2575">Pour vous assurer que tous les <xref:System.Net.Sockets.IPPacketInformation> les objets sont valides, une application doit affecter la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> option de socket `true` avant qu’il est lié à un point de terminaison local à l’aide de la <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2575">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="3a270-2576">Une application peut examiner le `ipPacketInformation` paramètre si elle a besoin de savoir si le datagramme a été envoyé à l’aide d’une adresse de multidiffusion ou de diffusion, de monodiffusion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2576">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2577">Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2577">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2578">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2578">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2579">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2579">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2580"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2580"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-2581">\- - ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2581">\- or-</span></span>  
  
 <span data-ttu-id="3a270-2582"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2582"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-2583"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2583"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2584">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2584">-or-</span></span>  
  
 <span data-ttu-id="3a270-2585"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2585"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-2586">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2586">-or-</span></span>  
  
 <span data-ttu-id="3a270-2587"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2587"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2588">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2588">-or-</span></span>  
  
 <span data-ttu-id="3a270-2589"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre de décalage.</span><span class="sxs-lookup"><span data-stu-id="3a270-2589"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-2590"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2590"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="3a270-2591">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2591">-or-</span></span>  
  
 <span data-ttu-id="3a270-2592">La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'a pas été définie.</span><span class="sxs-lookup"><span data-stu-id="3a270-2592">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="3a270-2593">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2593">-or-</span></span>  
  
 <span data-ttu-id="3a270-2594">Le .NET Framework s'exécute sur un processeur AMD 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3a270-2594">The .NET Framework is running on an AMD 64-bit processor.</span></span>  
  
 <span data-ttu-id="3a270-2595">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2595">-or-</span></span>  
  
 <span data-ttu-id="3a270-2596">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2596">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2597"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2597">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-2598">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</span><span class="sxs-lookup"><span data-stu-id="3a270-2598">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="3a270-2599">pour accepter les connexions à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2599">for accepting connections from the network.</span></span> <span data-ttu-id="3a270-2600">Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2600">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-2601">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-2601">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-2602">Démarre la réception asynchrone du nombre spécifié d'octets de données dans l'emplacement spécifié de la mémoire tampon de données, à l'aide du <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> spécifié et stocke le point de terminaison ainsi que les informations sur le paquet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2602">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="3a270-2603">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-2603">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-2604">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2604">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-2605">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-2605">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-2606">Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-2606">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2607">Le <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> méthode est utilisée principalement pour recevoir des données de message sur un socket sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2607">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="3a270-2608">L’adresse de local doit être connu.</span><span class="sxs-lookup"><span data-stu-id="3a270-2608">The socket's local address must be known.</span></span> <span data-ttu-id="3a270-2609">Cette méthode peut uniquement être utilisée avec le datagramme et des sockets bruts.</span><span class="sxs-lookup"><span data-stu-id="3a270-2609">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="3a270-2610">Le socket doit être initialisé avec le type de socket défini sur <xref:System.Net.Sockets.SocketType.Dgram> ou <xref:System.Net.Sockets.SocketType.Raw> avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-2610">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="3a270-2611">Cela est possible lorsque le socket est construit à l’aide de <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2611">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2612">L’appelant doit définir le <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété le <xref:System.Net.IPEndPoint> de l’hôte distant à partir de laquelle les données doit être reçu.</span><span class="sxs-lookup"><span data-stu-id="3a270-2612">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="3a270-2613">Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :</span><span class="sxs-lookup"><span data-stu-id="3a270-2613">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="3a270-2614">L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-2614">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="3a270-2615">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</span><span class="sxs-lookup"><span data-stu-id="3a270-2615">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="3a270-2616">Pour les sockets orientés message, un message entrant est placé dans la mémoire tampon jusqu'à la taille totale de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2616">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="3a270-2617">Le <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> et <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriétés déterminent où les données sont placées dans la mémoire tampon et la quantité de données.</span><span class="sxs-lookup"><span data-stu-id="3a270-2617">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="3a270-2618">Le <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> méthode définit automatiquement le <xref:System.Net.Sockets.SocketOptionName.PacketInformation> option de socket `true` la première fois qu’elle est appelée pour une donnée <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2618">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-2619">Toutefois, le <xref:System.Net.Sockets.IPPacketInformation> objet n’est valide que pour les paquets qui arrivent à l’ordinateur local une fois que l’option de socket a été définie.</span><span class="sxs-lookup"><span data-stu-id="3a270-2619">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="3a270-2620">Si un socket est envoyé entre des paquets lorsque le socket est lié à un point de terminaison local (explicitement par le <xref:System.Net.Sockets.Socket.Bind%2A> méthode ou implicitement par l’une de le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthodes) et le premier appel à la <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>(méthode), appels à <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> méthode entraîne n’est pas valide <xref:System.Net.Sockets.IPPacketInformation> objets à ces paquets.</span><span class="sxs-lookup"><span data-stu-id="3a270-2620">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="3a270-2621">Pour vous assurer que tous les <xref:System.Net.Sockets.IPPacketInformation> les objets sont valides, une application doit affecter la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> option de socket`true` avant qu’il est lié à un point de terminaison local à l’aide de la <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2621">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="3a270-2622">Une application peut examiner les résultats <xref:System.Net.Sockets.IPPacketInformation> objets s’il doit savoir si le datagramme a été envoyé à l’aide d’une adresse de multidiffusion ou de diffusion, de monodiffusion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2622">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a270-2623"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être Null.</span><span class="sxs-lookup"><span data-stu-id="3a270-2623">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-2624">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-2624">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2625"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2625">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2626">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2626">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-2627">Obtient ou définit une valeur spécifiant la durée après laquelle un appel <see cref="Overload:System.Net.Sockets.Socket.Receive" /> synchrone doit expirer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2627">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="3a270-2628">Valeur du délai d'expiration exprimée en millisecondes.</span><span class="sxs-lookup"><span data-stu-id="3a270-2628">The time-out value, in milliseconds.</span></span> <span data-ttu-id="3a270-2629">La valeur par défaut est 0, ce qui indique un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="3a270-2629">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="3a270-2630">La valeur -1 indique également un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="3a270-2630">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2631">Cette option s’applique à synchrone <xref:System.Net.Sockets.Socket.Receive%2A> uniquement les appels.</span><span class="sxs-lookup"><span data-stu-id="3a270-2631">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="3a270-2632">Si le délai d’expiration est dépassé, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lève un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2632">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2633">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-2633">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2634">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2634">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2635"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2635">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-2636">La valeur spécifiée pour une opération ensembliste est inférieure à -1.</span><span class="sxs-lookup"><span data-stu-id="3a270-2636">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-2637">Obtient le point de terminaison distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2637">Gets the remote endpoint.</span></span></summary>
        <value><span data-ttu-id="3a270-2638"><see cref="T:System.Net.EndPoint" /> avec lequel <see cref="T:System.Net.Sockets.Socket" /> communique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2638">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2639">Si vous utilisez un protocole orienté connexion, la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété obtient le <xref:System.Net.EndPoint> qui contient le distant IP adresse et numéro de port auquel le <xref:System.Net.Sockets.Socket> est connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-2639">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="3a270-2640">Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contient l’adresse IP de l’à distance par défaut et le numéro de port avec lequel le <xref:System.Net.Sockets.Socket> communiquera.</span><span class="sxs-lookup"><span data-stu-id="3a270-2640">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="3a270-2641">Vous devez effectuer un cast <xref:System.Net.EndPoint> à un <xref:System.Net.IPEndPoint> avant d’extraire des informations.</span><span class="sxs-lookup"><span data-stu-id="3a270-2641">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="3a270-2642">Vous pouvez ensuite appeler la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> méthode pour récupérer l’élément distant <xref:System.Net.IPAddress>et le <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> pour récupérer le numéro de port distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2642">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="3a270-2643">Le <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> est défini après un appel à <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2643">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-2644">Si vous essayez d’accéder à cette propriété plus tôt, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2644">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2645">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2645">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2646">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2646">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2647">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2647">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2648">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2648">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2649">L’exemple de code suivant récupère et affiche les points de terminaison locaux et distants.</span><span class="sxs-lookup"><span data-stu-id="3a270-2649">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2650">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2650">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2651"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2651">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead"><span data-ttu-id="3a270-2652"><see cref="T:System.Collections.IList" /> sur <see cref="T:System.Net.Sockets.Socket" /> instances à vérifier en ce qui concerne la lisibilité.</span><span class="sxs-lookup"><span data-stu-id="3a270-2652">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span></span></param>
        <param name="checkWrite"><span data-ttu-id="3a270-2653"><see cref="T:System.Collections.IList" /> sur <see cref="T:System.Net.Sockets.Socket" /> instances à vérifier en ce qui concerne la capacité d’écriture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2653">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span></span></param>
        <param name="checkError"><span data-ttu-id="3a270-2654"><see cref="T:System.Collections.IList" /> sur <see cref="T:System.Net.Sockets.Socket" /> instances à vérifier en ce qui concerne les erreurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2654">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span></span></param>
        <param name="microSeconds"><span data-ttu-id="3a270-2655">La valeur du délai d’expiration exprimée en microsecondes.</span><span class="sxs-lookup"><span data-stu-id="3a270-2655">The time-out value, in microseconds.</span></span> <span data-ttu-id="3a270-2656">Une valeur de -1 indique un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="3a270-2656">A -1 value indicates an infinite time-out.</span></span></param>
        <summary><span data-ttu-id="3a270-2657">Détermine l’état d’un ou plusieurs sockets.</span><span class="sxs-lookup"><span data-stu-id="3a270-2657">Determines the status of one or more sockets.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2658"><xref:System.Net.Sockets.Socket.Select%2A> est une méthode statique qui détermine l’état d’un ou plusieurs <xref:System.Net.Sockets.Socket> instances.</span><span class="sxs-lookup"><span data-stu-id="3a270-2658"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="3a270-2659">Vous devez placer un ou plusieurs sockets dans un <xref:System.Collections.IList> avant de pouvoir utiliser le <xref:System.Net.Sockets.Socket.Select%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2659">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="3a270-2660">Recherchez la lisibilité en appelant <xref:System.Net.Sockets.Socket.Select%2A> avec la <xref:System.Collections.IList> en tant que le `checkRead` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-2660">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="3a270-2661">Pour vérifier vos sockets pour l’accessibilité en écriture, utilisez la `checkWrite` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-2661">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="3a270-2662">Pour détecter les conditions d’erreur, utilisez `checkError`.</span><span class="sxs-lookup"><span data-stu-id="3a270-2662">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="3a270-2663">Après avoir appelé <xref:System.Net.Sockets.Socket.Select%2A>, le <xref:System.Collections.IList> sera remplie avec les sockets qui satisfont les conditions.</span><span class="sxs-lookup"><span data-stu-id="3a270-2663">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="3a270-2664">Si vous êtes dans un état d’écoute, une meilleure lisibilité signifie qu’un appel à <xref:System.Net.Sockets.Socket.Accept%2A> réussira sans se bloquer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2664">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="3a270-2665">Si vous avez déjà accepté la connexion, une meilleure lisibilité signifie que les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="3a270-2665">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="3a270-2666">Dans ce cas, toutes les opérations de réception aboutiront sans blocage.</span><span class="sxs-lookup"><span data-stu-id="3a270-2666">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="3a270-2667">Lecture peut également indiquer si l’élément distant <xref:System.Net.Sockets.Socket> a été fermé la connexion ; dans ce cas d’un appel à <xref:System.Net.Sockets.Socket.Receive%2A> est retourné immédiatement, avec zéro octet.</span><span class="sxs-lookup"><span data-stu-id="3a270-2667">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="3a270-2668"><xref:System.Net.Sockets.Socket.Select%2A> Renvoie lorsqu’au moins un des sockets d’intérêt (les sockets dans les `checkRead`, `checkWrite`, et `checkError` répertorie) répond aux critères spécifiés, ou le `microSeconds` paramètre est dépassé, selon ce qui se produit en premier.</span><span class="sxs-lookup"><span data-stu-id="3a270-2668"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="3a270-2669">Paramètre `microSeconds` -1 spécifie un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="3a270-2669">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="3a270-2670">Si vous effectuez un appel non bloquant à <xref:System.Net.Sockets.Socket.Connect%2A>, accessibilité en écriture signifie que vous êtes connecté avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2670">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="3a270-2671">Si vous avez déjà établi une connexion, l’accessibilité en écriture signifie que tous les enverront des opérations réussissent sans se bloquer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2671">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="3a270-2672">Si vous avez effectué un appel de non bloquant à <xref:System.Net.Sockets.Socket.Connect%2A>, le `checkerror` paramètre identifie les sockets qui n’ont pas été connectés avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2672">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2673">Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode si vous souhaitez uniquement déterminer l’état d’un seul <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2673">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2674">Cette méthode ne peut pas détecter certains types de problèmes de connexion, comme un câble réseau rompu, ou que l’hôte distant a été arrêté de manière anormale.</span><span class="sxs-lookup"><span data-stu-id="3a270-2674">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="3a270-2675">Vous devez essayer d’envoyer ou recevoir des données pour détecter ces types d’erreurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2675">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2676">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2676">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2677">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2677">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2678">Le code suivant utilise des exemple <xref:System.Net.Sockets.Socket.Select%2A> pour déterminer les sockets à l’écoute ayant une demande de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2678">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a270-2679">Le paramètre <paramref name="checkRead" /> a la valeur <see langword="null" /> ou est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-2679">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span></span>  
  
 <span data-ttu-id="3a270-2680">-et-</span><span class="sxs-lookup"><span data-stu-id="3a270-2680">-and-</span></span>  
  
 <span data-ttu-id="3a270-2681">Le paramètre <paramref name="checkWrite" /> a la valeur <see langword="null" /> ou est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-2681">The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty</span></span>  
  
 <span data-ttu-id="3a270-2682">-et-</span><span class="sxs-lookup"><span data-stu-id="3a270-2682">-and-</span></span>  
  
 <span data-ttu-id="3a270-2683">Le paramètre <paramref name="checkError" /> a la valeur <see langword="null" /> ou est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-2683">The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2684">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2684">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-2685">Envoie des données à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-2685">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2686">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2686">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="3a270-2687">Envoie des données à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-2687">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2688">Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2688">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2689"><xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2689"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="3a270-2690"><xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2690"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="3a270-2691">Cette surcharge requiert une mémoire tampon qui contient les données que vous souhaitez envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2691">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="3a270-2692">Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut est 0, valeur par défaut est 0 et le nombre d’octets à envoyer équivaut à la taille de la mémoire tampon de décalage de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2692">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="3a270-2693">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2693">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2694">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2694">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-2695">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2695">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-2696">Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2696">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="3a270-2697">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2697">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-2698">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2698">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2699">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2699">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2700">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2700">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2701">En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2701">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="3a270-2702">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2702">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="3a270-2703">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2703">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-2704">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2704">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-2705">Un état de réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2705">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2706">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2706">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2707">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2707">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2708">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2708">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-2709">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2709">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2710">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2710">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2711">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2711">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2712">L’exemple de code suivant illustre l’envoi de données sur un connecté <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2712">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2713"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2713"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2714">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2714">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2715"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2715">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-2716">Liste de <see cref="T:System.ArraySegment`1" /> de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2716">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="3a270-2717">Envoie le jeu de mémoires tampon dans la liste à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-2717">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2718">Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2718">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2719"><xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2719"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="3a270-2720">Cette surcharge requiert au moins une mémoire tampon qui contient les données que vous souhaitez envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2720">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="3a270-2721">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2721">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2722">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2722">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-2723">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2723">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-2724">Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2724">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="3a270-2725">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2725">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-2726">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2726">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2727">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2727">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2728">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2728">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2729">En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2729">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="3a270-2730">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2730">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="3a270-2731">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2731">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-2732">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2732">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-2733">Un état de réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2733">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2734">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2734">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2735">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2735">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2736">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2736">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-2737">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2737">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2738">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2738">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2739">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2739">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2740"><paramref name="buffers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2740"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-2741"><paramref name="buffers" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-2741"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2742">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2742">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-2743">Consultez la section Notes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3a270-2743">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2744"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2744">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2745">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2745">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2746">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2746">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-2747">Envoie des données à un <see cref="T:System.Net.Sockets.Socket" /> connecté à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2747">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2748">Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2748">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2749"><xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2749"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="3a270-2750">Le <xref:System.Net.Sockets.Socket.Send%2A> méthode peut être utilisée pour les protocoles orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2750">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="3a270-2751">Cette surcharge requiert une mémoire tampon qui contient les données que vous souhaitez envoyer et une combinaison d’opérations de <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2751">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="3a270-2752">Offset de mémoire tampon par défaut, 0 et le nombre d’octets à envoyer équivaut à la taille de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2752">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="3a270-2753">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` la valeur du paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2753">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-2754">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2754">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2755">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2755">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-2756">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2756">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-2757">Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2757">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="3a270-2758">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2758">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-2759">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2759">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2760">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2760">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2761">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2761">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2762">En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2762">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="3a270-2763">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2763">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="3a270-2764">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2764">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-2765">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2765">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-2766">Un état de réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2766">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2767">Vous devez vous assurer que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-2767">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-2768">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2768">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2769">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2769">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2770">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2770">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2771">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2771">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-2772">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2772">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2773">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2773">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2774">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2774">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2775">L’exemple de code suivant illustre l’envoi de données sur un connecté <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2775">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2776"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2776"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2777">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2777">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2778"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2778">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-2779">Liste de <see cref="T:System.ArraySegment`1" /> de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2779">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2780">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2780">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-2781">Envoie le jeu de mémoires tampon dans la liste à un <see cref="T:System.Net.Sockets.Socket" /> connecté, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2781">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2782">Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2782">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2783">Cette surcharge requiert au moins une mémoire tampon qui contient les données que vous souhaitez envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2783">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="3a270-2784">Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2784">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="3a270-2785">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketFlags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2785">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-2786">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2786">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2787">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2787">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-2788">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2788">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-2789">Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2789">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="3a270-2790">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2790">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-2791">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2791">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2792">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2792">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2793">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2793">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2794">En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2794">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="3a270-2795">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2795">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="3a270-2796">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2796">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-2797">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2797">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-2798">Un état de réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2798">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2799">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2799">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2800">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2800">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2801">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2801">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-2802">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2802">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2803">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2803">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2804">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2804">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2805"><paramref name="buffers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2805"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-2806"><paramref name="buffers" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-2806"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2807">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2807">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2808"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2808">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2809">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2809">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-2810">Le nombre d’octets à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2810">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2811">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2811">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-2812">Reçoit le nombre spécifié d'octets de données à un <see cref="T:System.Net.Sockets.Socket" /> connecté, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2812">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2813">Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2813">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2814"><xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2814"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="3a270-2815"><xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2815"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="3a270-2816">Cette surcharge requiert une mémoire tampon qui contient les données que vous souhaitez envoyer, le nombre d’octets à envoyer et une combinaison d’opérations de bits de n’importe quel <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2816">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="3a270-2817">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2817">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-2818">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2818">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2819">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2819">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-2820">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2820">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-2821">Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant chaque appel à la <xref:System.Net.Sockets.Socket.Send%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2821">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="3a270-2822">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2822">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-2823">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2823">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2824">Avec un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que le nombre d’octets demandés est envoyé, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2824">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2825">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2825">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2826">En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2826">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="3a270-2827">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2827">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="3a270-2828">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2828">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-2829">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2829">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-2830">Un état de réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2830">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2831">Vous devez vous assurer que la taille ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-2831">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-2832">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2832">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2833">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2833">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2834">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2834">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2835">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2835">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-2836">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2836">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2837">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2837">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2838">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2838">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2839">L’exemple de code suivant envoie les données de la mémoire tampon et spécifie <xref:System.Net.Sockets.SocketFlags.None> pour <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2839">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2840"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2840"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-2841"><paramref name="size" /> est inférieur à 0 ou dépasse la taille de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2841"><paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-2842"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2842"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="3a270-2843">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2843">-or-</span></span>  
  
 <span data-ttu-id="3a270-2844">Une erreur du système d'exploitation s'est produite lors de l'accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2844">An operating system error occurs while accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2845"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2845">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="3a270-2846">Liste de <see cref="T:System.ArraySegment`1" /> de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2846">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2847">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2847">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="3a270-2848">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2848">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="3a270-2849">Envoie le jeu de mémoires tampon dans la liste à un <see cref="T:System.Net.Sockets.Socket" /> connecté, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2849">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2850">Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2850">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2851">Cette surcharge requiert au moins une mémoire tampon qui contient les données que vous souhaitez envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2851">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="3a270-2852">Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2852">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="3a270-2853">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketFlags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2853">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-2854">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2854">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2855">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2855">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-2856">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2856">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-2857">Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2857">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="3a270-2858">Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2858">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-2859">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2859">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2860">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2860">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2861">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2861">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2862">En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2862">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="3a270-2863">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3a270-2863">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="3a270-2864">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2864">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-2865">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2865">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-2866">Un état de réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2866">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2867">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2867">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2868">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2868">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2869">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2869">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-2870">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2870">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2871">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2871">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2872">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2872">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2873"><paramref name="buffers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2873"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a270-2874"><paramref name="buffers" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="3a270-2874"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2875">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2875">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2876"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2876">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2877">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2877">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-2878">La position dans le tampon de données par laquelle doit commencer l’envoi des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-2878">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-2879">Le nombre d’octets à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2879">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2880">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2880">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-2881">Envoie le nombre spécifié d’octets de données à un <see cref="T:System.Net.Sockets.Socket" /> connecté, à part de l’offset spécifié et avec le <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-2881">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-2882">Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2882">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2883"><xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2883"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="3a270-2884"><xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2884"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="3a270-2885">Dans cette surcharge, si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2885">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-2886">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2886">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2887">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2887">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-2888">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2888">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="3a270-2889">Si vous n’utilisez pas <xref:System.Net.Sockets.Socket.SendTo%2A>, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2889">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="3a270-2890">Il est OK à utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2890">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-2891">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2891">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2892">Vous devez également être sûr que la taille ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-2892">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-2893">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2893">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-2894">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que le nombre d’octets demandés est envoyé, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2894">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2895">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2895">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2896">En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2896">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="3a270-2897">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2897">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="3a270-2898">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2898">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-2899">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2899">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-2900">Un état de réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2900">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2901">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2901">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2902">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2902">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2903">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2903">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-2904">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2904">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2905">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2905">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2906">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2906">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2907">L’exemple de code suivant spécifie la mémoire tampon de données, un offset, une taille, et <xref:System.Net.Sockets.SocketFlags> pour l’envoi de données connectée <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2907">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2908"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2908"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-2909"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2909"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2910">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2910">-or-</span></span>  
  
 <span data-ttu-id="3a270-2911"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2911"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-2912">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2912">-or-</span></span>  
  
 <span data-ttu-id="3a270-2913"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2913"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2914">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2914">-or-</span></span>  
  
 <span data-ttu-id="3a270-2915"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2915"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-2916"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2916"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="3a270-2917">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2917">-or-</span></span>  
  
 <span data-ttu-id="3a270-2918">Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2918">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2919"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2919">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-2920">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2920">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-2921">La position dans le tampon de données par laquelle doit commencer l’envoi des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-2921">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-2922">Le nombre d’octets à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-2922">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-2923">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2923">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="3a270-2924">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2924">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="3a270-2925">Envoie le nombre spécifié d'octets de données d'un <see cref="T:System.Net.Sockets.Socket" /> connecté, en démarrant à l'offset spécifié et en utilisant le <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié</span><span class="sxs-lookup"><span data-stu-id="3a270-2925">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span></span></summary>
        <returns><span data-ttu-id="3a270-2926">Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2926">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2927"><xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2927"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="3a270-2928"><xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2928"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="3a270-2929">Dans cette surcharge, si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2929">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-2930">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2930">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2931">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-2931">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-2932">Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2932">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="3a270-2933">Si vous n’utilisez pas <xref:System.Net.Sockets.Socket.SendTo%2A>, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2933">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="3a270-2934">Il est OK à utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2934">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="3a270-2935">Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2935">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2936">Vous devez également être sûr que la taille ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-2936">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-2937">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2937">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-2938">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que le nombre d’octets demandés est envoyé, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2938">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-2939">Si la valeur de délai d’attente a été dépassée, la <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2939">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-2940">En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2940">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="3a270-2941">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2941">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="3a270-2942">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2942">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-2943">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2943">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-2944">Un état de réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-2944">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2945">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-2945">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-2946">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-2946">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2947">L’achèvement d’un envoi n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2947">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="3a270-2948">Si aucun espace tampon n’est disponible dans le système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="3a270-2948">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-2949">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-2949">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-2950">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-2950">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2951">L’exemple de code suivant spécifie la mémoire tampon de données, un offset, une taille, et <xref:System.Net.Sockets.SocketFlags> pour l’envoi de données connectée <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2951">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-2952"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2952"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-2953"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2953"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2954">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2954">-or-</span></span>  
  
 <span data-ttu-id="3a270-2955"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2955"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-2956">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2956">-or-</span></span>  
  
 <span data-ttu-id="3a270-2957"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2957"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-2958">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2958">-or-</span></span>  
  
 <span data-ttu-id="3a270-2959"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2959"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-2960"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-2960"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="3a270-2961">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-2961">-or-</span></span>  
  
 <span data-ttu-id="3a270-2962">Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2962">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2963"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2963">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-2964">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-2964">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-2965">Envoie des données de façon asynchrone à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-2965">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="3a270-2966">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-2966">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-2967">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-2967">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-2968">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-2968">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-2969">Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-2969">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2970">Le <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode est utilisée pour écrire des données sortantes à partir d’un ou plusieurs tampons sur un socket orienté connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2970">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="3a270-2971">Cette méthode peut également être utilisée, toutefois, sur les sockets sans connexion que vous ont spécifié un hôte distant sur une opération de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2971">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="3a270-2972">Le <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établi dans les <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-2972">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-2973">Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :</span><span class="sxs-lookup"><span data-stu-id="3a270-2973">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="3a270-2974"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ou <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3a270-2974"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="3a270-2975"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> a la valeur</span><span class="sxs-lookup"><span data-stu-id="3a270-2975"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="3a270-2976"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> a la valeur</span><span class="sxs-lookup"><span data-stu-id="3a270-2976"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="3a270-2977">L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.SendAsync%2A> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-2977">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="3a270-2978">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</span><span class="sxs-lookup"><span data-stu-id="3a270-2978">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="3a270-2979">Le <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-2979">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="3a270-2980">Appel de la <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-2980">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="3a270-2981">Pour les sockets orientés message, ne dépassez pas la taille maximale du message du fournisseur de services Windows sockets sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-2981">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="3a270-2982">Si les données sont trop longues à traverser atomiquement le fournisseur de service sous-jacent, aucune donnée n’est transmise et la <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode lève une exception un <xref:System.Net.Sockets.SocketException> avec le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> défini sur le code d’erreur Winsock WSAEMSGSIZE natif (10040).</span><span class="sxs-lookup"><span data-stu-id="3a270-2982">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="3a270-2983">Notez que l’achèvement réussi de la <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-2983">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-2984">La propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> ou <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> sur le paramètre de <paramref name="e" /> doit référencer des mémoires tampon valides.</span><span class="sxs-lookup"><span data-stu-id="3a270-2984">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="3a270-2985">L'une ou l'autre de ces propriétés peut être définie, mais pas les deux à la fois.</span><span class="sxs-lookup"><span data-stu-id="3a270-2985">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-2986">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</span><span class="sxs-lookup"><span data-stu-id="3a270-2986">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-2987">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-2987">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2988"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2988">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2989">Le <see cref="T:System.Net.Sockets.Socket" /> n'est pas encore connecté ou n'a pas été obtenu via une méthode <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />ou <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2989">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-2990">Obtient ou définit une valeur spécifiant la taille de la mémoire tampon d'envoi de <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-2990">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="3a270-2991"><see cref="T:System.Int32" /> contenant la taille de la mémoire tampon d'envoi en octets.</span><span class="sxs-lookup"><span data-stu-id="3a270-2991">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span></span> <span data-ttu-id="3a270-2992">La valeur par défaut est 8192.</span><span class="sxs-lookup"><span data-stu-id="3a270-2992">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-2993">Une plus grande taille de mémoire tampon peut retarder la reconnaissance des difficultés de connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-2993">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="3a270-2994">Envisagez d’augmenter la taille de la mémoire tampon si vous transférez des fichiers volumineux, ou si vous utilisez une bande passante élevée, la latence élevée de la connexion (par exemple, un fournisseur large bande satellite).</span><span class="sxs-lookup"><span data-stu-id="3a270-2994">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-2995">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.SendBufferSize%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-2995">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-2996">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-2996">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-2997"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-2997">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-2998">La valeur spécifiée pour une opération ensembliste est inférieure à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-2998">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-2999">Envoie de façon synchrone un fichier et des données facultatives à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-2999">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="3a270-3000"><see cref="T:System.String" /> contenant le chemin d’accès et le nom du fichier à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3000">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="3a270-3001">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3001">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3a270-3002">Envoie le fichier <paramref name="fileName" /> à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté avec l'indicateur de transmission <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3002">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3003">Cette surcharge envoie le fichier `fileName` au socket connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-3003">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="3a270-3004">Le `flags` paramètre par défaut est <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) et le `preBuffer` et `postBuffer` les paramètres par défaut `null`.</span><span class="sxs-lookup"><span data-stu-id="3a270-3004">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="3a270-3005">Si `fileName` est dans le répertoire local, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3005">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="3a270-3006">Les caractères génériques («.. \\\myfile.txt ») et les noms de partage UNC («\\\\\\\shared active\\\myfile.txt ») sont pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3006">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="3a270-3007">Si le fichier est introuvable, l’exception <xref:System.IO.FileNotFoundException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3007">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="3a270-3008">Cette méthode utilise le `TransmitFile` de trouver la fonction dans l’API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="3a270-3008">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="3a270-3009">Pour plus d’informations sur la `TransmitFile` fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3a270-3009">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="3a270-3010"><xref:System.Net.Sockets.Socket.SendFile%2A> envoie de façon synchrone un fichier à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3010"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-3011"><xref:System.Net.Sockets.Socket.SendFile%2A> peut être utilisé pour les orientés connexion et les protocoles sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-3011"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="3a270-3012">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, sinon <xref:System.Net.Sockets.Socket.SendFile%2A> lève une <xref:System.Net.Sockets.SocketException> exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-3012">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="3a270-3013">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-3013">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-3014">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.SendFile%2A> bloque jusqu'à ce que le fichier est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3014">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="3a270-3015">En mode non bloquant, <xref:System.Net.Sockets.Socket.SendFile%2A> peut se terminer correctement avant de l’intégralité du fichier a été envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3015">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="3a270-3016">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3016">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-3017">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3017">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-3018">Un état de réussite de la <xref:System.Net.Sockets.Socket.SendFile%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3018">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3019">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3019">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3020">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3020">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3021">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-3021">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-3022">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-3022">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3023">L’exemple de code suivant crée et connecte à un socket et envoie ensuite un fichier à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-3023">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="3a270-3024">Le fichier « test.txt » se trouve dans le répertoire racine de l’ordinateur local.</span><span class="sxs-lookup"><span data-stu-id="3a270-3024">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-3025">Le socket n’est pas connecté à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-3025">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3026">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3026">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-3027">L’objet <see cref="T:System.Net.Sockets.Socket" /> n’est pas en mode blocage et ne peut pas accepter cet appel synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-3027">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="3a270-3028">Le fichier <paramref name="fileName" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3a270-3028">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3029">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3029">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="3a270-3030"><see cref="T:System.String" /> contenant le chemin d’accès et le nom du fichier à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3030">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="3a270-3031">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3031">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="3a270-3032">Tableau <see cref="T:System.Byte" /> contenant les données à envoyer avant l’envoi du fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-3032">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="3a270-3033">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3033">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="3a270-3034">Tableau <see cref="T:System.Byte" /> contenant les données à envoyer après l’envoi du fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-3034">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="3a270-3035">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3035">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="3a270-3036">Une ou plusieurs des valeurs <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3036">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <summary><span data-ttu-id="3a270-3037">Envoie le <paramref name="fileName" /> et les tampons de données du fichier à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté à l’aide de la valeur <see cref="T:System.Net.Sockets.TransmitFileOptions" /> spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3037">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3038">Cette surcharge requiert le nom du fichier à envoyer et une combinaison d’opérations de <xref:System.Net.Sockets.TransmitFileOptions> valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-3038">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="3a270-3039">Le `preBuffer` paramètre contient les données que vous voulez faire précéder le fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-3039">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="3a270-3040">`postBuffer` contient des données que vous souhaitez suivre le fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-3040">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="3a270-3041">Si `fileName` est dans le répertoire de travail actuel, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3041">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="3a270-3042">Les caractères génériques («.. \\\myfile.txt ») et les noms de partage UNC («\\\\\\\shared active\\\myfile.txt ») sont pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3042">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="3a270-3043">Le `flags` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur le transfert de fichiers.</span><span class="sxs-lookup"><span data-stu-id="3a270-3043">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="3a270-3044">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3044">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="3a270-3045">Cette méthode utilise le `TransmitFile` de trouver la fonction dans l’API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="3a270-3045">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="3a270-3046">Pour plus d’informations sur la `TransmitFile` fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3a270-3046">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="3a270-3047"><xref:System.Net.Sockets.Socket.SendFile%2A> envoie de façon synchrone un fichier à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3047"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-3048"><xref:System.Net.Sockets.Socket.SendFile%2A> peut être utilisé pour les orientés connexion et les protocoles sans connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-3048"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="3a270-3049">Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode ; sinon <xref:System.Net.Sockets.Socket.SendFile%2A> lève une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3049">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-3050">Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.</span><span class="sxs-lookup"><span data-stu-id="3a270-3050">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="3a270-3051">Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.SendFile%2A> bloque jusqu'à ce que le fichier entier est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3051">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="3a270-3052">En mode non bloquant, <xref:System.Net.Sockets.Socket.SendFile%2A> peut se terminer correctement avant de l’intégralité du fichier a été envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3052">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="3a270-3053">Il n’existe aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3053">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-3054">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3054">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-3055">Un état de réussite de la <xref:System.Net.Sockets.Socket.SendFile%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3055">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3056">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3056">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3057">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3057">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3058">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-3058">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-3059">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-3059">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3060">L’exemple de code suivant crée et connecte à un socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3060">The following code example creates and connects a socket.</span></span> <span data-ttu-id="3a270-3061">Le fichier « test.txt » se trouve dans le répertoire racine de l’ordinateur local.</span><span class="sxs-lookup"><span data-stu-id="3a270-3061">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="3a270-3062">Dans cet exemple, nous créer un prebuffer et une post-mémoire tampon de données et les envoyer à l’hôte distant avec le fichier.</span><span class="sxs-lookup"><span data-stu-id="3a270-3062">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="3a270-3063">La valeur par défaut <xref:System.Net.Sockets.TransmitFileOptions> sont utilisés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3063">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-3064">Le système d'exploitation n'est pas Windows NT ou une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="3a270-3064">The operating system is not Windows NT or later.</span></span>  
  
 <span data-ttu-id="3a270-3065">\- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-3065">\- or -</span></span>  
  
 <span data-ttu-id="3a270-3066">Le socket n’est pas connecté à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-3066">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3067">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3067">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-3068">L’objet <see cref="T:System.Net.Sockets.Socket" /> n’est pas en mode blocage et ne peut pas accepter cet appel synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-3068">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="3a270-3069">Le fichier <paramref name="fileName" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3a270-3069">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3070">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3070">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-3071">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-3071">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-3072">Envoie une collection de fichiers ou des données mises en mémoire tampon de façon asynchrone à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-3072">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="3a270-3073">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-3073">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-3074">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3074">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-3075">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-3075">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-3076">Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-3076">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3077">Le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode est utilisée pour envoyer des tampons de données de collection de fichiers ou dans la mémoire à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-3077">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="3a270-3078">Le <xref:System.Net.Sockets.Socket> doit déjà être connecté à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-3078">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="3a270-3079">Si un <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> références à un fichier dans le répertoire de travail, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3079">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="3a270-3080">Les caractères génériques et les noms de partage UNC sont pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3080">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="3a270-3081">Si le fichier est introuvable, <xref:System.IO.FileNotFoundException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3081">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="3a270-3082">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler\<SocketAsyncEventArgs > et l’attacher le rappel pour le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.</span><span class="sxs-lookup"><span data-stu-id="3a270-3082">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="3a270-3083">Le <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propriété sur le `e` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur le transfert de fichiers.</span><span class="sxs-lookup"><span data-stu-id="3a270-3083">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="3a270-3084">Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3084">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="3a270-3085">Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :</span><span class="sxs-lookup"><span data-stu-id="3a270-3085">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="3a270-3086">L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-3086">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="3a270-3087">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</span><span class="sxs-lookup"><span data-stu-id="3a270-3087">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="3a270-3088">Cette méthode utilise la fonction TransmitPackets détectée dans l’API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="3a270-3088">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="3a270-3089">Pour plus d’informations sur la fonction TransmitPackets et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3a270-3089">For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="3a270-3090">Bien que destiné à des protocoles orientés connexion, la <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode pour établir un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-3090">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="3a270-3091">Avec les protocoles sans connexion, vous devez être sûr que la taille de votre fichier ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-3091">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-3092">Dans ce cas, le datagramme n’est pas envoyé et <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> lève une <xref:System.Net.Sockets.SocketException> exception.</span><span class="sxs-lookup"><span data-stu-id="3a270-3092">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="3a270-3093">Le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode est optimisée selon le système d’exploitation sur lequel il est utilisé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3093">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="3a270-3094">Sur les éditions de Windows server, le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode est optimisée pour des performances élevées.</span><span class="sxs-lookup"><span data-stu-id="3a270-3094">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="3a270-3095">Sur les éditions client Windows, le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode est optimisée pour une utilisation minimale de mémoire et de ressources.</span><span class="sxs-lookup"><span data-stu-id="3a270-3095">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="3a270-3096">Utilisation de la <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> indicateur dans le <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propriété sur le `e` paramètre peut fournir des gains de performance significatifs.</span><span class="sxs-lookup"><span data-stu-id="3a270-3096">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="3a270-3097">Si l’initialisation du thread du <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> appel de méthode est utilisé pour les calculs lourds, il est possible, bien que peu probable, qu’appel de procédure asynchrone ne soient pas lancer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3097">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="3a270-3098">Notez qu’il existe une différence entre l’appel de procédure asynchrone en mode utilisateur et de noyau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3098">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="3a270-3099">Noyau sont lancés lorsqu’un thread est dans un état d’attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-3099">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="3a270-3100">En mode utilisateur sont lancés lorsqu’un thread est dans un état d’une attente</span><span class="sxs-lookup"><span data-stu-id="3a270-3100">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="3a270-3101">Le fichier spécifié dans la propriété <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3a270-3101">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-3102">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</span><span class="sxs-lookup"><span data-stu-id="3a270-3102">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-3103">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-3103">Windows XP or later is required for this method.</span></span> <span data-ttu-id="3a270-3104">Cette exception se produit également si le <see cref="T:System.Net.Sockets.Socket" /> n'est pas connecté à un hôte distant.</span><span class="sxs-lookup"><span data-stu-id="3a270-3104">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3105"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3105">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3106">Un <see cref="T:System.Net.Sockets.Socket" /> sans connexion est utilisé et le fichier qui est envoyé dépasse la taille maximale du paquet du transport sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-3106">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-3107">Obtient ou définit une valeur spécifiant la durée après laquelle un appel <see cref="Overload:System.Net.Sockets.Socket.Send" /> synchrone doit expirer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3107">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="3a270-3108">Valeur du délai d'expiration exprimée en millisecondes.</span><span class="sxs-lookup"><span data-stu-id="3a270-3108">The time-out value, in milliseconds.</span></span> <span data-ttu-id="3a270-3109">Si vous affectez à la propriété une valeur comprise entre 1 et 499, cette valeur est remplacée par 500.</span><span class="sxs-lookup"><span data-stu-id="3a270-3109">If you set the property with a value between 1 and 499, the value will be changed to 500.</span></span> <span data-ttu-id="3a270-3110">La valeur par défaut est 0, ce qui indique un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="3a270-3110">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="3a270-3111">La valeur -1 indique également un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="3a270-3111">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3112">Cette option s’applique à synchrone <xref:System.Net.Sockets.Socket.Send%2A> uniquement les appels.</span><span class="sxs-lookup"><span data-stu-id="3a270-3112">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="3a270-3113">Si le délai d’expiration est dépassé, le <xref:System.Net.Sockets.Socket.Send%2A> méthode lève un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3113">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3114">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.SendTimeout%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-3114">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3115">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3115">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3116"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3116">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-3117">La valeur spécifiée pour une opération ensembliste est inférieure à -1.</span><span class="sxs-lookup"><span data-stu-id="3a270-3117">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-3118">Envoie les données à un point de terminaison spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3118">Sends data to a specific endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-3119">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3119">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-3120"><see cref="T:System.Net.EndPoint" /> qui représente la destination des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-3120">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span></span></param>
        <summary><span data-ttu-id="3a270-3121">Envoie les données au point de terminaison spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3121">Sends data to the specified endpoint.</span></span></summary>
        <returns><span data-ttu-id="3a270-3122">Nombre d’octets envoyés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3122">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3123">Dans cette surcharge, offset de mémoire tampon par défaut, 0, le nombre d’octets à envoyer équivaut à la taille de la `buffer` paramètre et le <xref:System.Net.Sockets.SocketFlags> valeur par défaut 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-3123">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="3a270-3124">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3124">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="3a270-3125">Vous pouvez procéder ainsi si vous voulez appeler le <xref:System.Net.Sockets.Socket.Send%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3125">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="3a270-3126">Si vous appelez le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</span><span class="sxs-lookup"><span data-stu-id="3a270-3126">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="3a270-3127">Vous ne devez pas également pour appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3127">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="3a270-3128">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.SendTo%2A> terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3128">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="3a270-3129">Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendTo%2A> fonctionne également avec les protocoles orientés connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-3129">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="3a270-3130">Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou acceptez une demande de connexion entrante à l’aide du <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3130">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-3131">Si vous n’établissez ou accepter une connexion d’hôte distant, <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3131">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-3132">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3132">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-3133">Dans les deux cas, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorera le `remoteEP` paramètre et uniquement envoyer les données vers le connectée ou un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-3133">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="3a270-3134">Sockets bloquants se bloquent jusqu'à ce que tous les octets de la mémoire tampon sont envoyés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3134">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="3a270-3135">Dans la mesure où un non bloquant <xref:System.Net.Sockets.Socket> se termine immédiatement, il peut ne pas envoyer tous les octets dans le `buffer`.</span><span class="sxs-lookup"><span data-stu-id="3a270-3135">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="3a270-3136">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie tous les octets dans le `buffer`.</span><span class="sxs-lookup"><span data-stu-id="3a270-3136">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="3a270-3137">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3137">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-3138">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3138">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="3a270-3139">Un état de réussite de la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3139">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="3a270-3140">Si vous utilisez un protocole sans connexion en mode blocage, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3140">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="3a270-3141">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3141">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-3142">Vous devez également être sûr que le nombre d’octets envoyés ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-3142">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-3143">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3143">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3144">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3144">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3145">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3145">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3146">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-3146">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-3147">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-3147">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3148">L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3148">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-3149"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3149"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-3150">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-3150">-or-</span></span>  
  
 <span data-ttu-id="3a270-3151"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3151"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3152">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3152">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3153"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3153">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-3154">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3154">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-3155">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3155">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-3156"><see cref="T:System.Net.EndPoint" /> qui représente l'emplacement de destination des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-3156">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="3a270-3157">Envoie des données à un point de terminaison spécifique à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3157">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-3158">Nombre d’octets envoyés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3158">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3159">Dans cette surcharge, offset de mémoire tampon par défaut, 0 et le nombre d’octets à envoyer équivaut à la taille de la `buffer`.</span><span class="sxs-lookup"><span data-stu-id="3a270-3159">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="3a270-3160">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3160">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-3161">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3161">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="3a270-3162">Vous pouvez procéder ainsi si vous voulez appeler le <xref:System.Net.Sockets.Socket.Send%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3162">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="3a270-3163">Si vous appelez le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</span><span class="sxs-lookup"><span data-stu-id="3a270-3163">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="3a270-3164">Vous ne devez pas également pour appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3164">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="3a270-3165">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.SendTo%2A> terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3165">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="3a270-3166">Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendTo%2A> fonctionne également avec les protocoles orientés connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-3166">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="3a270-3167">Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou acceptez une demande de connexion entrante à l’aide du <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3167">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-3168">Si vous n’établissez ou accepter une connexion d’hôte distant, <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3168">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-3169">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3169">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-3170">Dans les deux cas, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorera le `remoteEP` paramètre et uniquement envoyer les données vers le connectée ou un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-3170">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="3a270-3171">Sockets bloquants se bloquent jusqu'à ce que demandé tous les octets dans le `buffer` sont envoyés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3171">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="3a270-3172">Dans la mesure où un non bloquant <xref:System.Net.Sockets.Socket> se termine immédiatement, il peut ne pas envoyer tous les octets dans le `buffer`.</span><span class="sxs-lookup"><span data-stu-id="3a270-3172">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="3a270-3173">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie tous les octets dans le `buffer`.</span><span class="sxs-lookup"><span data-stu-id="3a270-3173">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="3a270-3174">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3174">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-3175">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3175">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="3a270-3176">Un état de réussite de la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3176">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="3a270-3177">Si vous utilisez un protocole sans connexion en mode blocage, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3177">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="3a270-3178">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3178">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-3179">Vous devez également être sûr que le nombre d’octets envoyés ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-3179">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-3180">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3180">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3181">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3181">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3182">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3182">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3183">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-3183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-3184">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-3184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3185">L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3185">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="3a270-3186"><xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3186"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-3187"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3187"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-3188">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-3188">-or-</span></span>  
  
 <span data-ttu-id="3a270-3189"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3189"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3190">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3190">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3191"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3191">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-3192">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3192">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-3193">Le nombre d’octets à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3193">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-3194">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3194">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-3195"><see cref="T:System.Net.EndPoint" /> qui représente l'emplacement de destination des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-3195">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="3a270-3196">Envoie le nombre spécifié d'octets de données au point de terminaison spécifié à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3196">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-3197">Nombre d’octets envoyés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3197">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3198">Dans cette surcharge, offset de mémoire tampon par défaut 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-3198">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="3a270-3199">Si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3199">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-3200">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3200">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="3a270-3201">Vous pouvez procéder ainsi si vous voulez appeler le <xref:System.Net.Sockets.Socket.Send%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3201">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="3a270-3202">Si vous appelez le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</span><span class="sxs-lookup"><span data-stu-id="3a270-3202">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="3a270-3203">Vous ne devez pas également pour appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3203">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="3a270-3204">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.SendTo%2A> terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3204">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="3a270-3205">Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendTo%2A> fonctionne également avec les protocoles orientés connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-3205">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="3a270-3206">Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou acceptez une demande de connexion entrante à l’aide du <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3206">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-3207">Si vous n’établissez ou accepter une connexion d’hôte distant, <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3207">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-3208">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3208">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-3209">Dans les deux cas, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorera le `remoteEP` paramètre et uniquement envoyer les données vers le connectée ou un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-3209">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="3a270-3210">Sockets bloquants se bloquent jusqu'à ce que le nombre d’octets demandés est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3210">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="3a270-3211">Dans la mesure où un non bloquant <xref:System.Net.Sockets.Socket> se termine immédiatement, il peut ne pas envoyer tous les octets demandés en une seule opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-3211">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="3a270-3212">Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3212">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="3a270-3213">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3213">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-3214">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3214">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="3a270-3215">Un état de réussite de la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3215">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="3a270-3216">Si vous utilisez un protocole sans connexion en mode blocage, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3216">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="3a270-3217">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3217">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-3218">Vous devez également être sûr que le nombre d’octets envoyés ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-3218">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-3219">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3219">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3220">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3220">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3221">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3221">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3222">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-3222">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-3223">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-3223">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3224">L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3224">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="3a270-3225">La taille et <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3225">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-3226"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3226"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-3227">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-3227">-or-</span></span>  
  
 <span data-ttu-id="3a270-3228"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3228"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-3229">Le <paramref name="size" /> spécifié dépasse la taille de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3229">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3230">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3230">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3231"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3231">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="3a270-3232">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3232">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="3a270-3233">La position dans le tampon de données par laquelle doit commencer l’envoi des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-3233">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="3a270-3234">Le nombre d’octets à envoyer.</span><span class="sxs-lookup"><span data-stu-id="3a270-3234">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="3a270-3235">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3235">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="3a270-3236"><see cref="T:System.Net.EndPoint" /> qui représente l'emplacement de destination des données.</span><span class="sxs-lookup"><span data-stu-id="3a270-3236">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="3a270-3237">Envoie le nombre spécifié d'octets de données au point de terminaison spécifié, en commençant à l'emplacement spécifié dans la mémoire tampon et en utilisant le <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3237">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="3a270-3238">Nombre d’octets envoyés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3238">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3239">Dans cette surcharge, si vous spécifiez la <xref:System.Net.Sockets.SocketFlags.DontRoute> doivent être signalées comme le `socketflags` paramètre, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3239">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-3240">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3240">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="3a270-3241">Vous pouvez procéder ainsi si vous voulez appeler le <xref:System.Net.Sockets.Socket.Send%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3241">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="3a270-3242">Si vous appelez le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</span><span class="sxs-lookup"><span data-stu-id="3a270-3242">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="3a270-3243">Vous ne devez pas également pour appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3243">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="3a270-3244">Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.SendTo%2A> terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3244">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="3a270-3245">Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendTo%2A> fonctionne également avec les protocoles orientés connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-3245">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="3a270-3246">Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou acceptez une demande de connexion entrante à l’aide du <xref:System.Net.Sockets.Socket.Accept%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3246">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="3a270-3247">Si vous n’établissez ou accepter une connexion d’hôte distant, <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3247">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-3248">Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3248">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="3a270-3249">Dans les deux cas, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorera le `remoteEP` paramètre et uniquement envoyer les données vers le connectée ou un hôte distant par défaut.</span><span class="sxs-lookup"><span data-stu-id="3a270-3249">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="3a270-3250">Sockets bloquants se bloquent jusqu'à ce que le nombre d’octets demandés est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3250">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="3a270-3251">Depuis un non bloquant <xref:System.Net.Sockets.Socket> se termine immédiatement, il peut ne pas envoyer tous les octets demandés en une seule opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-3251">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="3a270-3252">Il vous incombe applications pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3252">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="3a270-3253">Il n’existe également aucune garantie que les données que vous envoyez seront affiche immédiatement sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3253">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="3a270-3254">Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3254">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="3a270-3255">Un état de réussite de la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode signifie que le système sous-jacent n’est pas de place pour la mémoire tampon de l’envoi de vos données pour un réseau.</span><span class="sxs-lookup"><span data-stu-id="3a270-3255">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="3a270-3256">Si vous utilisez un protocole sans connexion en mode blocage, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3256">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="3a270-3257">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3257">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a270-3258">Vous devez également être sûr que la taille ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-3258">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-3259">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3259">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3260">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3260">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3261">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3261">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3262">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-3262">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-3263">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-3263">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3264">L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3264">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="3a270-3265">L’offset, la taille et <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3265">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-3266"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3266"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3a270-3267">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-3267">-or-</span></span>  
  
 <span data-ttu-id="3a270-3268"><paramref name="remoteEP" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3268"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3a270-3269"><paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-3269"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-3270">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-3270">-or-</span></span>  
  
 <span data-ttu-id="3a270-3271"><paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3271"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="3a270-3272">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-3272">-or-</span></span>  
  
 <span data-ttu-id="3a270-3273"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="3a270-3273"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="3a270-3274">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-3274">-or-</span></span>  
  
 <span data-ttu-id="3a270-3275"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3275"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="3a270-3276"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.</span><span class="sxs-lookup"><span data-stu-id="3a270-3276"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="3a270-3277">- ou -</span><span class="sxs-lookup"><span data-stu-id="3a270-3277">-or-</span></span>  
  
 <span data-ttu-id="3a270-3278">Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3278">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3279"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3279">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3a270-3280">Un appelant de la pile des appels ne dispose pas des autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3a270-3280">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="3a270-3281">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-3281">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="3a270-3282">Envoie des données de façon asynchrone à un hôte distant spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3282">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="3a270-3283">Retourne la valeur <see langword="true" /> si l'opération d'E/S est en attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-3283">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="3a270-3284">L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3284">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="3a270-3285">Retourne la valeur <see langword="false" /> si l'opération d'E/S a été terminée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="3a270-3285">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="3a270-3286">Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</span><span class="sxs-lookup"><span data-stu-id="3a270-3286">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3287">Le <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant spécifié dans le <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété de le `e` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-3287">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="3a270-3288">Appel de la <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="3a270-3288">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="3a270-3289">Bien que cette méthode est conçue pour les protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendToAsync%2A> fonctionne avec les protocoles orientés connexion.</span><span class="sxs-lookup"><span data-stu-id="3a270-3289">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="3a270-3290">Pour être averti de l’exécution, vous devez créer une méthode de rappel qui implémente le EventHandler\<SocketAsyncEventArgs > et l’attacher le rappel pour le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.</span><span class="sxs-lookup"><span data-stu-id="3a270-3290">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="3a270-3291">Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :</span><span class="sxs-lookup"><span data-stu-id="3a270-3291">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="3a270-3292">L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.SendToAsync%2A> (méthode), afin que les informations soient récupérables dans la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="3a270-3292">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="3a270-3293">Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.</span><span class="sxs-lookup"><span data-stu-id="3a270-3293">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="3a270-3294">Si vous utilisez un protocole orienté connexion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3294">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="3a270-3295">Dans le cas contraire <xref:System.Net.Sockets.Socket.SendToAsync%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3295">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-3296">Lorsque vous utilisez un protocole orienté connexion, la <xref:System.Net.Sockets.Socket.SendToAsync%2A> ignore (méthode) le <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété et envoyer des données à la <xref:System.Net.EndPoint?displayProperty=nameWithType> établie dans le <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3296">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-3297">Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3297">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="3a270-3298">Vous pouvez procéder ainsi si vous voulez appeler le <xref:System.Net.Sockets.Socket.BeginSend%2A> ou <xref:System.Net.Sockets.Socket.SendAsync%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="3a270-3298">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="3a270-3299">Si vous appelez le <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendToAsync%2A>, le <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi.</span><span class="sxs-lookup"><span data-stu-id="3a270-3299">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="3a270-3300">Vous ne devez pas également pour appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3300">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="3a270-3301">Dans ce cas, le fournisseur de service sous-jacent affecte le plus approprié réseau local IP adresse et numéro de port.</span><span class="sxs-lookup"><span data-stu-id="3a270-3301">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="3a270-3302">Utiliser un numéro de port de zéro si vous souhaitez que le fournisseur de service sous-jacent pour sélectionner un port libre.</span><span class="sxs-lookup"><span data-stu-id="3a270-3302">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="3a270-3303">Si vous avez besoin identifier le réseau local attribué IP adresse et numéro de port, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement est signalé et que les délégués associés sont appelés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3303">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="3a270-3304">Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option pour <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> sur true.</span><span class="sxs-lookup"><span data-stu-id="3a270-3304">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="3a270-3305">Vous devez également être sûr que la taille de votre mémoire tampon ne dépasse pas la taille de paquet maximale du fournisseur de service sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-3305">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="3a270-3306">Dans ce cas, le datagramme n’enverra pas et <xref:System.Net.Sockets.Socket.SendToAsync%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3306">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="3a270-3307">Si vous spécifiez l’indicateur DontRoute dans le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriété, les données que vous envoyez ne sera pas routé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3307">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="3a270-3308">Pour les sockets orientés message, être vigilant pour ne pas dépasser la taille maximale du message du transport sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3a270-3308">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="3a270-3309">Si la taille de la mémoire tampon dépasse la taille de paquet maximale du fournisseur de services sous-jacent, le datagramme n’est pas envoyé et <xref:System.Net.Sockets.Socket.SendToAsync%2A> lèvera une <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3309">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="3a270-3310">La réussite d’une <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthode n’indique pas que les données a été remises avec succès.</span><span class="sxs-lookup"><span data-stu-id="3a270-3310">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a270-3311"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être Null.</span><span class="sxs-lookup"><span data-stu-id="3a270-3311">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-3312">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</span><span class="sxs-lookup"><span data-stu-id="3a270-3312">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-3313">Windows XP ou version ultérieure est requis pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3a270-3313">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3314"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3314">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3315">Le protocole spécifié est orienté connexion, mais le <see cref="T:System.Net.Sockets.Socket" /> n'est pas encore connecté.</span><span class="sxs-lookup"><span data-stu-id="3a270-3315">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level"><span data-ttu-id="3a270-3316">Niveau de protection IP à définir sur ce socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3316">The IP protection level to set on this socket.</span></span></param>
        <summary><span data-ttu-id="3a270-3317">Définit le niveau de protection IP sur un socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3317">Set the IP protection level on a socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3318">Le <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> méthode permet de restreindre un socket IPv6 ou IP à l’écoute d’une portée spécifiée, telle que les adresses avec le même lien locales préfixe ou de site local.</span><span class="sxs-lookup"><span data-stu-id="3a270-3318">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="3a270-3319">Cette option de socket permet aux applications de placer des restrictions d’accès sur les sockets IPv6 ou IP.</span><span class="sxs-lookup"><span data-stu-id="3a270-3319">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="3a270-3320">Ces restrictions permettent à une application qui s'exécute sur un réseau local privé de se renforcer facilement et efficacement contre les attaques externes.</span><span class="sxs-lookup"><span data-stu-id="3a270-3320">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="3a270-3321">Cette option de socket peut également être utilisée pour supprimer des restrictions d’accès si le `level` paramètre est défini sur <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3321">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="3a270-3322">Cette option de socket élargit ou limite la portée d'un socket en écoute, permettant l'accès illimité des utilisateurs publics et privés le cas échéant ou restreignant éventuellement l'accès au même site.</span><span class="sxs-lookup"><span data-stu-id="3a270-3322">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="3a270-3323">Cette option de socket utilise les niveaux de protection définis spécifiés dans l'énumération <xref:System.Net.Sockets.IPProtectionLevel>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3323">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="3a270-3324">Le <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> méthode est utilisée pour activer ou désactiver la traversée d’adresses réseau (NAT) pour un <xref:System.Net.Sockets.Socket> instance.</span><span class="sxs-lookup"><span data-stu-id="3a270-3324">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="3a270-3325">Parcours NAT peut être fourni à l’aide d’un tunnel ISATAP, 6to4 ou Teredo.</span><span class="sxs-lookup"><span data-stu-id="3a270-3325">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="3a270-3326">Lorsque le `level` paramètre est défini sur <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, ou <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, cela désactive explicitement la traversée NAT pour une <xref:System.Net.Sockets.Socket> instance.</span><span class="sxs-lookup"><span data-stu-id="3a270-3326">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="3a270-3327">Lorsque le `level` paramètre est défini sur <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, cela peut permettre de parcours NAT pour une <xref:System.Net.Sockets.Socket> selon les règles de pare-feu en place sur le système.</span><span class="sxs-lookup"><span data-stu-id="3a270-3327">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a270-3328">Le paramètre <paramref name="level" /> ne peut pas avoir la valeur <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3328">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span></span> <span data-ttu-id="3a270-3329">Le niveau de protection IP ne peut pas être non spécifié.</span><span class="sxs-lookup"><span data-stu-id="3a270-3329">The IP protection level cannot be set to unspecified.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-3330">Le <see cref="T:System.Net.Sockets.AddressFamily" /> du socket doit être <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3330">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span></span></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a270-3331">Définit une option <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3331">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="3a270-3332">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3332">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="3a270-3333">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3333">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="3a270-3334">Valeur de l'option, représentée en tant que <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3334">The value of the option, represented as a <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="3a270-3335">Affecte la valeur <see cref="T:System.Net.Sockets.Socket" /> spécifiée à l'option <see cref="T:System.Boolean" /> spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3335">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3336"><xref:System.Net.Sockets.Socket> options déterminent le comportement d’actuel <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3336"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-3337">Définissez `optionValue` à `true` pour activer l’option, ou la valeur `false` pour désactiver l’option.</span><span class="sxs-lookup"><span data-stu-id="3a270-3337">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="3a270-3338"><xref:System.Net.Sockets.Socket> options sont regroupées par niveau de prise en charge du protocole.</span><span class="sxs-lookup"><span data-stu-id="3a270-3338"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="3a270-3339">Vous trouverez ci-dessous les différentes <xref:System.Net.Sockets.Socket> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3339">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="3a270-3340">Ces options sont regroupées par approprié <xref:System.Net.Sockets.SocketOptionLevel> valeur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3340">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="3a270-3341">Si vous envisagez de définir l’une de ces options, veillez à utiliser les <xref:System.Net.Sockets.SocketOptionLevel> la valeur pour le `optionLevel` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-3341">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="3a270-3342">L’option que vous choisissez de définir doit être spécifiée dans le `optionName` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-3342">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="3a270-3343">Si vous souhaitez obtenir la valeur actuelle d’une des options répertoriées, utilisez la <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3343">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-3344"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3344"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="3a270-3345"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3345"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="3a270-3346"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3346"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="3a270-3347"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3347"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="3a270-3348">Pour plus d’informations sur ces options, reportez-vous à la <xref:System.Net.Sockets.SocketOptionName> énumération.</span><span class="sxs-lookup"><span data-stu-id="3a270-3348">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3349">Si vous recevez un <xref:System.Net.Sockets.SocketException> exception, utilisez la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3349">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3350">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3350">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3351">L’exemple de code suivant ouvre un socket et Active le `DontLinger` et `OutOfBandInline` options de socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3351">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3352">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3352">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3353">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3353">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="3a270-3354">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3354">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="3a270-3355">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3355">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="3a270-3356">Tableau de type <see cref="T:System.Byte" /> représentant la valeur de l'option.</span><span class="sxs-lookup"><span data-stu-id="3a270-3356">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span></span></param>
        <summary><span data-ttu-id="3a270-3357">Affecte la valeur spécifiée à l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée représentée sous la forme d'un tableau d'octets.</span><span class="sxs-lookup"><span data-stu-id="3a270-3357">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3358"><xref:System.Net.Sockets.Socket> options déterminent le comportement d’actuel <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3358"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-3359">Utilisez cette surcharge pour définir les <xref:System.Net.Sockets.Socket> options qui nécessitent un tableau d’octets comme valeur d’option.</span><span class="sxs-lookup"><span data-stu-id="3a270-3359">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3360">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3360">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3361">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3361">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3362">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-3362">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-3363">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-3363">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3364">Le code suivant exemple définit le <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> les valeurs de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-3364">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3365">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3365">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3366"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3366">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="3a270-3367">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3367">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="3a270-3368">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3368">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="3a270-3369">Valeur de l'option.</span><span class="sxs-lookup"><span data-stu-id="3a270-3369">A value of the option.</span></span></param>
        <summary><span data-ttu-id="3a270-3370">Affecte la valeur entière spécifiée à l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3370">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3371"><xref:System.Net.Sockets.Socket> options déterminent le comportement d’actuel <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3371"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-3372">Pour une option avec un <xref:System.Boolean> de type de données, spécifiez une valeur différente de zéro pour activer l’option et une valeur zéro pour désactiver l’option.</span><span class="sxs-lookup"><span data-stu-id="3a270-3372">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="3a270-3373">Pour une option avec un type de données integer, spécifiez la valeur appropriée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3373">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="3a270-3374"><xref:System.Net.Sockets.Socket> options sont regroupées par niveau de prise en charge du protocole.</span><span class="sxs-lookup"><span data-stu-id="3a270-3374"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="3a270-3375">Vous trouverez ci-dessous les différentes <xref:System.Net.Sockets.Socket> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3375">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="3a270-3376">Ces options sont regroupées par approprié <xref:System.Net.Sockets.SocketOptionLevel>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3376">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="3a270-3377">Si vous envisagez de définir l’une de ces options, veillez à utiliser les <xref:System.Net.Sockets.SocketOptionLevel> pour la `optionLevel` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-3377">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="3a270-3378">L’option que vous choisissez de définir doit être spécifiée dans le `optionName` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-3378">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="3a270-3379">Si vous souhaitez obtenir la valeur actuelle d’une des options répertoriées, utilisez la <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3379">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="3a270-3380"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3380"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="3a270-3381"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3381"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="3a270-3382"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3382"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="3a270-3383"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3383"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="3a270-3384"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="3a270-3384"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="3a270-3385">Pour plus d’informations sur ces options, reportez-vous à la <xref:System.Net.Sockets.SocketOptionName> énumération.</span><span class="sxs-lookup"><span data-stu-id="3a270-3385">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3386">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3386">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3387">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3387">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3388">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-3388">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-3389">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-3389">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3390">Le code suivant exemple définit le <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> les valeurs de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-3390">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3391">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3391">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3392"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3392">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="3a270-3393">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3393">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="3a270-3394">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3394">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="3a270-3395"><see cref="T:System.Net.Sockets.LingerOption" /> ou <see cref="T:System.Net.Sockets.MulticastOption" /> qui contient la valeur de l'option.</span><span class="sxs-lookup"><span data-stu-id="3a270-3395">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span></span></param>
        <summary><span data-ttu-id="3a270-3396">Affecte la valeur spécifiée à l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée représentée sous la forme d'un objet.</span><span class="sxs-lookup"><span data-stu-id="3a270-3396">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3397"><xref:System.Net.Sockets.Socket> options déterminent le comportement d’actuel <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3397"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-3398">Utilisez cette surcharge pour définir le <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, et <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> options.</span><span class="sxs-lookup"><span data-stu-id="3a270-3398">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="3a270-3399">Pour le <xref:System.Net.Sockets.SocketOptionName.Linger> option, utilisez <xref:System.Net.Sockets.Socket> pour la `optionLevel` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-3399">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="3a270-3400">Pour <xref:System.Net.Sockets.SocketOptionName.AddMembership> et <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilisez <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3400">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="3a270-3401">Si vous souhaitez obtenir la valeur actuelle d’une des options ci-dessus, utilisez la <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3a270-3401">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3402">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3402">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3403">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3403">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3404">Le code suivant exemple définit le <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> les valeurs de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-3404">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a270-3405"><paramref name="optionValue" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3405"><paramref name="optionValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3406">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3406">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3407"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3407">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><span data-ttu-id="3a270-3408">Une des valeurs de <see cref="T:System.Net.Sockets.SocketShutdown" /> spécifiant l'opération qui ne sera plus autorisée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3408">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span></span></param>
        <summary><span data-ttu-id="3a270-3409">Désactive les envois et les réceptions sur un <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3409">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3410">Lorsque vous utilisez une connexion orientée <xref:System.Net.Sockets.Socket>, appelez toujours la <xref:System.Net.Sockets.Socket.Shutdown%2A> méthode avant de fermer le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3410">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-3411">Cela garantit que toutes les données est envoyé et reçu sur le socket connecté avant sa fermeture.</span><span class="sxs-lookup"><span data-stu-id="3a270-3411">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="3a270-3412">Appelez le <xref:System.Net.Sockets.Socket.Close%2A> méthode pour libérer toutes les ressources managées et associés à la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3412">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="3a270-3413">N’essayez pas de réutiliser le <xref:System.Net.Sockets.Socket> après la fermeture.</span><span class="sxs-lookup"><span data-stu-id="3a270-3413">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="3a270-3414">Le tableau suivant présente la <xref:System.Net.Sockets.SocketShutdown> des valeurs d’énumération qui sont valides pour le `how` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3a270-3414">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="3a270-3415">Value</span><span class="sxs-lookup"><span data-stu-id="3a270-3415">Value</span></span>|<span data-ttu-id="3a270-3416">Description </span><span class="sxs-lookup"><span data-stu-id="3a270-3416">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="3a270-3417">Envoyer</span><span class="sxs-lookup"><span data-stu-id="3a270-3417">Send</span></span>|<span data-ttu-id="3a270-3418">Désactiver l’envoi sur ce <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3418">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="3a270-3419">Receive</span><span class="sxs-lookup"><span data-stu-id="3a270-3419">Receive</span></span>|<span data-ttu-id="3a270-3420">Désactive la réception sur ce <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3420">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="3a270-3421">Both</span><span class="sxs-lookup"><span data-stu-id="3a270-3421">Both</span></span>|<span data-ttu-id="3a270-3422">Désactiver l’envoi et la réception sur ce <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3422">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="3a270-3423">Paramètre `how` à <xref:System.Net.Sockets.SocketShutdown.Send> spécifie suivantes qui appelle à <xref:System.Net.Sockets.Socket.Send%2A> ne sont pas autorisés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3423">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="3a270-3424">Si vous utilisez une connexion <xref:System.Net.Sockets.Socket>, en spécifiant <xref:System.Net.Sockets.SocketShutdown.Send> n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="3a270-3424">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="3a270-3425">Paramètre `how` à <xref:System.Net.Sockets.SocketShutdown.Receive> spécifie suivantes qui appelle à <xref:System.Net.Sockets.Socket.Receive%2A> ne sont pas autorisés.</span><span class="sxs-lookup"><span data-stu-id="3a270-3425">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="3a270-3426">Cela n’a aucun effet sur les couches de protocole inférieures.</span><span class="sxs-lookup"><span data-stu-id="3a270-3426">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="3a270-3427">Si vous utilisez un protocole orienté connexion, la connexion est interrompue si une des conditions suivantes existe après un appel à <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span><span class="sxs-lookup"><span data-stu-id="3a270-3427">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="3a270-3428">Les données sont dans la mémoire tampon réseau entrante en attente de réception.</span><span class="sxs-lookup"><span data-stu-id="3a270-3428">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="3a270-3429">Plus de données est arrivé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3429">More data has arrived.</span></span>  
  
 <span data-ttu-id="3a270-3430">Si vous utilisez un protocole sans connexion, les datagrammes sont acceptés et en file d’attente.</span><span class="sxs-lookup"><span data-stu-id="3a270-3430">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="3a270-3431">Toutefois, si aucun espace tampon n’est disponible pour les datagrammes entrants supplémentaires, elles seront ignorées et aucune erreur ne s’affichera à l’expéditeur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3431">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="3a270-3432">À l’aide de <xref:System.Net.Sockets.Socket.Shutdown%2A> sur une connexion <xref:System.Net.Sockets.Socket> n’est pas recommandée.</span><span class="sxs-lookup"><span data-stu-id="3a270-3432">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="3a270-3433">Paramètre `how` à <xref:System.Net.Sockets.SocketShutdown.Both> désactive les envois et réceptions tel que décrit ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="3a270-3433">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3434">Si vous recevez un <xref:System.Net.Sockets.SocketException> lors de l’appel du <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode), utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3434">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3435">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3435">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a270-3436">Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3a270-3436">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="3a270-3437">Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="3a270-3437">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3438">Le code suivant utilise des exemple <xref:System.Net.Sockets.Socket.Shutdown%2A> pour désactiver la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3438">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3439">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3439">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3440"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3440">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-3441">Obtient le type de <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3441">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="3a270-3442">Une des valeurs de <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3442">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3443"><xref:System.Net.Sockets.Socket.SocketType%2A> est en lecture seule et est définie lorsque le <xref:System.Net.Sockets.Socket> est créé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3443"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3444">Le code suivant exemple affiche la <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, et <xref:System.Net.Sockets.ProtocolType> à la console.</span><span class="sxs-lookup"><span data-stu-id="3a270-3444">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-3445">Obtient une valeur indiquant si la prise en charge d'IPv4 est disponible et active sur l'hôte en cours.</span><span class="sxs-lookup"><span data-stu-id="3a270-3445">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-3446"><see langword="true" /> si l'hôte en cours prend en charge le protocole IPv4 ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3446"><see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3447">Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.</span><span class="sxs-lookup"><span data-stu-id="3a270-3447">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-3448">Obtient une valeur qui indique si le Framework prend en charge le protocole IPv6 pour certains membres <see cref="T:System.Net.Dns" /> obsolètes.</span><span class="sxs-lookup"><span data-stu-id="3a270-3448">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-3449"><see langword="true" /> si le Framework prend en charge le protocole IPv6 pour certaines méthodes <see cref="T:System.Net.Dns" /> obsolètes ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3449"><see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3450">Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.</span><span class="sxs-lookup"><span data-stu-id="3a270-3450">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-3451">Obtient ou définit une valeur qui spécifie la durée de vie des paquets IP (Internet Protocol) envoyés par <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3451">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="3a270-3452">Durée de vie.</span><span class="sxs-lookup"><span data-stu-id="3a270-3452">The TTL value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3453">La valeur de durée de vie indique le nombre maximal de routeurs que le paquet peut parcourir avant que le routeur n’ignore le paquet et un Message de protocole ICMP (Internet Control) « Durée de vie dépassée » message d’erreur est renvoyé à l’expéditeur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3453">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="3a270-3454">La valeur de durée de vie peut être définie à une valeur comprise entre 0 et 255.</span><span class="sxs-lookup"><span data-stu-id="3a270-3454">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="3a270-3455">Lorsque cette propriété n’est pas définie, la valeur de durée de vie par défaut pour un socket est 32.</span><span class="sxs-lookup"><span data-stu-id="3a270-3455">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="3a270-3456">Définition de cette propriété sur un socket de protocole TCP (Transmission Control) est ignorée par la pile TCP/IP si une connexion réussie a été établie à l’aide du socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3456">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="3a270-3457">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique.</span><span class="sxs-lookup"><span data-stu-id="3a270-3457">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="3a270-3458">Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="3a270-3458">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a270-3459">L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.Ttl%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3a270-3459">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3a270-3460">La valeur TTL ne peut pas être un nombre négatif.</span><span class="sxs-lookup"><span data-stu-id="3a270-3460">The TTL value can't be set to a negative number.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a270-3461">Cette propriété ne peut être définie que pour les sockets dans les familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3461">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="3a270-3462">Une erreur s’est produite pendant la tentative d’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="3a270-3462">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="3a270-3463">Cette erreur est également retournée lorsqu'une tentative a été faite pour affecter à TTL une valeur supérieure à 255.</span><span class="sxs-lookup"><span data-stu-id="3a270-3463">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3a270-3464"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="3a270-3464">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a270-3465">Spécifie si le socket doit utiliser uniquement le mode d'E/S avec chevauchement.</span><span class="sxs-lookup"><span data-stu-id="3a270-3465">Specifies whether the socket should only use Overlapped I/O mode.</span></span></summary>
        <value>
          <span data-ttu-id="3a270-3466"><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> utilise uniquement le mode d'E/S avec chevauchement ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3466"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3a270-3467">La valeur par défaut est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3a270-3467">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a270-3468">Définissez cette propriété sur `true` pour un <xref:System.Net.Sockets.Socket> vous voulez appeler <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3468">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="3a270-3469">Sinon, le Framework peut assigner un port de terminaison au socket, interdisant ainsi l’utilisation de <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a270-3469">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a270-3470">Le socket est lié à un port de terminaison.</span><span class="sxs-lookup"><span data-stu-id="3a270-3470">The socket has been bound to a completion port.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>