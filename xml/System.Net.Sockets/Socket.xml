<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="347e126095ce070da54b007a6da17f519d123b6f" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56374130" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implémente l'interface de sockets Berkeley.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket> classe fournit un ensemble complet de méthodes et propriétés pour les communications réseau. Le <xref:System.Net.Sockets.Socket> classe vous permet d’effectuer à la fois synchrone et transfert de données asynchrones à l’aide d’un des protocoles de communication répertoriées dans le <xref:System.Net.Sockets.ProtocolType> énumération.  
  
 Le <xref:System.Net.Sockets.Socket> classe suit le modèle d’affectation de noms .NET Framework pour les méthodes asynchrones. Par exemple, synchrones <xref:System.Net.Sockets.Socket.Receive%2A> méthode correspond à asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> et <xref:System.Net.Sockets.Socket.EndReceive%2A> méthodes.  
  
 Si votre application requiert uniquement un seul thread pendant l’exécution, utilisez les méthodes suivantes, qui sont conçues pour le mode de fonctionnement synchrone.  
  
-   Si vous utilisez un protocole orienté connexion, tels que TCP, votre serveur peut écouter les connexions à l’aide de la <xref:System.Net.Sockets.Socket.Listen%2A> (méthode). Le <xref:System.Net.Sockets.Socket.Accept%2A> méthode traite toute connexion entrante demande et retourne un <xref:System.Net.Sockets.Socket> que vous pouvez utiliser pour communiquer des données avec l’hôte distant. Utilisez cette retourné <xref:System.Net.Sockets.Socket> pour appeler le <xref:System.Net.Sockets.Socket.Send%2A> ou <xref:System.Net.Sockets.Socket.Receive%2A> (méthode). Appelez le <xref:System.Net.Sockets.Socket.Bind%2A> méthode avant d’appeler le <xref:System.Net.Sockets.Socket.Listen%2A> méthode si vous souhaitez spécifier le numéro d’adresse et le port IP local. Utiliser un numéro de port zéro si vous souhaitez que le fournisseur de services sous-jacent pour affecter un port disponible pour vous. Si vous souhaitez vous connecter à un hôte à l’écoute, appelez le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode). Pour communiquer des données, appelez le <xref:System.Net.Sockets.Socket.Send%2A> ou <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).  
  
-   Si vous utilisez un protocole sans connexion tel que UDP, il est inutile écouter les connexions du tout. Appelez le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode pour accepter tous les datagrammes entrants. Utilisez le <xref:System.Net.Sockets.Socket.SendTo%2A> méthode pour envoyer des datagrammes à un hôte distant.  
  
 Pour traiter les communications à l’aide de threads séparés pendant l’exécution, utilisez les méthodes suivantes, qui sont conçues pour le mode d’opération asynchrone.  
  
-   Si vous utilisez un protocole orienté connexion, tels que TCP, utilisez le <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, et <xref:System.Net.Sockets.Socket.EndConnect%2A> méthodes pour se connecter avec un hôte à l’écoute. Utilisez le <xref:System.Net.Sockets.Socket.BeginSend%2A> et <xref:System.Net.Sockets.Socket.EndSend%2A> ou <xref:System.Net.Sockets.Socket.BeginReceive%2A> et <xref:System.Net.Sockets.Socket.EndReceive%2A> méthodes pour communiquer des données de façon asynchrone. Demandes de connexion entrantes peuvent être traitées à l’aide de <xref:System.Net.Sockets.Socket.BeginAccept%2A> et <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Si vous utilisez un protocole sans connexion tel que UDP, vous pouvez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> et <xref:System.Net.Sockets.Socket.EndSendTo%2A> pour envoyer des datagrammes, et <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> et <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> pour recevoir des datagrammes.  
  
 Si vous effectuez plusieurs opérations asynchrones sur un socket, elles n’est pas nécessairement effectuez dans l’ordre dans lequel ils sont démarrés.  
  
 Lorsque vous avez terminé d’envoyer et de recevoir des données, utilisez le <xref:System.Net.Sockets.Socket.Shutdown%2A> méthode permettant de désactiver le <xref:System.Net.Sockets.Socket>. Après avoir appelé <xref:System.Net.Sockets.Socket.Shutdown%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> méthode pour libérer toutes les ressources associées à la <xref:System.Net.Sockets.Socket>.  
  
 Le <xref:System.Net.Sockets.Socket> classe vous permet de configurer votre <xref:System.Net.Sockets.Socket> à l’aide de la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode). Récupérez ces paramètres à l’aide de la <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (méthode).  
  
> [!NOTE]
>  Si vous écrivez une application relativement simple et ne nécessitent pas d’optimiser les performances, envisagez d’utiliser <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, et <xref:System.Net.Sockets.UdpClient>. Ces classes fournissent une interface plus simple et plus conviviale pour <xref:System.Net.Sockets.Socket> communications.  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment la <xref:System.Net.Sockets.Socket> classe peut être utilisée pour envoyer des données à un serveur HTTP et recevoir la réponse. Cet exemple bloque jusqu'à ce que la page entière est reçue.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Pour établir une connexion sortante ou accepter une demande entrante.</permission>
    <threadsafe>Instances de cette classe sont thread-safe.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">Programmation réseau dans le .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">Pratiques recommandées pour les classes System.Net</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">Gestion du cache pour les applications réseau</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">Protocole Internet version 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">Exemples de programmation réseau</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">Traçage réseau dans le .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">Sécurité dans la programmation réseau</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">Améliorations des performances de socket dans la version 3.5</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Informations de socket retournées par <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.Socket" /> avec la valeur spécifiée retournée par <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous appelez le <xref:System.Net.Sockets.Socket.%23ctor%2A> constructeur plusieurs fois avec le même tableau d’octets comme argument pour chaque appel, vous allez créer plusieurs gérés <xref:System.Net.Sockets.Socket>s avec le même socket sous-jacent. Cette pratique est vivement déconseillée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">Une des valeurs de <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Une des valeurs de <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.Socket" /> à l'aide du type de socket et du protocole spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `socketType` paramètre spécifie le type de la <xref:System.Net.Sockets.Socket> classe et le `protocolType` paramètre spécifie le protocole utilisé par <xref:System.Net.Sockets.Socket>. Les deux paramètres ne sont pas indépendants. Fréquence à laquelle le <xref:System.Net.Sockets.Socket> type est implicite dans le protocole. Si la combinaison de <xref:System.Net.Sockets.Socket> type et type de protocole résultats dans un non valide <xref:System.Net.Sockets.Socket>, ce constructeur lève un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si ce constructeur lève un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">La combinaison de <paramref name="socketType" /> et <paramref name="protocolType" /> aboutit à un socket non valide.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Une des valeurs de <see cref="T:System.Net.Sockets.AddressFamily" />.</param>
        <param name="socketType">Une des valeurs de <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Une des valeurs de <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.Socket" /> en utilisant la famille d'adresses, le type de socket et le protocole spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `addressFamily` paramètre spécifie le schéma d’adressage qui le <xref:System.Net.Sockets.Socket> classe utilise, le `socketType` paramètre spécifie le type de la <xref:System.Net.Sockets.Socket> (classe) et le `protocolType` paramètre spécifie le protocole utilisé par <xref:System.Net.Sockets.Socket>. Les trois paramètres ne sont pas indépendants. Certaines familles d’adresses restreindre les protocoles peuvent être utilisés avec eux et souvent la <xref:System.Net.Sockets.Socket> type est implicite dans le protocole. Si la combinaison de la famille d’adresses, <xref:System.Net.Sockets.Socket> type et tapez les résultats dans un non valide de protocole <xref:System.Net.Sockets.Socket>, ce constructeur lève un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si ce constructeur lève un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une instance de la <xref:System.Net.Sockets.Socket> classe.  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">La combinaison de <paramref name="addressFamily" />, <paramref name="socketType" /> et <paramref name="protocolType" /> crée un socket non valide.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un nouveau <see cref="T:System.Net.Sockets.Socket" /> pour une connexion nouvellement créée.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> pour une connexion nouvellement créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> mode synchrone extrait la première demande de connexion en attente à partir de la file d’attente de demande de connexion du socket d’écoute, puis crée et retourne un nouveau <xref:System.Net.Sockets.Socket>. Vous ne pouvez pas utiliser ce retourné <xref:System.Net.Sockets.Socket> pour accepter des connexions supplémentaires à partir de la file d’attente de connexion. Toutefois, vous pouvez appeler la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> méthode retourné <xref:System.Net.Sockets.Socket> pour identifier l’hôte distant réseau adresse et numéro de port.  
  
 En mode blocage, <xref:System.Net.Sockets.Socket.Accept%2A> bloque jusqu'à ce qu’une tentative de connexion entrante est en file d’attente. Une fois qu’une connexion est acceptée, l’original <xref:System.Net.Sockets.Socket> continue la file d’attente demandes de connexion entrantes jusqu'à ce que vous fermez il.  
  
 Si vous appelez cette méthode à l’aide d’une non bloquant <xref:System.Net.Sockets.Socket>et aucune connexion demandes sont en attente, <xref:System.Net.Sockets.Socket.Accept%2A> lève un <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Avant d’appeler le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode), vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et file d’attente de demandes de connexion entrantes.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant accepte une simple <xref:System.Net.Sockets.Socket> connexion.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">Le socket acceptant n'écoute pas les connexions. Vous devez appeler <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocoles orientés connexion peuvent utiliser le <xref:System.Net.Sockets.Socket.AcceptAsync%2A> tente de méthode pour traiter de manière asynchrone une connexion entrante. Acceptation des connexions de manière asynchrone vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct. Avant d’appeler le <xref:System.Net.Sockets.Socket.AcceptAsync%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et file d’attente de demandes de connexion entrantes.  
  
 Pour être averti de la saisie semi-automatique, vous devez créer une méthode de rappel qui implémente le délégué EventHandler\<SocketAsyncEventArgs > déléguer et la raccorder à le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.  
  
 Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requises :  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 L’appelant peut éventuellement spécifier un existant <xref:System.Net.Sockets.Socket> à utiliser pour la connexion entrante en spécifiant le <xref:System.Net.Sockets.Socket> à utiliser avec le <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriété.  
  
 Si le <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriété est null, un nouveau <xref:System.Net.Sockets.Socket> est construit avec les mêmes <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, et <xref:System.Net.Sockets.Socket.ProtocolType%2A> en cours <xref:System.Net.Sockets.Socket> et définir en tant que le <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriété.  
  
 L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.AcceptAsync%2A> (méthode), afin que les informations seront récupérables dans la méthode de rappel. Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.  
  
 Si vous le souhaitez, une mémoire tampon peut être fournie qui recevra le bloc initial de données sur le socket après le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode réussit. Dans ce cas, le <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriété doit être définie dans la mémoire tampon contenant les données à recevoir et le <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriété doit être définie pour le nombre maximal d’octets de données à recevoir dans la mémoire tampon. Ces propriétés peuvent être définies à l’aide de la <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> (méthode). Partie de la mémoire tampon transmis est utilisé en interne pour une utilisation par l’appel de Winsock AcceptEx sous-jacent. Cela signifie que la quantité de données retournées sera toujours inférieure à la valeur de la <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriété sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance fournie. La quantité de la mémoire tampon utilisée en interne varie en fonction de la famille d’adresses du socket. La taille de tampon minimale requise est 288 octets. Si une plus grande taille de mémoire tampon est spécifiée, puis le <xref:System.Net.Sockets.Socket> s’attendent des données supplémentaires autres que les données d’adresse reçues par l’appel de Winsock AcceptEx et attend que ces données supplémentaires sont reçues. Si un délai d’expiration se produit, la connexion est réinitialisée. Par conséquent, si des données supplémentaires sont attendues d’un montant spécifique, la taille du tampon doit être définie à la taille minimale de mémoire tampon plus cette quantité.  
  
 La méthode de rappel d’exécution doit examiner le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propriété afin de déterminer si le <xref:System.Net.Sockets.Socket.AcceptAsync%2A> opération a réussi.  
  
 Le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événements peuvent se produire dans certains cas, lorsque aucune connexion n’a pas été acceptée et provoquer le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propriété être définie sur <xref:System.Net.Sockets.SocketError.ConnectionReset>. Cela peut se produire à la suite de balayage des ports à l’aide d’une analyse de type demi-ouvertes SYN (un SYN -> SYN-ACK-> séquence RST). Applications à l’aide de la <xref:System.Net.Sockets.Socket.AcceptAsync%2A> méthode doit être prête à gérer cette condition.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argument n’est pas valide. Cette exception se produit si la mémoire tampon fournie n'est pas assez grande. La mémoire tampon doit être d'au moins 2 * (taille de (SOCKADDR_STORAGE + 16) octets.  
  
Cette exception se produit également si plusieurs mémoires tampons sont spécifiées, la propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> n'est pas null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un argument est hors limites. L'exception se produit si <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> est inférieur à 0.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération incorrecte a été demandée. Cette exception se produit si le <see cref="T:System.Net.Sockets.Socket" /> acceptant n'écoute pas les connexions ou si le socket accepté est lié.  
  
Vous devez appeler les méthodes <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler la méthode <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.  
  
Cette exception se produit également si le socket est déjà connecté ou si une opération de socket utilisait déjà le paramètre de <paramref name="e" /> spécifié.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la famille d'adresses de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Une des valeurs de <see cref="T:System.Net.Sockets.AddressFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.AddressFamily> Spécifie le schéma d’adressage une instance de la <xref:System.Net.Sockets.Socket> classe peut utiliser. Cette propriété est en lecture seule et est définie lorsque le <xref:System.Net.Sockets.Socket> est créé.  
  
   
  
## Examples  
 Le code suivant exemple affiche le <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, et <xref:System.Net.Sockets.ProtocolType> à la console.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de données reçues du réseau et disponibles pour la lecture.</summary>
        <value>Nombre d'octets de données reçues du réseau et disponibles pour la lecture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un non bloquant <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> est un bon moyen pour déterminer si les données sont en file d’attente pour la lecture, avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>. Les données disponibles sont que la quantité totale de données en file d’attente dans la mémoire tampon réseau pour la lecture. Si aucune donnée n’est en file d’attente dans la mémoire tampon réseau, <xref:System.Net.Sockets.Socket.Available%2A> retourne 0.  
  
 Si l’hôte distant arrête ou ferme la connexion, <xref:System.Net.Sockets.Socket.Available%2A> peut lever une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant compare les résultats de l’appel de IOControl avec FIONREAD et la propriété disponible.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la création asynchrone de <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocoles orientés connexion peuvent utiliser le <xref:System.Net.Sockets.Socket.BeginAccept%2A> tente de méthode pour traiter de manière asynchrone une connexion entrante. Acceptation des connexions de manière asynchrone vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct. Avant d’appeler le <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et file d’attente de demandes de connexion entrantes.  
  
 Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode). Pour ce faire, au minimum, vous devez passer à l’écoute <xref:System.Net.Sockets.Socket> objet <xref:System.Net.Sockets.Socket.BeginAccept%2A> via la `state` paramètre. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginAccept%2A>, le système généralement utilise un thread distinct pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndAccept%2A> jusqu'à ce qu’une connexion en attente est extraite. <xref:System.Net.Sockets.Socket.EndAccept%2A> Retourne un nouveau <xref:System.Net.Sockets.Socket> de l’objet que vous pouvez utiliser pour envoyer et recevoir des données avec l’hôte distant. Vous ne pouvez pas utiliser ce retourné <xref:System.Net.Sockets.Socket> pour accepter des connexions supplémentaires à partir de la file d’attente de connexion. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), utilisez <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.  
  
 Le système peut également utiliser le thread appelant pour appeler la méthode de rappel. Dans ce cas, le <xref:System.IAsyncResult.CompletedSynchronously%2A> propriété sur retourné <xref:System.IAsyncResult> définira pour indiquer que le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode terminé de façon synchrone.  
  
 Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>. Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode est appelée.  Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode lèvera une <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.  
  
> [!NOTE]
>  Vous pouvez utiliser la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété de retourné <xref:System.Net.Sockets.Socket> pour identifier l’hôte distant réseau adresse et numéro de port.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant tente de recevoir une connexion entrante de façon asynchrone.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT est requis pour cette méthode.</exception>
        <exception cref="T:System.InvalidOperationException">Le socket acceptant n'écoute pas les connexions. Vous devez appeler <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
ou 
Le socket accepté est lié.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> est inférieur à 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Nombre d'octets à accepter de l'expéditeur.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Lance une opération asynchrone d'acceptation d'une tentative de connexion entrante et reçoit le premier bloc de données envoyé par l'application cliente.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la création asynchrone de <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocoles orientés connexion peuvent utiliser le <xref:System.Net.Sockets.Socket.BeginAccept%2A> tente de méthode pour traiter de manière asynchrone une connexion entrante. Acceptation des connexions de manière asynchrone vous permet d’envoyer et recevoir des données dans un thread d’exécution distinct. Cette surcharge vous permet de spécifier le nombre d’octets à accepter dans le transfert initial dans le `receiveSize` paramètre.  
  
 Avant d’appeler le <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et file d’attente de demandes de connexion entrantes.  
  
 Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode). Pour ce faire, au minimum, vous devez passer à l’écoute <xref:System.Net.Sockets.Socket> objet <xref:System.Net.Sockets.Socket.BeginAccept%2A> via la `state` paramètre. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginAccept%2A>, le système généralement utilise un thread distinct pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndAccept%2A> jusqu'à ce qu’une connexion en attente est extraite.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Retourne un nouvel <xref:System.Net.Sockets.Socket> que vous pouvez utiliser pour envoyer et recevoir des données avec l’hôte distant. Vous ne pouvez pas utiliser ce retourné <xref:System.Net.Sockets.Socket> pour accepter des connexions supplémentaires à partir de la file d’attente de connexion. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), utilisez <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.  
  
 Le système peut également utiliser le thread appelant pour appeler la méthode de rappel. Dans ce cas, le <xref:System.IAsyncResult.CompletedSynchronously%2A> propriété sur retourné <xref:System.IAsyncResult> définira pour indiquer que le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode terminé de façon synchrone.  
  
 Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>.  Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode est appelée.  Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode lèvera une <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.  
  
> [!NOTE]
>  Vous pouvez appeler à utiliser le <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété de retourné <xref:System.Net.Sockets.Socket> objet pour identifier l’hôte distant réseau adresse et numéro de port.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant ouvre un socket et accepte une connexion asynchrone. Dans cet exemple, le socket accepte les 10 premiers octets de données. Le nombre d’octets reçus et les données sont affichées sur la console par le délégué de rappel. Consultez <xref:System.Net.Sockets.Socket.BeginReceive%2A> pour obtenir une description de la façon dont les données restantes sont reçues.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT est requis pour cette méthode.</exception>
        <exception cref="T:System.InvalidOperationException">Le socket acceptant n'écoute pas les connexions. Vous devez appeler <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
ou 
Le socket accepté est lié.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> est inférieur à 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Objet <see cref="T:System.Net.Sockets.Socket" /> accepté. Cette valeur peut être <see langword="null" />.</param>
        <param name="receiveSize">Nombre maximal d'octets à recevoir.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Lance une opération asynchrone d'acceptation d'une tentative de connexion entrante provenant d'un socket spécifié et reçoit le premier bloc de données envoyé par l'application cliente.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui fait référence à la création d'un objet <see cref="T:System.Net.Sockets.Socket" /> asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocoles orientés connexion peuvent utiliser le <xref:System.Net.Sockets.Socket.BeginAccept%2A> tente de méthode pour traiter de manière asynchrone une connexion entrante. Acceptation des connexions de manière asynchrone vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct. Cette surcharge vous permet de spécifier le socket accepté dans le `acceptSocket` paramètre. Si ce paramètre est `null`, le socket accepté est créé par le <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode). Vous pouvez spécifier le nombre d’octets à accepter dans le transfert initial dans le `receiveSize` paramètre.  
  
 Avant d’appeler le <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), vous devez appeler la <xref:System.Net.Sockets.Socket.Listen%2A> méthode pour écouter et file d’attente de demandes de connexion entrantes.  
  
 Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode). Pour ce faire, au minimum, vous devez passer à l’écoute <xref:System.Net.Sockets.Socket> objet <xref:System.Net.Sockets.Socket.BeginAccept%2A> via la `state` paramètre. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginAccept%2A>, le système généralement utilise un thread distinct pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndAccept%2A> jusqu'à ce qu’une connexion en attente est extraite.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Retourne un nouvel <xref:System.Net.Sockets.Socket> de l’objet que vous pouvez utiliser pour envoyer et recevoir des données avec l’hôte distant. Vous ne pouvez pas utiliser ce retourné <xref:System.Net.Sockets.Socket> pour accepter des connexions supplémentaires à partir de la file d’attente de connexion. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), utilisez <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.  
  
 Le système peut également utiliser le thread appelant pour appeler la méthode de rappel. Dans ce cas, le <xref:System.IAsyncResult.CompletedSynchronously%2A> propriété sur retourné <xref:System.IAsyncResult> définira pour indiquer que le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode terminé de façon synchrone.  
  
 Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>. Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode est appelée.  Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode lèvera une <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.  
  
> [!NOTE]
>  Vous pouvez utiliser la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété de retourné <xref:System.Net.Sockets.Socket> objet pour identifier l’hôte distant réseau adresse et numéro de port.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant ouvre un socket et accepte une connexion asynchrone. Dans cet exemple, le socket accepte les 10 premiers octets de données et la `acceptSocket` paramètre est `null`, qui force le <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode pour créer le socket accepté. Le nombre d’octets reçus et les données sont affichées sur la console par le délégué de rappel. Consultez <xref:System.Net.Sockets.Socket.BeginReceive%2A> pour obtenir une description de la façon dont les données restantes sont reçues.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT est requis pour cette méthode.</exception>
        <exception cref="T:System.InvalidOperationException">Le socket acceptant n'écoute pas les connexions. Vous devez appeler <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> et <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> avant d'appeler <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
ou 
Le socket accepté est lié.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> est inférieur à 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre une demande asynchrone pour une connexion d'hôte distant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> qui représente l’hôte distant.</param>
        <param name="end_point"><see cref="T:System.Net.EndPoint" /> qui représente l’hôte distant.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Démarre une demande asynchrone pour une connexion d'hôte distant.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la connexion asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un protocole orienté connexion, le <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode démarre une demande asynchrone pour une connexion à la `remoteEP` paramètre. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.BeginConnect%2A> établit un hôte distant par défaut. Connexion ou la définition de façon asynchrone l’hôte distant par défaut vous donne la possibilité d’envoyer et recevoir des données dans un thread d’exécution distinct.  
  
 Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode). Au minimum, vous devez passer le <xref:System.Net.Sockets.Socket> à <xref:System.Net.Sockets.Socket.BeginConnect%2A> via la `state` paramètre. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket>et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginConnect%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndConnect%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> se connecte avec succès ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode), utilisez <xref:System.Threading.WaitHandle.WaitOne%2A>. Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.BeginConnect%2A> avant d’envoyer et recevoir des données. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> et <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> pour communiquer avec un hôte distant. Si vous n’appelez pas <xref:System.Net.Sockets.Socket.BeginConnect%2A>, tous les datagrammes provenant d’une adresse autre que la valeur par défaut spécifiée seront ignorées. Si vous souhaitez définir votre hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler <xref:System.Net.Sockets.Socket.SetSocketOption%2A> et la valeur de la diffusion `true`. Si vous ne pouvez pas, <xref:System.Net.Sockets.Socket.BeginConnect%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Si vous utilisez un protocole orienté connexion et que vous n’appelez pas <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.BeginConnect%2A>, le fournisseur de services sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié. Si vous utilisez un protocole sans connexion, le fournisseur de services assignera pas un réseau local adresse et numéro de port jusqu'à ce que vous appeliez la <xref:System.Net.Sockets.Socket.BeginSend%2A> ou <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). Si vous souhaitez changer l’hôte distant par défaut, appelez le <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode à nouveau avec le point de terminaison souhaité.  
  
 Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>. Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode est appelée.  Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode lèvera une <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Si ce socket a été déconnecté précédemment, puis <xref:System.Net.Sockets.Socket.BeginConnect%2A> doit être appelée sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée. Il s’agit d’une limitation du fournisseur sous-jacent.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant lance une tentative de connexion asynchrone.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou une opération asynchrone est déjà en cours d’exécution.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Élément <see cref="T:System.Net.IPAddress" /> de l'hôte distant.</param>
        <param name="port">Numéro de port de l'hôte distant.</param>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’opération de connexion est terminée.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’opération de connexion est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion. Cet objet est passé au délégué <paramref name="requestCallback" /> quand l'opération est terminée.</param>
        <summary>Démarre une demande asynchrone pour une connexion d'hôte distant. L’hôte est spécifié par <see cref="T:System.Net.IPAddress" /> et un numéro de port.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la connexion asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode). En règle générale, la méthode est appelée par le `requestCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Connect%2A> surcharges de méthode, ou <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>. Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode est appelée.  Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode lèvera une <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Si ce socket a été déconnecté précédemment, puis <xref:System.Net.Sockets.Socket.BeginConnect%2A> doit être appelée sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée. Il s’agit d’une limitation du fournisseur sous-jacent. Également le <xref:System.Net.EndPoint> qui est utilisé doit être différent.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant lance une tentative de connexion asynchrone.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.Socket" /> n’est pas dans la famille des sockets.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n’est pas valide.</exception>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="address" /> est égale à zéro.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou une opération asynchrone est déjà en cours d’exécution.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="addresses">Au moins un <see cref="T:System.Net.IPAddress" />, désignant l’hôte distant.</param>
        <param name="port">Numéro de port de l'hôte distant.</param>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’opération de connexion est terminée.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’opération de connexion est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion. Cet objet est passé au délégué <paramref name="requestCallback" /> quand l'opération est terminée.</param>
        <summary>Démarre une demande asynchrone pour une connexion d'hôte distant. L’hôte est spécifié par un tableau <see cref="T:System.Net.IPAddress" /> et un numéro de port.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence aux connexions asynchrones.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode). En règle générale, la méthode est appelée par le `requestCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Connect%2A> surcharges de méthode.  
  
 Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>. Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode est appelée.  Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode lèvera une <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Si ce socket a été déconnecté précédemment, puis <xref:System.Net.Sockets.Socket.BeginConnect%2A> doit être appelée sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée. Il s’agit d’une limitation du fournisseur sous-jacent. Également le <xref:System.Net.EndPoint> qui est utilisé doit être différent.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant lance une tentative de connexion asynchrone.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Cette méthode est valide pour les sockets qui utilisent <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n’est pas valide.</exception>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="address" /> est égale à zéro.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou une opération asynchrone est déjà en cours d’exécution.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="host">Nom de l'hôte distant.</param>
        <param name="port">Numéro de port de l'hôte distant.</param>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’opération de connexion est terminée.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’opération de connexion est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion. Cet objet est passé au délégué <paramref name="requestCallback" /> quand l'opération est terminée.</param>
        <summary>Démarre une demande asynchrone pour une connexion d'hôte distant. L’hôte est spécifié par un nom d’hôte et un numéro de port.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la connexion asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode). En règle générale, la méthode est appelée par le `requestCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Connect%2A> surcharges de méthode.  
  
 Pour annuler un appel en attente à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode), fermez le <xref:System.Net.Sockets.Socket>. Lorsque le <xref:System.Net.Sockets.Socket.Close%2A> méthode est appelée lorsqu’une opération asynchrone est en cours, le rappel fourni à la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode est appelée.  Un appel ultérieur à la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode lèvera une <xref:System.ObjectDisposedException> pour indiquer que l’opération a été annulée.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Si ce socket a été déconnecté précédemment, puis <xref:System.Net.Sockets.Socket.BeginConnect%2A> doit être appelée sur un thread qui ne quitte pas jusqu'à ce que l’opération est terminée. Il s’agit d’une limitation du fournisseur sous-jacent. Également le <xref:System.Net.EndPoint> qui est utilisé doit être différent.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant lance une tentative de connexion asynchrone.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Cette méthode est valide pour les sockets appartenant aux familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n’est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou une opération asynchrone est déjà en cours d’exécution.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" /> si ce socket peut être réutilisé après la fermeture de la connexion ; sinon, <see langword="false" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Lance une demande asynchrone de déconnexion d'un point de terminaison distant.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui fait référence à l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un protocole orienté connexion, vous pouvez appeler la <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> méthode pour demander la déconnexion d’un point de terminaison distant. Si `reuseSocket` est `true`, vous pouvez réutiliser le socket.  
  
 Le <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> méthode utilise un thread séparé pour appeler la méthode de rappel spécifiée. Le <xref:System.Net.Sockets.Socket.EndDisconnect%2A> méthode s’interrompt jusqu'à ce que la déconnexion en attente est terminée. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException> exception, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un socket pour la communication asynchrone et envoie des données à un hôte distant. Lorsque les données ont été envoyées, <xref:System.Net.Sockets.Socket.Shutdown%2A> est appelée pour arrêter l’envoi et l’activité de réception. Puis <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> est appelé pour lancer une demande de déconnexion. Lorsque la demande est terminée, le <xref:System.Net.Sockets.Socket.Connected%2A> propriété est interrogée pour tester si le socket est déconnecté.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception. Cet objet est passé au délégué <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quand l'opération est terminée.</param>
        <summary>Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceive%2A> (méthode). En règle générale, la méthode est appelée par le `callback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Receive%2A> surcharges de méthode.  
  
 Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  `state` est une instanciation d’une classe définie par l’utilisateur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception. Cet objet est passé au délégué <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quand l'opération est terminée.</param>
        <summary>Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceive%2A> (méthode). En règle générale, la méthode est appelée par le `callback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Receive%2A> surcharges de méthode.  
  
 Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  `state` est une instanciation d’une classe définie par l’utilisateur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="offset">Position de base zéro dans le paramètre <paramref name="buffer" /> à laquelle stocker les données reçues.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception. Cet objet est passé au délégué <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quand l'opération est terminée.</param>
        <summary>Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceive%2A> (méthode). En règle générale, la méthode est appelée par le `callback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Receive%2A> surcharges de méthode.  
  
 Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  `state` est une instanciation d’une classe définie par l’utilisateur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant commence à la réception asynchrone de données à partir d’un connecté <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="offset">Emplacement dans <paramref name="buffer" /> où stocker les données reçues.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="flags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <param name="error">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception. Cet objet est passé au délégué <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quand l'opération est terminée.</param>
        <summary>Démarre la réception asynchrone de données à partir d'un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceive%2A> (méthode). En règle générale, la méthode est appelée par le `callback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.Socket.Receive%2A> surcharges de méthode.  
  
 Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  `state` est une instanciation d’une classe définie par l’utilisateur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="offset">Position de base zéro dans le paramètre <paramref name="buffer" /> à laquelle stocker les données.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> qui représente la source des données.</param>
        <param name="remote_end"><see cref="T:System.Net.EndPoint" /> qui représente la source des données.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Démarre la réception asynchrone de données à partir d'un périphérique réseau spécifié.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode démarre la lecture asynchrone des datagrammes sans connexion à partir d’un hôte distant. Appel de la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode vous donne la possibilité de recevoir les données dans un thread d’exécution distinct.  
  
 Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode). Pour ce faire, au minimum, votre `state` paramètre doit contenir le service connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, le système utilisera un thread distinct pour exécuter la méthode de rappel spécifiée et il se bloque sur <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> lit les données ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode), utilisez <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Appelez la méthode Set sur un : System.Threading.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Avant d’appeler <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, vous devez lier explicitement le <xref:System.Net.Sockets.Socket> vers un point de terminaison local en utilisant le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), ou <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Cette méthode lit les données dans le `buffer` paramètre et capture le point de terminaison à partir de laquelle les données sont envoyées de l’hôte distant. Pour plus d’informations sur la récupération de ce point de terminaison, consultez <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Cette méthode est plus utile si vous avez l’intention de réception asynchrone des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs hôtes. Dans ce cas, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local. Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole non fiable, les données excédentaires seront perdues. Si vous utilisez un protocole fiable, les données excédentaires sont retenues par le fournisseur de services et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode avec une mémoire tampon suffisant.  
  
 Pour garantir que le point de terminaison d’hôte distant est toujours retourné, une application doit lier explicitement le <xref:System.Net.Sockets.Socket> à un point de terminaison local à l’aide la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), puis appelez le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> méthode avec le `optionLevel` paramètre défini sur <xref:System.Net.Sockets.SocketOptionLevel.IP>ou <xref:System.Net.Sockets.SocketOptionLevel.IPv6> selon le cas, le `optionName` paramètre défini sur <xref:System.Net.Sockets.SocketOptionName.PacketInformation>et le `optionValue` paramètre pour activer cette option avant d’appeler le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode). Sinon, il est possible pour le point de terminaison d’hôte distant ne soit ne pas retourné lorsque l’expéditeur a envoyé un nombre de datagrammes avant que le destinataire a appelé le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode).  
  
 Bien que <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion. Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode ou accepter une demande de connexion entrante en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode). Si vous appelez le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode avant d’établir ou d’accepter une connexion, vous obtiendrez un <xref:System.Net.Sockets.SocketException>. Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode). Dans les deux cas, le <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et recevoir uniquement des données de la connecté ou hôte distant par défaut.  
  
 Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lit autant de données est disponible jusqu’au nombre d’octets spécifié par le `size` paramètre.  
  
 Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant reçoit de façon asynchrone des datagrammes sans connexion à partir d’un hôte distant.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="offset">Position de base zéro dans le paramètre <paramref name="buffer" /> à laquelle stocker les données.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> qui représente la source des données.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Démarre la réception asynchrone du nombre spécifié d’octets de données dans l’emplacement spécifié de la mémoire tampon de données, à l’aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié et stocke le point de terminaison ainsi que les informations sur le paquet.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à la lecture asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opération de réception asynchrone doit être effectuée en appelant le <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez le <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> (méthode).  
  
 Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Cette méthode lit les données dans le `buffer` paramètre et capture le point de terminaison à partir de laquelle les données sont envoyées de l’hôte distant, ainsi que des informations sur le paquet reçu. Pour plus d’informations sur la récupération de ce point de terminaison, consultez <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Cette méthode est plus utile si vous avez l’intention de réception asynchrone des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs hôtes.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode). <xref:System.Net.Sockets.Socket.BeginSend%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Appel de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.  
  
 Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode). Pour ce faire, au minimum, votre `state` paramètre doit contenir le service connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSend%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSend%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode), utilisez le <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode). Appelez la méthode Set sur un : System.Threading.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSend%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut. Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Il s’agit d’OK à utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.BeginSend%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  `state` est une instanciation d’une classe définie par l’utilisateur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> est vide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode). <xref:System.Net.Sockets.Socket.BeginSend%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Appel de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.  
  
 Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode). Pour ce faire, au minimum, votre `state` paramètre doit contenir le service connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSend%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSend%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode), utilisez le <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode). Appelez la méthode Set sur un <xref:System.Threading.ManualResetEvent> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSend%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut. Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Il s’agit d’OK à utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.BeginSend%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  `state` est une instanciation d’une classe définie par l’utilisateur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> est vide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="offset">Position de base zéro dans le paramètre <paramref name="buffer" /> à laquelle commencer l'envoi des données.</param>
        <param name="size">Le nombre d’octets à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode). <xref:System.Net.Sockets.Socket.BeginSend%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Appel de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.  
  
 Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode). Pour ce faire, au minimum, votre `state` paramètre doit contenir le service connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSend%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSend%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode), utilisez le <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode). Appelez la méthode Set sur un : System.Threading.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSend%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut. Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Il s’agit d’OK à utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.BeginSend%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  `state` est une instanciation d’une classe définie par l’utilisateur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est inférieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="offset">Position de base zéro dans le paramètre <paramref name="buffer" /> à laquelle commencer l'envoi des données.</param>
        <param name="size">Le nombre d’octets à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Envoie des données de façon asynchrone à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode). <xref:System.Net.Sockets.Socket.BeginSend%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Appel de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.  
  
 Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode). Pour ce faire, au minimum, votre `state` paramètre doit contenir le service connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSend%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSend%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode), utilisez le <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode). Appelez la méthode Set sur un : System.Threading.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSend%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut. Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Il s’agit d’OK à utiliser <xref:System.Net.Sockets.Socket.BeginSendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Avec les protocoles sans connexion, vous devez être sûr que la taille de votre mémoire tampon ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.BeginSend%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  `state` est une instanciation d’une classe définie par l’utilisateur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant commence à envoyer de façon asynchrone des données à un hôte distant.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est inférieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Exemple de socket client asynchrone</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Exemple de sockets serveur asynchrones</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie un fichier de façon asynchrone à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Chaîne qui contient le chemin d'accès et le nom du fichier à envoyer. Ce paramètre peut être <see langword="null" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Envoie le fichier <paramref name="fileName" /> à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté à l'aide de l'indicateur <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui représente l'envoi asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge envoie le fichier `fileName` au socket connecté. Si `fileName` est dans le répertoire local, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés. Les caractères génériques («.. \\\myfile.txt ») et les noms des partages UNC («\\\\\\\shared directory\\\myfile.txt ») sont pris en charge. Si le fichier est introuvable, l’exception <xref:System.IO.FileNotFoundException> est levée.  
  
 Cette méthode utilise la `TransmitFile` fonction trouvée dans l’API Windows Sockets 2. Pour plus d’informations sur la `TransmitFile` fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.  
  
 Le <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthodes. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Appel de la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode vous permet d’envoyer un fichier dans un thread d’exécution distinct.  
  
 Pour terminer l’opération, vous pouvez créer une méthode de rappel qui est appelée par le <xref:System.AsyncCallback> paramètre de délégué. Pour ce faire, au minimum, le `state` paramètre doit contenir le <xref:System.Net.Sockets.Socket> de l’objet utilisé pour la communication. Si votre rappel a besoin de plus d’informations, vous pouvez créer une classe ou une structure contenant les <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cet objet personnalisé à la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSendFile%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, le système utilise un thread distinct pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSendFile%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie l’intégralité du fichier ou lève une exception. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut. Avec les protocoles sans connexion, vous devez être sûr que la taille de votre fichier ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Le cas échéant, le datagramme n’est pas envoyé et <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lève un <xref:System.Net.Sockets.SocketException> exception.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException> exception, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant crée et connecte un socket pour la communication asynchrone. Tout d’abord, le fichier « text.txt » est envoyé de manière asynchrone à l’hôte distant. Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndSendFile%2A> pour terminer la transmission.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Le socket n’est pas connecté à un hôte distant.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier <paramref name="fileName" /> est introuvable.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Chaîne qui contient le chemin d'accès et le nom du fichier à envoyer. Ce paramètre peut être <see langword="null" />.</param>
        <param name="preBuffer">Tableau <see cref="T:System.Byte" /> contenant les données à envoyer avant l’envoi du fichier. Ce paramètre peut être <see langword="null" />.</param>
        <param name="postBuffer">Tableau <see cref="T:System.Byte" /> contenant les données à envoyer après l’envoi du fichier. Ce paramètre peut être <see langword="null" />.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> à appeler une fois cette opération terminée. Ce paramètre peut être <see langword="null" />.</param>
        <param name="state">Objet défini par l'utilisateur contenant les informations d'état de cette demande. Ce paramètre peut être <see langword="null" />.</param>
        <summary>Envoie de façon asynchrone un fichier et des mémoires tampon de données à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge requiert le nom du fichier à envoyer et une combinaison au niveau du bit de <xref:System.Net.Sockets.TransmitFileOptions> valeurs. Le `preBuffer` paramètre contient les données que vous souhaitez faire précéder le fichier. `postBuffer` contient des données que vous souhaitez suivre le fichier. Si `fileName` est dans le répertoire local, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés. Les caractères génériques («.. \\\myfile.txt ») et les noms des partages UNC («\\\\\\\shared directory\\\myfile.txt ») sont pris en charge. Si le fichier est introuvable, l’exception <xref:System.IO.FileNotFoundException> est levée.  
  
 Le `flags` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur le transfert de fichiers. Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Cette méthode utilise la `TransmitFile` fonction trouvée dans l’API Windows Sockets 2. Pour plus d’informations sur la `TransmitFile` fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.  
  
 Le <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthodes. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Appel de la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode vous donne la possibilité d’envoyer un fichier dans un thread d’exécution distinct.  
  
 Pour terminer l’opération, vous pouvez créer une méthode de rappel qui est appelée par le <xref:System.AsyncCallback> paramètre de délégué. Pour ce faire, au minimum, le `state` paramètre doit contenir le <xref:System.Net.Sockets.Socket> de l’objet utilisé pour la communication. Si votre rappel a besoin de plus d’informations, vous pouvez créer une classe ou une structure contenant les <xref:System.Net.Sockets.Socket> et les autres informations requises. Passez une instance de cet objet personnalisé à la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSendFile%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, le système utilise un thread distinct pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSendFile%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie l’intégralité du fichier ou lève une exception. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Bien que destiné à des protocoles orientés connexion, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode pour établir un hôte distant par défaut. Avec les protocoles sans connexion, vous devez être sûr que la taille de votre fichier ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Le cas échéant, le datagramme n’est pas envoyé et <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lève un <xref:System.Net.Sockets.SocketException> exception.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException> exception, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant crée et connecte à un socket pour la communication asynchrone et commence à envoyer le fichier « text.txt » en mode asynchrone à l’hôte distant. Dans cet exemple, un `preBuffer` et un `postBuffer` de données est créé pour envoyer avec le fichier et la valeur par défaut <xref:System.Net.Sockets.TransmitFileOptions> valeur est utilisée. Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndSendFile%2A> pour terminer la transmission.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous.</exception>
        <exception cref="T:System.NotSupportedException">Le système d'exploitation n'est pas Windows NT ou une version ultérieure.  
  
ou 
Le socket n’est pas connecté à un hôte distant.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier <paramref name="fileName" /> est introuvable.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="offset">Position de base zéro dans <paramref name="buffer" /> à laquelle commencer l'envoi des données.</param>
        <param name="size">Le nombre d’octets à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> qui représente l’appareil distant.</param>
        <param name="remote_end"><see cref="T:System.Net.EndPoint" /> qui représente l’appareil distant.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet qui contient les informations d’état de cette demande.</param>
        <summary>Envoie des données de façon asynchrone à un hôte distant spécifique.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant spécifié dans le `remoteEP` paramètre. Appel de la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct. Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> fonctionne avec les protocoles orientés connexion.  
  
 Vous pouvez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> (méthode). Pour ce faire, au minimum, votre `state` paramètre doit contenir le service connecté ou par défaut <xref:System.Net.Sockets.Socket> utilisé pour la communication. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe pour contenir le <xref:System.Net.Sockets.Socket>et les autres informations requises. Passez une instance de cette classe pour le <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.Socket.EndSendTo%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.Socket.EndSendTo%2A> jusqu'à ce que le <xref:System.Net.Sockets.Socket> envoie le nombre d’octets demandé ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> (méthode), utilisez le <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (méthode). Appelez la méthode Set sur un : System.Threading.ManualResetEvent dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si vous utilisez un protocole orienté connexion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode), ou <xref:System.Net.Sockets.Socket.BeginSendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> ignore le `remoteEP` paramètre et envoie les données à la <xref:System.Net.EndPoint> établie dans le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).  
  
 Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>. Vous devez uniquement effectuer cette opération si vous avez l’intention d’appeler le <xref:System.Net.Sockets.Socket.BeginSend%2A> (méthode). Si vous n’appelez pas la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi. Vous n’êtes également pas obligé d’appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode). Dans ce cas, le fournisseur de services sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié. Utiliser un numéro de port zéro si vous souhaitez que le fournisseur de services sous-jacent pour sélectionner un port disponible. Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.EndSendTo%2A> méthode se termine correctement.  
  
 Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. -Vous devez également vous assurer de que la taille de votre mémoire tampon ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.EndSendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le contexte d’exécution (le contexte de sécurité, l’utilisateur avec emprunt d’identité et le contexte d’appel) est mises en cache asynchrone <xref:System.Net.Sockets.Socket> méthodes. Après la première utilisation d’un contexte particulier (une asynchrone spécifique <xref:System.Net.Sockets.Socket> (méthode), un spécifique <xref:System.Net.Sockets.Socket> instance et un rappel spécifique), les utilisations suivantes de ce contexte seront affiche une amélioration des performances.  
  
   
  
## Examples  
 L’exemple de code suivant envoie de façon asynchrone à l’hôte distant spécifié les données.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling d'un délégué comme méthode de rappel</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.EndPoint" /> local à associer à <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Associe <see cref="T:System.Net.Sockets.Socket" /> à un point de terminaison local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utiliser le <xref:System.Net.Sockets.Socket.Bind%2A> méthode si vous devez utiliser un point de terminaison local spécifique. Vous devez appeler <xref:System.Net.Sockets.Socket.Bind%2A> avant de pouvoir appeler le <xref:System.Net.Sockets.Socket.Listen%2A> (méthode). Vous n’avez pas besoin d’appeler <xref:System.Net.Sockets.Socket.Bind%2A> avant d’utiliser le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode), sauf si vous devez utiliser un point de terminaison local spécifique. Vous pouvez utiliser la <xref:System.Net.Sockets.Socket.Bind%2A> méthode sur les protocoles orientés connexion.  
  
 Avant d’appeler <xref:System.Net.Sockets.Socket.Bind%2A>, vous devez d’abord créer local <xref:System.Net.IPEndPoint> à partir de laquelle vous souhaitez communiquer des données. Si vous ne souhaitez pas l’adresse locale est affecté, vous pouvez créer un <xref:System.Net.IPEndPoint> à l’aide de <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> ainsi que le paramètre d’adresse, le service sous-jacent fournisseur affecte l’adresse réseau la plus appropriée. Cela peut vous aider à simplifier votre application si vous avez plusieurs interfaces réseau. Si vous ne souhaitez pas le port local est utilisé, vous pouvez créer un <xref:System.Net.IPEndPoint> à l’aide de 0 pour le numéro de port. Dans ce cas, le fournisseur de service affecte un numéro de port disponible entre 1024 et 5000.  
  
 Si vous utilisez l’approche ci-dessus, vous pouvez découvrir quel numéro d’adresse et le port de réseau local a été affecté en appelant le <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> ne retournera pas l’adresse réseau assignée localement jusqu'à une fois que vous avez effectué un appel à la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.EndConnect%2A> (méthode). Si vous utilisez un protocole sans connexion, vous aurez pas accès à ces informations jusqu'à ce que vous avez terminé un envoi ou de réception.  
  
 Si un socket UDP souhaite recevoir des informations d’interface sur les paquets reçus, le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> méthode doit être appelée explicitement avec l’option de socket définie sur <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immédiatement après l’appel la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode).  
  
> [!NOTE]
>  Si vous souhaitez recevoir des datagrammes multicast, vous devez appeler la <xref:System.Net.Sockets.Socket.Bind%2A> méthode avec un numéro de port de multidiffusion.  
  
> [!NOTE]
>  Vous devez appeler la <xref:System.Net.Sockets.Socket.Bind%2A> méthode si vous souhaitez recevoir des datagrammes sans connexion à l’aide du <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException> lors de l’appel le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple lie un <xref:System.Net.Sockets.Socket> à l’aide du point de terminaison local spécifié.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir de l’hôte défini par <paramref name="localEP" />. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si <see cref="T:System.Net.Sockets.Socket" /> est en mode blocage.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> est bloqué ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété indique si un <xref:System.Net.Sockets.Socket> est en mode blocage.  
  
 Si vous êtes en mode blocage, et vous appeler une méthode qui ne se termine pas immédiatement, votre application bloque l’exécution jusqu'à la fin de l’opération demandée. Si vous souhaitez que l’exécution à continuer même si l’opération demandée n’est pas terminée, modifiez le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false`. Le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété n’a aucun effet sur les méthodes asynchrones. Si vous envoyez et recevoir des données de façon asynchrone et souhaitez bloquer l’exécution, utilisez la <xref:System.Threading.ManualResetEvent> classe.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> utilisé pour demander la connexion à l'hôte distant en appelant l'une des méthodes <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</param>
        <summary>Annule une requête asynchrone pour une connexion d'hôte distant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> méthode annule une demande asynchrone d’une connexion d’hôte distant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="e" /> ne peut pas être null et <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être vide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ferme la connexion <see cref="T:System.Net.Sockets.Socket" /> et libère toutes les ressources associées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme la connexion <see cref="T:System.Net.Sockets.Socket" /> et libère toutes les ressources associées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.Close%2A> méthode ferme la connexion de l’hôte distant et les versions toutes les ressources managées et associés à la <xref:System.Net.Sockets.Socket>. Lors de sa fermeture, le <xref:System.Net.Sockets.Socket.Connected%2A> propriété est définie sur `false`.  
  
 Pour les protocoles orientés connexion, il est recommandé d’appeler <xref:System.Net.Sockets.Socket.Shutdown%2A> avant d’appeler le <xref:System.Net.Sockets.Socket.Close%2A> (méthode). Cela garantit que toutes les données envoyées et reçues sur le socket connecté avant sa fermeture.  
  
 Si vous devez appeler <xref:System.Net.Sockets.Socket.Close%2A> sans appeler d’abord <xref:System.Net.Sockets.Socket.Shutdown%2A>, vous pouvez vous assurer que les données en attente pour la transmission sortante est envoyée en définissant le <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> option `false` et en spécifiant un intervalle de délai d’expiration différent de zéro. <xref:System.Net.Sockets.Socket.Close%2A> puis bloquera jusqu'à ce que ces données sont envoyées ou jusqu'à ce que le délai spécifié expire. Si vous définissez <xref:System.Net.Sockets.SocketOptionName.DontLinger> à `false` et spécifiez un intervalle de délai d’attente zéro, <xref:System.Net.Sockets.Socket.Close%2A> libère la connexion et ignore automatiquement les données en file d’attente sortantes.  
  
> [!NOTE]
>  Pour définir le <xref:System.Net.Sockets.SocketOptionName.DontLinger> option de socket `false`, créer un <xref:System.Net.Sockets.LingerOption>, définissez la propriété est activée sur `true`et définissez le <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété à la période d’expiration souhaitée. Utilisez cette <xref:System.Net.Sockets.LingerOption> avec la <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option pour appeler le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode).  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple ferme un <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Attendez jusqu’à <paramref name="timeout" /> secondes pour envoyer toutes les données restantes, puis fermez le socket.</param>
        <summary>Ferme la connexion <see cref="T:System.Net.Sockets.Socket" /> et libère toutes les ressources associées avec un délai d’attente spécifié pour permettre l’envoi des données en file d’attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.Close%2A> méthode ferme la connexion de l’hôte distant et les versions toutes les ressources managées et associés à la <xref:System.Net.Sockets.Socket>. Lors de sa fermeture, le <xref:System.Net.Sockets.Socket.Connected%2A> propriété est définie sur `false`.  
  
 Pour les protocoles orientés connexion, il est recommandé d’appeler <xref:System.Net.Sockets.Socket.Shutdown%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Close%2A>. Cela garantit que toutes les données envoyées et reçues sur le socket connecté avant sa fermeture.  
  
 Si vous devez appeler <xref:System.Net.Sockets.Socket.Close%2A> sans appeler d’abord <xref:System.Net.Sockets.Socket.Shutdown%2A>, vous pouvez vous assurer que les données en attente pour la transmission sortante est envoyée en définissant le <xref:System.Net.Sockets.SocketOptionName.DontLinger> option `false` et en spécifiant un intervalle de délai d’expiration différent de zéro. <xref:System.Net.Sockets.Socket.Close%2A> puis bloquera jusqu'à ce que ces données sont envoyées ou jusqu'à ce que le délai spécifié expire. Si vous définissez <xref:System.Net.Sockets.SocketOptionName.DontLinger> à `false` et spécifiez un intervalle de délai d’attente zéro, <xref:System.Net.Sockets.Socket.Close%2A> libère la connexion et ignore automatiquement les données en file d’attente sortantes.  
  
> [!NOTE]
>  Pour définir le <xref:System.Net.Sockets.SocketOptionName.DontLinger> option de socket `false`, créer un <xref:System.Net.Sockets.LingerOption>, définissez la propriété est activée sur `true`et définissez le <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété à la période de délai d’expiration souhaitée. Utilisez cette <xref:System.Net.Sockets.LingerOption> avec la <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option pour appeler le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode).  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment fermer une <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Établit une connexion à un hôte distant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> qui représente l’appareil distant.</param>
        <summary>Établit une connexion à un hôte distant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un protocole orienté connexion, tels que TCP, la <xref:System.Net.Sockets.Socket.Connect%2A> méthode établit de manière synchrone une connexion réseau entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> et le point de terminaison distant spécifié. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.Connect%2A> établit un hôte distant par défaut. Après avoir appelé <xref:System.Net.Sockets.Socket.Connect%2A>, vous pouvez envoyer des données à l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Send%2A> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).  
  
 Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’envoyer et recevoir des données. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> et <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> pour communiquer de manière synchrone avec un hôte distant. Si vous n’appelez pas <xref:System.Net.Sockets.Socket.Connect%2A>, tous les datagrammes provenant d’une adresse autre que la valeur par défaut spécifiée seront ignorées. Si vous souhaitez définir votre hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
 Le <xref:System.Net.Sockets.Socket.Connect%2A> méthode se bloque, sauf si vous définissez spécifiquement le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false` avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>. Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException> , car il a besoin de temps pour établir la connexion. Protocoles sans connexion ne seront pas lever une exception car ils établissent simplement un hôte distant par défaut. Vous pouvez utiliser <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur. Si l’erreur retournée est WSAEWOULDBLOCK, la connexion de l’hôte distant a été initiée par orienté connexion <xref:System.Net.Sockets.Socket>, mais n’est ne pas encore terminée correctement. Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode pour déterminer quand le <xref:System.Net.Sockets.Socket> est terminé connexion.  
  
> [!NOTE]
>  Si vous utilisez un protocole orienté connexion et n’a pas appelé <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>, le fournisseur de services sous-jacent affecte le numéro d’adresse et le port de réseau local. Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un réseau local adresse et numéro de port jusqu'à ce que vous effectuez un envoi ou opération de réception. Si vous souhaitez changer l’hôte distant par défaut, appelez <xref:System.Net.Sockets.Socket.Connect%2A> à nouveau avec le point de terminaison souhaité.  
  
> [!NOTE]
>  Si le socket a été précédemment déconnecté, vous ne pouvez pas utiliser cette méthode pour restaurer la connexion. Utilisez une des asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthodes se reconnecter. Il s’agit d’une limitation du fournisseur sous-jacent.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">pour la connexion à l’hôte distant. Énumération associée : <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Adresse IP de l’hôte distant.</param>
        <param name="port">Numéro de port de l'hôte distant.</param>
        <summary>Établit une connexion à un hôte distant. L’hôte est spécifié par une adresse IP et un numéro de port.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un protocole orienté connexion, tels que TCP, la <xref:System.Net.Sockets.Socket.Connect%2A> méthode établit de manière synchrone une connexion réseau entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> et le point de terminaison distant spécifié. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.Connect%2A> établit un hôte distant par défaut. Après avoir appelé <xref:System.Net.Sockets.Socket.Connect%2A> vous pouvez envoyer des données à l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Send%2A> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).  
  
 Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’envoyer et recevoir des données. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> et <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> pour communiquer de manière synchrone avec un hôte distant. Si vous appelez <xref:System.Net.Sockets.Socket.Connect%2A> tous les datagrammes provenant d’une adresse autre que la valeur par défaut spécifiée seront ignorées. Si vous souhaitez définir votre hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> méthode se bloque, sauf si vous définissez spécifiquement le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false` avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>. Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException> , car il a besoin de temps pour établir la connexion. Protocoles sans connexion ne seront pas lever une exception car ils établissent simplement un hôte distant par défaut. Vous pouvez utiliser <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur. Si l’erreur retournée est WSAEWOULDBLOCK, la connexion de l’hôte distant a été initiée par orienté connexion <xref:System.Net.Sockets.Socket>, mais n’est ne pas encore terminée correctement. Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode pour déterminer quand le <xref:System.Net.Sockets.Socket> est terminé connexion.  
  
> [!NOTE]
>  Si vous utilisez un protocole orienté connexion et n’a pas appelé <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>, le fournisseur de services sous-jacent affecte le numéro d’adresse et le port de réseau local. Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un réseau local adresse et numéro de port jusqu'à ce que vous effectuez un envoi ou opération de réception. Si vous souhaitez changer l’hôte distant par défaut, appelez <xref:System.Net.Sockets.Socket.Connect%2A> à nouveau avec le point de terminaison souhaité.  
  
> [!NOTE]
>  Si le socket a été précédemment déconnecté, vous ne pouvez pas utiliser cette méthode pour restaurer la connexion. Utilisez une des asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthodes se reconnecter. Il s’agit d’une limitation du fournisseur sous-jacent.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n’est pas valide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Cette méthode est valide pour les sockets appartenant aux familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="address" /> est égale à zéro.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">Adresses IP de l’hôte distant.</param>
        <param name="port">Numéro de port de l'hôte distant.</param>
        <summary>Établit une connexion à un hôte distant. L’hôte est spécifié par un tableau d’adresses IP et un numéro de port.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est généralement utilisée immédiatement après un appel à <xref:System.Net.Dns.GetHostAddresses%2A>, qui peut retourner plusieurs adresses IP pour un seul hôte. Si vous utilisez un protocole orienté connexion, tels que TCP, la <xref:System.Net.Sockets.Socket.Connect%2A> méthode établit de manière synchrone une connexion réseau entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> et le point de terminaison distant spécifié. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.Connect%2A> établit un hôte distant par défaut. Après avoir appelé <xref:System.Net.Sockets.Socket.Connect%2A> vous pouvez envoyer des données à l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Send%2A> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).  
  
 Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’envoyer et recevoir des données. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> et <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> pour communiquer de manière synchrone avec un hôte distant. Si vous appelez <xref:System.Net.Sockets.Socket.Connect%2A> tous les datagrammes provenant d’une adresse autre que la valeur par défaut spécifiée seront ignorées. Si vous souhaitez définir votre hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> méthode se bloque, sauf si vous définissez spécifiquement le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false` avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>. Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException> , car il a besoin de temps pour établir la connexion. Protocoles sans connexion ne seront pas lever une exception car ils établissent simplement un hôte distant par défaut. Vous pouvez utiliser <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur. Si l’erreur retournée est WSAEWOULDBLOCK, la connexion de l’hôte distant a été initiée par orienté connexion <xref:System.Net.Sockets.Socket>, mais n’est ne pas encore terminée correctement. Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode pour déterminer quand le <xref:System.Net.Sockets.Socket> est terminé connexion.  
  
> [!NOTE]
>  Si vous utilisez un protocole orienté connexion et n’a pas appelé <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>, le fournisseur de services sous-jacent affecte le numéro d’adresse et le port de réseau local. Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un réseau local adresse et numéro de port jusqu'à ce que vous effectuez un envoi ou opération de réception. Si vous souhaitez changer l’hôte distant par défaut, appelez <xref:System.Net.Sockets.Socket.Connect%2A> à nouveau avec le point de terminaison souhaité.  
  
> [!NOTE]
>  Si le socket a été précédemment déconnecté, vous ne pouvez pas utiliser cette méthode pour restaurer la connexion. Utilisez une des asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthodes se reconnecter. Il s’agit d’une limitation du fournisseur sous-jacent.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n’est pas valide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Cette méthode est valide pour les sockets appartenant aux familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="address" /> est égale à zéro.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Nom de l'hôte distant.</param>
        <param name="port">Numéro de port de l'hôte distant.</param>
        <summary>Établit une connexion à un hôte distant. L’hôte est spécifié par un nom d’hôte et un numéro de port.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un protocole orienté connexion, tels que TCP, la <xref:System.Net.Sockets.Socket.Connect%2A> méthode établit de manière synchrone une connexion réseau entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> et l’hôte distant spécifié. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.Connect%2A> établit un hôte distant par défaut. Après avoir appelé <xref:System.Net.Sockets.Socket.Connect%2A> vous pouvez envoyer des données à l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Send%2A> (méthode), ou recevoir des données à partir de l’appareil à distance avec le <xref:System.Net.Sockets.Socket.Receive%2A> (méthode).  
  
 Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’envoyer et recevoir des données. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> et <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> pour communiquer de manière synchrone avec un hôte distant. Si vous appelez <xref:System.Net.Sockets.Socket.Connect%2A> tous les datagrammes provenant d’une adresse autre que la valeur par défaut spécifiée seront ignorées. Si vous souhaitez définir votre hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> méthode se bloque, sauf si vous définissez spécifiquement le <xref:System.Net.Sockets.Socket.Blocking%2A> propriété `false` avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>. Si vous utilisez un protocole orienté connexion tels que TCP et si vous désactivez le blocage, <xref:System.Net.Sockets.Socket.Connect%2A> lèvera une <xref:System.Net.Sockets.SocketException> , car il a besoin de temps pour établir la connexion. Protocoles sans connexion ne seront pas lever une exception car ils établissent simplement un hôte distant par défaut. Vous pouvez utiliser <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur. Si l’erreur retournée est WSAEWOULDBLOCK, la connexion de l’hôte distant a été initiée par orienté connexion <xref:System.Net.Sockets.Socket>, mais n’est ne pas encore terminée correctement. Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode pour déterminer quand le <xref:System.Net.Sockets.Socket> est terminé connexion.  
  
 Si IPv6 est activé et le <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> est appelée pour vous connecter à un hôte qui résout les deux IPv6 et des adresses IPv4, la connexion à l’adresse IPv6 sera tentée en premier avant l’adresse IPv4. Cela peut avoir pour effet de retarder l’heure pour établir la connexion si l’hôte n’écoute pas sur l’adresse IPv6.  
  
> [!NOTE]
>  Si vous utilisez un protocole orienté connexion et n’a pas appelé <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.Connect%2A>, le fournisseur de services sous-jacent affecte le numéro d’adresse et le port de réseau local. Si vous utilisez un protocole sans connexion, le fournisseur de services n’affectera pas un réseau local adresse et numéro de port jusqu'à ce que vous effectuez un envoi ou opération de réception. Si vous souhaitez changer l’hôte distant par défaut, appelez <xref:System.Net.Sockets.Socket.Connect%2A> à nouveau avec le point de terminaison souhaité.  
  
> [!NOTE]
>  Si le socket a été précédemment déconnecté, vous ne pouvez pas utiliser cette méthode pour restaurer la connexion. Utilisez une des asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthodes se reconnecter. Il s’agit d’une limitation du fournisseur sous-jacent.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n’est pas valide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Cette méthode est valide pour les sockets appartenant aux familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> a été mis dans un état d’écoute en appelant <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre une demande asynchrone pour une connexion à un hôte distant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Démarre une demande asynchrone pour une connexion à un hôte distant.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un protocole orienté connexion, la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode démarre une demande asynchrone pour une connexion à l’hôte distant. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> établit un hôte distant par défaut.  
  
 Pour être averti de la saisie semi-automatique, vous devez créer une méthode de rappel qui implémente le délégué EventHandler\<SocketAsyncEventArgs > et l’attacher le rappel pour le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.  
  
 L’appelant doit attribuer la <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété le <xref:System.Net.IPEndPoint> de l’hôte distant pour se connecter à.  
  
 L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode), afin que les informations seront récupérables dans la méthode de rappel. Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.  
  
 Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.ConnectAsync%2A> avant d’envoyer et recevoir des données. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendToAsync%2A> et <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> pour communiquer avec un hôte distant. Si vous n’appelez pas <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, tous les datagrammes provenant d’une adresse autre que la valeur par défaut spécifiée seront ignorées. Si vous souhaitez changer l’hôte distant par défaut, appelez le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode à nouveau avec le point de terminaison souhaité.  
  
 Si vous souhaitez définir l’hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler <xref:System.Net.Sockets.Socket.SetSocketOption%2A> et la valeur de la diffusion `true`. Si cela n’est pas fait, le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode lève un <xref:System.Net.Sockets.SocketException>.  
  
 Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requises :  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Si vous le souhaitez, une mémoire tampon peut être fournie qui sera envoyé atomiquement sur le socket après le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode réussit. Dans ce cas, le <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriété doit être définie dans la mémoire tampon contenant les données à envoyer et <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriété doit être définie pour le nombre d’octets de données à envoyer à partir de la mémoire tampon. Une fois qu’une connexion est établie, cette mémoire tampon de données est envoyée.  
  
 Si vous utilisez un protocole orienté connexion et que vous n’appelez pas <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, le fournisseur de services sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.  
  
 Si vous utilisez un protocole sans connexion, le fournisseur de services assignera pas un réseau local IP adresse et numéro de port jusqu'à ce que vous appeliez la <xref:System.Net.Sockets.Socket.SendAsync%2A> ou <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> méthodes.  
  
 Le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode lève une exception <xref:System.NotSupportedException> si la famille d’adresses de la <xref:System.Net.Sockets.Socket> et <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> ne sont pas la même famille d’adresses.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException> lorsque vous appelez cette méthode, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argument n’est pas valide. Cette exception se produit si plusieurs mémoires tampons sont spécifiées, la propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> n'est pas null.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="e" /> ne peut pas être null et <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être vide.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> est à l'écoute ou une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode. Cette exception se produit également si le point de terminaison local et les <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne sont pas la même famille d'adresses.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">Une des valeurs de <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Une des valeurs de <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Démarre une demande asynchrone pour une connexion à un hôte distant.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un protocole orienté connexion, la méthode System.NET.Sockets.ProtocolType démarre une demande asynchrone d’un connexion à l’hôte distant. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> établit un hôte distant par défaut spécifié par le `socketType` et `protocolType` paramètres.  
  
 Pour être averti de la saisie semi-automatique, vous devez créer une méthode de rappel qui implémente le délégué EventHandler\<SocketAsyncEventArgs > et l’attacher le rappel pour le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.  
  
 L’appelant doit attribuer la <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété le <xref:System.Net.IPEndPoint> de l’hôte distant pour se connecter à.  
  
 L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode), afin que les informations seront récupérables dans la méthode de rappel. Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.  
  
 Si vous utilisez un protocole sans connexion tel que UDP, vous n’avez pas à appeler <xref:System.Net.Sockets.Socket.ConnectAsync%2A> avant d’envoyer et recevoir des données. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendToAsync%2A> et <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> pour communiquer avec un hôte distant. Si vous n’appelez pas <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, tous les datagrammes provenant d’une adresse autre que la valeur par défaut spécifiée seront ignorées. Si vous souhaitez changer l’hôte distant par défaut, appelez le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode à nouveau avec le point de terminaison souhaité.  
  
 Si vous souhaitez définir l’hôte distant par défaut à une adresse de diffusion, vous devez d’abord appeler <xref:System.Net.Sockets.Socket.SetSocketOption%2A> et la valeur de la diffusion `true`. Si cela n’est pas fait, le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode lève un <xref:System.Net.Sockets.SocketException>.  
  
 Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requises :  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Si vous le souhaitez, une mémoire tampon peut être fournie qui sera envoyé atomiquement sur le socket après le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode réussit. Dans ce cas, le <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriété doit être définie dans la mémoire tampon contenant les données à envoyer et <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriété doit être définie pour le nombre d’octets de données à envoyer à partir de la mémoire tampon. Une fois qu’une connexion est établie, cette mémoire tampon de données est envoyée.  
  
 Si vous utilisez un protocole orienté connexion et que vous n’appelez pas <xref:System.Net.Sockets.Socket.Bind%2A> avant d’appeler <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, le fournisseur de services sous-jacent affecte le nombre d’adresse et le port de réseau local plus approprié.  
  
 Si vous utilisez un protocole sans connexion, le fournisseur de services assignera pas un réseau local IP adresse et numéro de port jusqu'à ce que vous appeliez la <xref:System.Net.Sockets.Socket.SendAsync%2A> ou <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> méthodes.  
  
 Le <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode lève une exception <xref:System.NotSupportedException> si la famille d’adresses de la <xref:System.Net.Sockets.Socket> et <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> ne sont pas la même famille d’adresses.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException> lorsque vous appelez cette méthode, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argument n’est pas valide. Cette exception se produit si plusieurs mémoires tampons sont spécifiées, la propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> n'est pas null.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="e" /> ne peut pas être null et <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être vide.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> est à l'écoute ou une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode. Cette exception se produit également si le point de terminaison local et les <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne sont pas la même famille d'adresses.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Net.Sockets.Socket" /> est connecté à un hôte distant depuis la dernière opération <see cref="Overload:System.Net.Sockets.Socket.Send" /> ou <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> était connecté à une ressource distante lors de l'opération la plus récente ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Connected` propriété obtient l’état de connexion de la <xref:System.Net.Sockets.Socket> depuis la dernière opération d’e/s. Quand il renvoie `false`, le <xref:System.Net.Sockets.Socket> n’a jamais été connecté ou n’est plus connecté.  
  
 La valeur de la <xref:System.Net.Sockets.Socket.Connected%2A> propriété reflète l’état de la connexion depuis la dernière opération. Si vous avez besoin déterminer l’état actuel de la connexion, appeler un envoi non bloquant, zéro octet. Si l’appel est retournée avec succès ou lève un code d’erreur WAEWOULDBLOCK (10035), puis le socket est toujours connecté ; Sinon, le socket n’est plus connecté.  
  
 Si vous appelez <xref:System.Net.Sockets.Socket.Connect%2A> sur un socket datagramme UDP (User Protocol), le <xref:System.Net.Sockets.Socket.Connected%2A> propriété retourne toujours `true`; Toutefois, cette action ne modifie pas la nature sans connexion inhérente d’UDP.  
  
   
  
## Examples  
 L’exemple de code suivant se connecte à un point de terminaison distant, vérifie le <xref:System.Net.Sockets.Socket.Connected%2A> propriété et vérifie l’état actuel de la connexion.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" /> si ce socket peut être réutilisé après la fermeture de la connexion active ; sinon, <see langword="false" />.</param>
        <summary>Ferme la connexion de socket et autorise la réutilisation du socket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un protocole orienté connexion, vous pouvez utiliser cette méthode pour fermer le socket. Cette méthode met fin à la connexion et affecte le <xref:System.Net.Sockets.Socket.Connected%2A> propriété `false`. Toutefois, si `reuseSocket` est `true`, vous pouvez réutiliser le socket.  
  
 Pour vous assurer que toutes les données est envoyées et reçues avant que le socket est fermé, vous devez appeler <xref:System.Net.Sockets.Socket.Shutdown%2A> avant d’appeler le <xref:System.Net.Sockets.Socket.Disconnect%2A> (méthode).  
  
 Si vous devez appeler <xref:System.Net.Sockets.Socket.Disconnect%2A> sans appeler d’abord <xref:System.Net.Sockets.Socket.Shutdown%2A>, vous pouvez définir le <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> option `false` et spécifiez un intervalle de délai d’expiration différent de zéro pour vous assurer que les données en attente transmission sortante est envoyé. <xref:System.Net.Sockets.Socket.Disconnect%2A> puis se bloque jusqu'à ce que les données sont envoyées ou jusqu'à ce que le délai spécifié expire. Si vous définissez <xref:System.Net.Sockets.SocketOptionName.DontLinger> à `false` et spécifiez un intervalle de délai d’attente zéro, <xref:System.Net.Sockets.Socket.Close%2A> libère la connexion et ignore automatiquement les données en file d’attente sortantes.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un socket pour la communication synchrone et envoie des données à un hôte distant. Il appelle ensuite <xref:System.Net.Sockets.Socket.Shutdown%2A>pour arrêter l’envoi et de réception d’activité, et <xref:System.Net.Sockets.Socket.Disconnect%2A>pour fermer la connexion de socket.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Cette méthode nécessite Windows 2000 ou version antérieure, ou l'exception sera levée.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Lance une demande asynchrone de déconnexion d'un point de terminaison distant.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez un protocole orienté connexion, appelant le <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> méthode requiert la déconnexion d’un point de terminaison distant. Si vous définissez <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> à `true` dans le `e` paramètre, le socket peut être réutilisé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="e" /> ne peut pas être Null.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode `Dispose` une fois que vous avez terminé d'utiliser <xref:System.Net.Sockets.Socket>. La méthode `Dispose` rend le <xref:System.Net.Sockets.Socket> inutilisable. Après avoir appelé `Dispose`, vous devez libérer toutes les références à la <xref:System.Net.Sockets.Socket> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Net.Sockets.Socket> occupée.  
  
 Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours `Dispose` avant de libérer votre dernière référence à <xref:System.Net.Sockets.Socket>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Net.Sockets.Socket> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Net.Sockets.Socket" /> et supprime éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Net.Sockets.Socket>. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> autorise la fragmentation des datagrammes IP (Internet Protocol).</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> autorise la fragmentation des datagrammes ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les datagrammes exigent une fragmentation lorsque leur taille dépasse le transfert unité maximale (MTU) du support de transmission. Les datagrammes peuvent être fragmentés par l’hôte d’envoi (toutes les versions d’Internet Protocol) ou un routeur intermédiaire (protocole Internet Version 4 uniquement). Si un datagramme doit être fragmenté et le <xref:System.Net.Sockets.Socket.DontFragment%2A> option est définie, le datagramme est ignoré, et un message d’erreur de contrôle Message ICMP (Internet Protocol) est envoyé à l’expéditeur du datagramme.  
  
 Définition de cette propriété sur un socket de protocole TCP (Transmission Control) n’aura aucun effet.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.DontFragment%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette propriété ne peut être définie que pour les sockets dans les familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> est un socket en mode double utilisé pour IPv4 et IPv6.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> est un socket en mode double ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">ID du processus cible où un doublon de la référence de socket est créé.</param>
        <summary>Duplique la référence de socket pour le processus cible et ferme le socket pour ce processus.</summary>
        <returns>Référence de socket à passer au processus cible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le processus cible doit utiliser <xref:System.Net.Sockets.Socket.%23ctor%2A> pour créer l’instance de socket en double.  
  
 Si vous appelez le <xref:System.Net.Sockets.Socket.%23ctor%2A> constructeur plusieurs fois avec le même tableau d’octets comme argument pour chaque appel, vous allez créer plusieurs gérés <xref:System.Net.Sockets.Socket> instances avec le même socket sous-jacent. Cette pratique est vivement déconseillée.  
  
 Si le processus de création du socket utilise des méthodes asynchrones (<xref:System.Net.Sockets.Socket.BeginReceive%2A> ou <xref:System.Net.Sockets.Socket.BeginSend%2A>), le processus doit tout d’abord définir le <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> propriété à true ; sinon, le socket est lié au port de terminaison du processus de création, ce qui peut provoquer un <xref:System.ArgumentNullException> levée sur le processus cible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> n'est pas un ID de processus valide. 
ou 
La duplication de la référence de socket a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> peut envoyer ou recevoir des paquets de diffusion.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> autorise les paquets de diffusion ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La diffusion est limitée à un sous-réseau spécifique et doit utiliser User Datagram Protocol (UDP). Pour Internet Protocol version 4, vous pouvez diffuser à votre sous-réseau local en envoyant un paquet à 255.255.255.255 ; ou vous pouvez utiliser l’adresse de diffusion dirigée, qui est la partie du réseau d’une adresse IP (Internet Protocol) avec tous les bits définis dans la partie hôte. Par exemple, si votre adresse IP est 192.168.1.40 (une adresse de classe C, avec un masque de sous-réseau de 255.255.255.0, la partie du réseau est les trois premiers octets et la partie hôte est le dernier octet), votre adresse de diffusion dirigée est 192.168.1.255.  
  
 Définition de cette propriété sur un socket de protocole TCP (Transmission Control) n’aura aucun effet.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Cette option n'est valide que pour un socket datagramme.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accepte de manière asynchrone une tentative de connexion entrante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les octets transférés.</param>
        <param name="asyncResult">Objet <see cref="T:System.IAsyncResult" /> qui stocke les informations d'état pour cette opération asynchrone ainsi que toutes les données définies par l'utilisateur.</param>
        <summary>Accepte de manière asynchrone une tentative de connexion entrante et crée un nouvel objet <see cref="T:System.Net.Sockets.Socket" /> pour gérer les communications de l'hôte distant. Cette méthode retourne une mémoire tampon qui contient les données initiales transférées.</summary>
        <returns>Objet <see cref="T:System.Net.Sockets.Socket" /> pour gérer la communication avec l'hôte distant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> termine un appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Avant d’appeler <xref:System.Net.Sockets.Socket.BeginAccept%2A>, vous devez créer une méthode de rappel qui est appelée par le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après la <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode retourne.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la `asyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.Socket> sur lequel la tentative de connexion est effectuée. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode se termine avec succès de la tentative de connexion. Le `buffer` paramètre de cette surcharge contient les données qui a été reçues dans l’appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A> et `bytesTransferred` paramètre contient le nombre d’octets qui ont été transférés dans l’appel.  
  
 Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode se bloque jusqu'à ce qu’une connexion est en attente dans la file d’attente de connexion entrante. Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode accepte la connexion entrante et retourne un nouvel <xref:System.Net.Sockets.Socket> qui peut être utilisé pour envoyer des données et recevoir des données à partir de l’hôte distant.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.Socket.BeginAccept%2A> pour créer et connecter un socket et accepte les 10 premiers octets de données. Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndAccept%2A> à la fin de la demande asynchrone. Le nombre d’octets transmis et les données sont retournées dans le `buffer` et `bytesTransferred` paramètres de cette méthode et sont affichés dans la console.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est vide.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> a été appelée au préalable.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite lors de la tentative d’accès à <see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état pour cette opération asynchrone ainsi que toutes les données définies par l'utilisateur.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état pour cette opération asynchrone ainsi que toutes les données définies par l'utilisateur.</param>
        <summary>Accepte de manière asynchrone une tentative de connexion entrante et crée un nouveau <see cref="T:System.Net.Sockets.Socket" /> pour gérer les communications de l'hôte distant.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> pour gérer la communication avec l'hôte distant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> termine un appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Avant d’appeler <xref:System.Net.Sockets.Socket.BeginAccept%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après la <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode retourne. Elle doit accepter le `asyncResult` paramètre retourné à partir de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la `asyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.Socket> sur lequel la tentative de connexion est effectuée. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode se termine avec succès de la tentative de connexion.  
  
 Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode se bloque jusqu'à ce qu’une connexion est en attente dans la file d’attente de connexion entrante. Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode accepte la connexion entrante et retourne un nouvel <xref:System.Net.Sockets.Socket> qui peut être utilisé pour envoyer des données et recevoir des données à partir de l’hôte distant.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant met fin à une demande asynchrone et crée un nouveau <xref:System.Net.Sockets.Socket> pour accepter une demande de connexion entrante. Pour obtenir un exemple complet illustrant des communications asynchrones avec les sockets, consultez [exemples de Code de Socket](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Pour plus d'informations, consultez la section Notes.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> a été appelée au préalable.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT est requis pour cette méthode.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les octets transférés.</param>
        <param name="bytesTransferred">Nombre d'octets transférés.</param>
        <param name="asyncResult">Objet <see cref="T:System.IAsyncResult" /> qui stocke les informations d'état pour cette opération asynchrone ainsi que toutes les données définies par l'utilisateur.</param>
        <summary>Accepte de manière asynchrone une tentative de connexion entrante et crée un nouvel objet <see cref="T:System.Net.Sockets.Socket" /> pour gérer les communications de l'hôte distant. Cette méthode retourne une mémoire tampon qui contient les données initiales et le nombre d'octets transférés.</summary>
        <returns>Objet <see cref="T:System.Net.Sockets.Socket" /> pour gérer la communication avec l'hôte distant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> termine un appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Avant d’appeler <xref:System.Net.Sockets.Socket.BeginAccept%2A>, vous devez créer une méthode de rappel qui est appelée par le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après la <xref:System.Net.Sockets.Socket.BeginAccept%2A> méthode retourne. Elle doit accepter le `asyncResult` paramètre retourné à partir de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> (méthode).  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la `asyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.Socket> sur lequel la tentative de connexion est effectuée. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode se termine avec succès de la tentative de connexion. Le `buffer` paramètre de cette surcharge contient les données qui a été reçues dans l’appel à <xref:System.Net.Sockets.Socket.BeginAccept%2A> et `bytesTransferred` paramètre contient le nombre d’octets qui ont été transférés dans l’appel.  
  
 Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode se bloque jusqu'à ce qu’une connexion est en attente dans la file d’attente de connexion entrante. Le <xref:System.Net.Sockets.Socket.EndAccept%2A> méthode accepte la connexion entrante et retourne un nouvel <xref:System.Net.Sockets.Socket> qui peut être utilisé pour envoyer des données et recevoir des données à partir de l’hôte distant.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.Socket.BeginAccept%2A> pour créer et connecter un socket et accepte les 10 premiers octets de données. Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndAccept%2A> à la fin de la demande asynchrone. Le nombre d’octets transmis et les données sont retournées dans le `buffer` et `bytesTransferred` paramètres de cette méthode et sont affichés dans la console.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est vide.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> a été appelée au préalable.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès à <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <summary>Met fin à une demande de connexion asynchrone en attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> est une méthode de blocage qui se termine la demande de connexion d’hôte distant asynchrone démarrée la <xref:System.Net.Sockets.Socket.BeginConnect%2A> (méthode).  
  
 Avant d’appeler <xref:System.Net.Sockets.Socket.BeginConnect%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginConnect%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginConnect%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir le <xref:System.Net.Sockets.Socket> sur lequel la tentative de connexion est effectuée. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndConnect%2A> méthode se termine avec succès de la tentative de connexion.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant met fin à la tentative de connexion asynchrone. Pour obtenir un exemple complet illustrant des communications asynchrones avec les sockets, consultez [exemples de Code de Socket](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> a été précédemment appelé pour la connexion asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objet <see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <summary>Met fin à une demande de déconnexion asynchrone en attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> termine un appel à <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. Le <xref:System.Net.Sockets.Socket.EndDisconnect%2A> méthode se bloque jusqu'à la fin de la déconnexion. Pour plus d’informations sur les opérations asynchrones, consultez la rubrique de vue d’ensemble de programmation asynchrone dans la bibliothèque MSDN.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un socket pour la communication asynchrone et envoie des données à un hôte distant. Lorsque les données ont été envoyées, <xref:System.Net.Sockets.Socket.Shutdown%2A> est appelée pour arrêter l’envoi et l’activité de réception. Puis <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> est appelé pour lancer une demande de déconnexion. Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndDisconnect%2A> à la fin de la demande asynchrone. Lorsque la demande est terminée, le <xref:System.Net.Sockets.Socket.Connected%2A> propriété est interrogée pour tester si le socket est déconnecté.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> a été précédemment appelé pour la connexion asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.Net.WebException">La demande de déconnexion a expiré.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met fin à une lecture asynchrone en attente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <summary>Met fin à une lecture asynchrone en attente.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode termine l’opération de lecture asynchrone démarrée la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode).  
  
 Avant d’appeler <xref:System.Net.Sockets.Socket.BeginReceive%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginReceive%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginReceive%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode). Extraire la réception <xref:System.Net.Sockets.Socket> à partir de cet objet d’état. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.  
  
 Le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode se bloque jusqu'à ce que les données sont disponibles. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndReceive%2A> lira le premier datagramme en file d’attente disponible dans la mémoire tampon réseau entrante. Si vous utilisez un protocole orienté connexion, le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode). Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult>et extrayez la mémoire tampon contenue dans l’objet d’état qui en résulte.  
  
 Pour annuler un en attente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, appelez le <xref:System.Net.Sockets.Socket.Close%2A> (méthode).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant met fin à une lecture asynchrone en attente. Pour obtenir un exemple complet illustrant des communications asynchrones avec les sockets, consultez [exemples de Code de Socket](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> a été précédemment appelé pour la lecture asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <summary>Met fin à une lecture asynchrone en attente.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode termine l’opération de lecture asynchrone démarrée la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode).  
  
 Avant d’appeler <xref:System.Net.Sockets.Socket.BeginReceive%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginReceive%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginReceive%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode). Extraire la réception <xref:System.Net.Sockets.Socket> à partir de cet objet d’état. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.  
  
 Le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode se bloque jusqu'à ce que les données sont disponibles. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndReceive%2A> lira le premier datagramme en file d’attente disponible dans la mémoire tampon réseau entrante. Si vous utilisez un protocole orienté connexion, le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.Socket.BeginReceive%2A> (méthode). Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.EndReceive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult>et extrayez la mémoire tampon contenue dans l’objet d’état qui en résulte.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> a été précédemment appelé pour la lecture asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <param name="endPoint"><see cref="T:System.Net.EndPoint" /> source.</param>
        <param name="end_point"><see cref="T:System.Net.EndPoint" /> source.</param>
        <summary>Met fin à une lecture asynchrone en attente à partir d'un point de terminaison spécifique.</summary>
        <returns>En cas de réussite, nombre d'octets reçus. En cas d'échec, retourne 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode termine l’opération de lecture asynchrone démarrée la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode).  
  
 Avant d’appeler <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode). Extraire la réception <xref:System.Net.Sockets.Socket> à partir de cet objet d’état. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.  
  
 Le <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> lira le premier datagramme en file d’attente disponible dans la mémoire tampon réseau entrante. Si vous utilisez un protocole orienté connexion, le <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (méthode). Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> méthode terminer immédiatement et retournera zéro octet. Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> de l’objet et extrayez la mémoire tampon contenue dans l’objet d’état qui en résulte. Pour identifier l’hôte d’origine, vous devez extraire le <xref:System.Net.EndPoint> et effectuer un cast en un <xref:System.Net.IPEndPoint>. Utilisez le <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> méthode pour obtenir l’adresse IP et le <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> méthode pour obtenir le numéro de port.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant met fin à une lecture asynchrone en attente à partir d’un spécifique <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> a été précédemment appelé pour la lecture asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" /> pour le paquet reçu.</param>
        <param name="endPoint"><see cref="T:System.Net.EndPoint" /> source.</param>
        <param name="ipPacketInformation"><see cref="T:System.Net.IPAddress" /> et interface du paquet reçu.</param>
        <summary>Met fin à une lecture asynchrone en attente à partir d'un point de terminaison spécifique. Cette méthode révèle également davantage d'informations sur le paquet que <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>En cas de réussite, nombre d'octets reçus. En cas d'échec, retourne 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas.  
  
 Pour effectuer cette opération de façon synchrone, utilisez la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> (méthode).  
  
 Examinez `ipPacketInformation` si vous avez besoin de savoir si le datagramme a été envoyé à l’aide d’une adresse de multidiffusion ou de diffusion, de monodiffusion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.  
  
ou 
 <paramref name="endPoint" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> a été précédemment appelé pour la lecture asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met fin à un envoi asynchrone en attente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> stockant les informations d'état de cette demande asynchrone.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> stockant les informations d'état de cette demande asynchrone.</param>
        <summary>Met fin à un envoi asynchrone en attente.</summary>
        <returns>En cas de réussite, nombre d'octets envoyés à <see cref="T:System.Net.Sockets.Socket" /> ; sinon, erreur de <see cref="T:System.Net.Sockets.Socket" /> non valide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> termine l’opération d’envoi asynchrone démarrée <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginSend%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir de l’envoi <xref:System.Net.Sockets.Socket>. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.  
  
 Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloque jusqu'à ce que le datagramme est envoyé. Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloque jusqu'à ce que la mémoire tampon a été envoyée. Si la valeur de retour à partir de <xref:System.Net.Sockets.Socket.EndSend%2A> indique que la mémoire tampon n’a pas complètement envoyée, appelez le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode là encore, la modification de la mémoire tampon pour stocker les données non envoyées.  
  
 Il n’existe aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant met fin à un envoi asynchrone en attente.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> a été précédemment appelé pour l'envoi asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> stockant les informations d'état de cette demande asynchrone.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <summary>Met fin à un envoi asynchrone en attente.</summary>
        <returns>En cas de réussite, nombre d'octets envoyés à <see cref="T:System.Net.Sockets.Socket" /> ; sinon, erreur de <see cref="T:System.Net.Sockets.Socket" /> non valide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> termine l’opération d’envoi asynchrone démarrée <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Avant d’appeler <xref:System.Net.Sockets.Socket.BeginSend%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginSend%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir de l’envoi <xref:System.Net.Sockets.Socket>. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndSend%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.  
  
 Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloque jusqu'à ce que le datagramme est envoyé. Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloque jusqu'à ce que la mémoire tampon a été envoyée. Si la valeur de retour à partir de <xref:System.Net.Sockets.Socket.EndSend%2A> indique que la mémoire tampon n’a pas complètement envoyée, appelez le <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode là encore, la modification de la mémoire tampon pour stocker les données non envoyées.  
  
 Il n’existe aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.BeginSend%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Toutes les e/s initié par un thread donné est annulée lors de la sortie du thread. Une opération asynchrone en attente peut échouer si le thread se termine avant la fin de l’opération.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> a été précédemment appelé pour l'envoi asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objet <see cref="T:System.IAsyncResult" /> stockant les informations d'état de cette opération asynchrone.</param>
        <summary>Met fin à un envoi asynchrone en attente d'un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> termine l’opération d’envoi asynchrone démarrée <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Avant d’appeler <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginSendFile%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> objet retourné par la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir de l’envoi <xref:System.Net.Sockets.Socket>. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndSendFile%2A> méthode se termine avec succès l’opération d’envoi.  
  
 Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloque jusqu'à ce que le datagramme est envoyé. Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloque jusqu'à ce que le fichier entier est envoyé. Il n’existe aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée et connecte à un socket pour la communication asynchrone et commence à envoyer le fichier « text.txt » en mode asynchrone à l’hôte distant. Le délégué de rappel appelle <xref:System.Net.Sockets.Socket.EndSendFile%2A> pour terminer la transmission.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est vide.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> a été précédemment appelé pour <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui stocke des informations d'état et toutes les données définies par l'utilisateur pour cette opération asynchrone.</param>
        <summary>Met fin à un envoi asynchrone en attente vers un emplacement spécifique.</summary>
        <returns>En cas de réussite, nombre d'octets envoyés ; sinon, erreur de <see cref="T:System.Net.Sockets.Socket" /> non valide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> termine l’opération d’envoi asynchrone démarrée <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Avant d’appeler <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.Socket.BeginReceive%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné par la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> méthode de la <xref:System.IAsyncResult> paramètre pour obtenir de l’envoi <xref:System.Net.Sockets.Socket>. Après avoir obtenu le <xref:System.Net.Sockets.Socket>, vous pouvez appeler la <xref:System.Net.Sockets.Socket.EndSendTo%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.  
  
 Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.EndSendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé. Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.EndSendTo%2A> se bloque jusqu'à ce que le nombre demandé d’octets est envoyé. Il n’existe aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant met fin à un envoi asynchrone vers un emplacement spécifique.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> a été précédemment appelé pour l'envoi asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> n'autorise qu'un seul processus à se lier à un port.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> n'autorise qu'un seul socket à se lier à un port spécifique ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" /> pour Windows Server 2003 et Windows XP Service Pack 2, et <see langword="false" /> pour toutes les autres versions.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> est `false`, plusieurs sockets peuvent utiliser la <xref:System.Net.Sockets.Socket.Bind%2A> méthode à laquelle lier à un port spécifique ; mais un seul des sockets peut effectuer des opérations sur le trafic réseau envoyé au port. Si plus d’un socket tente d’utiliser le <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> méthode à lier à un port particulier, puis un avec l’adresse IP plus spécifique gère le trafic réseau envoyé à ce port.  
  
 Si <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> est `true`, la première utilisation de la <xref:System.Net.Sockets.Socket.Bind%2A> méthode tente de lier à un port particulier, quel que soit l’adresse IP (Internet Protocol), réussit ; toutes les utilisations de la <xref:System.Net.Sockets.Socket.Bind%2A> méthode à essayer de se lier à ce port sera échouer jusqu'à ce que le socket lié d’origine est détruit.  
  
 Cette propriété doit être définie avant <xref:System.Net.Sockets.Socket.Bind%2A> est appelée ; sinon un <xref:System.InvalidOperationException> sera levée.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> a été appelé pour ce <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par la classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket> classe finaliseur appelle le <xref:System.Net.Sockets.Socket.Close%2A> méthode pour fermer le <xref:System.Net.Sockets.Socket> et libérer les ressources associées à la <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur de hachage pour une instance de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Valeur de hachage entier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
La méthode GetHashCode retourne un code de hachage de cette instance. Cette valeur peut être utilisée en tant que clé dans les tables de hachage.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la valeur d'une option <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <summary>Retourne la valeur d'une option <see cref="T:System.Net.Sockets.Socket" /> spécifiée, représentée sous la forme d'un objet.</summary>
        <returns>Objet représentant la valeur de l'option. Si le paramètre <paramref name="optionName" /> a la valeur du champ <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, la valeur de retour est une instance de la classe <see cref="T:System.Net.Sockets.LingerOption" />. Si <paramref name="optionName" /> a la valeur du champ <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> ou <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, la valeur de retour est une instance de la classe <see cref="T:System.Net.Sockets.MulticastOption" />. Si <paramref name="optionName" /> a une autre valeur, la valeur de retour est un entier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> options déterminent le comportement de l’actuel <xref:System.Net.Sockets.Socket>. Utilisez cette surcharge pour obtenir le <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, et <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> options. Pour le <xref:System.Net.Sockets.SocketOptionName.Linger> , utilisez l’option <xref:System.Net.Sockets.Socket> pour le `optionLevel` paramètre. Pour <xref:System.Net.Sockets.SocketOptionName.AddMembership> et <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilisez <xref:System.Net.Sockets.SocketOptionLevel.IP>. Si vous souhaitez définir la valeur d’une des options ci-dessus, utilisez la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple récupère le <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> valeurs de délai d’attente et les affiche dans la console.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.  
  
ou 
 <paramref name="optionName" /> avait la valeur <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> non prise en charge.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Tableau de type <see cref="T:System.Byte" /> devant recevoir la valeur de l'option.</param>
        <summary>Retourne la valeur de l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée sous la forme d'un tableau d'octets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> options déterminent le comportement de l’actuel <xref:System.Net.Sockets.Socket>. En cas de réussite de cette méthode, le tableau spécifié par le `optionValue` paramètre contient la valeur de l’objet <xref:System.Net.Sockets.Socket> option.  
  
 Lorsque la longueur de la `optionValue` tableau est inférieure au nombre d’octets requis pour stocker la valeur de l’objet <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur. Utilisez cette surcharge pour tous les sockets qui sont représentés par des valeurs booléennes ou des entiers.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple récupère le <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> valeurs de délai d’attente et les affiche dans la console.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.  
  
ou 
Dans les applications .NET Compact Framework, l'espace de mémoire tampon par défaut de Windows CE est de 32 768 octets. Vous pouvez modifier l'espace de mémoire tampon de chaque socket en appelant <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionLength">Longueur (en octets) de la valeur de retour attendue.</param>
        <summary>Retourne la valeur de l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée dans un tableau.</summary>
        <returns>Tableau de type <see cref="T:System.Byte" /> contenant la valeur de l'option de socket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `optionLength` paramètre définit la taille maximale du tableau d’octets retourné. Si la valeur de l’option nécessite moins d’octets, le tableau contient uniquement le nombre d’octets. Si la valeur de l’option nécessite davantage d’octets, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Utilisez cette surcharge pour tous les sockets qui sont représentés par des valeurs booléennes ou des entiers.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple récupère le <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> valeurs de délai d’attente et les affiche dans la console.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.  
  
ou 
Dans les applications .NET Compact Framework, l'espace de mémoire tampon par défaut de Windows CE est de 32 768 octets. Vous pouvez modifier l'espace de mémoire tampon de chaque socket en appelant <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle du système d'exploitation pour <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value><see cref="T:System.IntPtr" /> qui représente le handle du système d'exploitation pour <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit les modes de fonctionnement de bas niveau de <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Valeur <see cref="T:System.Int32" /> qui spécifie le code de contrôle de l'opération à exécuter.</param>
        <param name="optionInValue">Tableau <see cref="T:System.Byte" /> contenant les données d'entrée requises par l'opération.</param>
        <param name="optionOutValue">Tableau <see cref="T:System.Byte" /> contenant les données de sortie retournées par l'opération.</param>
        <summary>Définit les modes de fonctionnement de bas niveau de <see cref="T:System.Net.Sockets.Socket" /> à l'aide de codes de contrôle numériques.</summary>
        <returns>Nombre d'octets dans le paramètre <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.IOControl%2A> méthode fournit un accès de bas niveau du système d’exploitation <xref:System.Net.Sockets.Socket> sous-jacent de l’instance actuelle de la <xref:System.Net.Sockets.Socket> classe. Pour plus d’informations, consultez la documentation de WSAIoctl dans MSDN library.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant compare les résultats de FIONREAD et la propriété disponible.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative de modification du mode blocage sans utiliser la propriété <see cref="P:System.Net.Sockets.Socket.Blocking" /> a été effectuée.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour exécuter du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Valeur <see cref="T:System.Net.Sockets.IOControlCode" /> qui spécifie le code de contrôle de l'opération à exécuter.</param>
        <param name="optionInValue">Tableau de type <see cref="T:System.Byte" /> contenant les données d'entrée requises par l'opération.</param>
        <param name="optionOutValue">Tableau de type <see cref="T:System.Byte" /> contenant les données de sortie retournées par l'opération.</param>
        <summary>Définit les modes de fonctionnement de bas niveau de <see cref="T:System.Net.Sockets.Socket" /> à l'aide de l'énumération <see cref="T:System.Net.Sockets.IOControlCode" /> afin de spécifier les codes de contrôle.</summary>
        <returns>Nombre d'octets dans le paramètre <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit un accès de bas niveau du système d’exploitation <xref:System.Net.Sockets.Socket> sous-jacent de l’instance actuelle de la <xref:System.Net.Sockets.Socket> classe. Pour plus d’informations, consultez la documentation de WSAIoctl dans MSDN library.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant compare les résultats de l’appel <xref:System.Net.Sockets.Socket.IOControl%2A> avec <xref:System.Net.Sockets.IOControlCode.DataToRead> et <xref:System.Net.Sockets.Socket.Available%2A> propriété.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative de modification du mode blocage sans utiliser la propriété <see cref="P:System.Net.Sockets.Socket.Blocking" /> a été effectuée.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour exécuter du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Net.Sockets.Socket" /> est lié à un port local spécifique.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> est lié à un port local ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un socket est considéré comme lié à un port local s’il est lié explicitement en appelant le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), ou lié implicitement en appelant des membres tels que <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, qui utilisent un port local éphémère (port libre supérieur à 1024, sélectionné par le système d’exploitation.) Les serveurs utilisent la <xref:System.Net.Sockets.Socket.Bind%2A> méthode pour lier à un port connu afin que les clients peuvent se connecter à leur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.IsBound%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si <see cref="T:System.Net.Sockets.Socket" /> doit différer la fermeture d'un socket lors d'une tentative d'envoi de l'ensemble des données en attente.</summary>
        <value><see cref="T:System.Net.Sockets.LingerOption" /> qui spécifie comment maintenir un socket lors de sa fermeture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.LingerState%2A> propriété modifie la façon dont <xref:System.Net.Sockets.Socket.Close%2A> méthode se comporte. Cette propriété lors de l’ensemble modifie les conditions sous lesquelles la connexion peut être réinitialisée à Winsock. Réinitialisations de connexion peuvent encore se produire en fonction du comportement de protocole IP.  
  
 Cette propriété contrôle la durée pendant laquelle une connexion orientée connexion restera ouverte après un appel à <xref:System.Net.Sockets.Socket.Close%2A> lorsqu’il reste des données à envoyer.  
  
 Lorsque vous appelez des méthodes pour envoyer des données à un homologue, ces données sont placées dans le tampon réseau sortant. Cette propriété peut être utilisée pour vous assurer que ces données sont envoyées à l’hôte distant avant le <xref:System.Net.Sockets.TcpClient.Close%2A> méthode annule la connexion.  
  
 Pour activer le maintien, créez un <xref:System.Net.Sockets.LingerOption> de l’instance qui contient les valeurs souhaitées, puis définissez le <xref:System.Net.Sockets.Socket.LingerState%2A> propriété à cette instance.  
  
 Le tableau suivant décrit le comportement de la <xref:System.Net.Sockets.Socket.Close%2A> méthode pour les valeurs possibles de la <xref:System.Net.Sockets.LingerOption.Enabled%2A> propriété et la <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété stockée dans le <xref:System.Net.Sockets.Socket.LingerState%2A> propriété.  
  
|LingerState.Enabled|LingerState.LingerTime|Comportement|  
|-------------------------|----------------------------|--------------|  
|`false` (désactivé), la valeur par défaut|Le délai d’attente n’est pas applicable, (par défaut).|Essaie d’envoyer les données en attente jusqu'à ce que le délai expire.|  
|`true` (activé)|Un délai d’expiration différent de zéro|Essaie d’envoyer les données en attente jusqu'à ce que le délai spécifié expire et si la tentative échoue, Winsock réinitialise la connexion.|  
|`true` (activé)|Un délai d’attente nulle.|Ignore toutes les données en attente. Pour un socket orienté connexion (TCP, par exemple), Winsock réinitialise la connexion.|  
  
 La pile IP calcule le délai par défaut protocole IP à utiliser en fonction du temps d’aller-retour de la connexion. Dans la plupart des cas, le délai d’attente calculé par la pile est plus pertinent que celui défini par une application. Il s’agit du comportement par défaut pour un socket lors de la <xref:System.Net.Sockets.Socket.LingerState%2A> propriété n’est pas définie.  
  
 Lorsque le <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété stockée dans le <xref:System.Net.Sockets.Socket.LingerState%2A> propriété est supérieure au délai de protocole IP par défaut, le délai de protocole IP par défaut sera toujours s’appliquent et remplacent.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.LingerState%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Longueur maximale de la file d'attente des connexions en attente.</param>
        <summary>Met <see cref="T:System.Net.Sockets.Socket" /> dans un état d'écoute.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> provoque orienté connexion <xref:System.Net.Sockets.Socket> pour écouter les tentatives de connexion entrante. Le `backlog` paramètre spécifie le nombre de connexions entrantes qui peut être en file d’attente d’acceptation. Pour déterminer le nombre maximal de connexions que vous pouvez spécifier, récupérez le <xref:System.Net.Sockets.SocketOptionName.MaxConnections> valeur. <xref:System.Net.Sockets.Socket.Listen%2A> ne bloque pas.  
  
 Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur. Utilisez <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> pour accepter une connexion à partir de la file d’attente.  
  
> [!NOTE]
>  Vous devez appeler la <xref:System.Net.Sockets.Socket.Bind%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.Listen%2A>, ou <xref:System.Net.Sockets.Socket.Listen%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Le paramètre de backlog est limité à des valeurs différentes selon le système d’exploitation. Vous pouvez spécifier une valeur plus élevée, mais le backlog sera limité en fonction du système d’exploitation.  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.Socket> pour écouter les connexions entrantes.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le point de terminaison local.</summary>
        <value><see cref="T:System.Net.EndPoint" /> que <see cref="T:System.Net.Sockets.Socket" /> utilise pour les communications.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété obtient un <xref:System.Net.EndPoint> qui contient le local IP adresse et numéro de port auquel votre <xref:System.Net.Sockets.Socket> est lié. Vous devez effectuer un cast <xref:System.Net.EndPoint> à un <xref:System.Net.IPEndPoint> avant la récupération de toutes les informations. Vous pouvez ensuite appeler la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> méthode pour récupérer l’ordinateur local <xref:System.Net.IPAddress>et le <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> méthode pour récupérer le numéro de port local.  
  
 Le <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété est généralement définie une fois que vous effectuez un appel à la <xref:System.Net.Sockets.Socket.Bind%2A> (méthode). Si vous autorisez le système affecter l’adresse IP locale de votre socket et le numéro de port, le <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété sera définie après la première opération d’e/s. Pour les protocoles orientés connexion, la première opération d’e/s serait un appel à la <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Pour les protocoles sans connexion, la première opération d’e/s serait s’agir de l’envoyer ou recevoir des appels.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant récupère et affiche les points de terminaison locaux et distants.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur spécifiant si les paquets multicast sortants sont remis à l'application émettrice.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> reçoit les paquets multicast sortants ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La multidiffusion est une méthode évolutive pour la communication de type plusieurs-à-plusieurs sur Internet. Un processus s’abonne à une adresse de multidiffusion ; Ensuite, tous les paquets envoyés par un processus abonné sont reçus par chaque autre processus abonné à l’adresse de multidiffusion.  
  
 Définition de cette propriété sur un socket de protocole TCP (Transmission Control) n’aura aucun effet.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> spécifiant si le flux de données <see cref="T:System.Net.Sockets.Socket" /> utilise l'algorithme Nagle.</summary>
        <value><see langword="false" /> si <see cref="T:System.Net.Sockets.Socket" /> utilise l'algorithme Nagle ; sinon, <see langword="true" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’algorithme Nagle est conçu pour réduire le trafic réseau en obligeant le socket à mettre en mémoire tampon petits paquets et de combiner et de les envoyer dans un seul paquet dans certaines circonstances. Un paquet TCP se compose de 40 octets d’en-tête plus les données envoyées. Lorsque de petits paquets de données sont envoyés avec TCP, la surcharge résultant de l’en-tête TCP peut devenir une partie significative du trafic réseau. Sur les réseaux très chargés, la congestion résultant de cette surcharge peut entraîner de perte de datagrammes et retransmissions, ainsi que les temps de propagation excessive provoquée par la congestion. L’algorithme Nagle empêche l’émission de nouvelles TCP segmentswhen nouveau les données sortantes arrivent à partir de l’utilisateur si toutes les données sur la connexion restent sans accusé de réception.  
  
 La majorité des applications réseau doit utiliser l’algorithme Nagle.  
  
 Définition de cette propriété sur un socket de protocole UDP (User Datagram) n’aura aucun effet.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.NoDelay%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès à <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si le système d'exploitation et les cartes réseau sous-jacents prennent en charge le protocole IPv4 (Internet Protocol version 4).</summary>
        <value><see langword="true" /> si le système d'exploitation et les cartes réseau prennent en charge le protocole IPv4 ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si le système d'exploitation et les cartes réseau sous-jacents prennent en charge le protocole IPv6 (Internet Protocol version 6).</summary>
        <value><see langword="true" /> si le système d'exploitation et les cartes réseau prennent en charge le protocole IPv6 ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Temps d'attente (en microsecondes) d'une réponse.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Net.Sockets.SelectMode" />.</param>
        <summary>Détermine l'état de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>État du <see cref="T:System.Net.Sockets.Socket" /> basé sur la valeur de mode d'appel passée dans le paramètre <paramref name="mode" />.  
  
 <list type="table"><listheader><term> Mode 
 </term><description> Valeur de retour 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> si la méthode <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> a été appelée et si une connexion est en attente ; 
ou 
 <see langword="true" /> si des données sont disponibles pour la lecture ; 
ou 
 <see langword="true" /> si la connexion a été fermée, réinitialisée ou terminée ; 
sinon, retourne <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" /> si une méthode <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> a été utilisée et si la connexion a abouti ; 
ou 
 <see langword="true" /> si des données peuvent être envoyées ; 
sinon, retourne <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" /> si une méthode <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> sans blocage a été utilisée et si la connexion a échoué ; 
ou 
 <see langword="true" /> si le champ <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> n'est pas défini et si des données hors bande sont disponibles ; 
sinon, retourne <see langword="false" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.Poll%2A> méthode vérifie l’état de la <xref:System.Net.Sockets.Socket>. Spécifiez <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> pour le `selectMode` paramètre pour déterminer si le <xref:System.Net.Sockets.Socket> est lisible. Spécifiez <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> pour déterminer si le <xref:System.Net.Sockets.Socket> est accessible en écriture. Utilisez <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> pour détecter une condition d’erreur. <xref:System.Net.Sockets.Socket.Poll%2A> bloque l’exécution jusqu'à ce que la période spécifiée, mesurée en `microseconds`, s’écoule. Définir le `microSeconds` paramètre à un entier négatif si vous souhaitez que d’attendre indéfiniment une réponse. Si vous souhaitez vérifier l’état de plusieurs sockets, vous préférerez peut-être utiliser le <xref:System.Net.Sockets.Socket.Select%2A> (méthode).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Cette méthode ne peut pas détecter certains types de problèmes de connexion, comme un câble réseau rompu, ou que l’hôte distant a été arrêté de manière anormale. Vous devez tenter d’envoyer ou recevoir des données pour détecter ces types d’erreurs.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un socket, se connecte à un serveur et utilise <xref:System.Net.Sockets.Socket.Poll%2A> pour vérifier l’état du socket.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le paramètre <paramref name="mode" /> ne fait pas partie des valeurs <see cref="T:System.Net.Sockets.SelectMode" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de protocole de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Une des valeurs de <see cref="T:System.Net.Sockets.ProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.ProtocolType%2A> propriété est définie lorsque le <xref:System.Net.Sockets.Socket> est créé et spécifie le protocole utilisé par cet <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Le code suivant exemple affiche le <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, et <xref:System.Net.Sockets.ProtocolType> à la console.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reçoit des données d'un <see cref="T:System.Net.Sockets.Socket" /> lié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <summary>Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans une mémoire tampon de réception.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus avec succès. Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.  
  
 Cette surcharge nécessite uniquement de fournir un mémoire tampon de réception. Valeur par défaut est 0, les valeurs par défaut de taille à la longueur du paramètre de mémoire tampon, offset de mémoire tampon et la <xref:System.Net.Sockets.SocketFlags> valeur par défaut, <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>. Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données provenant de l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Si vous utilisez orienté connexion <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données est disponible, jusqu'à la taille de la mémoire tampon. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Si vous utilisez un sans connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode). Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est renseigné avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant reçoit des données sur un connecté <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Liste des <see cref="T:System.ArraySegment`1" />s de type <see cref="T:System.Byte" /> qui contient les données reçues.</param>
        <summary>Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans la liste des mémoires tampon de réception.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit les données dans le paramètre de mémoires tampons et retourne le nombre d’octets lus avec succès. Vous pouvez appeler à partir de sockets orientés connexion et sans connexion.  
  
 Cette surcharge vous oblige à fournir une ou plusieurs mémoires tampons de réception.  
  
 Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>. Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données provenant de la connexion de l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Si vous utilisez orienté connexion <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données est disponible, jusqu'à la taille de la mémoire tampon. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Si vous utilisez un sans connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode). Si le datagramme reçu est supérieur à la taille de la `buffers` paramètre, `buffers` est renseigné avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
 **Remarque** ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans une mémoire tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus avec succès. Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.  
  
 Cette surcharge seulement vous oblige à fournir un mémoire tampon de réception et nécessaires <xref:System.Net.Sockets.SocketFlags>. Offset de mémoire tampon par défaut 0, et la taille par défaut est la longueur du paramètre octets.  
  
 Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>. Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données provenant de l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles. Si vous êtes en mode non bloquant, et aucune donnée n’est disponible dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, réessayez votre opération de réception.  
  
 Si vous utilisez orienté connexion <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données est disponible jusqu'à la taille de la mémoire tampon. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Si vous utilisez un sans connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode). Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est renseigné avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant spécifie une mémoire tampon de données, et <xref:System.Net.Sockets.SocketFlags> pour recevoir des données sur un connecté <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Liste des <see cref="T:System.ArraySegment`1" />s de type <see cref="T:System.Byte" /> qui contient les données reçues.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans la liste des mémoires tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit les données dans le `buffers` paramètre et retourne le nombre d’octets lus avec succès. Vous pouvez appeler à partir de sockets orientés connexion et sans connexion.  
  
 Cette surcharge vous oblige à fournir une ou plusieurs mémoires tampons de réception. Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut, <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>. Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données provenant de la connexion de l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Receive%2A> appeler lève un <xref:System.Net.Sockets.SocketException>. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Si vous utilisez orienté connexion <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données est disponible, jusqu'à la taille de la mémoire tampon. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Si vous utilisez un sans connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode). Si le datagramme reçu est supérieur à la taille de la `buffers` paramètre, `buffers` est renseigné avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment recevoir des données sur un connecté <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> est <see langword="null" />.  
  
ou 
 <paramref name="buffers" />.Count est égal à zéro.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Reçoit le nombre spécifié d'octets de données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans une mémoire tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le `buffer` paramètre et retourne le nombre d’octets lus avec succès. Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.  
  
 Cette surcharge seulement vous oblige à fournir un mémoire tampon de réception, le nombre d’octets à recevoir et nécessaires <xref:System.Net.Sockets.SocketFlags>.  
  
 Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>. Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données provenant de l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, réessayez votre opération de réception.  
  
 Si vous utilisez orienté connexion <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Si vous utilisez un sans connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode). Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est renseigné avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple suivant reçoit les données se trouvant dans `buffer`et spécifie <xref:System.Net.Sockets.SocketFlags.None> pour <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> dépasse la taille de <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Liste des <see cref="T:System.ArraySegment`1" />s de type <see cref="T:System.Byte" /> qui contient les données reçues.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <summary>Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans la liste des mémoires tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit les données dans le `buffers` paramètre et retourne le nombre d’octets lus avec succès. Vous pouvez appeler à partir de sockets orientés connexion et sans connexion.  
  
 Cette surcharge vous oblige à fournir une ou plusieurs mémoires tampons de réception. Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut, <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>. Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données provenant de la connexion de l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Receive%2A> appeler lève un <xref:System.Net.Sockets.SocketException>. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Si vous utilisez orienté connexion <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données est disponible, jusqu'à la taille de la mémoire tampon. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Si vous utilisez un sans connexion <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode). Si le datagramme reçu est supérieur à la taille de la `buffers` paramètre, `buffers` est renseigné avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> est <see langword="null" />.  
  
ou 
 <paramref name="buffers" />.Count est égal à zéro.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</param>
        <param name="offset">Emplacement dans <paramref name="buffer" /> où stocker les données reçues.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Reçoit le nombre spécifié d'octets d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans la position d'offset spécifiée de la mémoire tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus avec succès. Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.  
  
 Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>. Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données provenant de l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Si vous utilisez orienté connexion <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données est disponible, jusqu’au nombre d’octets spécifié par le paramètre de taille. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Si vous utilisez un sans connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode). Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est renseigné avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant spécifie un tampon de données, un offset, une taille et un indicateur de socket avant de recevoir des données sur un connecté <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.  
  
ou 
La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'a pas été définie.  
  
ou 
Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="offset">La position dans le paramètre <paramref name="buffer" /> pour stocker les données reçues.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <summary>Reçoit les données d'un <see cref="T:System.Net.Sockets.Socket" /> lié dans une mémoire tampon de réception, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit les données dans le paramètre de mémoire tampon et retourne le nombre d’octets lus avec succès. Vous pouvez appeler <xref:System.Net.Sockets.Socket.Receive%2A> à partir de sockets orientés connexion et sans connexion.  
  
 Si vous utilisez un protocole orienté connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante avant d’appeler <xref:System.Net.Sockets.Socket.Receive%2A>. Le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit uniquement les données provenant de l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous utilisez un protocole sans connexion, vous pouvez également utiliser le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> vous permettra de recevoir des données en provenance de n’importe quel hôte.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se bloque jusqu'à ce que les données sont disponibles, sauf si une valeur de délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Receive%2A> appel lève une <xref:System.Net.Sockets.SocketException>. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Si vous utilisez orienté connexion <xref:System.Net.Sockets.Socket>, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lit autant de données est disponible, jusqu’au nombre d’octets spécifié par le paramètre de taille. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode terminer immédiatement et retournera zéro octet.  
  
 Si vous utilisez un sans connexion <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lira le premier datagramme en file d’attente à partir de l’adresse de destination que vous spécifiez dans le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode). Si le datagramme reçu est supérieur à la taille de la `buffer` paramètre, `buffer` est renseigné avec la première partie du message, les données excédentaires sont perdues et un <xref:System.Net.Sockets.SocketException> est levée.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.  
  
ou 
La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'est pas définie.  
  
ou 
Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Démarre une demande asynchrone pour recevoir les données d'un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> méthode est utilisée sur les sockets connectés ou les sockets sans connexion liés et est utilisée pour lire les données entrantes. Adresse locale du socket doit être connu.  
  
 Pour les sockets sans connexion liés, cette fonction restreint les adresses à partir de laquelle les messages reçus sont acceptés. La fonction retourne uniquement les messages à partir de l’adresse distante spécifiée dans la connexion. Messages à partir d’autres adresses sont ignorés.  
  
 Le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriété sur le `e` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur la demande de lecture. Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ou <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> a la valeur  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> a la valeur  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> (méthode), afin que les informations seront récupérables dans la méthode de rappel. Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.  
  
 Pour les sockets de style de flux d’octets, les données entrantes sont placées dans la mémoire tampon jusqu'à ce que la mémoire tampon est remplie, la connexion est fermée, ou les données en mémoire tampon en interne sont épuisées.  
  
 Pour les sockets orientés message, un message entrant est placé dans la mémoire tampon jusqu'à la taille totale de la mémoire tampon associée le `e` paramètre. Si le message est supérieur à la mémoire tampon, la mémoire tampon est remplie avec la première partie du message.  
  
 Pour les sockets orientés connexion, la <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> méthode peut indiquer l’arrêt normal du circuit virtuel de deux façons qui varient selon que le socket est orienté flux d’octets ou message. Pour les flux d’octets, zéro octets ayant été lus indique la fermeture sans perte de données et que plus aucun octet ne sera lu. Pour les sockets orientés message, où un zéro octet message est souvent autorisé, un <xref:System.Net.Sockets.SocketException> avec la <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> ensemble sur le code d’erreur Winsock WSAEDISCON natif (10101) est utilisé pour indiquer une fermeture sans perte de données. Dans tous les cas, un <xref:System.Net.Sockets.SocketException> avec le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> défini sur le WSAECONNRESET Winsock native code d’erreur (10054) indique que la fermeture s’est produite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argument n'était pas valide. La propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> ou <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> sur le paramètre de <paramref name="e" /> doit référencer des mémoires tampon valides. L'une ou l'autre de ces propriétés peut être définie, mais pas les deux à la fois.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur spécifiant la taille de la mémoire tampon de réception de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value><see cref="T:System.Int32" /> contenant la taille de la mémoire tampon de réception en octets. La valeur par défaut est 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une plus grande taille de mémoire tampon est potentiellement réduit le nombre d’accusés de réception vides (paquets TCP sans partie données), mais peut également retarder la reconnaissance des difficultés de connexion. Envisagez d’augmenter la taille de mémoire tampon si vous transférez des fichiers volumineux, ou si vous utilisez une bande passante élevée, la connexion d’une latence élevée (par exemple, un fournisseur large bande satellite).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée pour une opération ensembliste est inférieure à 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reçoit un datagramme et stocke le point de terminaison source.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</param>
        <summary>Reçoit un datagramme dans la mémoire tampon de données et stocke le point de terminaison.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données a été envoyées. Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs hôtes.  
  
 Cette surcharge seulement vous oblige à fournir une réception `buffer`et un <xref:System.Net.EndPoint> qui représente l’hôte distant. Offset de mémoire tampon par défaut 0. La taille par défaut est la longueur de la `buffer` paramètre et le `socketFlags` valeur par défaut, <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Avant d’appeler <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, vous devez lier explicitement le <xref:System.Net.Sockets.Socket> à un point de terminaison local en utilisant le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode). Si vous ne le faites pas, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Avec les protocoles sans connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local. Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole non fiable, les données excédentaires seront perdues. Si vous utilisez un protocole fiable, les données excédentaires sont retenues par le fournisseur de services et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode avec une mémoire tampon suffisant.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Bien que <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion. Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou accepter une distant entrantes connexion d’hôte en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous n’établissez ou accepter une connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode), vous obtiendrez un <xref:System.Net.Sockets.SocketException>. Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). Dans les deux cas, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et recevoir uniquement des données de la connecté ou hôte distant par défaut.  
  
 Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lit autant de données est disponible jusqu'à une taille de `buffer`. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode terminer immédiatement et retournera zéro octet.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l'emplacement de stockage pour les données reçues.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</param>
        <summary>Reçoit un datagramme dans la mémoire tampon de données à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié et stocke le point de terminaison.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données a été envoyées. Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs hôtes.  
  
 Cette surcharge seulement vous oblige à fournir une mémoire tampon de réception nécessaires <xref:System.Net.Sockets.SocketFlags>et un <xref:System.Net.EndPoint> qui représente l’hôte distant. Le décalage par défaut, 0 et les valeurs par défaut de taille à la longueur du paramètre de mémoire tampon.  
  
> [!NOTE]
>  Avant d’appeler <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, vous devez lier explicitement le <xref:System.Net.Sockets.Socket> à un point de terminaison local en utilisant le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode). Si vous ne le faites pas, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Avec les protocoles sans connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local. Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole non fiable, les données excédentaires seront perdues. Si vous utilisez un protocole fiable, les données excédentaires sont retenues par le fournisseur de services et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode avec une mémoire tampon suffisant.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Bien que <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion. Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou accepter une distant entrantes connexion d’hôte en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous n’établissez ou accepter une connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode), vous obtiendrez un <xref:System.Net.Sockets.SocketException>. Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). Dans les deux cas, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et recevoir uniquement des données de la connecté ou hôte distant par défaut.  
  
 Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lit autant de données est disponible jusqu'à une taille de `buffer`. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode terminer immédiatement et retournera zéro octet.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant. <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</param>
        <summary>Reçoit le nombre spécifié d'octets dans la mémoire tampon de données, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié et stocke le point de terminaison.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données a été envoyées. Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs hôtes.  
  
 Cette surcharge seulement vous oblige à fournir une mémoire tampon de réception, le nombre d’octets que vous souhaitez recevoir, nécessaires <xref:System.Net.Sockets.SocketFlags>et un <xref:System.Net.EndPoint> qui représente l’hôte distant. Offset de mémoire tampon par défaut 0.  
  
 Avec les protocoles sans connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local. Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole non fiable, les données excédentaires seront perdues. Si vous utilisez un protocole fiable, les données excédentaires sont retenues par le fournisseur de services et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode avec une mémoire tampon suffisant.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Bien que <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion. Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou accepter une distant entrantes connexion d’hôte en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous n’établissez ou accepter une connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode), vous obtiendrez un <xref:System.Net.Sockets.SocketException>. Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). Dans les deux cas, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et recevoir uniquement des données de la connecté ou hôte distant par défaut.  
  
 Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lit autant de données est disponible jusqu’au nombre d’octets spécifié par le `size` paramètre. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode terminer immédiatement et retournera zéro octet.  
  
> [!NOTE]
>  Avant d’appeler <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, vous devez lier explicitement le <xref:System.Net.Sockets.Socket> à un point de terminaison local en utilisant le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode). Si vous ne le faites pas, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant. La taille du tampon, et <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.  
  
ou 
La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'a pas été définie.  
  
ou 
Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</param>
        <param name="offset">La position dans le paramètre <paramref name="buffer" /> pour stocker les données reçues.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</param>
        <summary>Reçoit le nombre d’octets de données spécifié dans l’emplacement de la mémoire tampon spécifié à l’aide des <see cref="T:System.Net.Sockets.SocketFlags" /> et stocke le point de terminaison.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle les données a été envoyées. Cette méthode est utile si vous souhaitez recevoir des datagrammes sans connexion à partir d’un hôte inconnu ou de plusieurs hôtes.  
  
 Avec les protocoles sans connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lira le premier datagramme en file d’attente reçu dans la mémoire tampon de réseau local. Si le datagramme reçu est supérieur à la taille de `buffer`, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode remplira `buffer` avec autant de messages et lève un <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole non fiable, les données excédentaires seront perdues. Si vous utilisez un protocole fiable, les données excédentaires sont retenues par le fournisseur de services et vous pouvez le récupérer en appelant le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode avec une mémoire tampon suffisant.  
  
 Si aucune donnée n’est disponible pour la lecture, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se bloque jusqu'à ce que les données sont disponibles. Si vous êtes en mode non bloquant, et aucune donnée disponible dans le dans le tampon de pile de protocole, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode se termine immédiatement et lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.Available%2A> propriété afin de déterminer si les données sont disponibles pour la lecture. Lorsque <xref:System.Net.Sockets.Socket.Available%2A> est différente de zéro, recommencez l’opération de réception.  
  
 Bien que <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> est destiné aux protocoles sans connexion, vous pouvez utiliser un protocole orienté connexion. Si vous choisissez pour ce faire, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou accepter une distant entrantes connexion d’hôte en appelant le <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous n’établissez ou accepter une connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode), vous obtiendrez un <xref:System.Net.Sockets.SocketException>. Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode). Dans les deux cas, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode ignore la `remoteEP` paramètre et recevoir uniquement des données de la connecté ou hôte distant par défaut.  
  
 Avec des sockets orientés connexion, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lit autant de données est disponible jusqu'à la quantité d’octets spécifié par le `size` paramètre. Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion avec le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode) et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> méthode terminer immédiatement et retournera zéro octet.  
  
> [!NOTE]
>  Avant d’appeler <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, vous devez lier explicitement le <xref:System.Net.Sockets.Socket> à un point de terminaison local en utilisant le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode). Si vous ne le faites pas, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant reçoit un datagramme sans connexion à partir d’un hôte distant. Le décalage, la taille de la mémoire tampon, et <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (méthode).  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre de décalage.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.  
  
ou 
La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'a pas été définie.  
  
ou 
Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Démarre la réception asynchrone de données à partir d'un périphérique réseau spécifié.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> méthode est utilisée principalement pour recevoir des données sur un socket sans connexion. Adresse locale du socket doit être connu.  
  
 L’appelant doit attribuer la <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété le <xref:System.Net.IPEndPoint> de l’hôte distant à partir duquel les données doit être reçu.  
  
 Le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriété sur le `e` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur la demande de lecture. Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> (méthode), afin que les informations seront récupérables dans la méthode de rappel. Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.  
  
 Pour les sockets orientés message, un message entrant est placé dans la mémoire tampon jusqu'à la taille totale de la mémoire tampon. Le <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> et <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriétés déterminent où les données sont placées dans la mémoire tampon et la quantité de données.  
  
 Pour les sockets de style de flux d’octets, les données entrantes sont placées dans la mémoire tampon jusqu'à ce que la mémoire tampon est remplie, la connexion est fermée, ou les données en mémoire tampon en interne sont épuisées. Le <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> et <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriétés déterminent où les données sont placées dans la mémoire tampon et la quantité de données.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être Null.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui est l’emplacement de stockage des données reçues.</param>
        <param name="offset">La position dans le paramètre <paramref name="buffer" /> pour stocker les données reçues.</param>
        <param name="size">Nombre d'octets à recevoir.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />, passé par référence, qui représente le serveur distant.</param>
        <param name="ipPacketInformation"><see cref="T:System.Net.Sockets.IPPacketInformation" /> contenant des informations d’adresse et d’interface.</param>
        <summary>Reçoit le nombre d’octets de données spécifié à l’emplacement de la mémoire tampon spécifié à l’aide des <see cref="T:System.Net.Sockets.SocketFlags" /> spécifiés, puis stocke les informations de paquet et de point de terminaison.</summary>
        <returns>Nombre d’octets reçus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> méthode lit les données dans le `buffer` paramètre, retourne le nombre d’octets lus correctement et capture le point de terminaison hôte distant à partir de laquelle l’envoi des données, ainsi que des informations sur le paquet reçu.  
  
 Le <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> méthode est utilisée principalement pour recevoir des données de message sur un socket sans connexion. Adresse locale du socket doit être connu. Cette méthode peut uniquement être utilisée avec le datagramme et les sockets bruts du protocole. Le socket doit être initialisé avec le type de socket défini sur <xref:System.Net.Sockets.SocketType.Dgram> ou <xref:System.Net.Sockets.SocketType.Raw> avant d’appeler cette méthode. Cela est possible lorsque le socket est construit à l’aide de <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Pour les sockets orientés message, un message entrant est placé dans le `buffer` paramètre jusqu'à la taille totale spécifiée dans le `size` paramètre. Le `offset` paramètre détermine l’emplacement dans le `buffer` les données sont placées. Le volume réel de données placées dans le `buffer` est retourné par la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> (méthode).  
  
 Le <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> méthode affecte automatiquement la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> option de socket `true` la première fois qu’elle est appelée pour une donnée <xref:System.Net.Sockets.Socket>. Toutefois, le texte retourné <xref:System.Net.Sockets.IPPacketInformation> objet n’est valide pour les paquets qui arrivent à l’ordinateur local après que l’option de socket a été définie. Si un socket est envoyé entre des paquets lorsqu’il est lié à un point de terminaison local (explicitement par le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode) ou implicitement par l’une de le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthodes) et son premier appel à la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> appels de méthode, à <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> méthode retournera non valide <xref:System.Net.Sockets.IPPacketInformation> objets pour ces paquets.  
  
 Pour vous assurer que tous les <xref:System.Net.Sockets.IPPacketInformation> les objets sont valides, une application doit définir le <xref:System.Net.Sockets.SocketOptionName.PacketInformation> option de socket `true` avant qu’il est lié à un point de terminaison local à l’aide de la <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> (méthode).  
  
 Une application peut examiner le `ipPacketInformation` paramètre si elle a besoin de savoir si le datagramme a été envoyé à l’aide d’une adresse de multidiffusion ou de diffusion, de monodiffusion.  
  
> [!NOTE]
>  Le <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> doit correspondre à la <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilisé dans <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
\- - ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre de décalage.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.  
  
ou 
La propriété <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> n'a pas été définie.  
  
ou 
Le .NET Framework s'exécute sur un processeur AMD 64 bits.  
  
ou 
Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Le système d'exploitation est Windows 2000 ou une version antérieure, alors que cette méthode nécessite Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">pour accepter les connexions à partir du réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Démarre la réception asynchrone du nombre spécifié d'octets de données dans l'emplacement spécifié de la mémoire tampon de données, à l'aide du <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> spécifié et stocke le point de terminaison ainsi que les informations sur le paquet.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> méthode est utilisée principalement pour recevoir des données de message sur un socket sans connexion. Adresse locale du socket doit être connu. Cette méthode peut uniquement être utilisée avec le datagramme et les sockets bruts du protocole. Le socket doit être initialisé avec le type de socket défini sur <xref:System.Net.Sockets.SocketType.Dgram> ou <xref:System.Net.Sockets.SocketType.Raw> avant d’appeler cette méthode. Cela est possible lorsque le socket est construit à l’aide de <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 L’appelant doit attribuer la <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété le <xref:System.Net.IPEndPoint> de l’hôte distant à partir duquel les données doit être reçu.  
  
 Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> (méthode), afin que les informations seront récupérables dans la méthode de rappel. Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.  
  
 Pour les sockets orientés message, un message entrant est placé dans la mémoire tampon jusqu'à la taille totale de la mémoire tampon. Le <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> et <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriétés déterminent où les données sont placées dans la mémoire tampon et la quantité de données.  
  
 Le <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> méthode définit automatiquement le <xref:System.Net.Sockets.SocketOptionName.PacketInformation> option de socket `true` la première fois qu’elle est appelée pour une donnée <xref:System.Net.Sockets.Socket>. Toutefois, le <xref:System.Net.Sockets.IPPacketInformation> objet n’est valide pour les paquets qui arrivent à l’ordinateur local après que l’option de socket a été définie. Si un socket est envoyé entre des paquets lorsque le socket est lié à un point de terminaison local (explicitement par le <xref:System.Net.Sockets.Socket.Bind%2A> méthode ou implicitement par l’une de le <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthodes) et le premier appel à la <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>(méthode), les appels à <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> méthode entraîne n’est pas valide <xref:System.Net.Sockets.IPPacketInformation> objets pour ces paquets.  
  
 Pour vous assurer que tous les <xref:System.Net.Sockets.IPPacketInformation> les objets sont valides, une application doit définir le <xref:System.Net.Sockets.SocketOptionName.PacketInformation> option de socket`true` avant qu’il est lié à un point de terminaison local à l’aide de la <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> (méthode).  
  
 Une application peut examiner les résultats <xref:System.Net.Sockets.IPPacketInformation> objets si elle doit savoir si le datagramme a été envoyé à l’aide d’une adresse de multidiffusion ou de diffusion, de monodiffusion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être Null.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur spécifiant la durée après laquelle un appel <see cref="Overload:System.Net.Sockets.Socket.Receive" /> synchrone doit expirer.</summary>
        <value>Valeur du délai d'attente exprimée en millisecondes. La valeur par défaut est 0, ce qui indique un délai d'attente infini. La valeur -1 indique également un délai d'attente infini.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette option s’applique à synchrone <xref:System.Net.Sockets.Socket.Receive%2A> appelle uniquement. Si le délai d’attente est dépassé, le <xref:System.Net.Sockets.Socket.Receive%2A> méthode lève un <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée pour une opération ensembliste est inférieure à -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le point de terminaison distant.</summary>
        <value><see cref="T:System.Net.EndPoint" /> avec lequel <see cref="T:System.Net.Sockets.Socket" /> communique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez un protocole orienté connexion, le <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property get le <xref:System.Net.EndPoint> qui contient le distant IP adresse et numéro de port auquel le <xref:System.Net.Sockets.Socket> est connecté. Si vous utilisez un protocole sans connexion, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contient l’adresse IP de l’à distance par défaut et le numéro de port par lequel le <xref:System.Net.Sockets.Socket> communiquera. Vous devez effectuer un cast <xref:System.Net.EndPoint> à un <xref:System.Net.IPEndPoint> avant la récupération de toutes les informations. Vous pouvez ensuite appeler la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> méthode pour récupérer l’instance distante <xref:System.Net.IPAddress>et le <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> méthode pour récupérer le numéro de port distant.  
  
 Le <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> est définie après un appel à <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.Connect%2A>. Si vous essayez d’accéder à cette propriété précédemment, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant récupère et affiche les points de terminaison locaux et distants.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead"><see cref="T:System.Collections.IList" /> sur <see cref="T:System.Net.Sockets.Socket" /> instances à vérifier en ce qui concerne la lisibilité.</param>
        <param name="checkWrite"><see cref="T:System.Collections.IList" /> sur <see cref="T:System.Net.Sockets.Socket" /> instances à vérifier en ce qui concerne la capacité d’écriture.</param>
        <param name="checkError"><see cref="T:System.Collections.IList" /> sur <see cref="T:System.Net.Sockets.Socket" /> instances à vérifier en ce qui concerne les erreurs.</param>
        <param name="microSeconds">La valeur du délai d’expiration exprimée en microsecondes. Une valeur de -1 indique un délai d’attente infini.</param>
        <summary>Détermine l’état d’un ou plusieurs sockets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> est une méthode statique qui détermine l’état d’une ou plusieurs <xref:System.Net.Sockets.Socket> instances. Vous devez placer un ou plusieurs sockets dans un <xref:System.Collections.IList> avant de pouvoir utiliser le <xref:System.Net.Sockets.Socket.Select%2A> (méthode). Recherchez la lisibilité en appelant <xref:System.Net.Sockets.Socket.Select%2A> avec la <xref:System.Collections.IList> comme le `checkRead` paramètre. Pour vérifier vos sockets concerne, utilisez le `checkWrite` paramètre. Pour détecter les conditions d’erreur, utilisez `checkError`. Après avoir appelé <xref:System.Net.Sockets.Socket.Select%2A>, le <xref:System.Collections.IList> sera remplie avec les sockets qui satisfont les conditions.  
  
 Si vous êtes dans un état d’écoute, une meilleure lisibilité signifie qu’un appel à <xref:System.Net.Sockets.Socket.Accept%2A> réussiront sans se bloquer. Si vous avez déjà accepté la connexion, la lisibilité signifie que les données sont disponibles pour la lecture. Dans ce cas, toutes les opérations de réception aboutiront sans blocage. Lecture peut également indiquer si l’instance distante <xref:System.Net.Sockets.Socket> a arrêté la connexion ; dans ce cas un appel à <xref:System.Net.Sockets.Socket.Receive%2A> est retournée immédiatement, avec zéro octet.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> retourne quand au moins un des sockets d’intérêt (les sockets dans les `checkRead`, `checkWrite`, et `checkError` répertorie) répond à ses critères spécifiés, ou le `microSeconds` paramètre est dépassé, le premier prévalant. Paramètre `microSeconds` à -1 spécifie un délai d’attente infini.  
  
 Si vous effectuez un appel non bloquant à <xref:System.Net.Sockets.Socket.Connect%2A>, accessibilité en écriture signifie que vous êtes connecté avec succès. Si vous avez déjà une connexion établie, l’accessibilité en écriture signifie que tous les envoi opérations réussissent sans se bloquer.  
  
 Si vous avez effectué un appel non bloquant à <xref:System.Net.Sockets.Socket.Connect%2A>, le `checkerror` paramètre identifie les sockets qui n’ont pas été connecté avec succès.  
  
> [!NOTE]
>  Utilisez le <xref:System.Net.Sockets.Socket.Poll%2A> méthode si vous souhaitez uniquement déterminer l’état d’un seul <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Cette méthode ne peut pas détecter certains types de problèmes de connexion, comme un câble réseau rompu, ou que l’hôte distant a été arrêté de manière anormale. Vous devez tenter d’envoyer ou recevoir des données pour détecter ces types d’erreurs.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.Socket.Select%2A> pour déterminer les sockets à l’écoute ayant une demande de connexion.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="checkRead" /> a la valeur <see langword="null" /> ou est vide.  
  
-et- 
Le paramètre <paramref name="checkWrite" /> a la valeur <see langword="null" /> ou est vide. 
-et- 
Le paramètre <paramref name="checkError" /> a la valeur <see langword="null" /> ou est vide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie des données à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <summary>Envoie des données à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns>Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès. <xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.  
  
 Cette surcharge requiert une mémoire tampon qui contient les données que vous souhaitez envoyer. Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut est 0, valeur par défaut est 0 et le nombre d’octets à envoyer les valeurs par défaut à la taille de la mémoire tampon d’offset de mémoire tampon.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou utiliser <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devrez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>. En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’envoi de données sur un connecté <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Liste de <see cref="T:System.ArraySegment`1" /> de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <summary>Envoie le jeu de mémoires tampon dans la liste à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns>Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.  
  
 Cette surcharge requiert au moins une mémoire tampon qui contient les données que vous souhaitez envoyer.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou utiliser <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devrez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>. En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> est vide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Consultez la section Notes ci-dessous.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envoie des données à un <see cref="T:System.Net.Sockets.Socket" /> connecté à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès. Le <xref:System.Net.Sockets.Socket.Send%2A> méthode peut être utilisée pour les protocoles orientés connexion et sans connexion.  
  
 Cette surcharge requiert une mémoire tampon qui contient les données que vous souhaitez envoyer et une combinaison au niveau du bit de <xref:System.Net.Sockets.SocketFlags>. Offset de mémoire tampon par défaut, 0 et le nombre d’octets à envoyer les valeurs par défaut à la taille de la mémoire tampon. Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` valeur du paramètre, les données que vous envoyez ne seront pas routées.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou utiliser <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devrez appeler la <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>. En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Vous devez vous assurer que la taille de votre mémoire tampon ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’envoi de données sur un connecté <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Liste de <see cref="T:System.ArraySegment`1" /> de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envoie le jeu de mémoires tampon dans la liste à un <see cref="T:System.Net.Sockets.Socket" /> connecté, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge requiert au moins une mémoire tampon qui contient les données que vous souhaitez envoyer. Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut 0. Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketFlags` paramètre, les données que vous envoyez ne seront pas routées.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou utiliser <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devrez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>. En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> est vide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="size">Le nombre d’octets à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Reçoit le nombre spécifié d'octets de données à un <see cref="T:System.Net.Sockets.Socket" /> connecté, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès. <xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.  
  
 Cette surcharge requiert une mémoire tampon qui contient les données que vous souhaitez envoyer, le nombre d’octets à envoyer et une combinaison au niveau du bit de n’importe quel <xref:System.Net.Sockets.SocketFlags>. Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou utiliser <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devrez appeler la <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant chaque appel à la <xref:System.Net.Sockets.Socket.Send%2A> (méthode). Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Avec un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que le nombre demandé d’octets est envoyé, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>. En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets demandé. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Vous devez vous assurer que la taille ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant envoie les données de mémoire tampon et spécifie <xref:System.Net.Sockets.SocketFlags.None> pour <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> est inférieur à 0 ou dépasse la taille de la mémoire tampon.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.  
  
ou 
Une erreur du système d'exploitation s'est produite lors de l'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Liste de <see cref="T:System.ArraySegment`1" /> de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <summary>Envoie le jeu de mémoires tampon dans la liste à un <see cref="T:System.Net.Sockets.Socket" /> connecté, à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge requiert au moins une mémoire tampon qui contient les données que vous souhaitez envoyer. Le <xref:System.Net.Sockets.SocketFlags> valeur par défaut 0. Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketFlags` paramètre, les données que vous envoyez ne seront pas routées.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou utiliser <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Si vous n’utilisez pas le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode), vous devrez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>. Vous pouvez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>. En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets dans la mémoire tampon. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie les octets dans la mémoire tampon. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> est vide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="offset">La position dans le tampon de données par laquelle doit commencer l’envoi des données.</param>
        <param name="size">Le nombre d’octets à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envoie le nombre spécifié d’octets de données à un <see cref="T:System.Net.Sockets.Socket" /> connecté, à part de l’offset spécifié et avec le <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès. <xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.  
  
 Dans cette surcharge, si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou utiliser <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A>. Si vous n’utilisez pas <xref:System.Net.Sockets.Socket.SendTo%2A>, vous devrez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>. Il s’agit d’OK à utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Vous devez également être sûr que la taille ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que le nombre demandé d’octets est envoyé, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>. En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets demandé. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant spécifie la mémoire tampon de données, un offset, une taille, et <xref:System.Net.Sockets.SocketFlags> pour l’envoi de données connectée <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.  
  
ou 
Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="offset">La position dans le tampon de données par laquelle doit commencer l’envoi des données.</param>
        <param name="size">Le nombre d’octets à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objet <see cref="T:System.Net.Sockets.SocketError" /> qui stocke l'erreur de socket.</param>
        <summary>Envoie le nombre spécifié d'octets de données d'un <see cref="T:System.Net.Sockets.Socket" /> connecté, en démarrant à l'offset spécifié et en utilisant le <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié</summary>
        <returns>Le nombre d’octets envoyés au <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envoie des données de façon synchrone à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> méthode et retourne le nombre d’octets envoyé avec succès. <xref:System.Net.Sockets.Socket.Send%2A> peut être utilisé pour les protocoles orientés connexion et sans connexion.  
  
 Dans cette surcharge, si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode ou <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou utiliser <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole sans connexion et un plan pour envoyer des données à plusieurs hôtes différents, vous devez utiliser <xref:System.Net.Sockets.Socket.SendTo%2A>. Si vous n’utilisez pas <xref:System.Net.Sockets.Socket.SendTo%2A>, vous devrez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant chaque appel à <xref:System.Net.Sockets.Socket.Send%2A>. Il s’agit d’OK à utiliser <xref:System.Net.Sockets.Socket.SendTo%2A> même après avoir établi un hôte distant par défaut avec <xref:System.Net.Sockets.Socket.Connect%2A>. Vous pouvez également modifier l’hôte distant par défaut avant d’appeler <xref:System.Net.Sockets.Socket.Send%2A> en effectuant un autre appel à <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Vous devez également être sûr que la taille ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.Send%2A> se bloque jusqu'à ce que le nombre demandé d’octets est envoyé, sauf si un délai d’attente a été définie à l’aide de <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si la valeur de délai d’attente a été dépassée, le <xref:System.Net.Sockets.Socket.Send%2A> appel lève une <xref:System.Net.Sockets.SocketException>. En mode non bloquant, <xref:System.Net.Sockets.Socket.Send%2A> peut se terminer correctement, même si elle envoie inférieur au nombre d’octets demandé. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.Send%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  La réussite d’un envoi n’indique pas que les données a été correctement remises. Si aucun espace tampon n’est disponible au sein du système de transport pour contenir les données à transmettre, envoi bloquera, sauf si le socket a été placé en mode non bloquant.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant spécifie la mémoire tampon de données, un offset, une taille, et <xref:System.Net.Sockets.SocketFlags> pour l’envoi de données connectée <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.  
  
ou 
Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Envoie des données de façon asynchrone à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode est utilisée pour écrire des données sortantes à partir d’un ou plusieurs tampons sur un socket orienté connexion. Cette méthode peut également être utilisée, toutefois, sur les sockets sans connexion que vous ont spécifié un hôte distant sur une opération de connexion.  
  
 Le <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant établie dans le <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode).  
  
 Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ou <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> a la valeur  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> a la valeur  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.SendAsync%2A> (méthode), afin que les informations seront récupérables dans la méthode de rappel. Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.  
  
 Le <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode lève une exception si vous n’appelez pas tout d’abord <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Appel de la <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.  
  
 Pour les sockets orientés message, ne dépassez pas la taille maximale des messages du fournisseur de services Windows sockets sous-jacent. Si les données sont trop longues à traverser atomiquement le fournisseur de service sous-jacent, aucune donnée n’est transmise et la <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode lève un <xref:System.Net.Sockets.SocketException> avec le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> défini sur le code d’erreur Winsock WSAEMSGSIZE natif (10040).  
  
 Notez que la réussite de la <xref:System.Net.Sockets.Socket.SendAsync%2A> méthode n’indique pas que les données a été correctement remises.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> ou <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> sur le paramètre de <paramref name="e" /> doit référencer des mémoires tampon valides. L'une ou l'autre de ces propriétés peut être définie, mais pas les deux à la fois.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Le <see cref="T:System.Net.Sockets.Socket" /> n'est pas encore connecté ou n'a pas été obtenu via une méthode <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />ou <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur spécifiant la taille de la mémoire tampon d'envoi de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value><see cref="T:System.Int32" /> contenant la taille de la mémoire tampon d'envoi en octets. La valeur par défaut est 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une plus grande taille de mémoire tampon peut retarder la reconnaissance des difficultés de connexion. Envisagez d’augmenter la taille de mémoire tampon si vous transférez des fichiers volumineux, ou si vous utilisez une bande passante élevée, la connexion d’une latence élevée (par exemple, un fournisseur large bande satellite).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.SendBufferSize%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée pour une opération ensembliste est inférieure à 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie de façon synchrone un fichier et des données facultatives à un <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><see cref="T:System.String" /> contenant le chemin d’accès et le nom du fichier à envoyer. Ce paramètre peut être <see langword="null" />.</param>
        <summary>Envoie le fichier <paramref name="fileName" /> à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté avec l'indicateur de transmission <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge envoie le fichier `fileName` au socket connecté. Le `flags` paramètre par défaut est <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) et le `preBuffer` et `postBuffer` paramètres par défaut `null`. Si `fileName` est dans le répertoire local, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés. Les caractères génériques («.. \\\myfile.txt ») et les noms des partages UNC («\\\\\\\shared directory\\\myfile.txt ») sont pris en charge. Si le fichier est introuvable, l’exception <xref:System.IO.FileNotFoundException> est levée.  
  
 Cette méthode utilise la `TransmitFile` fonction trouvée dans l’API Windows Sockets 2. Pour plus d’informations sur la `TransmitFile` fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> envoie de façon synchrone un fichier à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). <xref:System.Net.Sockets.Socket.SendFile%2A> peut être utilisé pour les orienté connexion et les protocoles sans connexion.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode, sinon <xref:System.Net.Sockets.Socket.SendFile%2A> lève un <xref:System.Net.Sockets.SocketException> exception. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant ou utilisez <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.SendFile%2A> bloque jusqu'à ce que le fichier est envoyé. En mode non bloquant, <xref:System.Net.Sockets.Socket.SendFile%2A> peut se terminer correctement avant que l’intégralité du fichier a été envoyé. Il n’existe aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.SendFile%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée et connecte à un socket et envoie ensuite un fichier à l’hôte distant. Le fichier « test.txt » se trouve dans le répertoire racine de l’ordinateur local.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le socket n’est pas connecté à un hôte distant.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’objet <see cref="T:System.Net.Sockets.Socket" /> n’est pas en mode blocage et ne peut pas accepter cet appel synchrone.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier <paramref name="fileName" /> est introuvable.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName"><see cref="T:System.String" /> contenant le chemin d’accès et le nom du fichier à envoyer. Ce paramètre peut être <see langword="null" />.</param>
        <param name="preBuffer">Tableau <see cref="T:System.Byte" /> contenant les données à envoyer avant l’envoi du fichier. Ce paramètre peut être <see langword="null" />.</param>
        <param name="postBuffer">Tableau <see cref="T:System.Byte" /> contenant les données à envoyer après l’envoi du fichier. Ce paramètre peut être <see langword="null" />.</param>
        <param name="flags">Une ou plusieurs des valeurs <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <summary>Envoie le <paramref name="fileName" /> et les tampons de données du fichier à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté à l’aide de la valeur <see cref="T:System.Net.Sockets.TransmitFileOptions" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge requiert le nom du fichier à envoyer et une combinaison au niveau du bit de <xref:System.Net.Sockets.TransmitFileOptions> valeurs. Le `preBuffer` paramètre contient les données que vous souhaitez faire précéder le fichier. `postBuffer` contient des données que vous souhaitez suivre le fichier. Si `fileName` est dans le répertoire de travail actuel, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés. Les caractères génériques («.. \\\myfile.txt ») et les noms des partages UNC («\\\\\\\shared directory\\\myfile.txt ») sont pris en charge.  
  
 Le `flags` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur le transfert de fichiers. Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Cette méthode utilise la `TransmitFile` fonction trouvée dans l’API Windows Sockets 2. Pour plus d’informations sur la `TransmitFile` fonction et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> envoie de façon synchrone un fichier à l’hôte distant spécifié dans le <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). <xref:System.Net.Sockets.Socket.SendFile%2A> peut être utilisé pour les orienté connexion et les protocoles sans connexion.  
  
 Si vous utilisez un protocole sans connexion, vous devez appeler <xref:System.Net.Sockets.Socket.Connect%2A> avant d’appeler cette méthode ; sinon <xref:System.Net.Sockets.Socket.SendFile%2A> lève un <xref:System.Net.Sockets.SocketException>. Si vous utilisez un protocole orienté connexion, vous devez soit utiliser <xref:System.Net.Sockets.Socket.Connect%2A> pour établir une connexion d’hôte distant, ou utiliser <xref:System.Net.Sockets.Socket.Accept%2A> pour accepter une connexion entrante.  
  
 Si vous utilisez un protocole orienté connexion, <xref:System.Net.Sockets.Socket.SendFile%2A> bloque jusqu'à ce que le fichier entier est envoyé. En mode non bloquant, <xref:System.Net.Sockets.Socket.SendFile%2A> peut se terminer correctement avant que l’intégralité du fichier a été envoyé. Il n’existe aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.SendFile%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée et connecte un socket. Le fichier « test.txt » se trouve dans le répertoire racine de l’ordinateur local. Dans cet exemple, nous créer un prebuffer et le postbuffer de données et les envoyer à l’hôte distant avec le fichier. La valeur par défaut <xref:System.Net.Sockets.TransmitFileOptions> sont utilisés.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le système d'exploitation n'est pas Windows NT ou une version ultérieure.  
  
ou 
Le socket n’est pas connecté à un hôte distant.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’objet <see cref="T:System.Net.Sockets.Socket" /> n’est pas en mode blocage et ne peut pas accepter cet appel synchrone.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier <paramref name="fileName" /> est introuvable.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Envoie une collection de fichiers ou des données mises en mémoire tampon de façon asynchrone à un objet <see cref="T:System.Net.Sockets.Socket" /> connecté.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode est utilisée pour envoyer une collection de fichiers ou dans la mémoire des mémoires tampons de données à l’hôte distant. Le <xref:System.Net.Sockets.Socket> doit déjà être connecté à l’hôte distant.  
  
 Si un <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> références à un fichier dans le répertoire de travail, il peut être identifié uniquement avec le nom du fichier ; sinon, le chemin d’accès complet et le nom du fichier doivent être spécifiés. Les caractères génériques et les noms de partage UNC sont pris en charge. Si le fichier est introuvable, <xref:System.IO.FileNotFoundException> est levée.  
  
 Pour être averti de la saisie semi-automatique, vous devez créer une méthode de rappel qui implémente le délégué EventHandler\<SocketAsyncEventArgs > et l’attacher le rappel pour le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.  
  
 Le <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propriété sur le `e` paramètre fournit le fournisseur de services Windows Sockets avec des informations supplémentaires sur le transfert de fichiers. Pour plus d’informations sur l’utilisation de ce paramètre, consultez <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> (méthode), afin que les informations seront récupérables dans la méthode de rappel. Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.  
  
 Cette méthode utilise la fonction TransmitPackets détectée dans l’API Windows Sockets 2. Pour plus d’informations sur la fonction TransmitPackets et ses indicateurs, consultez la documentation de Windows Sockets dans MSDN Library.  
  
 Bien que destiné à des protocoles orientés connexion, la <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode fonctionne également pour les protocoles sans connexion, si vous appelez d’abord la <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode pour établir un hôte distant par défaut. Avec les protocoles sans connexion, vous devez être sûr que la taille de votre fichier ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Le cas échéant, le datagramme n’est pas envoyé et <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> lève un <xref:System.Net.Sockets.SocketException> exception.  
  
 Le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode est optimisée selon le système d’exploitation sur lequel il est utilisé. Sur les éditions de Windows server, le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode est optimisée pour de hautes performances.  
  
 Sur les éditions clientes Windows, le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> méthode est optimisée pour une utilisation minimale de mémoire et de ressources.  
  
 Utiliser le <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> indicateur dans le <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propriété sur le `e` paramètre peut fournir des performances nettement supérieures. Si l’initialisation du thread le <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> appel de méthode est utilisé pour les calculs lourds, il est possible, bien qu’improbable, qu’APC ne soient pas lancement. Notez qu’il existe une différence entre l’appel de procédure asynchrone du noyau et en mode utilisateur. Noyau sont lancés lorsqu’un thread se trouve dans un état d’attente. En mode utilisateur sont lancés lorsqu’un thread est dans un état d’une attente  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans la propriété <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> est introuvable.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode. Cette exception se produit également si le <see cref="T:System.Net.Sockets.Socket" /> n'est pas connecté à un hôte distant.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Un <see cref="T:System.Net.Sockets.Socket" /> sans connexion est utilisé et le fichier qui est envoyé dépasse la taille maximale du paquet du transport sous-jacent.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur spécifiant la durée après laquelle un appel <see cref="Overload:System.Net.Sockets.Socket.Send" /> synchrone doit expirer.</summary>
        <value>Valeur du délai d'attente exprimée en millisecondes. Si vous affectez à la propriété une valeur comprise entre 1 et 499, cette valeur est remplacée par 500. La valeur par défaut est 0, ce qui indique un délai d'attente infini. La valeur -1 indique également un délai d'attente infini.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette option s’applique à synchrone <xref:System.Net.Sockets.Socket.Send%2A> appelle uniquement. Si le délai d’attente est dépassé, le <xref:System.Net.Sockets.Socket.Send%2A> méthode lève un <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.SendTimeout%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée pour une opération ensembliste est inférieure à -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie les données à un point de terminaison spécifique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> qui représente la destination des données.</param>
        <summary>Envoie les données au point de terminaison spécifié.</summary>
        <returns>Nombre d'octets envoyés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans cette surcharge, la mémoire tampon de l’offset de valeur par défaut est 0, le nombre d’octets à envoyer les valeurs par défaut à la taille de la `buffer` paramètre et le <xref:System.Net.Sockets.SocketFlags> valeur par défaut 0.  
  
 Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>. Vous devez uniquement effectuer cette opération si vous avez l’intention d’appeler le <xref:System.Net.Sockets.Socket.Send%2A> (méthode). Si vous n’appelez pas la <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi. Vous n’êtes également pas obligé d’appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié. Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode se termine correctement.  
  
 Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendTo%2A> fonctionne également avec les protocoles orientés connexion. Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou accepter une demande de connexion entrante à l’aide du <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous n’établissez ou accepter une connexion d’hôte distant, <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Dans ces cas, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorera la `remoteEP` paramètre et uniquement envoyer les données vers le service connecté ou un hôte distant par défaut.  
  
 Sockets bloquants se bloquent jusqu'à ce que tous les octets dans la mémoire tampon sont envoyés. Dans la mesure où un non bloquant <xref:System.Net.Sockets.Socket> se termine immédiatement, il peut ne pas envoyer tous les octets dans le `buffer`. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie tous les octets dans le `buffer`. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité significative de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
 Si vous utilisez un protocole sans connexion en mode blocage, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé. Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Vous devez également être sûr que le nombre d’octets envoyés ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> qui représente l'emplacement de destination des données.</param>
        <summary>Envoie des données à un point de terminaison spécifique à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Nombre d'octets envoyés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans cette surcharge, la mémoire tampon de l’offset de valeur par défaut est 0 et le nombre d’octets à envoyer les valeurs par défaut à la taille de la `buffer`. Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
 Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>. Vous devez uniquement effectuer cette opération si vous avez l’intention d’appeler le <xref:System.Net.Sockets.Socket.Send%2A> (méthode). Si vous n’appelez pas la <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi. Vous n’êtes également pas obligé d’appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié. Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode se termine correctement.  
  
 Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendTo%2A> fonctionne également avec les protocoles orientés connexion. Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou accepter une demande de connexion entrante à l’aide du <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous n’établissez ou accepter une connexion d’hôte distant, <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Dans ces cas, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorera la `remoteEP` paramètre et uniquement envoyer les données vers le service connecté ou un hôte distant par défaut.  
  
 Sockets bloquants se bloquent jusqu'à ce que demandé tous les octets dans le `buffer` sont envoyés. Dans la mesure où un non bloquant <xref:System.Net.Sockets.Socket> se termine immédiatement, il peut ne pas envoyer tous les octets dans le `buffer`. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie tous les octets dans le `buffer`. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
 Si vous utilisez un protocole sans connexion en mode blocage, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé. Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Vous devez également être sûr que le nombre d’octets envoyés ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié. <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="size">Le nombre d’octets à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> qui représente l'emplacement de destination des données.</param>
        <summary>Envoie le nombre spécifié d'octets de données au point de terminaison spécifié à l'aide du <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Nombre d'octets envoyés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans cette surcharge, offset de mémoire tampon par défaut 0. Si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
 Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>. Vous devez uniquement effectuer cette opération si vous avez l’intention d’appeler le <xref:System.Net.Sockets.Socket.Send%2A> (méthode). Si vous n’appelez pas la <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi. Vous n’êtes également pas obligé d’appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié. Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode se termine correctement.  
  
 Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendTo%2A> fonctionne également avec les protocoles orientés connexion. Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou accepter une demande de connexion entrante à l’aide du <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous n’établissez ou accepter une connexion d’hôte distant, <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Dans ces cas, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorera la `remoteEP` paramètre et uniquement envoyer les données vers le service connecté ou un hôte distant par défaut.  
  
 Sockets bloquants se bloquent jusqu'à ce que le nombre demandé d’octets est envoyé. Dans la mesure où un non bloquant <xref:System.Net.Sockets.Socket> se termine immédiatement, il peut ne pas envoyer tous les octets demandés en une seule opération. Il incombe de votre application pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
 Si vous utilisez un protocole sans connexion en mode blocage, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé. Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Vous devez également être sûr que le nombre d’octets envoyés ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié. La taille et <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le <paramref name="size" /> spécifié dépasse la taille de <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="offset">La position dans le tampon de données par laquelle doit commencer l’envoi des données.</param>
        <param name="size">Le nombre d’octets à envoyer.</param>
        <param name="socketFlags">Combinaison d'opérations de bits des valeurs <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> qui représente l'emplacement de destination des données.</param>
        <summary>Envoie le nombre spécifié d'octets de données au point de terminaison spécifié, en commençant à l'emplacement spécifié dans la mémoire tampon et en utilisant le <see cref="T:System.Net.Sockets.SocketFlags" /> spécifié.</summary>
        <returns>Nombre d'octets envoyés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans cette surcharge, si vous spécifiez le <xref:System.Net.Sockets.SocketFlags.DontRoute> signalées comme le `socketflags` paramètre, les données que vous envoyez ne seront pas routées.  
  
 Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>. Vous devez uniquement effectuer cette opération si vous avez l’intention d’appeler le <xref:System.Net.Sockets.Socket.Send%2A> (méthode). Si vous n’appelez pas la <xref:System.Net.Sockets.Socket.Connect%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendTo%2A>, le `remoteEP` paramètre remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi. Vous n’êtes également pas obligé d’appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode), car le fournisseur de services sous-jacent assigne le nombre d’adresse et le port de réseau local plus approprié. Si vous avez besoin identifier le numéro d’adresse et le port attribué de réseau local, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode se termine correctement.  
  
 Bien que destiné aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendTo%2A> fonctionne également avec les protocoles orientés connexion. Si vous utilisez un protocole orienté connexion, vous devez tout d’abord établir une connexion d’hôte distant en appelant le <xref:System.Net.Sockets.Socket.Connect%2A> méthode ou accepter une demande de connexion entrante à l’aide du <xref:System.Net.Sockets.Socket.Accept%2A> (méthode). Si vous n’établissez ou accepter une connexion d’hôte distant, <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Vous pouvez également établir un hôte distant par défaut pour un protocole sans connexion avant d’appeler le <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode). Dans ces cas, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorera la `remoteEP` paramètre et uniquement envoyer les données vers le service connecté ou un hôte distant par défaut.  
  
 Sockets bloquants se bloquent jusqu'à ce que le nombre demandé d’octets est envoyé. Depuis un non bloquant <xref:System.Net.Sockets.Socket> se termine immédiatement, il peut ne pas envoyer tous les octets demandés en une seule opération. Il vous incombe applications pour suivre le nombre d’octets envoyés et de recommencer l’opération jusqu'à ce que l’application envoie le nombre d’octets demandé. Il n’existe également aucune garantie que les données que vous envoyez apparaîtra immédiatement sur le réseau. Pour augmenter l’efficacité du réseau, le système sous-jacent peut retarder la transmission jusqu'à ce qu’une quantité importante de données sortantes est collectée. Réussite de la <xref:System.Net.Sockets.Socket.SendTo%2A> méthode signifie que le système sous-jacent n’est plus de place pour envoyer vos données pour un réseau de mémoire tampon.  
  
 Si vous utilisez un protocole sans connexion en mode blocage, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloque jusqu'à ce que le datagramme est envoyé. Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Vous devez également être sûr que la taille ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.SendTo%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant envoie un datagramme sans connexion à l’hôte distant spécifié. Le décalage, la taille, et <xref:System.Net.Sockets.SocketFlags> sont passés à la <xref:System.Net.Sockets.Socket.SendTo%2A> (méthode).  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="remoteEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="size" /> est inférieur à 0.  
  
ou 
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> n’est pas une combinaison valide de valeurs.  
  
ou 
Une erreur du système d’exploitation se produit pendant l’accès au <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant de la pile des appels ne dispose pas des autorisations requises.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> à utiliser pour cette opération de socket asynchrone.</param>
        <summary>Envoie des données de façon asynchrone à un hôte distant spécifique.</summary>
        <returns><see langword="true" /> si l’opération d’E/S est en attente. L'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> sera déclenché une fois l'opération terminée.  
  
 <see langword="false" /> si l’opération d’E/S a été terminée de manière synchrone. Dans ce cas, l'événement <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sur le paramètre <paramref name="e" /> ne sera pas déclenché et l'objet <paramref name="e" /> transmis en tant que paramètre peut être examiné immédiatement après que l'appel de méthode a été retourné pour extraire le résultat de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant spécifié dans le <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété de le `e` paramètre. Appel de la <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct. Bien que cette méthode est destinée aux protocoles sans connexion, <xref:System.Net.Sockets.Socket.SendToAsync%2A> fonctionne avec les protocoles orientés connexion.  
  
 Pour être averti de la saisie semi-automatique, vous devez créer une méthode de rappel qui implémente le délégué EventHandler\<SocketAsyncEventArgs > et l’attacher le rappel pour le <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement.  
  
 Les propriétés et événements suivants sur le <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objet sont requis pour appeler cette méthode avec succès :  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 L’appelant peut affecter la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriété à n’importe quel objet d’état utilisateur souhaité avant d’appeler le <xref:System.Net.Sockets.Socket.SendToAsync%2A> (méthode), afin que les informations seront récupérables dans la méthode de rappel. Si le rappel a besoin de plus d’informations qu’un seul objet, une petite classe peut être créée pour contenir les autres informations d’état requises en tant que membres.  
  
 Si vous utilisez un protocole orienté connexion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode). Sinon <xref:System.Net.Sockets.Socket.SendToAsync%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Lorsque vous utilisez un protocole orienté connexion, le <xref:System.Net.Sockets.Socket.SendToAsync%2A> méthode ignore la <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété et envoie les données à la <xref:System.Net.EndPoint?displayProperty=nameWithType> établie dans le <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (méthode).  
  
 Si vous utilisez un protocole sans connexion, vous n’avez pas besoin d’établir un hôte distant par défaut avec le <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Vous devez uniquement effectuer cette opération si vous avez l’intention d’appeler le <xref:System.Net.Sockets.Socket.BeginSend%2A> ou <xref:System.Net.Sockets.Socket.SendAsync%2A> méthodes. Si vous n’appelez pas la <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> méthode avant d’appeler <xref:System.Net.Sockets.Socket.SendToAsync%2A>, le <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriété remplacera l’hôte distant par défaut spécifié pour cette opération uniquement d’envoi. Vous n’êtes également pas obligé d’appeler le <xref:System.Net.Sockets.Socket.Bind%2A> (méthode). Dans ce cas, le fournisseur de services sous-jacent affectera le plus approprié réseau local IP adresse et numéro de port. Utiliser un numéro de port zéro si vous souhaitez que le fournisseur de services sous-jacent pour sélectionner un port disponible. Si vous avez besoin identifier le réseau local attribué IP adresse et numéro de port, vous pouvez utiliser la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriété après la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> événement est signalé, et les délégués associés sont appelés.  
  
 Si vous souhaitez envoyer des données à une adresse de diffusion, vous devez d’abord appeler la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (méthode) et définir le socket option pour <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> sur true. Vous devez également être sûr que la taille de votre mémoire tampon ne dépasse pas la taille maximale du paquet du fournisseur de services sous-jacent. Si tel est le cas le datagramme ne sera pas envoyé et <xref:System.Net.Sockets.Socket.SendToAsync%2A> lèvera une <xref:System.Net.Sockets.SocketException>.  
  
 Si vous spécifiez l’indicateur DontRoute dans le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriété, les données que vous envoyez ne seront pas routées.  
  
 Pour les sockets orientés message, être vigilant pour ne pas dépasser la taille maximale des messages du transport sous-jacent. Si la taille de la mémoire tampon dépasse la taille maximale du paquet du fournisseur de service sous-jacent, le datagramme n’est pas envoyé et <xref:System.Net.Sockets.Socket.SendToAsync%2A> lèvera une <xref:System.Net.Sockets.SocketException>. La réussite d’un <xref:System.Net.Sockets.Socket.SendToAsync%2A> (méthode) n’indique pas que les données a été correctement remises.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> ne peut pas être Null.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération de socket utilisant l'objet <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> spécifié dans le paramètre <paramref name="e" /> spécifié était déjà en cours.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP ou version ultérieure est requis pour cette méthode.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Le protocole spécifié est orienté connexion, mais le <see cref="T:System.Net.Sockets.Socket" /> n'est pas encore connecté.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">Niveau de protection IP à définir sur ce socket.</param>
        <summary>Définit le niveau de protection IP sur un socket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> méthode permet de restreindre un socket IPv6 ou IP à l’écoute d’une portée spécifiée, telle que les adresses avec le même lien local ou site préfixe local. Cette option de socket permet aux applications de placer des restrictions d’accès sur les sockets IPv6 ou IP. Ces restrictions permettent à une application qui s'exécute sur un réseau local privé de se renforcer facilement et efficacement contre les attaques externes. Cette option de socket peut également être utilisée pour supprimer les restrictions d’accès si le `level` paramètre est défini sur <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Cette option de socket élargit ou limite la portée d'un socket en écoute, permettant l'accès illimité des utilisateurs publics et privés le cas échéant ou restreignant éventuellement l'accès au même site.  
  
 Cette option de socket utilise les niveaux de protection définis spécifiés dans l'énumération <xref:System.Net.Sockets.IPProtectionLevel>.  
  
 Le <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> méthode est utilisée pour activer ou désactiver la traversée d’adresses réseau (NAT) pour un <xref:System.Net.Sockets.Socket> instance. Parcours NAT peut être fourni à l’aide de Teredo, 6to4 ou un tunnel ISATAP.  
  
 Lorsque le `level` paramètre est défini sur <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, ou <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, cela désactive explicitement NAT traversal pour un <xref:System.Net.Sockets.Socket> instance.  
  
 Lorsque le `level` paramètre est défini sur <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, cela peut permettre de parcours NAT pour une <xref:System.Net.Sockets.Socket> selon les règles de pare-feu en place sur le système.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="level" /> ne peut pas avoir la valeur <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. Le niveau de protection IP ne peut pas être non spécifié.</exception>
        <exception cref="T:System.NotSupportedException">Le <see cref="T:System.Net.Sockets.AddressFamily" /> du socket doit être <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit une option <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Valeur de l'option, représentée en tant que <see cref="T:System.Boolean" />.</param>
        <summary>Affecte la valeur <see cref="T:System.Net.Sockets.Socket" /> spécifiée à l'option <see cref="T:System.Boolean" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> options déterminent le comportement de l’actuel <xref:System.Net.Sockets.Socket>. Définissez `optionValue` à `true` pour activer l’option, ou la valeur `false` pour désactiver l’option.  
  
 <xref:System.Net.Sockets.Socket> options sont regroupées par niveau de prise en charge du protocole.  
  
 Vous trouverez ci-dessous les différentes <xref:System.Net.Sockets.Socket> options qui peuvent être définies à l’aide de cette surcharge. Ces options sont regroupées par approprié <xref:System.Net.Sockets.SocketOptionLevel> valeur. Si vous envisagez de définir ces options, veillez à utiliser approprié <xref:System.Net.Sockets.SocketOptionLevel> valeur pour le `optionLevel` paramètre. L’option que vous choisissez de définir doit être spécifiée dans le `optionName` paramètre. Si vous souhaitez obtenir la valeur actuelle d’une des options répertoriées, utilisez le <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (méthode).  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Pour plus d’informations sur ces options, reportez-vous à la <xref:System.Net.Sockets.SocketOptionName> énumération.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException> exception, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple de code suivant ouvre un socket et permet la `DontLinger` et `OutOfBandInline` options de socket.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Tableau de type <see cref="T:System.Byte" /> représentant la valeur de l'option.</param>
        <summary>Affecte la valeur spécifiée à l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée représentée sous la forme d'un tableau d'octets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> options déterminent le comportement de l’actuel <xref:System.Net.Sockets.Socket>. Utilisez cette surcharge pour définir celles <xref:System.Net.Sockets.Socket> options qui nécessitent un tableau d’octets comme valeur d’option.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> les valeurs de délai d’attente.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Valeur de l'option.</param>
        <summary>Affecte la valeur entière spécifiée à l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> options déterminent le comportement de l’actuel <xref:System.Net.Sockets.Socket>. Pour une option avec un <xref:System.Boolean> de type de données, spécifiez une valeur différente de zéro pour activer l’option et une valeur zéro pour désactiver l’option. Pour une option avec un type de données integer, spécifiez la valeur appropriée. <xref:System.Net.Sockets.Socket> options sont regroupées par niveau de prise en charge du protocole.  
  
 Vous trouverez ci-dessous les différentes <xref:System.Net.Sockets.Socket> options qui peuvent être définies à l’aide de cette surcharge. Ces options sont regroupées par approprié <xref:System.Net.Sockets.SocketOptionLevel>. Si vous envisagez de définir ces options, veillez à utiliser approprié <xref:System.Net.Sockets.SocketOptionLevel> pour le `optionLevel` paramètre. L’option que vous choisissez de définir doit être spécifiée dans le `optionName` paramètre. Si vous souhaitez obtenir la valeur actuelle d’une des options répertoriées, utilisez le <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (méthode).  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options qui peuvent être définies à l’aide de cette surcharge.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Pour plus d’informations sur ces options, reportez-vous à la <xref:System.Net.Sockets.SocketOptionName> énumération.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> les valeurs de délai d’attente.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Une des valeurs de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue"><see cref="T:System.Net.Sockets.LingerOption" /> ou <see cref="T:System.Net.Sockets.MulticastOption" /> qui contient la valeur de l'option.</param>
        <summary>Affecte la valeur spécifiée à l'option <see cref="T:System.Net.Sockets.Socket" /> spécifiée représentée sous la forme d'un objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> options déterminent le comportement de l’actuel <xref:System.Net.Sockets.Socket>. Utilisez cette surcharge pour définir le <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, et <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> options. Pour le <xref:System.Net.Sockets.SocketOptionName.Linger> , utilisez l’option <xref:System.Net.Sockets.Socket> pour le `optionLevel` paramètre. Pour <xref:System.Net.Sockets.SocketOptionName.AddMembership> et <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilisez <xref:System.Net.Sockets.SocketOptionLevel.IP>. Si vous souhaitez obtenir la valeur actuelle d’une des options ci-dessus, utilisez la <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (méthode).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.Sockets.LingerOption> et <xref:System.Net.Sockets.Socket.Send%2A> les valeurs de délai d’attente.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Une des valeurs de <see cref="T:System.Net.Sockets.SocketShutdown" /> spécifiant l'opération qui ne sera plus autorisée.</param>
        <summary>Désactive les envois et les réceptions sur un <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez orienté connexion <xref:System.Net.Sockets.Socket>, appelez toujours le <xref:System.Net.Sockets.Socket.Shutdown%2A> méthode avant de fermer le <xref:System.Net.Sockets.Socket>. Cela garantit que toutes les données envoyées et reçues sur le socket connecté avant sa fermeture.  
  
 Appelez le <xref:System.Net.Sockets.Socket.Close%2A> méthode pour libérer toutes les ressources managées et associés à la <xref:System.Net.Sockets.Socket>. N’essayez pas de réutiliser le <xref:System.Net.Sockets.Socket> après la fermeture.  
  
 Le tableau suivant présente le <xref:System.Net.Sockets.SocketShutdown> des valeurs d’énumération qui sont valides pour le `how` paramètre.  
  
|Value|Description |  
|-----------|-----------------|  
|Envoyer|Désactiver l’envoi sur ce <xref:System.Net.Sockets.Socket>.|  
|Receive|Désactive la réception sur ce <xref:System.Net.Sockets.Socket>.|  
|Les deux|Désactiver l’envoi et la réception sur ce <xref:System.Net.Sockets.Socket>.|  
  
 Paramètre `how` à <xref:System.Net.Sockets.SocketShutdown.Send> spécifie autrement suivantes les appels à <xref:System.Net.Sockets.Socket.Send%2A> ne sont pas autorisés. Si vous utilisez un sans connexion <xref:System.Net.Sockets.Socket>, en spécifiant <xref:System.Net.Sockets.SocketShutdown.Send> n’a aucun effet.  
  
 Paramètre `how` à <xref:System.Net.Sockets.SocketShutdown.Receive> spécifie autrement suivantes les appels à <xref:System.Net.Sockets.Socket.Receive%2A> ne sont pas autorisés. Cela n’a aucun effet sur les couches de protocole inférieures. Si vous utilisez un protocole orienté connexion, la connexion est interrompue si une des conditions suivantes existe après un appel à <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   Les données sont dans la mémoire tampon réseau entrante en attente de réception.  
  
-   Plus de données est arrivé.  
  
 Si vous utilisez un protocole sans connexion, les datagrammes sont acceptés et en file d’attente. Toutefois, si aucun espace tampon n’est disponible pour les datagrammes entrants supplémentaires, elles seront ignorées et aucune erreur ne s’affichera à l’expéditeur. À l’aide de <xref:System.Net.Sockets.Socket.Shutdown%2A> sur un sans connexion <xref:System.Net.Sockets.Socket> n’est pas recommandée.  
  
 Paramètre `how` à <xref:System.Net.Sockets.SocketShutdown.Both> désactive les envois et reçoit comme décrit ci-dessus.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException> lors de l’appel le <xref:System.Net.Sockets.Socket.Shutdown%2A> (méthode), utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.Socket.Shutdown%2A> pour désactiver le <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Une des valeurs de <see cref="T:System.Net.Sockets.SocketType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> est en lecture seule et est définie lorsque le <xref:System.Net.Sockets.Socket> est créé.  
  
   
  
## Examples  
 Le code suivant exemple affiche le <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, et <xref:System.Net.Sockets.ProtocolType> à la console.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la prise en charge d'IPv4 est disponible et active sur l'hôte en cours.</summary>
        <value><see langword="true" /> si l'hôte en cours prend en charge le protocole IPv4 ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le Framework prend en charge le protocole IPv6 pour certains membres <see cref="T:System.Net.Dns" /> obsolètes.</summary>
        <value><see langword="true" /> si le Framework prend en charge le protocole IPv6 pour certaines méthodes <see cref="T:System.Net.Dns" /> obsolètes ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système d’exploitation peut prendre en charge les protocoles IPv4 et IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Appelez IDisposable.Dispose lorsque vous avez terminé à l’aide de la <xref:System.Net.Sockets.Socket>. La méthode IDisposable.Dispose quitte le <xref:System.Net.Sockets.Socket> dans un état inutilisable. Après l’appel à IDisposable.Dispose, vous devez libérer toutes les références à la <xref:System.Net.Sockets.Socket> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Net.Sockets.Socket> occupée. Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Appelez toujours IDisposable.Dispose avant de libérer votre dernière référence à la <xref:System.Net.Sockets.Socket>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Net.Sockets.Socket> de l'objet `Finalize`.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie la durée de vie des paquets IP (Internet Protocol) envoyés par <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Durée de vie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de durée de vie indique le nombre maximal de routeurs que le paquet peut parcourir avant que le routeur n’ignore le paquet et un Message de protocole ICMP (Internet Control) « TTL dépassé » message d’erreur est renvoyé à l’expéditeur.  
  
 La valeur de durée de vie peut être définie sur une valeur comprise entre 0 et 255. Lorsque cette propriété n’est pas définie, la valeur de durée de vie par défaut pour un socket est 32.  
  
 Définition de cette propriété sur un socket de protocole TCP (Transmission Control) est ignorée par la pile TCP/IP si une connexion réussie a été établie à l’aide du socket.  
  
 Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, reportez-vous à la version de Windows Sockets 2 documentation de code d’erreur API dans la bibliothèque MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.Ttl%2A> propriété.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur TTL ne peut pas être un nombre négatif.</exception>
        <exception cref="T:System.NotSupportedException">Cette propriété ne peut être définie que pour les sockets dans les familles <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant la tentative d’accès au socket. Cette erreur est également retournée lorsqu'une tentative a été faite pour affecter à TTL une valeur supérieure à 255.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie si le socket doit utiliser uniquement le mode d'E/S avec chevauchement.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> utilise uniquement le mode d'E/S avec chevauchement ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété sur `true` pour un <xref:System.Net.Sockets.Socket> que vous voulez appeler <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. Sinon, le Framework peut assigner un port de terminaison pour le socket, ce qui empêchera l’utilisation de <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le socket est lié à un port de terminaison.</exception>
      </Docs>
    </Member>
  </Members>
</Type>