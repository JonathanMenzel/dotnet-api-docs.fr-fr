<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TransmitFileOptions.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac57b5a0fa4a075e8c683de9144df832ae697f025f8.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7b5a0fa4a075e8c683de9144df832ae697f025f8</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> enumeration defines values used in file transfer requests.</source>
          <target state="translated">L'énumération <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> définit les valeurs utilisées dans les demandes de transfert de fichiers.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> The flags Disconnect and ReuseSocket return the socket to a disconnected, reusable state after the file has been transmitted.</source>
          <target state="translated"><bpt id="p1">**</bpt>Remarque<ept id="p1">**</ept> les indicateurs de déconnexion ReuseSocket retrouver le socket déconnecté, réutilisable de l’état une fois que le fichier a été transmis.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>These flags should not be used on a socket where quality of service (QOS) has been requested, because the service provider might immediately delete any quality of service associated with the socket before the file transfer has completed.</source>
          <target state="translated">Ces indicateurs ne doivent pas servir sur un socket où la qualité de service (QOS) a été demandée, car le fournisseur de services peut supprimer immédiatement toute qualité de service associée au socket avant la fin du transfert de fichiers.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>The best approach for a QOS-enabled socket is to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> when the file transfer has completed, rather than relying on these flags.</source>
          <target state="translated">La meilleure approche pour un socket prenant en charge QOS consiste à appeler <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> lorsque le transfert de fichiers est terminée, au lieu de compter sur ces indicateurs.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>The following example demonstrates the use of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.ReuseSocket&gt;</ph> in a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.ReuseSocket&gt;</ph> dans un appel à <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">Le fichier « test.txt » se trouve dans le répertoire racine de l’ordinateur local.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>In this example, a prebuffer and postbuffer of data are created and sent to the remote host with the file.</source>
          <target state="translated">Dans cet exemple, un prebuffer postbuffer de données sont créés et envoyées à l’hôte distant avec le fichier.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>To use the system's default thread, UseDefaultWorkerThread is specified.</source>
          <target state="translated">Pour utiliser le thread du système par défaut, UseDefaultWorkerThread est spécifié.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.Disconnect">
          <source>Start a transport-level disconnect after all the file data has been queued for transmission.</source>
          <target state="translated">Démarrez une déconnexion de niveau transport lorsque toutes les données de fichiers sont mises en file d'attente en vue de leur transmission.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.Disconnect">
          <source>When used with <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket" /&gt;</ph>, these flags return the socket to a disconnected, reusable state after the file has been transmitted.</source>
          <target state="translated">En cas d'utilisation avec <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket" /&gt;</ph>, ces indicateurs rétablissent l'état déconnecté et réutilisable du socket une fois le fichier transmis.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket">
          <source>The socket handle may be reused when the request completes.</source>
          <target state="translated">Le handle de socket peut être réutilisé une fois la demande terminée.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket">
          <source>This flag is valid only if <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph> is also specified.</source>
          <target state="translated">Cet indicateur n'est valide que si <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph> est également spécifié.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket">
          <source>When used with <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph>, these flags return the socket to a disconnected, reusable state after the file has been transmitted.</source>
          <target state="translated">En cas d'utilisation avec <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph>, ces indicateurs rétablissent l'état déconnecté et réutilisable du socket une fois le fichier transmis.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread">
          <source>Use the default thread to process long file transfer requests.</source>
          <target state="translated">Utilisez le thread par défaut pour traiter les longues demandes de transfert de fichiers.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.UseKernelApc">
          <source>Use kernel asynchronous procedure calls (APCs) instead of worker threads to process long file transfer requests.</source>
          <target state="translated">Utilisez des appels de procédure asynchrone du noyau plutôt que des threads de travail pour traiter les longues demandes de transfert de fichiers.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.UseKernelApc">
          <source>Long requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.</source>
          <target state="translated">Les longues demandes sont celles qui requièrent plusieurs lectures du fichier ou d'un cache. La demande dépend par conséquent de la taille du fichier et de la longueur spécifiée du paquet d'envoi.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.UseSystemThread">
          <source>Use system threads to process long file transfer requests.</source>
          <target state="translated">Utilisez des threads système pour traiter les longues demandes de transfert de fichiers.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.WriteBehind">
          <source>Complete the file transfer request immediately, without pending.</source>
          <target state="translated">Exécutez immédiatement la demande de transfert de fichiers, sans la mettre en attente.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.WriteBehind">
          <source>If this flag is specified and the file transfer succeeds, the data has been accepted by the system but not necessarily acknowledged by the remote end.</source>
          <target state="translated">Si cet indicateur est spécifié et si le transfert de fichiers réussit, les données sont acceptées par le système, mais pas nécessairement par l'extrémité distante.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.WriteBehind">
          <source>Do not use this flag with the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket" /&gt;</ph> flags.</source>
          <target state="translated">N'utilisez pas cet indicateur avec les indicateurs <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph> et <ph id="ph2">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>