<Type Name="NetworkStream" FullName="System.Net.Sockets.NetworkStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0f9b3287ea8eafb8d3d2d9f207429a0f3d86eb49" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460983" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NetworkStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetworkStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.NetworkStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NetworkStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetworkStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit le flux de données sous-jacent pour l’accès réseau.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> classe fournit des méthodes pour envoyer et recevoir des données via <xref:System.Net.Sockets.SocketType.Stream> sockets en mode blocage. Pour plus d’informations sur le blocage et non bloquant <xref:System.Net.Sockets.Socket>s, consultez [à l’aide d’un Socket Client asynchrone](~/docs/framework/network-programming/using-an-asynchronous-client-socket.md). Vous pouvez utiliser la <xref:System.Net.Sockets.NetworkStream> classe pour les transferts de données synchrones et asynchrones. Pour plus d’informations sur les communications synchrones et asynchrones, consultez [Sockets](~/docs/framework/network-programming/sockets.md).  
  
 Pour créer un <xref:System.Net.Sockets.NetworkStream>, vous devez fournir un connecté <xref:System.Net.Sockets.Socket>. Vous pouvez également spécifier <xref:System.IO.FileAccess> autorisation le <xref:System.Net.Sockets.NetworkStream> sur fourni <xref:System.Net.Sockets.Socket>. Par défaut, la fermeture de la <xref:System.Net.Sockets.NetworkStream> ne ferme pas fourni <xref:System.Net.Sockets.Socket>. Si vous souhaitez que le <xref:System.Net.Sockets.NetworkStream> soit autorisé à fermer fourni <xref:System.Net.Sockets.Socket>, vous devez spécifier `true` pour la valeur de le `ownsSocket` paramètre.  
  
 Utilisez le <xref:System.Net.Sockets.NetworkStream.Write%2A> et <xref:System.Net.Sockets.NetworkStream.Read%2A> méthodes unique pour les threads d’e/s bloquante synchrone. Si vous souhaitez traiter votre d’e/s à l’aide de threads séparés, envisagez d’utiliser le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> et <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthodes, ou le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> et <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthodes pour la communication.  
  
 Le <xref:System.Net.Sockets.NetworkStream> ne prend pas en charge l’accès aléatoire aux flux de données réseau. La valeur de la <xref:System.Net.Sockets.NetworkStream.CanSeek%2A> propriété qui indique si le flux prend en charge la recherche, est toujours `false`; lecture le <xref:System.Net.Sockets.NetworkStream.Position%2A> propriété, la lecture de la <xref:System.Net.Sockets.NetworkStream.Length%2A> propriété, ou en appelant le <xref:System.Net.Sockets.NetworkStream.Seek%2A> méthode lève un <xref:System.NotSupportedException>.  
  
 Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans avoir besoin pour la synchronisation. Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un <xref:System.Net.Sockets.NetworkStream> de connecté <xref:System.Net.Sockets.SocketType.Stream> <xref:System.Net.Sockets.Socket> et effectuer une e/s bloquante synchrone de base.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="socket">
          <see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</param>
        <summary>Crée une nouvelle instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifiée aux <xref:System.Net.Sockets.Socket>. Le <xref:System.Net.Sockets.NetworkStream> ne possède pas le <xref:System.Net.Sockets.Socket>, de sorte que l’appel du <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ne ferme pas le <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un <xref:System.Net.Sockets.NetworkStream> avec un <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le paramètre <paramref name="socket" /> n'est pas connecté.  
  
 - ou -  
  
 La propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
 - ou -  
  
 Le paramètre <paramref name="socket" /> est dans un état non bloquant.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, bool ownsSocket);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">
          <see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</param>
        <param name="ownsSocket">A la valeur <see langword="true" /> pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> prendra possession de <see cref="T:System.Net.Sockets.Socket" /> ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié avec l'appartenance <see cref="T:System.Net.Sockets.Socket" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifiée aux <xref:System.Net.Sockets.Socket>. Si la valeur de `ownsSocket` paramètre est `true`, le <xref:System.Net.Sockets.NetworkStream> prend possession de l’objet sous-jacent <xref:System.Net.Sockets.Socket>et en appelant le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ferme également sous-jacent <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la propriété de la <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le paramètre <paramref name="socket" /> n'est pas connecté.  
  
 - ou -  
  
 la propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
 - ou -  
  
 le paramètre <paramref name="socket" /> est dans un état non bloquant.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="socket">
          <see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</param>
        <param name="access">Combinaison d'opérations de bits des valeurs <see cref="T:System.IO.FileAccess" /> qui spécifie le type d'accès accordé à <see cref="T:System.Net.Sockets.NetworkStream" /> sur le <see cref="T:System.Net.Sockets.Socket" /> fourni.</param>
        <summary>Crée une nouvelle instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié possédant les droits d'accès donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec l’accès spécifié à l’objet <xref:System.Net.Sockets.Socket>. Avec ce constructeur, le <xref:System.Net.Sockets.NetworkStream> ne possède pas le <xref:System.Net.Sockets.Socket>, de sorte que l’appel du <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ne ferme pas sous-jacent <xref:System.Net.Sockets.Socket>.  
  
 Le `access` jeux de paramètres la <xref:System.Net.Sockets.NetworkStream.CanRead%2A> et <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriétés de la <xref:System.Net.Sockets.NetworkStream>. Si vous spécifiez <xref:System.IO.FileAccess.Write>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.Read>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.ReadWrite>, les deux appels de méthode sont autorisés.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la possibilité de lire et écrire dans le <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le paramètre <paramref name="socket" /> n'est pas connecté.  
  
 - ou -  
  
 la propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
 - ou -  
  
 le paramètre <paramref name="socket" /> est dans un état non bloquant.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access, bool ownsSocket);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">
          <see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</param>
        <param name="access">Combinaison d'opérations de bits des valeurs <see cref="T:System.IO.FileAccess" /> qui spécifie le type d'accès accordé à <see cref="T:System.Net.Sockets.NetworkStream" /> sur le <see cref="T:System.Net.Sockets.Socket" /> fourni.</param>
        <param name="ownsSocket">A la valeur <see langword="true" /> pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> prendra possession de <see cref="T:System.Net.Sockets.Socket" /> ; sinon, <see langword="false" />.</param>
        <summary>Crée une instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié possédant les droits d'accès et l'appartenance <see cref="T:System.Net.Sockets.Socket" /> donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifiée aux <xref:System.Net.Sockets.Socket>. Si la valeur de la `ownsSocket` paramètre est `true`, le <xref:System.Net.Sockets.NetworkStream> prend possession de l’objet sous-jacent <xref:System.Net.Sockets.Socket>et en appelant le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ferme également sous-jacent <xref:System.Net.Sockets.Socket>.  
  
 Le `access` jeux de paramètres la <xref:System.Net.Sockets.NetworkStream.CanRead%2A> et <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriétés de la <xref:System.Net.Sockets.NetworkStream>. Si vous spécifiez <xref:System.IO.FileAccess.Write>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.Read>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.ReadWrite>, les deux appels de méthode sont autorisés.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la possibilité de lire et écrire dans le <xref:System.Net.Sockets.Socket>. La propriété de la <xref:System.Net.Sockets.Socket> est accordée à <xref:System.Net.Sockets.NetworkStream> en spécifiant `true` pour la `ownsSocket` paramètre.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le paramètre <paramref name="socket" /> n'est pas connecté.  
  
 - ou -  
  
 La propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
 - ou -  
  
 Le paramètre <paramref name="socket" /> est dans un état non bloquant.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui correspond à l'emplacement dans la mémoire pour stocker des données lues à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">Emplacement dans <c>buffer</c> auquel commencer le stockage des données.</param>
        <param name="size">Nombre d'octets à lire à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> exécuté lorsque <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> se termine.</param>
        <param name="state">Objet contenant toutes les données supplémentaires définies par l'utilisateur.</param>
        <summary>Démarre une lecture asynchrone de <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'appel asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode démarre la lecture asynchrone des données à partir des tampons réseau entrants. Appel de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode vous donne la possibilité de recevoir des données dans un thread d’exécution distinct.  
  
 Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode). Au minimum, votre `state` paramètre doit contenir le <xref:System.Net.Sockets.NetworkStream>. Étant donné que vous devez obtenir les données reçues dans votre méthode de rappel, vous devez créer une petite classe ou une structure contenant un tampon de lecture et d’autres informations utiles. Passez l’instance de classe ou structure à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.NetworkStream.EndRead%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, le système attend jusqu'à ce que les données reçues ou une erreur se produit, puis le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.NetworkStream.EndRead%2A> jusqu'à fourni <xref:System.Net.Sockets.NetworkStream> lit données ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Appelez <xref:System.Threading.EventWaitHandle.Set%2A> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans avoir besoin pour la synchronisation. Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.  
  
   
  
## Examples  
 Le code suivant utilise des exemple <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> pour lire des données de façon asynchrone à partir du flux réseau. Le `myReadCallBack` méthode implémente la <xref:System.AsyncCallback> délégué et est appelée par le système lorsque <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> renvoie.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="offset" /> est inférieur à 0.  
  
 - ou -  
  
 Le paramètre <paramref name="offset" /> est supérieure à la longueur du paramètre <paramref name="buffer" />.  
  
 - ou -  
  
 <paramref name="size" /> est inférieur à 0.  
  
 - ou -  
  
 <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.  
  
 - ou -  
  
 Une erreur s'est produite pendant la lecture à partir du réseau.  
  
 - ou -  
  
 Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">Emplacement dans <c>buffer</c> auquel commencer l’envoi des données.</param>
        <param name="size">Nombre d'octets à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> exécuté lorsque <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> se termine.</param>
        <param name="state">Objet contenant toutes les données supplémentaires définies par l'utilisateur.</param>
        <summary>Démarre une écriture asynchrone dans un flux.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'appel asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant. Appel de la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.  
  
 Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> (méthode). Au minimum, votre `state` paramètre doit contenir le <xref:System.Net.Sockets.NetworkStream>. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.NetworkStream> et les autres informations requises. Passez l’instance de classe ou structure à la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit implémenter la <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> jusqu'à ce que le <xref:System.Net.Sockets.NetworkStream> envoie le nombre d’octets demandé ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Appelez <xref:System.Threading.EventWaitHandle.Set%2A> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans avoir besoin pour la synchronisation. Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.  
  
   
  
## Examples  
 Le code suivant utilise des exemple <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> pour écrire des données de façon asynchrone dans un flux réseau. Le `myWriteCallBack` méthode implémente la <xref:System.AsyncCallback> délégué et est appelée par le système lorsque <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> renvoie.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="offset" /> est inférieur à 0.  
  
 - ou -  
  
 Le paramètre <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
 - ou -  
  
 Le paramètre <paramref name="size" /> est inférieur à 0.  
  
 - ou -  
  
 Le paramètre <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.  
  
 - ou -  
  
 Une erreur s'est produite pendant l'écriture sur le réseau.  
  
 - ou -  
  
 Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Net.Sockets.NetworkStream" /> prend en charge la lecture.</summary>
        <value>
          <see langword="true" /> si les données du flux peuvent être lues ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Net.Sockets.NetworkStream.CanRead%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Fournir les informations appropriées <xref:System.IO.FileAccess> énumérées dans le constructeur pour définir la lisibilité et écriture de la <xref:System.Net.Sockets.NetworkStream>. Le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Le code suivant exemple vérifie <xref:System.Net.Sockets.NetworkStream.CanRead%2A> pour vérifier que le <xref:System.Net.Sockets.NetworkStream> est accessible en lecture. Il effectue ensuite une opération de lecture sur le <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le flux prend en charge la recherche. Cette propriété n'est pas actuellement prise en charge. Elle retourne toujours <see langword="false" />.</summary>
        <value>
          <see langword="false" /> dans tous les cas pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> ne peut pas rechercher un emplacement spécifique dans le flux.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si les propriétés de délai d'attente peuvent être utilisées pour <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <value>
          <see langword="true" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est présente, car elle est héritée <xref:System.IO.Stream>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Net.Sockets.NetworkStream" /> prend en charge l'écriture.</summary>
        <value>
          <see langword="true" /> si les données peuvent être écrites dans <see cref="T:System.Net.Sockets.NetworkStream" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Fournir les informations appropriées <xref:System.IO.FileAccess> énumérées dans le constructeur pour définir la lisibilité et écriture de la <xref:System.Net.Sockets.NetworkStream>. Le <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Le code suivant exemple vérifie <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> pour vérifier que le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture. Il effectue ensuite une opération d’écriture sur le <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Entier signé 32 bits qui spécifie le nombre de millisecondes à attendre avant d'envoyer les données restantes éventuelles, préalablement à la fermeture.</param>
        <summary>Ferme <see cref="T:System.Net.Sockets.NetworkStream" /> après avoir attendu le temps spécifié pour permettre l'envoi des données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode libère les ressources non managées et managées associées à la <xref:System.Net.Sockets.NetworkStream>. Si le <xref:System.Net.Sockets.NetworkStream> possède sous-jacent <xref:System.Net.Sockets.Socket>, il est également fermé.  
  
 Si un <xref:System.Net.Sockets.NetworkStream> a été associé à un <xref:System.Net.Sockets.TcpClient>, le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode fermera la connexion TCP, mais ne dispose pas de la <xref:System.Net.Sockets.TcpClient>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="timeout" /> est inférieur à -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool DataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DataAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DataAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DataAvailable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si des données sont disponibles sur le <see cref="T:System.Net.Sockets.NetworkStream" /> à lire.</summary>
        <value>
          <see langword="true" /> si des données sont disponibles dans le flux à lire ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> propriété pour déterminer si les données sont prêtes à être lu. Si <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> est `true`, un appel à <xref:System.Net.Sockets.NetworkStream.Read%2A> retourne immédiatement. Si l’hôte distant arrête ou ferme la connexion, <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> peut lever un <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 L’exemple de code suivant lit le <xref:System.Net.Sockets.NetworkStream> tant que les données sont disponibles.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Utilisez la propriété <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> pour obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Net.Sockets.NetworkStream" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose` appelle la méthode protégée `Dispose(Boolean)` méthode avec la `disposing` paramètre la valeur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` la valeur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Net.Sockets.NetworkStream>. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> qui représente un appel asynchrone.</param>
        <summary>Gère la fin d'une lecture asynchrone.</summary>
        <returns>Nombre d'octets lus à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode termine l’opération de lecture asynchrone démarrée dans le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).  
  
 Avant d’appeler <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode). Extraire la réception <xref:System.Net.Sockets.NetworkStream> à partir de cet objet d’état. Après avoir obtenu le <xref:System.Net.Sockets.NetworkStream>, appelez le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.  
  
 Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode est bloquée jusqu'à ce que les données sont disponibles. Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode). Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode se termine immédiatement et retourne zéro octet.  
  
 Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult>et extrayez la mémoire tampon contenue dans l’objet d’état obtenu.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, `myReadCallback` est fourni à <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> comme méthode de rappel. <xref:System.Net.Sockets.NetworkStream.EndRead%2A> est implémenté dans `myReadCallback` fin asynchrone de lecture appel démarré par <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#5)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#5)]
 [!code-vb[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.  
  
 - ou -  
  
 Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> qui représente l'appel asynchrone.</param>
        <summary>Gère la fin d'une écriture asynchrone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> termine l’opération d’envoi asynchrone démarrée dans <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 Avant d’appeler <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la `IAsyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.NetworkStream>. Après avoir obtenu le <xref:System.Net.Sockets.NetworkStream>, vous pouvez appeler la <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.  
  
 Le <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthode est bloquée jusqu'à ce que le nombre d’octets demandés est envoyé.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, `myWriteCallback` est fourni à <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> comme méthode de rappel. <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> est implémenté dans `myWriteCallback` pour terminer l’appel d’écriture asynchrone démarrée par <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.  
  
 - ou -  
  
 Une erreur s'est produite pendant l'écriture sur le réseau.  
  
 - ou -  
  
 Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NetworkStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NetworkStream ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Code d’application ne doit pas appeler cette méthode ; d’un objet <xref:System.Object.Finalize%2A> méthode est appelée automatiquement lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur l’utilisation de la méthode Finalize, consultez [destructeurs et méthodes Finalize](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md), et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vide les données du flux. Cette méthode est réservée à une utilisation ultérieure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.Flush%2A> méthode implémente le <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> méthode ; Toutefois, étant donné que <xref:System.Net.Sockets.NetworkStream> est ne pas mis en mémoire tampon, il n’a aucun effet sur les flux de réseau. Appel de la <xref:System.Net.Sockets.NetworkStream.Flush%2A> méthode ne lève pas d’exception.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Jeton d’annulation utilisé pour propager la notification d’annulation de cette opération.</param>
        <summary>Vide les données du flux en tant qu'opération asynchrone.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task" />.  
  
 Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Retourné <xref:System.Threading.Tasks.Task> objet s’achève une fois les données a été vidées à partir du flux pour le <xref:System.Net.Sockets.NetworkStream> instance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la longueur des données disponibles dans le flux. Cette propriété n'est pas actuellement prise en charge et lève toujours <see cref="T:System.NotSupportedException" />.</summary>
        <value>Longueur des données disponibles dans le flux.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Toute utilisation de cette propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position actuelle dans le flux. Cette propriété n'est pas actuellement prise en charge et lève toujours <see cref="T:System.NotSupportedException" />.</summary>
        <value>Position actuelle dans le flux.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Toute utilisation de cette propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, size As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui correspond à l'emplacement dans la mémoire pour stocker des données lues à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">Emplacement dans <c>buffer</c> auquel commencer le stockage des données.</param>
        <param name="size">Nombre d'octets à lire à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Lit les données de <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>Nombre d’octets lus à partir de <see cref="T:System.Net.Sockets.NetworkStream" />, ou 0 si le socket est fermé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit les données dans le `buffer` paramètre et retourne le nombre d’octets lus correctement. Si le socket est fermé, le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode renvoie la valeur 0. Le <xref:System.Net.Sockets.NetworkStream.Read%2A> opération lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre. Si l’hôte distant arrête la connexion, et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode se termine immédiatement et retourne zéro octet.  
  
> [!NOTE]
>  Vérifiez si le <xref:System.Net.Sockets.NetworkStream> est lisible en appelant le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété. Si vous tentez de lire un <xref:System.Net.Sockets.NetworkStream> qui n’est pas lisible, vous obtiendrez une <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Le code suivant utilise des exemple <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> pour déterminer si les données sont disponibles pour la lecture. Si les données sont disponibles, il lit à partir de la <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="offset" /> est inférieur à 0.  
  
 - ou -  
  
 Le paramètre <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
 - ou -  
  
 Le paramètre <paramref name="size" /> est inférieur à 0.  
  
 - ou -  
  
 Le paramètre <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.  
  
 - ou -  
  
 Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.  
  
 - ou -  
  
 Une erreur s'est produite pendant la lecture à partir du réseau.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Readable">
      <MemberSignature Language="C#" Value="protected bool Readable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Readable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Readable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Readable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Readable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si <see cref="T:System.Net.Sockets.NetworkStream" /> peut être lu.</summary>
        <value>
          <see langword="true" /> pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> peut être lu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez dériver la <xref:System.Net.Sockets.NetworkStream> classe à utiliser le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété. Si <xref:System.Net.Sockets.NetworkStream.Readable%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Vous pouvez également déterminer si un <xref:System.Net.Sockets.NetworkStream> est lisible en vérifiant accessible publiquement <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété.  
  
 Le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, le `CanCommunicate` propriété vérifications le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété pour déterminer si le <xref:System.Net.Sockets.NetworkStream> est accessible en lecture.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle une opération de lecture reste bloquée en attendant des données.</summary>
        <value>
          <see cref="T:System.Int32" /> qui spécifie la durée, en millisecondes, qui doit s'écouler avant l'échec d'une opération de lecture. La valeur par défaut, <see cref="F:System.Threading.Timeout.Infinite" />, spécifie que l'opération de lecture n'expire pas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération de lecture ne se termine pas dans le délai spécifié par cette propriété, l’opération de lecture lève une <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Cette propriété affecte uniquement les lectures synchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Cette propriété n’affecte pas les lectures asynchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant définit le délai d’attente de lecture d’un flux de réseau à 10 millisecondes.  
  
 [!code-csharp[NCLTcpClientSync#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée est inférieure ou égale à zéro et n'est pas <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ce paramètre n'est pas utilisé.</param>
        <param name="origin">Ce paramètre n'est pas utilisé.</param>
        <summary>Affecte la valeur donnée à la position actuelle du flux. Cette méthode n'est pas actuellement prise en charge et lève toujours <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Position dans le flux.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Toute utilisation de cette propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Ce paramètre n'est pas utilisé.</param>
        <summary>Définit la longueur du flux. Cette méthode lève toujours <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Toute utilisation de cette propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="Socket">
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Socket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Socket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Socket" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Socket As Socket" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Socket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent.</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> qui représente la connexion réseau sous-jacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de <xref:System.Net.Sockets.NetworkStream> pouvez utiliser cette propriété pour obtenir l’objet sous-jacent <xref:System.Net.Sockets.Socket>. Utilisez sous-jacent <xref:System.Net.Sockets.Socket> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.Socket%2A> propriété si vous avez besoin d’accéder aux au-delà de celles qui <xref:System.Net.Sockets.NetworkStream> fournit.  
  
> [!NOTE]
>  Cette propriété est accessible uniquement par le biais de cette classe ou une classe dérivée.  
  
   
  
## Examples  
 L’exemple de code suivant récupère sous-jacent <xref:System.Net.Sockets.Socket> pour vérifier une connexion active.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">Emplacement dans <c>buffer</c> à partir duquel commencer l’écriture des données.</param>
        <param name="size">Nombre d'octets à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Écrit des données dans <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode commence à la position spécifiée `offset` et envoie `size` octets à partir du contenu de `buffer` au réseau. Le <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode est bloquée jusqu'à ce que le nombre d’octets demandé est envoyé ou une <xref:System.Net.Sockets.SocketException> est levée. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Vérifiez si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture en accédant à la <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété. Si vous tentez d’écrire dans un <xref:System.Net.Sockets.NetworkStream> qui n’est pas accessible en écriture, vous obtiendrez une <xref:System.IO.IOException>. Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Le code suivant exemple vérifie si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture. Si elle est ensuite <xref:System.Net.Sockets.NetworkStream.Write%2A> est utilisé pour écrire un message de petite taille.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="offset" /> est inférieur à 0.  
  
 - ou -  
  
 Le paramètre <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
 - ou -  
  
 Le paramètre <paramref name="size" /> est inférieur à 0.  
  
 - ou -  
  
 Le paramètre <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur s'est produite pendant l'écriture sur le réseau.  
  
 - ou -  
  
 Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.  
  
 - ou -  
  
 Une erreur s'est produite pendant la lecture à partir du réseau.</exception>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="Writeable">
      <MemberSignature Language="C#" Value="protected bool Writeable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Writeable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Writeable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Writeable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Writeable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Net.Sockets.NetworkStream" /> est accessible en écriture.</summary>
        <value>
          <see langword="true" /> si les données peuvent être écrites dans le flux ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez dériver la <xref:System.Net.Sockets.NetworkStream> classe à utiliser le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété. Si <xref:System.Net.Sockets.NetworkStream.Writeable%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Vous pouvez également déterminer si un <xref:System.Net.Sockets.NetworkStream> est accessible en écriture en vérifiant accessible publiquement <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété.  
  
 Le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, le `CanCommunicate` propriété vérifie le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété pour déterminer si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle une opération d'écriture reste bloquée en attendant des données.</summary>
        <value>
          <see cref="T:System.Int32" /> qui spécifie la durée, en millisecondes, qui doit s'écouler avant l'échec d'une opération d'écriture. La valeur par défaut, <see cref="F:System.Threading.Timeout.Infinite" />, spécifie que l'opération d'écriture n'expire pas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération d’écriture ne se termine pas dans le délai spécifié par cette propriété, l’opération d’écriture lève un <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Cette propriété affecte les opérations d’écriture synchrone uniquement effectuées en appelant le <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Cette propriété n’affecte pas les écritures asynchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant définit le délai d’attente de l’écriture d’un flux de réseau à 10 millisecondes.  
  
 [!code-cpp[NCLTcpServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclTcpServerSync/cpp/tcplistener.cpp#0)]
 [!code-csharp[NCLTcpServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclTcpServerSync/CS/tcplistener.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée est inférieure ou égale à zéro et n'est pas <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>