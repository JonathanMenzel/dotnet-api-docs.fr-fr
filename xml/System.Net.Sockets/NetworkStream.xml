<Type Name="NetworkStream" FullName="System.Net.Sockets.NetworkStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1ec3dfbba227fd23ea100bde76cba1b9a9e92fbb" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55367076" /></Metadata><TypeSignature Language="C#" Value="public class NetworkStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetworkStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.NetworkStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NetworkStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetworkStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type NetworkStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <summary>Fournit le flux de données sous-jacent pour l’accès réseau.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> classe fournit des méthodes pour l’envoi et réception de données sur <xref:System.Net.Sockets.SocketType.Stream> sockets en mode blocage. Pour plus d’informations sur le blocage et non bloquant <xref:System.Net.Sockets.Socket>s, consultez [à l’aide d’un Socket Client asynchrone](~/docs/framework/network-programming/using-an-asynchronous-client-socket.md). Vous pouvez utiliser la <xref:System.Net.Sockets.NetworkStream> classe pour les transferts de données synchrones et asynchrones. Pour plus d’informations sur la communication synchrone et asynchrone, consultez [Sockets](~/docs/framework/network-programming/sockets.md).  
  
 Pour créer un <xref:System.Net.Sockets.NetworkStream>, vous devez fournir un connecté <xref:System.Net.Sockets.Socket>. Vous pouvez également spécifier quel <xref:System.IO.FileAccess> autorisation la <xref:System.Net.Sockets.NetworkStream> a sur fourni <xref:System.Net.Sockets.Socket>. Par défaut, la fermeture de la <xref:System.Net.Sockets.NetworkStream> ne ferme pas fourni <xref:System.Net.Sockets.Socket>. Si vous souhaitez que le <xref:System.Net.Sockets.NetworkStream> être autorisé à fermer fourni <xref:System.Net.Sockets.Socket>, vous devez spécifier `true` pour la valeur de la `ownsSocket` paramètre.  
  
 Utilisez le <xref:System.Net.Sockets.NetworkStream.Write%2A> et <xref:System.Net.Sockets.NetworkStream.Read%2A> méthodes pour unique simple des threads d’e/s bloquante synchrone. Si vous souhaitez traiter votre d’e/s à l’aide de threads séparés, envisagez d’utiliser le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> et <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthodes, ou le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> et <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthodes pour la communication.  
  
 Le <xref:System.Net.Sockets.NetworkStream> ne prend pas en charge l’accès aléatoire au flux de données réseau. La valeur de la <xref:System.Net.Sockets.NetworkStream.CanSeek%2A> propriété, qui indique si le flux prend en charge la recherche, est toujours `false`; lecture le <xref:System.Net.Sockets.NetworkStream.Position%2A> propriété, lecture le <xref:System.Net.Sockets.NetworkStream.Length%2A> propriété, ou en appelant le <xref:System.Net.Sockets.NetworkStream.Seek%2A> méthode lève un <xref:System.NotSupportedException>.  
  
 Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans la nécessité de synchronisation. Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un <xref:System.Net.Sockets.NetworkStream> à partir d’un connecté <xref:System.Net.Sockets.SocketType.Stream> <xref:System.Net.Sockets.Socket> et effectuer une e/s bloquante synchrone de base.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream socket" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="socket"><see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</param>
        <summary>Crée une nouvelle instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifié <xref:System.Net.Sockets.Socket>. Le <xref:System.Net.Sockets.NetworkStream> ne possède pas le <xref:System.Net.Sockets.Socket>, de sorte que l’appel le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ne ferme pas la <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un <xref:System.Net.Sockets.NetworkStream> avec un <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le paramètre <paramref name="socket" /> n'est pas connecté.  
  
ou 
La propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
ou 
Le paramètre <paramref name="socket" /> est dans un état non bloquant.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <related type="Article" href="~/docs/framework/network-programming/using-streams-on-the-network.md">Utilisation de flux sur le réseau</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, bool ownsSocket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * bool -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, ownsSocket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket"><see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</param>
        <param name="ownsSocket">A la valeur <see langword="true" /> pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> prendra possession de <see cref="T:System.Net.Sockets.Socket" /> ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié avec l'appartenance <see cref="T:System.Net.Sockets.Socket" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifié <xref:System.Net.Sockets.Socket>. Si la valeur de `ownsSocket` paramètre est `true`, le <xref:System.Net.Sockets.NetworkStream> prend possession du sous-jacent <xref:System.Net.Sockets.Socket>et en appelant le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ferme également sous-jacent <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la propriété de la <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le paramètre <paramref name="socket" /> n'est pas connecté.  
  
ou 
la propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
ou 
le paramètre <paramref name="socket" /> est dans un état non bloquant.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * System.IO.FileAccess -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="socket"><see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</param>
        <param name="access">Combinaison d'opérations de bits des valeurs <see cref="T:System.IO.FileAccess" /> qui spécifie le type d'accès accordé à <see cref="T:System.Net.Sockets.NetworkStream" /> sur le <see cref="T:System.Net.Sockets.Socket" /> fourni.</param>
        <summary>Crée une nouvelle instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié possédant les droits d'accès donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec l’accès spécifié aux spécifié <xref:System.Net.Sockets.Socket>. Avec ce constructeur, le <xref:System.Net.Sockets.NetworkStream> ne possède pas le <xref:System.Net.Sockets.Socket>, de sorte que l’appel le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ne ferme pas sous-jacent <xref:System.Net.Sockets.Socket>.  
  
 Le `access` jeux de paramètres le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> et <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriétés de la <xref:System.Net.Sockets.NetworkStream>. Si vous spécifiez <xref:System.IO.FileAccess.Write>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.Read>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.ReadWrite>, les deux appels de méthode sont autorisés.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la possibilité de lire et écrire dans le <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le paramètre <paramref name="socket" /> n'est pas connecté.  
  
ou 
la propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
ou 
le paramètre <paramref name="socket" /> est dans un état non bloquant.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * System.IO.FileAccess * bool -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, access, ownsSocket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket"><see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</param>
        <param name="access">Combinaison d'opérations de bits des valeurs <see cref="T:System.IO.FileAccess" /> qui spécifie le type d'accès accordé à <see cref="T:System.Net.Sockets.NetworkStream" /> sur le <see cref="T:System.Net.Sockets.Socket" /> fourni.</param>
        <param name="ownsSocket">A la valeur <see langword="true" /> pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> prendra possession de <see cref="T:System.Net.Sockets.Socket" /> ; sinon, <see langword="false" />.</param>
        <summary>Crée une instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié possédant les droits d'accès et l'appartenance <see cref="T:System.Net.Sockets.Socket" /> donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifié <xref:System.Net.Sockets.Socket>. Si la valeur de la `ownsSocket` paramètre est `true`, le <xref:System.Net.Sockets.NetworkStream> prend possession du sous-jacent <xref:System.Net.Sockets.Socket>et en appelant le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ferme également sous-jacent <xref:System.Net.Sockets.Socket>.  
  
 Le `access` jeux de paramètres le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> et <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriétés de la <xref:System.Net.Sockets.NetworkStream>. Si vous spécifiez <xref:System.IO.FileAccess.Write>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.Read>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.ReadWrite>, les deux appels de méthode sont autorisés.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la possibilité de lire et écrire dans le <xref:System.Net.Sockets.Socket>. La propriété de la <xref:System.Net.Sockets.Socket> est accordée à <xref:System.Net.Sockets.NetworkStream> en spécifiant `true` pour le `ownsSocket` paramètre.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le paramètre <paramref name="socket" /> n'est pas connecté.  
  
ou 
La propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
ou 
Le paramètre <paramref name="socket" /> est dans un état non bloquant.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="networkStream.BeginRead (buffer, offset, size, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui correspond à l'emplacement dans la mémoire pour stocker des données lues à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">Emplacement de <paramref name="buffer" /> auquel commencer le stockage des données.</param>
        <param name="size">Nombre d'octets à lire à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> exécuté lorsque <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> se termine.</param>
        <param name="state">Objet contenant toutes les données supplémentaires définies par l'utilisateur.</param>
        <summary>Démarre une lecture asynchrone de <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'appel asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode démarre la lecture asynchrone des données à partir des tampons réseau entrants. Appel de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode vous donne la possibilité de recevoir les données dans un thread d’exécution distinct.  
  
 Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode). Au minimum, votre `state` paramètre doit contenir le <xref:System.Net.Sockets.NetworkStream>. Étant donné que vous souhaitez obtenir les données reçues dans votre méthode de rappel, vous devez créer une petite classe ou une structure contenant un tampon de lecture et d’autres informations utiles. Passez l’instance de classe ou structure à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.NetworkStream.EndRead%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, le système attendra jusqu'à ce que les données sont reçues ou une erreur se produit, puis le système utilise un thread distinct pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.NetworkStream.EndRead%2A> jusqu'à ce que le texte fourni <xref:System.Net.Sockets.NetworkStream> lit données ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode), utilisez le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Appelez <xref:System.Threading.EventWaitHandle.Set%2A> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode lit autant de données est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété afin de déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
 Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans la nécessité de synchronisation. Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> pour lire les données de façon asynchrone à partir du flux réseau. Le `myReadCallBack` méthode implémente la <xref:System.AsyncCallback> délégué et est appelée par le système lorsque <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> retourne.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="offset" /> est inférieur à 0.  
  
ou 
Le paramètre <paramref name="offset" /> est supérieure à la longueur du paramètre <paramref name="buffer" />.  
  
ou 
<paramref name="size" /> est inférieur à 0.  
  
ou 
<paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.  
  
ou 
Une erreur s'est produite pendant la lecture à partir du réseau.  
  
ou 
Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="networkStream.BeginWrite (buffer, offset, size, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">Emplacement de <paramref name="buffer" /> auquel commencer l'envoi des données.</param>
        <param name="size">Nombre d'octets à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> exécuté lorsque <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> se termine.</param>
        <param name="state">Objet contenant toutes les données supplémentaires définies par l'utilisateur.</param>
        <summary>Démarre une écriture asynchrone dans un flux.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'appel asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant. Appel de la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.  
  
 Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> (méthode). Au minimum, votre `state` paramètre doit contenir le <xref:System.Net.Sockets.NetworkStream>. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.NetworkStream> et les autres informations requises. Passez l’instance de classe ou structure à la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit implémenter la <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, le système utilise un thread distinct pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> jusqu'à ce que le <xref:System.Net.Sockets.NetworkStream> envoie le nombre d’octets demandé ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après avoir appelé la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> (méthode), utilisez le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Appelez <xref:System.Threading.EventWaitHandle.Set%2A> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété afin de déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
 Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans la nécessité de synchronisation. Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> pour écrire des données de façon asynchrone dans un flux réseau. Le `myWriteCallBack` méthode implémente la <xref:System.AsyncCallback> délégué et est appelée par le système lorsque <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> retourne.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="offset" /> est inférieur à 0.  
  
ou 
Le paramètre <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
Le paramètre <paramref name="size" /> est inférieur à 0.  
  
ou 
Le paramètre <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.  
  
ou 
Une erreur s'est produite pendant l'écriture sur le réseau.  
  
ou 
Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Sockets.NetworkStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Net.Sockets.NetworkStream" /> prend en charge la lecture.</summary>
        <value><see langword="true" /> si les données du flux peuvent être lues ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Net.Sockets.NetworkStream.CanRead%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Fournir les informations appropriées <xref:System.IO.FileAccess> valeur dans le constructeur pour définir la lisibilité et la facilité d’écriture d’énumérée le <xref:System.Net.Sockets.NetworkStream>. Le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Le code suivant exemple vérifie <xref:System.Net.Sockets.NetworkStream.CanRead%2A> pour vérifier que le <xref:System.Net.Sockets.NetworkStream> est lisible. Il effectue ensuite une opération de lecture sur le <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le flux prend en charge la recherche. Cette propriété n'est pas actuellement prise en charge. Elle retourne toujours <see langword="false" />.</summary>
        <value><see langword="false" /> dans tous les cas pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> ne peut pas rechercher un emplacement spécifique dans le flux.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si les propriétés de délai d'attente peuvent être utilisées pour <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <value><see langword="true" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est présente, car elle est héritée de <xref:System.IO.Stream>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Net.Sockets.NetworkStream" /> prend en charge l'écriture.</summary>
        <value><see langword="true" /> si les données peuvent être écrites dans <see cref="T:System.Net.Sockets.NetworkStream" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Fournir les informations appropriées <xref:System.IO.FileAccess> valeur dans le constructeur pour définir la lisibilité et la facilité d’écriture d’énumérée le <xref:System.Net.Sockets.NetworkStream>. Le <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Le code suivant exemple vérifie <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> pour vérifier que le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture. Il effectue ensuite une opération d’écriture sur le <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="networkStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Le `Close` méthode libère les ressources managées et non associées à la <xref:System.Net.Sockets.NetworkStream>. Si le <xref:System.Net.Sockets.NetworkStream> possède sous-jacent <xref:System.Net.Sockets.Socket>, il est également fermé.

Si un <xref:System.Net.Sockets.NetworkStream> a été associé à un <xref:System.Net.Sockets.TcpClient>, le `Close` méthode fermera la connexion TCP, mais n’éliminera pas associé <xref:System.Net.Sockets.TcpClient>.

## Examples  
Le code suivant exemple ferme le <xref:System.Net.Sockets.NetworkStream>.

```vb
' Example for closing the NetworkStream.
' Close the NetworkStream
myNetworkStream.Close()
```

```csharp
// Example for closing the NetworkStream.

// Close the NetworkStream
myNetworkStream.Close();
```

```cpp
// Example for closing the NetworkStream.
// Close the NetworkStream
myNetworkStream->Close();
```

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="override this.Close : int -&gt; unit" Usage="networkStream.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Entier signé 32 bits qui spécifie le nombre de millisecondes à attendre avant d'envoyer les données restantes éventuelles, préalablement à la fermeture.</param>
        <summary>Ferme <see cref="T:System.Net.Sockets.NetworkStream" /> après avoir attendu le temps spécifié pour permettre l'envoi des données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode libère les ressources managées et non associées à la <xref:System.Net.Sockets.NetworkStream>. Si le <xref:System.Net.Sockets.NetworkStream> possède sous-jacent <xref:System.Net.Sockets.Socket>, il est également fermé.  
  
 Si un <xref:System.Net.Sockets.NetworkStream> a été associé à un <xref:System.Net.Sockets.TcpClient>, le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode fermera la connexion TCP, mais n’éliminera pas associé <xref:System.Net.Sockets.TcpClient>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="timeout" /> est inférieur à -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool DataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DataAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DataAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DataAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DataAvailable : bool" Usage="System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si des données sont disponibles sur le <see cref="T:System.Net.Sockets.NetworkStream" /> à lire.</summary>
        <value><see langword="true" /> si des données sont disponibles dans le flux à lire ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> propriété afin de déterminer si les données sont prêtes à être lu. Si <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> est `true`, un appel à <xref:System.Net.Sockets.NetworkStream.Read%2A> retourne immédiatement. Si l’hôte distant arrête ou ferme la connexion, <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> peut lever une <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 L’exemple de code suivant lit le <xref:System.Net.Sockets.NetworkStream> tant que les données sont disponibles.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Utilisez la propriété <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> pour obtenir le code d’erreur, et reportez-vous à la documentation sur les <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">codes d’erreur de l’API Windows Sockets version 2</see> pour obtenir une description détaillée de l’erreur.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="networkStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Net.Sockets.NetworkStream" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Net.Sockets.NetworkStream>. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="networkStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> qui représente un appel asynchrone.</param>
        <summary>Gère la fin d'une lecture asynchrone.</summary>
        <returns>Nombre d'octets lus à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode termine l’opération de lecture asynchrone démarrée la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).  
  
 Avant d’appeler <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode). Extraire la réception <xref:System.Net.Sockets.NetworkStream> à partir de cet objet d’état. Après avoir obtenu le <xref:System.Net.Sockets.NetworkStream>, appelez le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.  
  
 Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode se bloque jusqu'à ce que les données sont disponibles. Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode). Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode se termine immédiatement et retourne zéro octet.  
  
 Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult>et extrayez la mémoire tampon contenue dans l’objet d’état qui en résulte.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété afin de déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, `myReadCallback` est fourni pour <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> en tant que la méthode de rappel. <xref:System.Net.Sockets.NetworkStream.EndRead%2A> est implémenté dans `myReadCallback` fin asynchrone lire l’appel lancé par <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#5)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#5)]
 [!code-vb[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.  
  
ou 
Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="networkStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> qui représente l'appel asynchrone.</param>
        <summary>Gère la fin d'une écriture asynchrone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> termine l’opération d’envoi asynchrone démarrée <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 Avant d’appeler <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la `IAsyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.NetworkStream>. Après avoir obtenu le <xref:System.Net.Sockets.NetworkStream>, vous pouvez appeler la <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.  
  
 Le <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthode se bloque jusqu'à ce que le nombre demandé d’octets est envoyé.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété afin de déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, `myWriteCallback` est fourni pour <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> en tant que la méthode de rappel. <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> est implémenté dans `myWriteCallback` pour terminer l’appel d’écriture asynchrone démarrée par <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.  
  
ou 
Une erreur s'est produite pendant l'écriture sur le réseau.  
  
ou 
Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NetworkStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NetworkStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="networkStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Code d’application ne doit pas appeler cette méthode ; d’un objet <xref:System.Object.Finalize%2A> méthode est appelée automatiquement lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur l’utilisation de la méthode Finalize, consultez [destructeurs et méthodes Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md), et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="networkStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vide les données du flux. Cette méthode est réservée à une utilisation ultérieure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.Flush%2A> méthode implémente la <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> méthode ; Toutefois, étant donné que <xref:System.Net.Sockets.NetworkStream> est ne pas mis en mémoire tampon, il n’a aucun effet sur les flux de réseau. Appel de la <xref:System.Net.Sockets.NetworkStream.Flush%2A> méthode ne lève pas d’exception.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="networkStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Jeton d’annulation utilisé pour propager la notification d’annulation de cette opération.</param>
        <summary>Vide les données du flux en tant qu'opération asynchrone.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Retourné <xref:System.Threading.Tasks.Task> objet se termine une fois que les données ont été vidées à partir du flux pour le <xref:System.Net.Sockets.NetworkStream> instance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Sockets.NetworkStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la longueur des données disponibles dans le flux. Cette propriété n'est pas actuellement prise en charge et lève toujours <see cref="T:System.NotSupportedException" />.</summary>
        <value>Longueur des données disponibles dans le flux.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Toute utilisation de cette propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Sockets.NetworkStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position actuelle dans le flux. Cette propriété n'est pas actuellement prise en charge et lève toujours <see cref="T:System.NotSupportedException" />.</summary>
        <value>Position actuelle dans le flux.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Toute utilisation de cette propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, size As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="networkStream.Read (buffer, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui correspond à l'emplacement dans la mémoire pour stocker des données lues à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">Emplacement de <paramref name="buffer" /> auquel commencer le stockage des données.</param>
        <param name="size">Nombre d'octets à lire à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Lit les données de <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>Nombre d’octets lus à partir de <see cref="T:System.Net.Sockets.NetworkStream" />, ou 0 si le socket est fermé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit les données dans le `buffer` paramètre et retourne le nombre d’octets lus avec succès. Si le socket est fermé, le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode retourne 0. Le <xref:System.Net.Sockets.NetworkStream.Read%2A> opération lit autant de données est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre. Si l’hôte distant arrête la connexion, et toutes les données disponibles a été reçu, le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode se termine immédiatement et retourne zéro octet.  
  
> [!NOTE]
>  Vérifiez si le <xref:System.Net.Sockets.NetworkStream> est lisible en appelant le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété. Si vous tentez de lire à partir d’un <xref:System.Net.Sockets.NetworkStream> qui n’est pas lisible, vous obtiendrez un <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété afin de déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> pour déterminer si les données sont disponibles pour la lecture. Si les données sont disponibles, il lit à partir de la <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="offset" /> est inférieur à 0.  
  
ou 
Le paramètre <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
Le paramètre <paramref name="size" /> est inférieur à 0.  
  
ou 
Le paramètre <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.  
  
ou 
Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.  
  
ou 
Une erreur s'est produite pendant la lecture à partir du réseau.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <related type="Article" href="~/docs/framework/network-programming/using-streams-on-the-network.md">Utilisation de flux sur le réseau</related>
      </Docs>
    </Member>
    <Member MemberName="Readable">
      <MemberSignature Language="C#" Value="protected bool Readable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Readable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Readable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Readable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Readable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Readable : bool with get, set" Usage="System.Net.Sockets.NetworkStream.Readable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si <see cref="T:System.Net.Sockets.NetworkStream" /> peut être lu.</summary>
        <value><see langword="true" /> pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> peut être lu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez dériver la <xref:System.Net.Sockets.NetworkStream> classe à utiliser le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété. Si <xref:System.Net.Sockets.NetworkStream.Readable%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Vous pouvez également déterminer si un <xref:System.Net.Sockets.NetworkStream> est lisible en vérifiant accessible publiquement <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété.  
  
 Le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, le `CanCommunicate` propriété vérifications le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété afin de déterminer si le <xref:System.Net.Sockets.NetworkStream> est lisible.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="networkStream.ReadAsync (buffer, offset, size, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle une opération de lecture reste bloquée en attendant des données.</summary>
        <value><see cref="T:System.Int32" /> qui spécifie la durée, en millisecondes, qui doit s'écouler avant l'échec d'une opération de lecture. La valeur par défaut, <see cref="F:System.Threading.Timeout.Infinite" />, spécifie que l'opération de lecture n'expire pas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération de lecture ne se termine pas dans le délai spécifié par cette propriété, l’opération de lecture lève une <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Cette propriété affecte uniquement les lectures synchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Cette propriété n’affecte pas les lectures asynchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant définit le délai d’attente de lecture pour un flux de réseau à 10 millisecondes.  
  
 [!code-csharp[NCLTcpClientSync#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée est inférieure ou égale à zéro et n'est pas <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="networkStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ce paramètre n'est pas utilisé.</param>
        <param name="origin">Ce paramètre n'est pas utilisé.</param>
        <summary>Affecte la valeur donnée à la position actuelle du flux. Cette méthode n'est pas actuellement prise en charge et lève toujours <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Position dans le flux.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Toute utilisation de cette propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="networkStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Ce paramètre n'est pas utilisé.</param>
        <summary>Définit la longueur du flux. Cette méthode lève toujours <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Toute utilisation de cette propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="Socket">
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Socket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Socket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Socket" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Socket As Socket" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Socket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Socket : System.Net.Sockets.Socket" Usage="System.Net.Sockets.NetworkStream.Socket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> qui représente la connexion réseau sous-jacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de <xref:System.Net.Sockets.NetworkStream> pouvez utiliser cette propriété pour obtenir sous-jacent <xref:System.Net.Sockets.Socket>. Utilisez sous-jacent <xref:System.Net.Sockets.Socket> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.Socket%2A> propriété si vous avez besoin d’accéder aux au-delà de celles qui <xref:System.Net.Sockets.NetworkStream> fournit.  
  
> [!NOTE]
>  Cette propriété est accessible uniquement par le biais de cette classe ou une classe dérivée.  
  
   
  
## Examples  
 L’exemple de code suivant récupère sous-jacent <xref:System.Net.Sockets.Socket> pour vérifier une connexion active.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Appelez la méthode `Dispose` une fois que vous avez terminé d'utiliser <xref:System.Net.Sockets.NetworkStream>. La méthode `Dispose` rend le <xref:System.Net.Sockets.NetworkStream> inutilisable. Après avoir appelé `Dispose`, vous devez libérer toutes les références à la <xref:System.Net.Sockets.NetworkStream> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Net.Sockets.NetworkStream> occupée. Pour plus d’informations sur l’utilisation de la méthode Dispose, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE]
> Appelez toujours `Dispose` avant de libérer votre dernière référence à <xref:System.Net.Sockets.NetworkStream>. Sinon, les ressources qu’il utilise ne sont pas libérées jusqu'à ce que le garbage collector appelle la <xref:System.Net.Sockets.NetworkStream> méthode Finalize de l’objet.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="networkStream.Write (buffer, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de type <see cref="T:System.Byte" /> qui contient les données à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">Emplacement de <paramref name="buffer" /> à partir duquel commencer à écrire les données.</param>
        <param name="size">Nombre d'octets à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Écrit des données dans <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode commence à l’emplacement spécifié `offset` et envoie `size` octets à partir du contenu de `buffer` au réseau. Le <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode se bloque jusqu'à ce que le nombre d’octets demandé est envoyé ou un <xref:System.Net.Sockets.SocketException> est levée. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Vérifiez si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture en accédant à la <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété. Si vous tentez d’écrire dans un <xref:System.Net.Sockets.NetworkStream> qui n’est pas accessible en écriture, vous obtiendrez un <xref:System.IO.IOException>. Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété afin de déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Le code suivant exemple vérifie si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture. Si elle est ensuite <xref:System.Net.Sockets.NetworkStream.Write%2A> est utilisé pour écrire un petit message.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="offset" /> est inférieur à 0.  
  
ou 
Le paramètre <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
Le paramètre <paramref name="size" /> est inférieur à 0.  
  
ou 
Le paramètre <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur s'est produite pendant l'écriture sur le réseau.  
  
ou 
Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.  
  
ou 
Une erreur s'est produite pendant la lecture à partir du réseau.</exception>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="Writeable">
      <MemberSignature Language="C#" Value="protected bool Writeable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Writeable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Writeable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Writeable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Writeable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Writeable : bool with get, set" Usage="System.Net.Sockets.NetworkStream.Writeable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Net.Sockets.NetworkStream" /> est accessible en écriture.</summary>
        <value><see langword="true" /> si les données peuvent être écrites dans le flux ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez dériver la <xref:System.Net.Sockets.NetworkStream> classe à utiliser le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété. Si <xref:System.Net.Sockets.NetworkStream.Writeable%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Vous pouvez également déterminer si un <xref:System.Net.Sockets.NetworkStream> est accessible en écriture en vérifiant accessible publiquement <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété.  
  
 Le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, le `CanCommunicate` propriété vérifications le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété afin de déterminer si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="networkStream.WriteAsync (buffer, offset, size, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle une opération d'écriture reste bloquée en attendant des données.</summary>
        <value><see cref="T:System.Int32" /> qui spécifie la durée, en millisecondes, qui doit s'écouler avant l'échec d'une opération d'écriture. La valeur par défaut, <see cref="F:System.Threading.Timeout.Infinite" />, spécifie que l'opération d'écriture n'expire pas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération d’écriture ne se termine pas dans le délai spécifié par cette propriété, l’opération d’écriture lève un <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Cette propriété affecte les opérations d’écriture synchrone uniquement effectuées en appelant le <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Cette propriété n’affecte pas les écritures asynchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant définit le délai d’expiration de l’écriture d’un flux de réseau à 10 millisecondes.  
  
 [!code-cpp[NCLTcpServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclTcpServerSync/cpp/tcplistener.cpp#0)]
 [!code-csharp[NCLTcpServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclTcpServerSync/CS/tcplistener.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée est inférieure ou égale à zéro et n'est pas <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>