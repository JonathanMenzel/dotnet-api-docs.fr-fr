<Type Name="NetworkStream" FullName="System.Net.Sockets.NetworkStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="da6f477a2cb785859d916208bd6d3718adc35921" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36550625" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NetworkStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetworkStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.NetworkStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NetworkStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetworkStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type NetworkStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides the underlying stream of data for network access.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> classe fournit des méthodes pour envoyer et recevoir des données via <xref:System.Net.Sockets.SocketType.Stream> sockets en mode blocage. Pour plus d’informations sur le blocage et non bloquant <xref:System.Net.Sockets.Socket>s, consultez [à l’aide d’un Socket Client asynchrone](~/docs/framework/network-programming/using-an-asynchronous-client-socket.md). Vous pouvez utiliser la <xref:System.Net.Sockets.NetworkStream> classe pour les transferts de données synchrones et asynchrones. Pour plus d’informations sur les communications synchrones et asynchrones, consultez [Sockets](~/docs/framework/network-programming/sockets.md).  
  
 Pour créer un <xref:System.Net.Sockets.NetworkStream>, vous devez fournir un connecté <xref:System.Net.Sockets.Socket>. Vous pouvez également spécifier <xref:System.IO.FileAccess> autorisation le <xref:System.Net.Sockets.NetworkStream> sur fourni <xref:System.Net.Sockets.Socket>. Par défaut, la fermeture de la <xref:System.Net.Sockets.NetworkStream> ne ferme pas fourni <xref:System.Net.Sockets.Socket>. Si vous souhaitez que le <xref:System.Net.Sockets.NetworkStream> soit autorisé à fermer fourni <xref:System.Net.Sockets.Socket>, vous devez spécifier `true` pour la valeur de le `ownsSocket` paramètre.  
  
 Utilisez le <xref:System.Net.Sockets.NetworkStream.Write%2A> et <xref:System.Net.Sockets.NetworkStream.Read%2A> méthodes unique pour les threads d’e/s bloquante synchrone. Si vous souhaitez traiter votre d’e/s à l’aide de threads séparés, envisagez d’utiliser le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> et <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthodes, ou le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> et <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthodes pour la communication.  
  
 Le <xref:System.Net.Sockets.NetworkStream> ne prend pas en charge l’accès aléatoire aux flux de données réseau. La valeur de la <xref:System.Net.Sockets.NetworkStream.CanSeek%2A> propriété qui indique si le flux prend en charge la recherche, est toujours `false`; lecture le <xref:System.Net.Sockets.NetworkStream.Position%2A> propriété, la lecture de la <xref:System.Net.Sockets.NetworkStream.Length%2A> propriété, ou en appelant le <xref:System.Net.Sockets.NetworkStream.Seek%2A> méthode lève un <xref:System.NotSupportedException>.  
  
 Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans avoir besoin pour la synchronisation. Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un <xref:System.Net.Sockets.NetworkStream> de connecté <xref:System.Net.Sockets.SocketType.Stream> <xref:System.Net.Sockets.Socket> et effectuer une e/s bloquante synchrone de base.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream socket" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="socket">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifiée aux <xref:System.Net.Sockets.Socket>. Le <xref:System.Net.Sockets.NetworkStream> ne possède pas le <xref:System.Net.Sockets.Socket>, de sorte que l’appel du <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ne ferme pas le <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un <xref:System.Net.Sockets.NetworkStream> avec un <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  -or-  The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.  -or-  The <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, bool ownsSocket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * bool -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, ownsSocket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <param name="ownsSocket">Set to <see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifiée aux <xref:System.Net.Sockets.Socket>. Si la valeur de `ownsSocket` paramètre est `true`, le <xref:System.Net.Sockets.NetworkStream> prend possession de l’objet sous-jacent <xref:System.Net.Sockets.Socket>et en appelant le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ferme également sous-jacent <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la propriété de la <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  -or-  the value of the <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.  -or-  the <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * System.IO.FileAccess -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="socket">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <param name="access">A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specify the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec l’accès spécifié à l’objet <xref:System.Net.Sockets.Socket>. Avec ce constructeur, le <xref:System.Net.Sockets.NetworkStream> ne possède pas le <xref:System.Net.Sockets.Socket>, de sorte que l’appel du <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ne ferme pas sous-jacent <xref:System.Net.Sockets.Socket>.  
  
 Le `access` jeux de paramètres la <xref:System.Net.Sockets.NetworkStream.CanRead%2A> et <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriétés de la <xref:System.Net.Sockets.NetworkStream>. Si vous spécifiez <xref:System.IO.FileAccess.Write>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.Read>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.ReadWrite>, les deux appels de méthode sont autorisés.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la possibilité de lire et écrire dans le <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  -or-  the <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.  -or-  the <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * System.IO.FileAccess * bool -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, access, ownsSocket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <param name="access">A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specifies the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />.</param>
        <param name="ownsSocket">Set to <see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, <see langword="false" />.</param>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights and the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifiée aux <xref:System.Net.Sockets.Socket>. Si la valeur de la `ownsSocket` paramètre est `true`, le <xref:System.Net.Sockets.NetworkStream> prend possession de l’objet sous-jacent <xref:System.Net.Sockets.Socket>et en appelant le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ferme également sous-jacent <xref:System.Net.Sockets.Socket>.  
  
 Le `access` jeux de paramètres la <xref:System.Net.Sockets.NetworkStream.CanRead%2A> et <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriétés de la <xref:System.Net.Sockets.NetworkStream>. Si vous spécifiez <xref:System.IO.FileAccess.Write>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.Read>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Si vous spécifiez <xref:System.IO.FileAccess.ReadWrite>, les deux appels de méthode sont autorisés.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la possibilité de lire et écrire dans le <xref:System.Net.Sockets.Socket>. La propriété de la <xref:System.Net.Sockets.Socket> est accordée à <xref:System.Net.Sockets.NetworkStream> en spécifiant `true` pour la `ownsSocket` paramètre.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  -or-  The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.  -or-  The <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="networkStream.BeginRead (buffer, offset, size, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in <c>buffer</c> to begin storing the data.</param>
        <param name="size">The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that is executed when <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> completes.</param>
        <param name="state">An object that contains any additional user-defined data.</param>
        <summary>Begins an asynchronous read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode démarre la lecture asynchrone des données à partir des tampons réseau entrants. Appel de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode vous donne la possibilité de recevoir des données dans un thread d’exécution distinct.  
  
 Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode). Au minimum, votre `state` paramètre doit contenir le <xref:System.Net.Sockets.NetworkStream>. Étant donné que vous devez obtenir les données reçues dans votre méthode de rappel, vous devez créer une petite classe ou une structure contenant un tampon de lecture et d’autres informations utiles. Passez l’instance de classe ou structure à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.NetworkStream.EndRead%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, le système attend jusqu'à ce que les données reçues ou une erreur se produit, puis le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.NetworkStream.EndRead%2A> jusqu'à fourni <xref:System.Net.Sockets.NetworkStream> lit données ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Appelez <xref:System.Threading.EventWaitHandle.Set%2A> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans avoir besoin pour la synchronisation. Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.  
  
   
  
## Examples  
 Le code suivant utilise des exemple <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> pour lire des données de façon asynchrone à partir du flux réseau. Le `myReadCallBack` méthode implémente la <xref:System.AsyncCallback> délégué et est appelée par le système lorsque <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> renvoie.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  -or-  The <paramref name="offset" /> parameter is greater than the length of the <paramref name="buffer" /> paramater.  -or-  The <paramref name="size" /> is less than 0.  -or-  The <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.  -or-  There was a failure while reading from the network.  -or-  An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="networkStream.BeginWrite (buffer, offset, size, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in <c>buffer</c> to begin sending the data.</param>
        <param name="size">The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that is executed when <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> completes.</param>
        <param name="state">An object that contains any additional user-defined data.</param>
        <summary>Begins an asynchronous write to a stream.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant. Appel de la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.  
  
 Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> (méthode). Au minimum, votre `state` paramètre doit contenir le <xref:System.Net.Sockets.NetworkStream>. Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.NetworkStream> et les autres informations requises. Passez l’instance de classe ou structure à la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode via la `state` paramètre.  
  
 Votre méthode de rappel doit implémenter la <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> (méthode). Lorsque votre application appelle <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> jusqu'à ce que le <xref:System.Net.Sockets.NetworkStream> envoie le nombre d’octets demandé ou lève une exception. Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Appelez <xref:System.Threading.EventWaitHandle.Set%2A> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution. Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans avoir besoin pour la synchronisation. Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.  
  
   
  
## Examples  
 Le code suivant utilise des exemple <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> pour écrire des données de façon asynchrone dans un flux réseau. Le `myWriteCallBack` méthode implémente la <xref:System.AsyncCallback> délégué et est appelée par le système lorsque <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> renvoie.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  -or-  The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.  -or-  The <paramref name="size" /> parameter is less than 0.  -or-  The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.  -or-  There was a failure while writing to the network.  -or-  An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Sockets.NetworkStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports reading.</summary>
        <value>
          <see langword="true" /> Si les données peuvent être lues à partir du flux ; dans le cas contraire, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Net.Sockets.NetworkStream.CanRead%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Fournir les informations appropriées <xref:System.IO.FileAccess> énumérées dans le constructeur pour définir la lisibilité et écriture de la <xref:System.Net.Sockets.NetworkStream>. Le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Le code suivant exemple vérifie <xref:System.Net.Sockets.NetworkStream.CanRead%2A> pour vérifier que le <xref:System.Net.Sockets.NetworkStream> est accessible en lecture. Il effectue ensuite une opération de lecture sur le <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the stream supports seeking. This property is not currently supported.This property always returns <see langword="false" />.</summary>
        <value>
          <see langword="false" /> dans tous les cas pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> ne peut pas rechercher un emplacement spécifique dans le flux de données.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether timeout properties are usable for <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <value>
          <see langword="true" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est présente, car elle est héritée <xref:System.IO.Stream>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports writing.</summary>
        <value>
          <see langword="true" /> Si les données peuvent être écrites dans le <see cref="T:System.Net.Sockets.NetworkStream" />; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Fournir les informations appropriées <xref:System.IO.FileAccess> énumérées dans le constructeur pour définir la lisibilité et écriture de la <xref:System.Net.Sockets.NetworkStream>. Le <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Le code suivant exemple vérifie <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> pour vérifier que le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture. Il effectue ensuite une opération d’écriture sur le <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="override this.Close : int -&gt; unit" Usage="networkStream.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">A 32-bit signed integer that specifies the number of milliseconds to wait to send any remaining data before closing.</param>
        <summary>Closes the <see cref="T:System.Net.Sockets.NetworkStream" /> after waiting the specified time to allow data to be sent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode libère les ressources non managées et managées associées à la <xref:System.Net.Sockets.NetworkStream>. Si le <xref:System.Net.Sockets.NetworkStream> possède sous-jacent <xref:System.Net.Sockets.Socket>, il est également fermé.  
  
 Si un <xref:System.Net.Sockets.NetworkStream> a été associé à un <xref:System.Net.Sockets.TcpClient>, le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode fermera la connexion TCP, mais ne dispose pas de la <xref:System.Net.Sockets.TcpClient>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="timeout" /> parameter is less than -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool DataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DataAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DataAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DataAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DataAvailable : bool" Usage="System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether data is available on the <see cref="T:System.Net.Sockets.NetworkStream" /> to be read.</summary>
        <value>
          <see langword="true" /> Si les données sont disponibles sur le flux à lire ; dans le cas contraire, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> propriété pour déterminer si les données sont prêtes à être lu. Si <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> est `true`, un appel à <xref:System.Net.Sockets.NetworkStream.Read%2A> retourne immédiatement. Si l’hôte distant arrête ou ferme la connexion, <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> peut lever un <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 L’exemple de code suivant lit le <xref:System.Net.Sockets.NetworkStream> tant que les données sont disponibles.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="networkStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.NetworkStream" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose` appelle la méthode protégée `Dispose(Boolean)` méthode avec la `disposing` paramètre la valeur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` la valeur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Net.Sockets.NetworkStream>. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d’autres objets. Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’un Method](~/docs/standard/garbage-collection/implementing-dispose.md) de suppression.  Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, voir [nettoyage des Resources](~/docs/standard/garbage-collection/unmanaged.md) non managé et [substitution de la méthode Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="networkStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that represents an asynchronous call.</param>
        <summary>Handles the end of an asynchronous read.</summary>
        <returns>The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode termine l’opération de lecture asynchrone démarrée dans le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).  
  
 Avant d’appeler <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode). Extraire la réception <xref:System.Net.Sockets.NetworkStream> à partir de cet objet d’état. Après avoir obtenu le <xref:System.Net.Sockets.NetworkStream>, appelez le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.  
  
 Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode est bloquée jusqu'à ce que les données sont disponibles. Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode). Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode se termine immédiatement et retourne zéro octet.  
  
 Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult>et extrayez la mémoire tampon contenue dans l’objet d’état obtenu.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, `myReadCallback` est fourni à <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> comme méthode de rappel. <xref:System.Net.Sockets.NetworkStream.EndRead%2A> est implémenté dans `myReadCallback` fin asynchrone de lecture appel démarré par <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#5)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#5)]
 [!code-vb[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.  -or-  An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="networkStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</param>
        <summary>Handles the end of an asynchronous write.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> termine l’opération d’envoi asynchrone démarrée dans <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 Avant d’appeler <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer. Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> retourne. La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode en tant que paramètre.  
  
 Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la `IAsyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.NetworkStream>. Après avoir obtenu le <xref:System.Net.Sockets.NetworkStream>, vous pouvez appeler la <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.  
  
 Le <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthode est bloquée jusqu'à ce que le nombre d’octets demandés est envoyé.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, `myWriteCallback` est fourni à <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> comme méthode de rappel. <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> est implémenté dans `myWriteCallback` pour terminer l’appel d’écriture asynchrone démarrée par <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.  -or-  An error occurred while writing to the network.  -or-  An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NetworkStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NetworkStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="networkStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode substitue <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Code d’application ne doit pas appeler cette méthode ; d’un objet <xref:System.Object.Finalize%2A> méthode est appelée automatiquement lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur l’utilisation de la méthode Finalize, consultez [destructeurs et méthodes Finalize](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md), et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="networkStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Flushes data from the stream. This method is reserved for future use.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.Flush%2A> méthode implémente le <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> méthode ; Toutefois, étant donné que <xref:System.Net.Sockets.NetworkStream> est ne pas mis en mémoire tampon, il n’a aucun effet sur les flux de réseau. Appel de la <xref:System.Net.Sockets.NetworkStream.Flush%2A> méthode ne lève pas d’exception.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="networkStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">A cancellation token used to propagate notification that this  operation should be canceled.</param>
        <summary>Flushes data from the stream as an asynchronous operation.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />.  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Retourné <xref:System.Threading.Tasks.Task> objet s’achève une fois les données a été vidées à partir du flux pour le <xref:System.Net.Sockets.NetworkStream> instance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Sockets.NetworkStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the length of the data available on the stream. This property is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</summary>
        <value>La longueur des données disponibles sur le flux.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Sockets.NetworkStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current position in the stream. This property is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</summary>
        <value>Position actuelle dans le flux.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, size As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="networkStream.Read (buffer, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in <c>buffer</c> to begin storing the data to.</param>
        <param name="size">The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Reads data from the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />, or 0 if the socket is closed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit les données dans le `buffer` paramètre et retourne le nombre d’octets lus correctement. Si le socket est fermé, le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode renvoie la valeur 0. Le <xref:System.Net.Sockets.NetworkStream.Read%2A> opération lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre. Si l’hôte distant arrête la connexion, et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode se termine immédiatement et retourne zéro octet.  
  
> [!NOTE]
>  Vérifiez si le <xref:System.Net.Sockets.NetworkStream> est lisible en appelant le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété. Si vous tentez de lire un <xref:System.Net.Sockets.NetworkStream> qui n’est pas lisible, vous obtiendrez une <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>. Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 Le code suivant utilise des exemple <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> pour déterminer si les données sont disponibles pour la lecture. Si les données sont disponibles, il lit à partir de la <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  -or-  The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.  -or-  The <paramref name="size" /> parameter is less than 0.  -or-  The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.  -or-  An error occurred when accessing the socket.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.  -or-  There is a failure reading from the network.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Readable">
      <MemberSignature Language="C#" Value="protected bool Readable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Readable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Readable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Readable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Readable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Readable : bool with get, set" Usage="System.Net.Sockets.NetworkStream.Readable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> can be read.</summary>
        <value>
          <see langword="true" /> pour indiquer que le <see cref="T:System.Net.Sockets.NetworkStream" /> peut être lu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez dériver la <xref:System.Net.Sockets.NetworkStream> classe à utiliser le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété. Si <xref:System.Net.Sockets.NetworkStream.Readable%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Vous pouvez également déterminer si un <xref:System.Net.Sockets.NetworkStream> est lisible en vérifiant accessible publiquement <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété.  
  
 Le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, le `CanCommunicate` propriété vérifications le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété pour déterminer si le <xref:System.Net.Sockets.NetworkStream> est accessible en lecture.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="networkStream.ReadAsync (buffer, offset, size, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the amount of time that a read operation blocks waiting for data.</summary>
        <value>Un <see cref="T:System.Int32" /> qui spécifie la durée, en millisecondes, qui doit s’écouler avant l’échec d’une opération de lecture. La valeur par défaut, <see cref="F:System.Threading.Timeout.Infinite" />, spécifie que l’opération de lecture n’expire pas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération de lecture ne se termine pas dans le délai spécifié par cette propriété, l’opération de lecture lève une <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Cette propriété affecte uniquement les lectures synchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode). Cette propriété n’affecte pas les lectures asynchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant définit le délai d’attente de lecture d’un flux de réseau à 10 millisecondes.  
  
 [!code-csharp[NCLTcpClientSync#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than or equal to zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="networkStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">This parameter is not used.</param>
        <param name="origin">This parameter is not used.</param>
        <summary>Sets the current position of the stream to the given value. This method is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</summary>
        <returns>The position in the stream.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="networkStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">This parameter is not used.</param>
        <summary>Sets the length of the stream. This method always throws a <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
      </Docs>
    </Member>
    <Member MemberName="Socket">
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Socket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Socket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Socket" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Socket As Socket" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Socket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Socket : System.Net.Sockets.Socket" Usage="System.Net.Sockets.NetworkStream.Socket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the underlying <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Un <see cref="T:System.Net.Sockets.Socket" /> qui représente la connexion réseau sous-jacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de <xref:System.Net.Sockets.NetworkStream> pouvez utiliser cette propriété pour obtenir l’objet sous-jacent <xref:System.Net.Sockets.Socket>. Utilisez sous-jacent <xref:System.Net.Sockets.Socket> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.Socket%2A> propriété si vous avez besoin d’accéder aux au-delà de celles qui <xref:System.Net.Sockets.NetworkStream> fournit.  
  
> [!NOTE]
>  Cette propriété est accessible uniquement par le biais de cette classe ou une classe dérivée.  
  
   
  
## Examples  
 L’exemple de code suivant récupère sous-jacent <xref:System.Net.Sockets.Socket> pour vérifier une connexion active.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="networkStream.Write (buffer, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in <c>buffer</c> from which to start writing data.</param>
        <param name="size">The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Writes data to the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode commence à la position spécifiée `offset` et envoie `size` octets à partir du contenu de `buffer` au réseau. Le <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode est bloquée jusqu'à ce que le nombre d’octets demandé est envoyé ou une <xref:System.Net.Sockets.SocketException> est levée. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Vérifiez si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture en accédant à la <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété. Si vous tentez d’écrire dans un <xref:System.Net.Sockets.NetworkStream> qui n’est pas accessible en écriture, vous obtiendrez une <xref:System.IO.IOException>. Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Le code suivant exemple vérifie si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture. Si elle est ensuite <xref:System.Net.Sockets.NetworkStream.Write%2A> est utilisé pour écrire un message de petite taille.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  -or-  The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.  -or-  The <paramref name="size" /> parameter is less than 0.  -or-  The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.IO.IOException">There was a failure while writing to the network.  -or-  An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.  -or-  There was a failure reading from the network.</exception>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="Writeable">
      <MemberSignature Language="C#" Value="protected bool Writeable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Writeable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Writeable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Writeable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Writeable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Writeable : bool with get, set" Usage="System.Net.Sockets.NetworkStream.Writeable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> is writable.</summary>
        <value>
          <see langword="true" /> Si les données peuvent être écrites dans le flux ; dans le cas contraire, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez dériver la <xref:System.Net.Sockets.NetworkStream> classe à utiliser le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété. Si <xref:System.Net.Sockets.NetworkStream.Writeable%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Vous pouvez également déterminer si un <xref:System.Net.Sockets.NetworkStream> est accessible en écriture en vérifiant accessible publiquement <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété.  
  
 Le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.  
  
   
  
## Examples  
 Dans l’exemple de code suivant, le `CanCommunicate` propriété vérifie le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété pour déterminer si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="networkStream.WriteAsync (buffer, offset, size, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the amount of time that a write operation blocks waiting for data.</summary>
        <value>Un <see cref="T:System.Int32" /> qui spécifie la durée, en millisecondes, qui doit s’écouler avant l’échec d’une opération d’écriture. La valeur par défaut, <see cref="F:System.Threading.Timeout.Infinite" />, spécifie que l’opération d’écriture n’expire pas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération d’écriture ne se termine pas dans le délai spécifié par cette propriété, l’opération d’écriture lève un <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Cette propriété affecte les opérations d’écriture synchrone uniquement effectuées en appelant le <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode). Cette propriété n’affecte pas les écritures asynchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant définit le délai d’attente de l’écriture d’un flux de réseau à 10 millisecondes.  
  
 [!code-cpp[NCLTcpServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclTcpServerSync/cpp/tcplistener.cpp#0)]
 [!code-csharp[NCLTcpServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclTcpServerSync/CS/tcplistener.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than or equal to zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>