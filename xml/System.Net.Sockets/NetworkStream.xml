<Type Name="NetworkStream" FullName="System.Net.Sockets.NetworkStream">
  <TypeSignature Language="C#" Value="public class NetworkStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetworkStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.NetworkStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NetworkStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetworkStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="2c08b-101">Fournit le flux de données sous-jacent pour l’accès réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-101">Provides the underlying stream of data for network access.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-102">Le <xref:System.Net.Sockets.NetworkStream> classe fournit des méthodes pour envoyer et recevoir des données via <xref:System.Net.Sockets.SocketType.Stream> sockets en mode blocage.</span><span class="sxs-lookup"><span data-stu-id="2c08b-102">The <xref:System.Net.Sockets.NetworkStream> class provides methods for sending and receiving data over <xref:System.Net.Sockets.SocketType.Stream> sockets in blocking mode.</span></span> <span data-ttu-id="2c08b-103">Pour plus d’informations sur le blocage et non bloquant <xref:System.Net.Sockets.Socket>s, consultez [à l’aide d’un Socket Client asynchrone](~/docs/framework/network-programming/using-an-asynchronous-client-socket.md).</span><span class="sxs-lookup"><span data-stu-id="2c08b-103">For more information about blocking versus nonblocking <xref:System.Net.Sockets.Socket>s, see [Using an Asynchronous Client Socket](~/docs/framework/network-programming/using-an-asynchronous-client-socket.md).</span></span> <span data-ttu-id="2c08b-104">Vous pouvez utiliser la <xref:System.Net.Sockets.NetworkStream> classe pour les transferts de données synchrones et asynchrones.</span><span class="sxs-lookup"><span data-stu-id="2c08b-104">You can use the <xref:System.Net.Sockets.NetworkStream> class for both synchronous and asynchronous data transfer.</span></span> <span data-ttu-id="2c08b-105">Pour plus d’informations sur les communications synchrones et asynchrones, consultez [Sockets](~/docs/framework/network-programming/sockets.md).</span><span class="sxs-lookup"><span data-stu-id="2c08b-105">For more information about synchronous and asynchronous communication, see [Sockets](~/docs/framework/network-programming/sockets.md).</span></span>  
  
 <span data-ttu-id="2c08b-106">Pour créer un <xref:System.Net.Sockets.NetworkStream>, vous devez fournir un connecté <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-106">To create a <xref:System.Net.Sockets.NetworkStream>, you must provide a connected <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="2c08b-107">Vous pouvez également spécifier <xref:System.IO.FileAccess> autorisation le <xref:System.Net.Sockets.NetworkStream> sur fourni <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-107">You can also specify what <xref:System.IO.FileAccess> permission the <xref:System.Net.Sockets.NetworkStream> has over the provided <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="2c08b-108">Par défaut, la fermeture de la <xref:System.Net.Sockets.NetworkStream> ne ferme pas fourni <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-108">By default, closing the <xref:System.Net.Sockets.NetworkStream> does not close the provided <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="2c08b-109">Si vous souhaitez que le <xref:System.Net.Sockets.NetworkStream> soit autorisé à fermer fourni <xref:System.Net.Sockets.Socket>, vous devez spécifier `true` pour la valeur de le `ownsSocket` paramètre.</span><span class="sxs-lookup"><span data-stu-id="2c08b-109">If you want the <xref:System.Net.Sockets.NetworkStream> to have permission to close the provided <xref:System.Net.Sockets.Socket>, you must specify `true` for the value of the `ownsSocket` parameter.</span></span>  
  
 <span data-ttu-id="2c08b-110">Utilisez le <xref:System.Net.Sockets.NetworkStream.Write%2A> et <xref:System.Net.Sockets.NetworkStream.Read%2A> méthodes unique pour les threads d’e/s bloquante synchrone.</span><span class="sxs-lookup"><span data-stu-id="2c08b-110">Use the <xref:System.Net.Sockets.NetworkStream.Write%2A> and <xref:System.Net.Sockets.NetworkStream.Read%2A> methods for simple single thread synchronous blocking I/O.</span></span> <span data-ttu-id="2c08b-111">Si vous souhaitez traiter votre d’e/s à l’aide de threads séparés, envisagez d’utiliser le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> et <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthodes, ou le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> et <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthodes pour la communication.</span><span class="sxs-lookup"><span data-stu-id="2c08b-111">If you want to process your I/O using separate threads, consider using the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> and <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> methods, or the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> and <xref:System.Net.Sockets.NetworkStream.EndRead%2A> methods for communication.</span></span>  
  
 <span data-ttu-id="2c08b-112">Le <xref:System.Net.Sockets.NetworkStream> ne prend pas en charge l’accès aléatoire aux flux de données réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-112">The <xref:System.Net.Sockets.NetworkStream> does not support random access to the network data stream.</span></span> <span data-ttu-id="2c08b-113">La valeur de la <xref:System.Net.Sockets.NetworkStream.CanSeek%2A> propriété qui indique si le flux prend en charge la recherche, est toujours `false`; lecture le <xref:System.Net.Sockets.NetworkStream.Position%2A> propriété, la lecture de la <xref:System.Net.Sockets.NetworkStream.Length%2A> propriété, ou en appelant le <xref:System.Net.Sockets.NetworkStream.Seek%2A> méthode lève un <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-113">The value of the <xref:System.Net.Sockets.NetworkStream.CanSeek%2A> property, which indicates whether the stream supports seeking, is always `false`; reading the <xref:System.Net.Sockets.NetworkStream.Position%2A> property, reading the <xref:System.Net.Sockets.NetworkStream.Length%2A> property, or calling the <xref:System.Net.Sockets.NetworkStream.Seek%2A> method will throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="2c08b-114">Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans avoir besoin pour la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="2c08b-114">Read and write operations can be performed simultaneously on an instance of the <xref:System.Net.Sockets.NetworkStream> class without the need for synchronization.</span></span> <span data-ttu-id="2c08b-115">Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.</span><span class="sxs-lookup"><span data-stu-id="2c08b-115">As long as there is one unique thread for the write operations and one unique thread for the read operations, there will be no cross-interference between read and write threads and no synchronization is required.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-116">L’exemple de code suivant montre comment créer un <xref:System.Net.Sockets.NetworkStream> de connecté <xref:System.Net.Sockets.SocketType.Stream> <xref:System.Net.Sockets.Socket> et effectuer une e/s bloquante synchrone de base.</span><span class="sxs-lookup"><span data-stu-id="2c08b-116">The following code example demonstrates how to create a <xref:System.Net.Sockets.NetworkStream> from a connected <xref:System.Net.Sockets.SocketType.Stream><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.</span></span>  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2c08b-117">Crée une instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-117">Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="socket"><span data-ttu-id="2c08b-118"><see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-118">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</span></span></param>
        <summary><span data-ttu-id="2c08b-119">Crée une nouvelle instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="2c08b-119">Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-120">Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifiée aux <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-120">The <xref:System.Net.Sockets.NetworkStream> is created with read/write access to the specified <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="2c08b-121">Le <xref:System.Net.Sockets.NetworkStream> ne possède pas le <xref:System.Net.Sockets.Socket>, de sorte que l’appel du <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ne ferme pas le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-121">The <xref:System.Net.Sockets.NetworkStream> does not own the underlying <xref:System.Net.Sockets.Socket>, so calling the <xref:System.Net.Sockets.NetworkStream.Close%2A> method does not close the <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-122">L’exemple de code suivant montre comment créer un <xref:System.Net.Sockets.NetworkStream> avec un <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-122">The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c08b-123">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-123">The <paramref name="socket" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-124">Le paramètre <paramref name="socket" /> n'est pas connecté.</span><span class="sxs-lookup"><span data-stu-id="2c08b-124">The <paramref name="socket" /> parameter is not connected.</span></span>  
  
 <span data-ttu-id="2c08b-125">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-125">-or-</span></span>  
  
 <span data-ttu-id="2c08b-126">La propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-126">The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.</span></span>  
  
 <span data-ttu-id="2c08b-127">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-127">-or-</span></span>  
  
 <span data-ttu-id="2c08b-128">Le paramètre <paramref name="socket" /> est dans un état non bloquant.</span><span class="sxs-lookup"><span data-stu-id="2c08b-128">The <paramref name="socket" /> parameter is in a nonblocking state.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, bool ownsSocket);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket"><span data-ttu-id="2c08b-129"><see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-129">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</span></span></param>
        <param name="ownsSocket"><span data-ttu-id="2c08b-130">A la valeur <see langword="true" /> pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> prendra possession de <see cref="T:System.Net.Sockets.Socket" /> ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-130">Set to <see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="2c08b-131">Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié avec l'appartenance <see cref="T:System.Net.Sockets.Socket" /> spécifiée.</span><span class="sxs-lookup"><span data-stu-id="2c08b-131">Initializes a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-132">Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifiée aux <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-132">The <xref:System.Net.Sockets.NetworkStream> is created with read/write access to the specified <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="2c08b-133">Si la valeur de `ownsSocket` paramètre est `true`, le <xref:System.Net.Sockets.NetworkStream> prend possession de l’objet sous-jacent <xref:System.Net.Sockets.Socket>et en appelant le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ferme également sous-jacent <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-133">If the value of `ownsSocket` parameter is `true`, the <xref:System.Net.Sockets.NetworkStream> takes ownership of the underlying <xref:System.Net.Sockets.Socket>, and calling the <xref:System.Net.Sockets.NetworkStream.Close%2A> method also closes the underlying <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-134">L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la propriété de la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-134">The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c08b-135">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-135">The <paramref name="socket" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-136">Le paramètre <paramref name="socket" /> n'est pas connecté.</span><span class="sxs-lookup"><span data-stu-id="2c08b-136">The <paramref name="socket" /> parameter is not connected.</span></span>  
  
 <span data-ttu-id="2c08b-137">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-137">-or-</span></span>  
  
 <span data-ttu-id="2c08b-138">la propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-138">the value of the <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.</span></span>  
  
 <span data-ttu-id="2c08b-139">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-139">-or-</span></span>  
  
 <span data-ttu-id="2c08b-140">le paramètre <paramref name="socket" /> est dans un état non bloquant.</span><span class="sxs-lookup"><span data-stu-id="2c08b-140">the <paramref name="socket" /> parameter is in a nonblocking state.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="socket"><span data-ttu-id="2c08b-141"><see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-141">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</span></span></param>
        <param name="access"><span data-ttu-id="2c08b-142">Combinaison d'opérations de bits des valeurs <see cref="T:System.IO.FileAccess" /> qui spécifie le type d'accès accordé à <see cref="T:System.Net.Sockets.NetworkStream" /> sur le <see cref="T:System.Net.Sockets.Socket" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="2c08b-142">A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specify the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <summary><span data-ttu-id="2c08b-143">Crée une nouvelle instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié possédant les droits d'accès donnés.</span><span class="sxs-lookup"><span data-stu-id="2c08b-143">Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-144">Le <xref:System.Net.Sockets.NetworkStream> est créé avec l’accès spécifié à l’objet <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-144">The <xref:System.Net.Sockets.NetworkStream> is created with the specified access to the specified <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="2c08b-145">Avec ce constructeur, le <xref:System.Net.Sockets.NetworkStream> ne possède pas le <xref:System.Net.Sockets.Socket>, de sorte que l’appel du <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ne ferme pas sous-jacent <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-145">With this constructor, the <xref:System.Net.Sockets.NetworkStream> does not own the underlying <xref:System.Net.Sockets.Socket>, so calling the <xref:System.Net.Sockets.NetworkStream.Close%2A> method does not close the underlying <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="2c08b-146">Le `access` jeux de paramètres la <xref:System.Net.Sockets.NetworkStream.CanRead%2A> et <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriétés de la <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-146">The `access` parameter sets the <xref:System.Net.Sockets.NetworkStream.CanRead%2A> and <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> properties of the <xref:System.Net.Sockets.NetworkStream>.</span></span> <span data-ttu-id="2c08b-147">Si vous spécifiez <xref:System.IO.FileAccess.Write>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-147">If you specify <xref:System.IO.FileAccess.Write>, then the <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Write%2A> method.</span></span> <span data-ttu-id="2c08b-148">Si vous spécifiez <xref:System.IO.FileAccess.Read>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-148">If you specify <xref:System.IO.FileAccess.Read>, then the <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Read%2A> method.</span></span> <span data-ttu-id="2c08b-149">Si vous spécifiez <xref:System.IO.FileAccess.ReadWrite>, les deux appels de méthode sont autorisés.</span><span class="sxs-lookup"><span data-stu-id="2c08b-149">If you specify <xref:System.IO.FileAccess.ReadWrite>, both method calls are allowed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-150">L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la possibilité de lire et écrire dans le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-150">The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c08b-151">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-151">The <paramref name="socket" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-152">Le paramètre <paramref name="socket" /> n'est pas connecté.</span><span class="sxs-lookup"><span data-stu-id="2c08b-152">The <paramref name="socket" /> parameter is not connected.</span></span>  
  
 <span data-ttu-id="2c08b-153">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-153">-or-</span></span>  
  
 <span data-ttu-id="2c08b-154">la propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-154">the <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.</span></span>  
  
 <span data-ttu-id="2c08b-155">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-155">-or-</span></span>  
  
 <span data-ttu-id="2c08b-156">le paramètre <paramref name="socket" /> est dans un état non bloquant.</span><span class="sxs-lookup"><span data-stu-id="2c08b-156">the <paramref name="socket" /> parameter is in a nonblocking state.</span></span></exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access, bool ownsSocket);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket"><span data-ttu-id="2c08b-157"><see cref="T:System.Net.Sockets.Socket" /> qu'utilisera <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-157">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</span></span></param>
        <param name="access"><span data-ttu-id="2c08b-158">Combinaison d'opérations de bits des valeurs <see cref="T:System.IO.FileAccess" /> qui spécifie le type d'accès accordé à <see cref="T:System.Net.Sockets.NetworkStream" /> sur le <see cref="T:System.Net.Sockets.Socket" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="2c08b-158">A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specifies the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <param name="ownsSocket"><span data-ttu-id="2c08b-159">A la valeur <see langword="true" /> pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> prendra possession de <see cref="T:System.Net.Sockets.Socket" /> ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-159">Set to <see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="2c08b-160">Crée une instance de la classe <see cref="T:System.Net.Sockets.NetworkStream" /> pour le <see cref="T:System.Net.Sockets.Socket" /> spécifié possédant les droits d'accès et l'appartenance <see cref="T:System.Net.Sockets.Socket" /> donnés.</span><span class="sxs-lookup"><span data-stu-id="2c08b-160">Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights and the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-161">Le <xref:System.Net.Sockets.NetworkStream> est créé avec un accès en lecture/écriture spécifiée aux <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-161">The <xref:System.Net.Sockets.NetworkStream> is created with read/write access to the specified <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="2c08b-162">Si la valeur de la `ownsSocket` paramètre est `true`, le <xref:System.Net.Sockets.NetworkStream> prend possession de l’objet sous-jacent <xref:System.Net.Sockets.Socket>et en appelant le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode ferme également sous-jacent <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-162">If the value of the `ownsSocket` parameter is `true`, the <xref:System.Net.Sockets.NetworkStream> takes ownership of the underlying <xref:System.Net.Sockets.Socket>, and calling the <xref:System.Net.Sockets.NetworkStream.Close%2A> method also closes the underlying <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="2c08b-163">Le `access` jeux de paramètres la <xref:System.Net.Sockets.NetworkStream.CanRead%2A> et <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriétés de la <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-163">The `access` parameter sets the <xref:System.Net.Sockets.NetworkStream.CanRead%2A> and <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> properties of the <xref:System.Net.Sockets.NetworkStream>.</span></span> <span data-ttu-id="2c08b-164">Si vous spécifiez <xref:System.IO.FileAccess.Write>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-164">If you specify <xref:System.IO.FileAccess.Write>, then the <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Write%2A> method.</span></span> <span data-ttu-id="2c08b-165">Si vous spécifiez <xref:System.IO.FileAccess.Read>, puis le <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-165">If you specify <xref:System.IO.FileAccess.Read>, then the <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Read%2A> method.</span></span> <span data-ttu-id="2c08b-166">Si vous spécifiez <xref:System.IO.FileAccess.ReadWrite>, les deux appels de méthode sont autorisés.</span><span class="sxs-lookup"><span data-stu-id="2c08b-166">If you specify <xref:System.IO.FileAccess.ReadWrite>, both method calls are allowed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-167">L’exemple de code suivant crée un <xref:System.Net.Sockets.NetworkStream> avec la possibilité de lire et écrire dans le <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-167">The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="2c08b-168">La propriété de la <xref:System.Net.Sockets.Socket> est accordée à <xref:System.Net.Sockets.NetworkStream> en spécifiant `true` pour la `ownsSocket` paramètre.</span><span class="sxs-lookup"><span data-stu-id="2c08b-168">Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.</span></span>  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c08b-169">Le paramètre <paramref name="socket" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-169">The <paramref name="socket" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-170">Le paramètre <paramref name="socket" /> n'est pas connecté.</span><span class="sxs-lookup"><span data-stu-id="2c08b-170">The <paramref name="socket" /> parameter is not connected.</span></span>  
  
 <span data-ttu-id="2c08b-171">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-171">-or-</span></span>  
  
 <span data-ttu-id="2c08b-172">La propriété <see cref="P:System.Net.Sockets.Socket.SocketType" /> du paramètre <paramref name="socket" /> n'a pas la valeur <see cref="F:System.Net.Sockets.SocketType.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-172">The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.</span></span>  
  
 <span data-ttu-id="2c08b-173">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-173">-or-</span></span>  
  
 <span data-ttu-id="2c08b-174">Le paramètre <paramref name="socket" /> est dans un état non bloquant.</span><span class="sxs-lookup"><span data-stu-id="2c08b-174">The <paramref name="socket" /> parameter is in a nonblocking state.</span></span></exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2c08b-175">Tableau de type <see cref="T:System.Byte" /> qui correspond à l'emplacement dans la mémoire pour stocker des données lues à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-175">An array of type <see cref="T:System.Byte" /> that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></param>
        <param name="offset"><span data-ttu-id="2c08b-176">Emplacement dans <c>buffer</c> auquel commencer le stockage des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-176">The location in <c>buffer</c> to begin storing the data.</span></span></param>
        <param name="size"><span data-ttu-id="2c08b-177">Nombre d'octets à lire à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-177">The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></param>
        <param name="callback"><span data-ttu-id="2c08b-178">Délégué <see cref="T:System.AsyncCallback" /> exécuté lorsque <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> se termine.</span><span class="sxs-lookup"><span data-stu-id="2c08b-178">The <see cref="T:System.AsyncCallback" /> delegate that is executed when <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> completes.</span></span></param>
        <param name="state"><span data-ttu-id="2c08b-179">Objet contenant toutes les données supplémentaires définies par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="2c08b-179">An object that contains any additional user-defined data.</span></span></param>
        <summary><span data-ttu-id="2c08b-180">Démarre une lecture asynchrone de <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-180">Begins an asynchronous read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></summary>
        <returns><span data-ttu-id="2c08b-181"><see cref="T:System.IAsyncResult" /> qui représente l'appel asynchrone.</span><span class="sxs-lookup"><span data-stu-id="2c08b-181">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-182">Le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode démarre la lecture asynchrone des données à partir des tampons réseau entrants.</span><span class="sxs-lookup"><span data-stu-id="2c08b-182">The <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method starts asynchronously reading data from the incoming network buffers.</span></span> <span data-ttu-id="2c08b-183">Appel de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode vous donne la possibilité de recevoir des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="2c08b-183">Calling the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="2c08b-184">Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-184">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method.</span></span> <span data-ttu-id="2c08b-185">Au minimum, votre `state` paramètre doit contenir le <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-185">At the very minimum, your `state` parameter must contain the <xref:System.Net.Sockets.NetworkStream>.</span></span> <span data-ttu-id="2c08b-186">Étant donné que vous devez obtenir les données reçues dans votre méthode de rappel, vous devez créer une petite classe ou une structure contenant un tampon de lecture et d’autres informations utiles.</span><span class="sxs-lookup"><span data-stu-id="2c08b-186">Because you will want to obtain the received data within your callback method, you should create a small class or structure to hold a read buffer and any other useful information.</span></span> <span data-ttu-id="2c08b-187">Passez l’instance de classe ou structure à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="2c08b-187">Pass the structure or class instance to the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="2c08b-188">Votre méthode de rappel doit appeler la <xref:System.Net.Sockets.NetworkStream.EndRead%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-188">Your callback method should call the <xref:System.Net.Sockets.NetworkStream.EndRead%2A> method.</span></span> <span data-ttu-id="2c08b-189">Lorsque votre application appelle <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, le système attend jusqu'à ce que les données reçues ou une erreur se produit, puis le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.NetworkStream.EndRead%2A> jusqu'à fourni <xref:System.Net.Sockets.NetworkStream> lit données ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="2c08b-189">When your application calls <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, the system will wait until data is received or an error occurs, and then the system will use a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.NetworkStream.EndRead%2A> until the provided <xref:System.Net.Sockets.NetworkStream> reads data or throws an exception.</span></span> <span data-ttu-id="2c08b-190">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-190">If you want the original thread to block after you call the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="2c08b-191">Appelez <xref:System.Threading.EventWaitHandle.Set%2A> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="2c08b-191">Call <xref:System.Threading.EventWaitHandle.Set%2A> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="2c08b-192">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="2c08b-192">For additional information about writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="2c08b-193">Le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="2c08b-193">The <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method reads as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-194">Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-194">If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="2c08b-195">Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="2c08b-195">If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="2c08b-196">Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans avoir besoin pour la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="2c08b-196">Read and write operations can be performed simultaneously on an instance of the <xref:System.Net.Sockets.NetworkStream> class without the need for synchronization.</span></span> <span data-ttu-id="2c08b-197">Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.</span><span class="sxs-lookup"><span data-stu-id="2c08b-197">As long as there is one unique thread for the write operations and one unique thread for the read operations, there will be no cross-interference between read and write threads and no synchronization is required.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-198">Le code suivant utilise des exemple <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> pour lire des données de façon asynchrone à partir du flux réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-198">The following code example uses <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> to read data asynchronously from the network stream.</span></span> <span data-ttu-id="2c08b-199">Le `myReadCallBack` méthode implémente la <xref:System.AsyncCallback> délégué et est appelée par le système lorsque <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> renvoie.</span><span class="sxs-lookup"><span data-stu-id="2c08b-199">The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> returns.</span></span>  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c08b-200">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-200">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2c08b-201">Le paramètre <paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="2c08b-201">The <paramref name="offset" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="2c08b-202">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-202">-or-</span></span>  
  
 <span data-ttu-id="2c08b-203">Le paramètre <paramref name="offset" /> est supérieure à la longueur du paramètre <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-203">The <paramref name="offset" /> parameter is greater than the length of the <paramref name="buffer" /> paramater.</span></span>  
  
 <span data-ttu-id="2c08b-204">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-204">-or-</span></span>  
  
 <span data-ttu-id="2c08b-205"><paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="2c08b-205">The <paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="2c08b-206">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-206">-or-</span></span>  
  
 <span data-ttu-id="2c08b-207"><paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-207">The <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-208">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-208">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.</span></span>  
  
 <span data-ttu-id="2c08b-209">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-209">-or-</span></span>  
  
 <span data-ttu-id="2c08b-210">Une erreur s'est produite pendant la lecture à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-210">There was a failure while reading from the network.</span></span>  
  
 <span data-ttu-id="2c08b-211">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-211">-or-</span></span>  
  
 <span data-ttu-id="2c08b-212">Une erreur s’est produite pendant l’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="2c08b-212">An error occurred when accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2c08b-213">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-213">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2c08b-214">Tableau de type <see cref="T:System.Byte" /> qui contient les données à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-214">An array of type <see cref="T:System.Byte" /> that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></param>
        <param name="offset"><span data-ttu-id="2c08b-215">Emplacement dans <c>buffer</c> auquel commencer l’envoi des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-215">The location in <c>buffer</c> to begin sending the data.</span></span></param>
        <param name="size"><span data-ttu-id="2c08b-216">Nombre d'octets à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-216">The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></param>
        <param name="callback"><span data-ttu-id="2c08b-217">Délégué <see cref="T:System.AsyncCallback" /> exécuté lorsque <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> se termine.</span><span class="sxs-lookup"><span data-stu-id="2c08b-217">The <see cref="T:System.AsyncCallback" /> delegate that is executed when <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> completes.</span></span></param>
        <param name="state"><span data-ttu-id="2c08b-218">Objet contenant toutes les données supplémentaires définies par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="2c08b-218">An object that contains any additional user-defined data.</span></span></param>
        <summary><span data-ttu-id="2c08b-219">Démarre une écriture asynchrone dans un flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-219">Begins an asynchronous write to a stream.</span></span></summary>
        <returns><span data-ttu-id="2c08b-220"><see cref="T:System.IAsyncResult" /> qui représente l'appel asynchrone.</span><span class="sxs-lookup"><span data-stu-id="2c08b-220">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-221">Le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode démarre une opération d’envoi asynchrone à l’hôte distant.</span><span class="sxs-lookup"><span data-stu-id="2c08b-221">The <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> method starts an asynchronous send operation to the remote host.</span></span> <span data-ttu-id="2c08b-222">Appel de la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode vous donne la possibilité d’envoyer des données dans un thread d’exécution distinct.</span><span class="sxs-lookup"><span data-stu-id="2c08b-222">Calling the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="2c08b-223">Vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> délégué et passe son nom à la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-223">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> method.</span></span> <span data-ttu-id="2c08b-224">Au minimum, votre `state` paramètre doit contenir le <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-224">At the very minimum, your `state` parameter must contain the <xref:System.Net.Sockets.NetworkStream>.</span></span> <span data-ttu-id="2c08b-225">Si votre rappel a besoin de plus d’informations, vous pouvez créer une petite classe ou une structure pour contenir le <xref:System.Net.Sockets.NetworkStream> et les autres informations requises.</span><span class="sxs-lookup"><span data-stu-id="2c08b-225">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.NetworkStream> and the other required information.</span></span> <span data-ttu-id="2c08b-226">Passez l’instance de classe ou structure à la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode via la `state` paramètre.</span><span class="sxs-lookup"><span data-stu-id="2c08b-226">Pass the structure or class instance to the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="2c08b-227">Votre méthode de rappel doit implémenter la <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-227">Your callback method should implement the <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> method.</span></span> <span data-ttu-id="2c08b-228">Lorsque votre application appelle <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, le système utilise un thread séparé pour exécuter la méthode de rappel spécifiée et se bloque sur <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> jusqu'à ce que le <xref:System.Net.Sockets.NetworkStream> envoie le nombre d’octets demandé ou lève une exception.</span><span class="sxs-lookup"><span data-stu-id="2c08b-228">When your application calls <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> until the <xref:System.Net.Sockets.NetworkStream> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="2c08b-229">Si vous souhaitez que le thread d’origine se bloque après que vous appelez le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode, utilisez la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-229">If you want the original thread to block after you call the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="2c08b-230">Appelez <xref:System.Threading.EventWaitHandle.Set%2A> dans la méthode de rappel lorsque vous souhaitez que le thread d’origine pour continuer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="2c08b-230">Call <xref:System.Threading.EventWaitHandle.Set%2A> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="2c08b-231">Pour plus d’informations sur l’écriture de méthodes de rappel, consultez [Marshaling d’un délégué comme méthode de rappel](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="2c08b-231">For additional information about writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-232">Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-232">If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="2c08b-233">Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="2c08b-233">If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="2c08b-234">Lire et écrire des opérations peuvent être effectuées simultanément sur une instance de la <xref:System.Net.Sockets.NetworkStream> classe sans avoir besoin pour la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="2c08b-234">Read and write operations can be performed simultaneously on an instance of the <xref:System.Net.Sockets.NetworkStream> class without the need for synchronization.</span></span> <span data-ttu-id="2c08b-235">Tant qu’il existe un thread unique pour les opérations d’écriture et un thread unique pour les opérations de lecture, il n’y aura aucune interférence ne s’entre en lecture et écriture threads et aucune synchronisation n’est requise.</span><span class="sxs-lookup"><span data-stu-id="2c08b-235">As long as there is one unique thread for the write operations and one unique thread for the read operations, there will be no cross-interference between read and write threads and no synchronization is required.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-236">Le code suivant utilise des exemple <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> pour écrire des données de façon asynchrone dans un flux réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-236">The following code example uses <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> to write data asynchronously to a network stream.</span></span> <span data-ttu-id="2c08b-237">Le `myWriteCallBack` méthode implémente la <xref:System.AsyncCallback> délégué et est appelée par le système lorsque <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> renvoie.</span><span class="sxs-lookup"><span data-stu-id="2c08b-237">The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> returns.</span></span>  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c08b-238">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-238">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2c08b-239">Le paramètre <paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="2c08b-239">The <paramref name="offset" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="2c08b-240">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-240">-or-</span></span>  
  
 <span data-ttu-id="2c08b-241">Le paramètre <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-241">The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="2c08b-242">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-242">-or-</span></span>  
  
 <span data-ttu-id="2c08b-243">Le paramètre <paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="2c08b-243">The <paramref name="size" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="2c08b-244">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-244">-or-</span></span>  
  
 <span data-ttu-id="2c08b-245">Le paramètre <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-245">The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-246">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-246">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.</span></span>  
  
 <span data-ttu-id="2c08b-247">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-247">-or-</span></span>  
  
 <span data-ttu-id="2c08b-248">Une erreur s'est produite pendant l'écriture sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-248">There was a failure while writing to the network.</span></span>  
  
 <span data-ttu-id="2c08b-249">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-249">-or-</span></span>  
  
 <span data-ttu-id="2c08b-250">Une erreur s’est produite pendant l’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="2c08b-250">An error occurred when accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2c08b-251">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-251">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-252">Obtient une valeur indiquant si <see cref="T:System.Net.Sockets.NetworkStream" /> prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-252">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports reading.</span></span></summary>
        <value>
          <span data-ttu-id="2c08b-253"><see langword="true" /> si les données du flux peuvent être lues ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-253"><see langword="true" /> if data can be read from the stream; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2c08b-254">La valeur par défaut est <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-254">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-255">Si <xref:System.Net.Sockets.NetworkStream.CanRead%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-255">If <xref:System.Net.Sockets.NetworkStream.CanRead%2A> is `true`, <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Read%2A> method.</span></span> <span data-ttu-id="2c08b-256">Fournir les informations appropriées <xref:System.IO.FileAccess> énumérées dans le constructeur pour définir la lisibilité et écriture de la <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-256">Provide the appropriate <xref:System.IO.FileAccess> enumerated value in the constructor to set the readability and writability of the <xref:System.Net.Sockets.NetworkStream>.</span></span> <span data-ttu-id="2c08b-257">Le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-257">The <xref:System.Net.Sockets.NetworkStream.CanRead%2A> property is set when the <xref:System.Net.Sockets.NetworkStream> is initialized.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-258">Le code suivant exemple vérifie <xref:System.Net.Sockets.NetworkStream.CanRead%2A> pour vérifier que le <xref:System.Net.Sockets.NetworkStream> est accessible en lecture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-258">The following code example checks <xref:System.Net.Sockets.NetworkStream.CanRead%2A> to verify that the <xref:System.Net.Sockets.NetworkStream> is readable.</span></span> <span data-ttu-id="2c08b-259">Il effectue ensuite une opération de lecture sur le <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-259">It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.</span></span>  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-260">Obtient une valeur qui indique si le flux prend en charge la recherche.</span><span class="sxs-lookup"><span data-stu-id="2c08b-260">Gets a value that indicates whether the stream supports seeking.</span></span> <span data-ttu-id="2c08b-261">Cette propriété n'est pas actuellement prise en charge. Elle retourne toujours <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-261">This property is not currently supported.This property always returns <see langword="false" />.</span></span></summary>
        <value>
          <span data-ttu-id="2c08b-262"><see langword="false" /> dans tous les cas pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> ne peut pas rechercher un emplacement spécifique dans le flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-262"><see langword="false" /> in all cases to indicate that <see cref="T:System.Net.Sockets.NetworkStream" /> cannot seek a specific location in the stream.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-263">Indique si les propriétés de délai d'attente peuvent être utilisées pour <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-263">Indicates whether timeout properties are usable for <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></summary>
        <value>
          <span data-ttu-id="2c08b-264"><see langword="true" /> dans tous les cas.</span><span class="sxs-lookup"><span data-stu-id="2c08b-264"><see langword="true" /> in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-265">Cette propriété est présente, car elle est héritée <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-265">This property is present because it is inherited from <xref:System.IO.Stream>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-266">Obtient une valeur indiquant si <see cref="T:System.Net.Sockets.NetworkStream" /> prend en charge l'écriture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-266">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports writing.</span></span></summary>
        <value>
          <span data-ttu-id="2c08b-267"><see langword="true" /> si les données peuvent être écrites dans <see cref="T:System.Net.Sockets.NetworkStream" /> ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-267"><see langword="true" /> if data can be written to the <see cref="T:System.Net.Sockets.NetworkStream" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2c08b-268">La valeur par défaut est <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-268">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-269">Si <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-269">If <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> is `true`, <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Write%2A> method.</span></span> <span data-ttu-id="2c08b-270">Fournir les informations appropriées <xref:System.IO.FileAccess> énumérées dans le constructeur pour définir la lisibilité et écriture de la <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-270">Provide the appropriate <xref:System.IO.FileAccess> enumerated value in the constructor to set the readability and writability of the <xref:System.Net.Sockets.NetworkStream>.</span></span> <span data-ttu-id="2c08b-271">Le <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-271">The <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> property is set when the <xref:System.Net.Sockets.NetworkStream> is initialized.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-272">Le code suivant exemple vérifie <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> pour vérifier que le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-272">The following code example checks <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> to verify that the <xref:System.Net.Sockets.NetworkStream> is writable.</span></span> <span data-ttu-id="2c08b-273">Il effectue ensuite une opération d’écriture sur le <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-273">It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.</span></span>  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="2c08b-274">Entier signé 32 bits qui spécifie le nombre de millisecondes à attendre avant d'envoyer les données restantes éventuelles, préalablement à la fermeture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-274">A 32-bit signed integer that specifies the number of milliseconds to wait to send any remaining data before closing.</span></span></param>
        <summary><span data-ttu-id="2c08b-275">Ferme <see cref="T:System.Net.Sockets.NetworkStream" /> après avoir attendu le temps spécifié pour permettre l'envoi des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-275">Closes the <see cref="T:System.Net.Sockets.NetworkStream" /> after waiting the specified time to allow data to be sent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-276">Le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode libère les ressources non managées et managées associées à la <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-276">The <xref:System.Net.Sockets.NetworkStream.Close%2A> method frees both unmanaged and managed resources associated with the <xref:System.Net.Sockets.NetworkStream>.</span></span> <span data-ttu-id="2c08b-277">Si le <xref:System.Net.Sockets.NetworkStream> possède sous-jacent <xref:System.Net.Sockets.Socket>, il est également fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-277">If the <xref:System.Net.Sockets.NetworkStream> owns the underlying <xref:System.Net.Sockets.Socket>, it is closed as well.</span></span>  
  
 <span data-ttu-id="2c08b-278">Si un <xref:System.Net.Sockets.NetworkStream> a été associé à un <xref:System.Net.Sockets.TcpClient>, le <xref:System.Net.Sockets.NetworkStream.Close%2A> méthode fermera la connexion TCP, mais ne dispose pas de la <xref:System.Net.Sockets.TcpClient>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-278">If a <xref:System.Net.Sockets.NetworkStream> was associated with a <xref:System.Net.Sockets.TcpClient>, the <xref:System.Net.Sockets.NetworkStream.Close%2A> method will close the TCP connection, but not dispose of the associated <xref:System.Net.Sockets.TcpClient>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2c08b-279">Le paramètre <paramref name="timeout" /> est inférieur à -1.</span><span class="sxs-lookup"><span data-stu-id="2c08b-279">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool DataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DataAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DataAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DataAvailable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-280">Obtient une valeur indiquant si des données sont disponibles sur le <see cref="T:System.Net.Sockets.NetworkStream" /> à lire.</span><span class="sxs-lookup"><span data-stu-id="2c08b-280">Gets a value that indicates whether data is available on the <see cref="T:System.Net.Sockets.NetworkStream" /> to be read.</span></span></summary>
        <value>
          <span data-ttu-id="2c08b-281"><see langword="true" /> si des données sont disponibles dans le flux à lire ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-281"><see langword="true" /> if data is available on the stream to be read; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-282">Utilisez le <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> propriété pour déterminer si les données sont prêtes à être lu.</span><span class="sxs-lookup"><span data-stu-id="2c08b-282">Use the <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> property to determine if data is ready to be read.</span></span> <span data-ttu-id="2c08b-283">Si <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> est `true`, un appel à <xref:System.Net.Sockets.NetworkStream.Read%2A> retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="2c08b-283">If <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> is `true`, a call to <xref:System.Net.Sockets.NetworkStream.Read%2A> returns immediately.</span></span> <span data-ttu-id="2c08b-284">Si l’hôte distant arrête ou ferme la connexion, <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> peut lever un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-284">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> may throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-285">L’exemple de code suivant lit le <xref:System.Net.Sockets.NetworkStream> tant que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="2c08b-285">The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.</span></span>  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2c08b-286">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-286">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-287">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-287">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="2c08b-288">Utilisez la propriété <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> pour obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="2c08b-288">Use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="2c08b-289"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="2c08b-289"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="2c08b-290">Libère les ressources non managées utilisées par <see cref="T:System.Net.Sockets.NetworkStream" /> et libère éventuellement les ressources managées.</span><span class="sxs-lookup"><span data-stu-id="2c08b-290">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.NetworkStream" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-291">Cette méthode est appelée par le public `Dispose` (méthode) et le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-291">This method is called by the public `Dispose` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="2c08b-292">`Dispose` appelle la méthode protégée `Dispose(Boolean)` méthode avec la `disposing` paramètre la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="2c08b-292">`Dispose` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="2c08b-293"><xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="2c08b-293"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="2c08b-294">Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-294">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.NetworkStream> references.</span></span> <span data-ttu-id="2c08b-295">Cette méthode appelle la méthode `Dispose` de chaque objet référencé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-295">This method invokes the `Dispose` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="2c08b-296"><see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets.</span><span class="sxs-lookup"><span data-stu-id="2c08b-296"><see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="2c08b-297">Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-297">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="2c08b-298">Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="2c08b-298">For more information about how to implement <see langword="Dispose(Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
 <span data-ttu-id="2c08b-299">Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span><span class="sxs-lookup"><span data-stu-id="2c08b-299">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="2c08b-300"><see cref="T:System.IAsyncResult" /> qui représente un appel asynchrone.</span><span class="sxs-lookup"><span data-stu-id="2c08b-300">An <see cref="T:System.IAsyncResult" /> that represents an asynchronous call.</span></span></param>
        <summary><span data-ttu-id="2c08b-301">Gère la fin d'une lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="2c08b-301">Handles the end of an asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="2c08b-302">Nombre d'octets lus à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-302">The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-303">Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode termine l’opération de lecture asynchrone démarrée dans le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-303">The <xref:System.Net.Sockets.NetworkStream.EndRead%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method.</span></span>  
  
 <span data-ttu-id="2c08b-304">Avant d’appeler <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="2c08b-304">Before calling <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="2c08b-305">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="2c08b-305">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> returns.</span></span> <span data-ttu-id="2c08b-306">La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="2c08b-306">The callback method must accept the <xref:System.IAsyncResult> returned from the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="2c08b-307">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult> pour obtenir l’objet d’état passé à la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-307">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method.</span></span> <span data-ttu-id="2c08b-308">Extraire la réception <xref:System.Net.Sockets.NetworkStream> à partir de cet objet d’état.</span><span class="sxs-lookup"><span data-stu-id="2c08b-308">Extract the receiving <xref:System.Net.Sockets.NetworkStream> from this state object.</span></span> <span data-ttu-id="2c08b-309">Après avoir obtenu le <xref:System.Net.Sockets.NetworkStream>, appelez le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode pour terminer l’opération de lecture et retourner le nombre d’octets lus.</span><span class="sxs-lookup"><span data-stu-id="2c08b-309">After obtaining the <xref:System.Net.Sockets.NetworkStream>, call the <xref:System.Net.Sockets.NetworkStream.EndRead%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="2c08b-310">Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode est bloquée jusqu'à ce que les données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="2c08b-310">The <xref:System.Net.Sockets.NetworkStream.EndRead%2A> method blocks until data is available.</span></span> <span data-ttu-id="2c08b-311">Le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode lit autant de données est disponible jusqu’au nombre d’octets spécifié dans le `size` paramètre de la <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-311">The <xref:System.Net.Sockets.NetworkStream.EndRead%2A> method reads as much data as is available up to the number of bytes specified in the `size` parameter of the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method.</span></span> <span data-ttu-id="2c08b-312">Si l’hôte distant arrête la <xref:System.Net.Sockets.Socket> connexion et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.NetworkStream.EndRead%2A> méthode se termine immédiatement et retourne zéro octet.</span><span class="sxs-lookup"><span data-stu-id="2c08b-312">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection and all available data has been received, the <xref:System.Net.Sockets.NetworkStream.EndRead%2A> method completes immediately and returns zero bytes.</span></span>  
  
 <span data-ttu-id="2c08b-313">Pour obtenir les données reçues, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult>et extrayez la mémoire tampon contenue dans l’objet d’état obtenu.</span><span class="sxs-lookup"><span data-stu-id="2c08b-313">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-314">Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-314">If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="2c08b-315">Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="2c08b-315">If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-316">Dans l’exemple de code suivant, `myReadCallback` est fourni à <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> comme méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="2c08b-316">In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method.</span></span> <span data-ttu-id="2c08b-317"><xref:System.Net.Sockets.NetworkStream.EndRead%2A> est implémenté dans `myReadCallback` fin asynchrone de lecture appel démarré par <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-317"><xref:System.Net.Sockets.NetworkStream.EndRead%2A> is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.</span></span>  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#5)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#5)]
 [!code-vb[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2c08b-318">Le paramètre <paramref name="asyncResult" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-318">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-319">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-319">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.</span></span>  
  
 <span data-ttu-id="2c08b-320">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-320">-or-</span></span>  
  
 <span data-ttu-id="2c08b-321">Une erreur s’est produite pendant l’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="2c08b-321">An error occurred when accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2c08b-322">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-322">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="2c08b-323"><see cref="T:System.IAsyncResult" /> qui représente l'appel asynchrone.</span><span class="sxs-lookup"><span data-stu-id="2c08b-323">The <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</span></span></param>
        <summary><span data-ttu-id="2c08b-324">Gère la fin d'une écriture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="2c08b-324">Handles the end of an asynchronous write.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-325"><xref:System.Net.Sockets.NetworkStream.EndWrite%2A> termine l’opération d’envoi asynchrone démarrée dans <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-325"><xref:System.Net.Sockets.NetworkStream.EndWrite%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="2c08b-326">Avant d’appeler <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, vous devez créer une méthode de rappel qui implémente le <xref:System.AsyncCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="2c08b-326">Before calling <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="2c08b-327">Cette méthode de rappel s’exécute dans un thread distinct et est appelée par le système après <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="2c08b-327">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> returns.</span></span> <span data-ttu-id="2c08b-328">La méthode de rappel doit accepter le <xref:System.IAsyncResult> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> méthode en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="2c08b-328">The callback method must accept the <xref:System.IAsyncResult> returned from the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="2c08b-329">Dans la méthode de rappel, appelez le <xref:System.IAsyncResult.AsyncState%2A> propriété de la `IAsyncResult` paramètre pour obtenir le <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-329">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> property of the `IAsyncResult` parameter to obtain the <xref:System.Net.Sockets.NetworkStream>.</span></span> <span data-ttu-id="2c08b-330">Après avoir obtenu le <xref:System.Net.Sockets.NetworkStream>, vous pouvez appeler la <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthode pour terminer l’opération d’envoi et de retourner le nombre d’octets envoyés avec succès.</span><span class="sxs-lookup"><span data-stu-id="2c08b-330">After obtaining the <xref:System.Net.Sockets.NetworkStream>, you can call the <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="2c08b-331">Le <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> méthode est bloquée jusqu'à ce que le nombre d’octets demandés est envoyé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-331">The <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> method blocks until the requested number of bytes are sent.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-332">Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-332">If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="2c08b-333">Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="2c08b-333">If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-334">Dans l’exemple de code suivant, `myWriteCallback` est fourni à <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> comme méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="2c08b-334">In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method.</span></span> <span data-ttu-id="2c08b-335"><xref:System.Net.Sockets.NetworkStream.EndWrite%2A> est implémenté dans `myWriteCallback` pour terminer l’appel d’écriture asynchrone démarrée par <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-335"><xref:System.Net.Sockets.NetworkStream.EndWrite%2A> is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</span></span>  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c08b-336">Le paramètre <paramref name="asyncResult" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-336">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-337">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-337">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.</span></span>  
  
 <span data-ttu-id="2c08b-338">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-338">-or-</span></span>  
  
 <span data-ttu-id="2c08b-339">Une erreur s'est produite pendant l'écriture sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-339">An error occurred while writing to the network.</span></span>  
  
 <span data-ttu-id="2c08b-340">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-340">-or-</span></span>  
  
 <span data-ttu-id="2c08b-341">Une erreur s’est produite pendant l’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="2c08b-341">An error occurred when accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2c08b-342">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-342">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NetworkStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NetworkStream ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2c08b-343">Libère toutes les ressources utilisées par <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-343">Releases all resources used by the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-344">Cette méthode se substitue à <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-344">This method overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2c08b-345">Code d’application ne doit pas appeler cette méthode ; d’un objet <xref:System.Object.Finalize%2A> méthode est appelée automatiquement lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-345">Application code should not call this method; an object's <xref:System.Object.Finalize%2A> method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2c08b-346">Pour plus d’informations sur l’utilisation de la méthode Finalize, consultez [destructeurs et méthodes Finalize](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md), et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3) .</span><span class="sxs-lookup"><span data-stu-id="2c08b-346">For more information about using the Finalize method, see [Finalize Methods and Destructors](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2c08b-347">Vide les données du flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-347">Flushes data from the stream.</span></span> <span data-ttu-id="2c08b-348">Cette méthode est réservée à une utilisation ultérieure.</span><span class="sxs-lookup"><span data-stu-id="2c08b-348">This method is reserved for future use.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-349">Le <xref:System.Net.Sockets.NetworkStream.Flush%2A> méthode implémente le <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> méthode ; Toutefois, étant donné que <xref:System.Net.Sockets.NetworkStream> est ne pas mis en mémoire tampon, il n’a aucun effet sur les flux de réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-349">The <xref:System.Net.Sockets.NetworkStream.Flush%2A> method implements the <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> method; however, because <xref:System.Net.Sockets.NetworkStream> is not buffered, it has no affect on network streams.</span></span> <span data-ttu-id="2c08b-350">Appel de la <xref:System.Net.Sockets.NetworkStream.Flush%2A> méthode ne lève pas d’exception.</span><span class="sxs-lookup"><span data-stu-id="2c08b-350">Calling the <xref:System.Net.Sockets.NetworkStream.Flush%2A> method does not throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="2c08b-351">Jeton d’annulation utilisé pour propager la notification d’annulation de cette opération.</span><span class="sxs-lookup"><span data-stu-id="2c08b-351">A cancellation token used to propagate notification that this  operation should be canceled.</span></span></param>
        <summary><span data-ttu-id="2c08b-352">Vide les données du flux en tant qu'opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="2c08b-352">Flushes data from the stream as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="2c08b-353">Retourne <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-353">Returns <see cref="T:System.Threading.Tasks.Task" />.</span></span>  
  
 <span data-ttu-id="2c08b-354">Objet de tâche représentant l'opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="2c08b-354">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-355">Cette opération ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="2c08b-355">This operation will not block.</span></span> <span data-ttu-id="2c08b-356">Retourné <xref:System.Threading.Tasks.Task> objet s’achève une fois les données a été vidées à partir du flux pour le <xref:System.Net.Sockets.NetworkStream> instance.</span><span class="sxs-lookup"><span data-stu-id="2c08b-356">The returned <xref:System.Threading.Tasks.Task> object will complete after data has been flushed from the stream for the <xref:System.Net.Sockets.NetworkStream> instance.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-357">Obtient la longueur des données disponibles dans le flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-357">Gets the length of the data available on the stream.</span></span> <span data-ttu-id="2c08b-358">Cette propriété n'est pas actuellement prise en charge et lève toujours <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-358">This property is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <value><span data-ttu-id="2c08b-359">Longueur des données disponibles dans le flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-359">The length of the data available on the stream.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2c08b-360">Toute utilisation de cette propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-360">Any use of this property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-361">Obtient ou définit la position actuelle dans le flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-361">Gets or sets the current position in the stream.</span></span> <span data-ttu-id="2c08b-362">Cette propriété n'est pas actuellement prise en charge et lève toujours <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-362">This property is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <value><span data-ttu-id="2c08b-363">Position actuelle dans le flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-363">The current position in the stream.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2c08b-364">Toute utilisation de cette propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-364">Any use of this property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, size As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2c08b-365">Tableau de type <see cref="T:System.Byte" /> qui correspond à l'emplacement dans la mémoire pour stocker des données lues à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-365">An array of type <see cref="T:System.Byte" /> that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></param>
        <param name="offset"><span data-ttu-id="2c08b-366">Emplacement dans <c>buffer</c> auquel commencer le stockage des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-366">The location in <c>buffer</c> to begin storing the data to.</span></span></param>
        <param name="size"><span data-ttu-id="2c08b-367">Nombre d'octets à lire à partir de <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-367">The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></param>
        <summary><span data-ttu-id="2c08b-368">Lit les données de <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-368">Reads data from the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></summary>
        <returns><span data-ttu-id="2c08b-369">Nombre d’octets lus à partir de <see cref="T:System.Net.Sockets.NetworkStream" />, ou 0 si le socket est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-369">The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />, or 0 if the socket is closed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-370">Cette méthode lit les données dans le `buffer` paramètre et retourne le nombre d’octets lus correctement.</span><span class="sxs-lookup"><span data-stu-id="2c08b-370">This method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="2c08b-371">Si le socket est fermé, le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode renvoie la valeur 0.</span><span class="sxs-lookup"><span data-stu-id="2c08b-371">If the socket is closed, the <xref:System.Net.Sockets.NetworkStream.Read%2A> method returns 0.</span></span> <span data-ttu-id="2c08b-372">Le <xref:System.Net.Sockets.NetworkStream.Read%2A> opération lit autant de données n’est disponible, jusqu’au nombre d’octets spécifié par le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="2c08b-372">The <xref:System.Net.Sockets.NetworkStream.Read%2A> operation reads as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="2c08b-373">Si l’hôte distant arrête la connexion, et toutes les données disponibles ont été reçues, le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode se termine immédiatement et retourne zéro octet.</span><span class="sxs-lookup"><span data-stu-id="2c08b-373">If the remote host shuts down the connection, and all available data has been received, the <xref:System.Net.Sockets.NetworkStream.Read%2A> method completes immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-374">Vérifiez si le <xref:System.Net.Sockets.NetworkStream> est lisible en appelant le <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-374">Check to see if the <xref:System.Net.Sockets.NetworkStream> is readable by calling the <xref:System.Net.Sockets.NetworkStream.CanRead%2A> property.</span></span> <span data-ttu-id="2c08b-375">Si vous tentez de lire un <xref:System.Net.Sockets.NetworkStream> qui n’est pas lisible, vous obtiendrez une <xref:System.IO.IOException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-375">If you attempt to read from a <xref:System.Net.Sockets.NetworkStream> that is not readable, you will get an <xref:System.IO.IOException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-376">Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-376">If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="2c08b-377">Dans ce cas, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="2c08b-377">If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-378">Le code suivant utilise des exemple <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> pour déterminer si les données sont disponibles pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-378">The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read.</span></span> <span data-ttu-id="2c08b-379">Si les données sont disponibles, il lit à partir de la <xref:System.Net.Sockets.NetworkStream>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-379">If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.</span></span>  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c08b-380">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-380">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2c08b-381">Le paramètre <paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="2c08b-381">The <paramref name="offset" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="2c08b-382">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-382">-or-</span></span>  
  
 <span data-ttu-id="2c08b-383">Le paramètre <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-383">The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="2c08b-384">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-384">-or-</span></span>  
  
 <span data-ttu-id="2c08b-385">Le paramètre <paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="2c08b-385">The <paramref name="size" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="2c08b-386">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-386">-or-</span></span>  
  
 <span data-ttu-id="2c08b-387">Le paramètre <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-387">The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span>  
  
 <span data-ttu-id="2c08b-388">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-388">-or-</span></span>  
  
 <span data-ttu-id="2c08b-389">Une erreur s’est produite pendant l’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="2c08b-389">An error occurred when accessing the socket.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-390">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-390">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2c08b-391">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-391">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</span></span>  
  
 <span data-ttu-id="2c08b-392">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-392">-or-</span></span>  
  
 <span data-ttu-id="2c08b-393">Une erreur s'est produite pendant la lecture à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-393">There is a failure reading from the network.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Readable">
      <MemberSignature Language="C#" Value="protected bool Readable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Readable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Readable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Readable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Readable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-394">Obtient ou définit une valeur indiquant si <see cref="T:System.Net.Sockets.NetworkStream" /> peut être lu.</span><span class="sxs-lookup"><span data-stu-id="2c08b-394">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> can be read.</span></span></summary>
        <value>
          <span data-ttu-id="2c08b-395"><see langword="true" /> pour indiquer que <see cref="T:System.Net.Sockets.NetworkStream" /> peut être lu ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-395"><see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> can be read; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2c08b-396">La valeur par défaut est <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-396">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-397">Vous devez dériver la <xref:System.Net.Sockets.NetworkStream> classe à utiliser le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-397">You must derive from the <xref:System.Net.Sockets.NetworkStream> class to use the <xref:System.Net.Sockets.NetworkStream.Readable%2A> property.</span></span> <span data-ttu-id="2c08b-398">Si <xref:System.Net.Sockets.NetworkStream.Readable%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-398">If <xref:System.Net.Sockets.NetworkStream.Readable%2A> is `true`, <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Read%2A> method.</span></span> <span data-ttu-id="2c08b-399">Vous pouvez également déterminer si un <xref:System.Net.Sockets.NetworkStream> est lisible en vérifiant accessible publiquement <xref:System.Net.Sockets.NetworkStream.CanRead%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-399">You can also determine whether a <xref:System.Net.Sockets.NetworkStream> is readable by checking the publicly accessible <xref:System.Net.Sockets.NetworkStream.CanRead%2A> property.</span></span>  
  
 <span data-ttu-id="2c08b-400">Le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-400">The <xref:System.Net.Sockets.NetworkStream.Readable%2A> property is set when the <xref:System.Net.Sockets.NetworkStream> is initialized.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-401">Dans l’exemple de code suivant, le `CanCommunicate` propriété vérifications le <xref:System.Net.Sockets.NetworkStream.Readable%2A> propriété pour déterminer si le <xref:System.Net.Sockets.NetworkStream> est accessible en lecture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-401">In the following code example, the `CanCommunicate` property checks the <xref:System.Net.Sockets.NetworkStream.Readable%2A> property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.</span></span>  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-402">Obtient ou définit la durée pendant laquelle une opération de lecture reste bloquée en attendant des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-402">Gets or sets the amount of time that a read operation blocks waiting for data.</span></span></summary>
        <value><span data-ttu-id="2c08b-403"><see cref="T:System.Int32" /> qui spécifie la durée, en millisecondes, qui doit s'écouler avant l'échec d'une opération de lecture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-403">A <see cref="T:System.Int32" /> that specifies the amount of time, in milliseconds, that will elapse before a read operation fails.</span></span> <span data-ttu-id="2c08b-404">La valeur par défaut, <see cref="F:System.Threading.Timeout.Infinite" />, spécifie que l'opération de lecture n'expire pas.</span><span class="sxs-lookup"><span data-stu-id="2c08b-404">The default value, <see cref="F:System.Threading.Timeout.Infinite" />, specifies that the read operation does not time out.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-405">Si l’opération de lecture ne se termine pas dans le délai spécifié par cette propriété, l’opération de lecture lève une <xref:System.IO.IOException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-405">If the read operation does not complete within the time specified by this property, the read operation throws an <xref:System.IO.IOException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-406">Cette propriété affecte uniquement les lectures synchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.Read%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-406">This property affects only synchronous reads performed by calling the <xref:System.Net.Sockets.NetworkStream.Read%2A> method.</span></span> <span data-ttu-id="2c08b-407">Cette propriété n’affecte pas les lectures asynchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-407">This property does not affect asynchronous reads performed by calling the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-408">L’exemple de code suivant définit le délai d’attente de lecture d’un flux de réseau à 10 millisecondes.</span><span class="sxs-lookup"><span data-stu-id="2c08b-408">The following code example sets the read time-out for a network stream to 10 milliseconds.</span></span>  
  
 [!code-csharp[NCLTcpClientSync#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2c08b-409">La valeur spécifiée est inférieure ou égale à zéro et n'est pas <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-409">The value specified is less than or equal to zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="2c08b-410">Ce paramètre n'est pas utilisé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-410">This parameter is not used.</span></span></param>
        <param name="origin"><span data-ttu-id="2c08b-411">Ce paramètre n'est pas utilisé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-411">This parameter is not used.</span></span></param>
        <summary><span data-ttu-id="2c08b-412">Affecte la valeur donnée à la position actuelle du flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-412">Sets the current position of the stream to the given value.</span></span> <span data-ttu-id="2c08b-413">Cette méthode n'est pas actuellement prise en charge et lève toujours <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-413">This method is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="2c08b-414">Position dans le flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-414">The position in the stream.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2c08b-415">Toute utilisation de cette propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-415">Any use of this property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2c08b-416">Ce paramètre n'est pas utilisé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-416">This parameter is not used.</span></span></param>
        <summary><span data-ttu-id="2c08b-417">Définit la longueur du flux.</span><span class="sxs-lookup"><span data-stu-id="2c08b-417">Sets the length of the stream.</span></span> <span data-ttu-id="2c08b-418">Cette méthode lève toujours <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-418">This method always throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2c08b-419">Toute utilisation de cette propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-419">Any use of this property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Socket">
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Socket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Socket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Socket" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Socket As Socket" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Socket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-420">Obtient le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="2c08b-420">Gets the underlying <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="2c08b-421"><see cref="T:System.Net.Sockets.Socket" /> qui représente la connexion réseau sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="2c08b-421">A <see cref="T:System.Net.Sockets.Socket" /> that represents the underlying network connection.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-422">Les classes dérivées de <xref:System.Net.Sockets.NetworkStream> pouvez utiliser cette propriété pour obtenir l’objet sous-jacent <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-422">Classes deriving from <xref:System.Net.Sockets.NetworkStream> can use this property to get the underlying <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="2c08b-423">Utilisez sous-jacent <xref:System.Net.Sockets.Socket> retourné à partir de la <xref:System.Net.Sockets.NetworkStream.Socket%2A> propriété si vous avez besoin d’accéder aux au-delà de celles qui <xref:System.Net.Sockets.NetworkStream> fournit.</span><span class="sxs-lookup"><span data-stu-id="2c08b-423">Use the underlying <xref:System.Net.Sockets.Socket> returned from the <xref:System.Net.Sockets.NetworkStream.Socket%2A> property if you require access beyond that which <xref:System.Net.Sockets.NetworkStream> provides.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-424">Cette propriété est accessible uniquement par le biais de cette classe ou une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="2c08b-424">This property is accessible only through this class or a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-425">L’exemple de code suivant récupère sous-jacent <xref:System.Net.Sockets.Socket> pour vérifier une connexion active.</span><span class="sxs-lookup"><span data-stu-id="2c08b-425">The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.</span></span>  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2c08b-426">Tableau de type <see cref="T:System.Byte" /> qui contient les données à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-426">An array of type <see cref="T:System.Byte" /> that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></param>
        <param name="offset"><span data-ttu-id="2c08b-427">Emplacement dans <c>buffer</c> à partir duquel commencer l’écriture des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-427">The location in <c>buffer</c> from which to start writing data.</span></span></param>
        <param name="size"><span data-ttu-id="2c08b-428">Nombre d'octets à écrire dans <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-428">The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></param>
        <summary><span data-ttu-id="2c08b-429">Écrit des données dans <see cref="T:System.Net.Sockets.NetworkStream" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-429">Writes data to the <see cref="T:System.Net.Sockets.NetworkStream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-430">Le <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode commence à la position spécifiée `offset` et envoie `size` octets à partir du contenu de `buffer` au réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-430">The <xref:System.Net.Sockets.NetworkStream.Write%2A> method starts at the specified `offset` and sends `size` bytes from the contents of `buffer` to the network.</span></span> <span data-ttu-id="2c08b-431">Le <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode est bloquée jusqu'à ce que le nombre d’octets demandé est envoyé ou une <xref:System.Net.Sockets.SocketException> est levée.</span><span class="sxs-lookup"><span data-stu-id="2c08b-431">The <xref:System.Net.Sockets.NetworkStream.Write%2A> method blocks until the requested number of bytes is sent or a <xref:System.Net.Sockets.SocketException> is thrown.</span></span> <span data-ttu-id="2c08b-432">Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété à obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</span><span class="sxs-lookup"><span data-stu-id="2c08b-432">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-433">Vérifiez si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture en accédant à la <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-433">Check to see if the <xref:System.Net.Sockets.NetworkStream> is writable by accessing the <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> property.</span></span> <span data-ttu-id="2c08b-434">Si vous tentez d’écrire dans un <xref:System.Net.Sockets.NetworkStream> qui n’est pas accessible en écriture, vous obtiendrez une <xref:System.IO.IOException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-434">If you attempt to write to a <xref:System.Net.Sockets.NetworkStream> that is not writable, you will get an <xref:System.IO.IOException>.</span></span> <span data-ttu-id="2c08b-435">Si vous recevez un <xref:System.IO.IOException>, vérifiez le <xref:System.Exception.InnerException%2A> propriété pour déterminer si elle a été provoquée par un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-435">If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-436">Le code suivant exemple vérifie si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-436">The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable.</span></span> <span data-ttu-id="2c08b-437">Si elle est ensuite <xref:System.Net.Sockets.NetworkStream.Write%2A> est utilisé pour écrire un message de petite taille.</span><span class="sxs-lookup"><span data-stu-id="2c08b-437">If it is, then <xref:System.Net.Sockets.NetworkStream.Write%2A> is used to write a small message.</span></span>  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c08b-438">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-438">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2c08b-439">Le paramètre <paramref name="offset" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="2c08b-439">The <paramref name="offset" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="2c08b-440">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-440">-or-</span></span>  
  
 <span data-ttu-id="2c08b-441">Le paramètre <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-441">The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="2c08b-442">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-442">-or-</span></span>  
  
 <span data-ttu-id="2c08b-443">Le paramètre <paramref name="size" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="2c08b-443">The <paramref name="size" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="2c08b-444">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-444">-or-</span></span>  
  
 <span data-ttu-id="2c08b-445">Le paramètre <paramref name="size" /> est supérieur à la longueur de <paramref name="buffer" /> moins la valeur du paramètre <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-445">The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2c08b-446">Une erreur s'est produite pendant l'écriture sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-446">There was a failure while writing to the network.</span></span>  
  
 <span data-ttu-id="2c08b-447">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-447">-or-</span></span>  
  
 <span data-ttu-id="2c08b-448">Une erreur s’est produite pendant l’accès au socket.</span><span class="sxs-lookup"><span data-stu-id="2c08b-448">An error occurred when accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2c08b-449">Le <see cref="T:System.Net.Sockets.NetworkStream" /> est fermé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-449">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</span></span>  
  
 <span data-ttu-id="2c08b-450">- ou -</span><span class="sxs-lookup"><span data-stu-id="2c08b-450">-or-</span></span>  
  
 <span data-ttu-id="2c08b-451">Une erreur s'est produite pendant la lecture à partir du réseau.</span><span class="sxs-lookup"><span data-stu-id="2c08b-451">There was a failure reading from the network.</span></span></exception>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="Writeable">
      <MemberSignature Language="C#" Value="protected bool Writeable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Writeable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Writeable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Writeable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Writeable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-452">Obtient une valeur qui indique si <see cref="T:System.Net.Sockets.NetworkStream" /> est accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-452">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> is writable.</span></span></summary>
        <value>
          <span data-ttu-id="2c08b-453"><see langword="true" /> si les données peuvent être écrites dans le flux ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-453"><see langword="true" /> if data can be written to the stream; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2c08b-454">La valeur par défaut est <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-454">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-455">Vous devez dériver la <xref:System.Net.Sockets.NetworkStream> classe à utiliser le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-455">You must derive from the <xref:System.Net.Sockets.NetworkStream> class to use the <xref:System.Net.Sockets.NetworkStream.Writeable%2A> property.</span></span> <span data-ttu-id="2c08b-456">Si <xref:System.Net.Sockets.NetworkStream.Writeable%2A> est `true`, <xref:System.Net.Sockets.NetworkStream> autorise les appels à la <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-456">If <xref:System.Net.Sockets.NetworkStream.Writeable%2A> is `true`, <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Write%2A> method.</span></span> <span data-ttu-id="2c08b-457">Vous pouvez également déterminer si un <xref:System.Net.Sockets.NetworkStream> est accessible en écriture en vérifiant accessible publiquement <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="2c08b-457">You can also determine whether a <xref:System.Net.Sockets.NetworkStream> is writable by checking the publicly accessible <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> property.</span></span>  
  
 <span data-ttu-id="2c08b-458">Le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété est définie lorsque le <xref:System.Net.Sockets.NetworkStream> est initialisé.</span><span class="sxs-lookup"><span data-stu-id="2c08b-458">The <xref:System.Net.Sockets.NetworkStream.Writeable%2A> property is set when the <xref:System.Net.Sockets.NetworkStream> is initialized.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-459">Dans l’exemple de code suivant, le `CanCommunicate` propriété vérifie le <xref:System.Net.Sockets.NetworkStream.Writeable%2A> propriété pour déterminer si le <xref:System.Net.Sockets.NetworkStream> est accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-459">In the following code example, the `CanCommunicate` property checks the <xref:System.Net.Sockets.NetworkStream.Writeable%2A> property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.</span></span>  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c08b-460">Obtient ou définit la durée pendant laquelle une opération d'écriture reste bloquée en attendant des données.</span><span class="sxs-lookup"><span data-stu-id="2c08b-460">Gets or sets the amount of time that a write operation blocks waiting for data.</span></span></summary>
        <value><span data-ttu-id="2c08b-461"><see cref="T:System.Int32" /> qui spécifie la durée, en millisecondes, qui doit s'écouler avant l'échec d'une opération d'écriture.</span><span class="sxs-lookup"><span data-stu-id="2c08b-461">A <see cref="T:System.Int32" /> that specifies the amount of time, in milliseconds, that will elapse before a write operation fails.</span></span> <span data-ttu-id="2c08b-462">La valeur par défaut, <see cref="F:System.Threading.Timeout.Infinite" />, spécifie que l'opération d'écriture n'expire pas.</span><span class="sxs-lookup"><span data-stu-id="2c08b-462">The default value, <see cref="F:System.Threading.Timeout.Infinite" />, specifies that the write operation does not time out.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c08b-463">Si l’opération d’écriture ne se termine pas dans le délai spécifié par cette propriété, l’opération d’écriture lève un <xref:System.IO.IOException>.</span><span class="sxs-lookup"><span data-stu-id="2c08b-463">If the write operation does not complete within the time specified by this property, the write operation throws a <xref:System.IO.IOException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c08b-464">Cette propriété affecte les opérations d’écriture synchrone uniquement effectuées en appelant le <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-464">This property affects only synchronous write operations performed by calling the <xref:System.Net.Sockets.NetworkStream.Write%2A> method.</span></span> <span data-ttu-id="2c08b-465">Cette propriété n’affecte pas les écritures asynchrones exécutées en appelant le <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="2c08b-465">This property does not affect asynchronous writes performed by calling the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c08b-466">L’exemple de code suivant définit le délai d’attente de l’écriture d’un flux de réseau à 10 millisecondes.</span><span class="sxs-lookup"><span data-stu-id="2c08b-466">The following code example sets the write time-out for a network stream to 10 milliseconds.</span></span>  
  
 [!code-cpp[NCLTcpServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclTcpServerSync/cpp/tcplistener.cpp#0)]
 [!code-csharp[NCLTcpServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclTcpServerSync/CS/tcplistener.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2c08b-467">La valeur spécifiée est inférieure ou égale à zéro et n'est pas <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="2c08b-467">The value specified is less than or equal to zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>