<Type Name="EntityCollection&lt;TEntity&gt;" FullName="System.Data.Objects.DataClasses.EntityCollection&lt;TEntity&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b574b777b4ff63fbe3458359610b6cadef1f8e44" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30390483" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EntityCollection&lt;TEntity&gt; : System.Data.Objects.DataClasses.RelatedEnd, System.Collections.Generic.ICollection&lt;TEntity&gt;, System.Collections.Generic.IEnumerable&lt;TEntity&gt;, System.ComponentModel.IListSource where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityCollection`1&lt;class TEntity&gt; extends System.Data.Objects.DataClasses.RelatedEnd implements class System.Collections.Generic.ICollection`1&lt;!TEntity&gt;, class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt;, class System.Collections.IEnumerable, class System.ComponentModel.IListSource" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.DataClasses.EntityCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityCollection(Of TEntity)&#xA;Inherits RelatedEnd&#xA;Implements ICollection(Of TEntity), IEnumerable(Of TEntity), IListSource" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TEntity&gt;&#xA; where TEntity : classpublic ref class EntityCollection sealed : System::Data::Objects::DataClasses::RelatedEnd, System::Collections::Generic::ICollection&lt;TEntity&gt;, System::Collections::Generic::IEnumerable&lt;TEntity&gt;, System::ComponentModel::IListSource" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Data.Objects.DataClasses.RelatedEnd</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TEntity">Type d’entité de la collection.</typeparam>
    <summary>Représente une collection d’objets à la terminaison « plusieurs » d’une relation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> est une collection d'objets d'un type d'entité particulier qui représente la terminaison « plusieurs » d'une relation un-à-plusieurs ou plusieurs à plusieurs.  
  
 Un objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> est retourné par une propriété de navigation. Utilisez la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> pour charger des objets connexes dans un objet <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Pour stocker une collection d'objets non connexe d'un type d'entité spécifique, tel que le résultat d'un objet <xref:System.Data.Objects.ObjectQuery%601>, utilisez une instance de la classe <xref:System.Collections.Generic.List%601>.  
  
 Un objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> peut avoir un objet <xref:System.Data.Objects.DataClasses.EntityReference%601> correspondant. Lorsque des objets <xref:System.Data.Objects.DataClasses.EntityCollection%601> et <xref:System.Data.Objects.DataClasses.EntityReference%601> modèlent des terminaisons opposées de la même relation, l'intégrité de la relation est maintenue au niveau de l'objet. Les deux classes sont synchronisées automatiquement.  
  
 Cette classe ne peut pas être héritée.  
  
   
  
## Examples  
 Cet exemple est basé sur le. Pour exécuter le code de cet exemple, vous devez déjà avoir ajouté le modèle de vente AdventureWorks Sales Model à votre projet et configuré ce dernier pour qu’il utilise Entity Framework. Pour ce faire, exécutez les procédures de [Comment : configurer manuellement un projet Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) et [Comment : définir manuellement les fichiers de modèle et de mappage](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 L'exemple réalise les actions suivantes :  
  
1.  Crée deux nouvelles entités `SalesOrderHeader` et les ajoute à l'entité `Contact`.  
  
2.  Obtient toutes les terminaisons connexes à partir de l'objet <xref:System.Data.Objects.DataClasses.RelationshipManager> associé à l'entité `Contact`.  
  
3.  Itère au sein de la collection d'objets <xref:System.Data.Objects.DataClasses.IRelatedEnd>.  
  
4.  Obtient l'objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> pour chaque terminaison connexe.  
  
5.  Utilise la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> pour déplacer l'une des entités à partir de la collection.  
  
6.  Appelle la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> pour déterminer si l'objet a été supprimé de la collection.  
  
7.  Utilise la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> pour rajouter l'entité.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur public pour <xref:System.Data.Objects.DataClasses.EntityCollection%601> est destiné à une utilisation par Object Services lors de la désérialisation de graphiques d'objets. Vous devez accéder à une instance de <xref:System.Data.Objects.DataClasses.EntityCollection%601> à partir d'une propriété de navigation au lieu d'utiliser ce constructeur.  
  
 Pour stocker une collection d'objets non connexe d'un type d'entité spécifique, tel que le résultat d'un objet <xref:System.Data.Objects.ObjectQuery%601>, utilisez une instance de <xref:System.Collections.Generic.List%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TEntity entity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Objet à ajouter à la collection. <c>entity</c> doit implémenter <see cref="T:System.Data.Objects.DataClasses.IEntityWithRelationships" />.</param>
        <summary>Ajoute un objet à la collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> ajoute un objet à un objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> et crée une relation entre les deux objets. Lorsque l'objet source est attaché à une instance <xref:System.Data.Objects.ObjectContext> instance, la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> ajoute également l'objet à l'objet <xref:System.Data.Objects.ObjectContext>. Cette opération est traduite en opération d'insertion dans la source de données lorsque <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> est appelée. Pour plus d’informations, consultez [création, ajout, modification et suppression des objets](http://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 La méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> peut être appelée plusieurs fois sur la même instance d'objet.  
  
   
  
## Examples  
 Cet exemple est basé sur le. Pour exécuter le code de cet exemple, vous devez déjà avoir ajouté le modèle de vente AdventureWorks Sales Model à votre projet et configuré ce dernier pour qu’il utilise Entity Framework. Pour ce faire, exécutez les procédures de [Comment : configurer manuellement un projet Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) et [Comment : définir manuellement les fichiers de modèle et de mappage](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Cet exemple crée deux nouvelles entités `SalesOrderHeader`, les ajoute à l'entité `Contact` et, après avoir supprimé un objet, utilise la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> pour rajouter l'objet à la collection.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Attach">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit une relation entre deux objets attachés dans un contexte d'objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entities As IEnumerable(Of TEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Collections::Generic::IEnumerable&lt;TEntity&gt; ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
      </Parameters>
      <Docs>
        <param name="entities">Collection d’objets dans le contexte de l’objet qui sont associés à l’objet source.</param>
        <summary>Définit les relations entre un objet et une collection d’objets connexes dans un contexte d’objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.Objects.ObjectContext.Attach%2A> est utilisée pour définir les relations entre un objet et une collection d'objets connexes lorsque l'objet source et la collection d'objets connexes existent déjà dans le contexte de l'objet. Pour attacher un objet ou un graphique d'objet lorsque les relations sont déjà définies, appelez la méthode <xref:System.Data.Objects.ObjectContext.Attach%2A> sur l'objet <xref:System.Data.Objects.ObjectContext>. Pour créer un nouvel objet associé à l'objet source, appelez la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> sur l'objet <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Pour plus d’informations, consultez [attachement et détachement des objets](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Si la collection est déjà remplie ou partiellement remplie, la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> fusionne les entités existantes avec les entités données. Il n'est pas supposé que les entités données sont le jeu complet d'entités associées.  
  
 Toutes les entités passées doivent être à l'état <xref:System.Data.EntityState.Unchanged> ou <xref:System.Data.EntityState.Modified>. Les objets à l'état <xref:System.Data.EntityState.Deleted> sont autorisés uniquement lorsque le gestionnaire d'état effectue déjà le suivi de l'instance de relation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          La collection <paramref name="entities" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'objet source ou un objet de la collection <paramref name="entities" /> a la valeur <see langword="null" />, ou n'est pas dans l'état <see cref="F:System.Data.EntityState.Unchanged" /> ou <see cref="F:System.Data.EntityState.Modified" />.  
  
 - ou -  
  
 La relation ne peut pas être définie en fonction des métadonnées EDM. Cela peut se produire lorsque l'association dans le schéma conceptuel ne prend pas en charge une relation entre les deux types.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Objet qui est attaché.</param>
        <summary>Définit une relation entre deux objets attachés dans un contexte d'objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> est utilisée pour définir les relations entre deux objets lorsque les deux objets existent déjà dans le contexte de l'objet. Pour attacher un objet ou un graphique d'objet lorsque les relations sont déjà définies, appelez la méthode <xref:System.Data.Objects.ObjectContext.Attach%2A> sur l'objet <xref:System.Data.Objects.ObjectContext>. Pour créer un nouvel objet associé à l'objet source, appelez la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> sur l'objet <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Pour plus d’informations, consultez [attachement et détachement des objets](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Si l'objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> contient déjà des objets chargés, la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> fusionne l'objet avec les objets existants dans l'objet <xref:System.Data.Objects.DataClasses.EntityCollection%601>.  
  
 Il n'est pas supposé que l'objet attaché est le jeu complet d'objets entité associés.  
  
 L'objet associé à cet objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> et tous les objets qui y sont attachés doivent être à l'état <xref:System.Data.EntityState.Unchanged> ou <xref:System.Data.EntityState.Modified>.  
  
 Les objets à l'état <xref:System.Data.EntityState.Deleted> peuvent être attachés uniquement lorsque l'objet <xref:System.Data.Objects.ObjectStateManager> effectue déjà le suivi de l'instance de relation.  
  
   
  
## Examples  
 Cet exemple est basé sur le. Pour exécuter le code de cet exemple, vous devez déjà avoir ajouté le modèle de vente AdventureWorks Sales Model à votre projet et configuré ce dernier pour qu’il utilise Entity Framework. Pour ce faire, exécutez les procédures de [Comment : configurer manuellement un projet Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) et [Comment : définir manuellement les fichiers de modèle et de mappage](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Cet exemple attache une collection de détaché `SalesOrderDetail` objets et un détaché `SalesOrderHeader` de l’objet à un contexte d’objet, puis définit les relations entre les `SalesOrderHeader` objet et chaque `SalesOrderDetail` objet.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Lorsque le paramètre <paramref name="entity" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Lorsque le paramètre <paramref name="entity" /> ne peut pas être mis en rapport avec l'objet source. Cela peut se produire lorsque l'association dans le schéma conceptuel ne prend pas en charge une relation entre les deux types.  
  
 - ou -  
  
 Lorsque l'un ou l'autre des objets a la valeur <see langword="null" /> ou n'est pas dans l'état <see cref="F:System.Data.EntityState.Unchanged" /> ou <see cref="F:System.Data.EntityState.Modified" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime toutes les entités de la collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Clear%2A> effectue les actions suivantes :  
  
-   Définit le <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> indicateur `false`.  
  
-   Supprime toutes les entités de la collection.  
  
-   Détache de l'objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> les relations entre les entités supprimées et le propriétaire de l'objet <xref:System.Data.Objects.ObjectStateManager>.  
  
-   Supprime le propriétaire de l'objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> des entités connexes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(TEntity entity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Objet à rechercher dans <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</param>
        <summary>Détermine si un objet spécifique existe dans la collection.</summary>
        <returns>
          <see langword="true" /> si l'objet est trouvé dans <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilise la méthode <xref:System.Object.Equals%2A?displayProperty=nameWithType> pour comparer l'objet spécifié aux objets déjà dans la collection.  
  
   
  
## Examples  
 Cet exemple est basé sur le. Pour exécuter le code de cet exemple, vous devez déjà avoir ajouté le modèle de vente AdventureWorks Sales Model à votre projet et configuré ce dernier pour qu’il utilise Entity Framework. Pour ce faire, exécutez les procédures de [Comment : configurer manuellement un projet Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) et [Comment : définir manuellement les fichiers de modèle et de mappage](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 L'exemple réalise les actions suivantes :  
  
1.  Crée deux nouvelles entités `SalesOrderHeader` et les ajoute à l'entité `Contact`.  
  
2.  Obtient toutes les terminaisons connexes à partir de l'objet <xref:System.Data.Objects.DataClasses.RelationshipManager> associé à l'entité Contact.  
  
3.  Itère au sein de la collection d'objets <xref:System.Data.Objects.DataClasses.IRelatedEnd>.  
  
4.  Obtient l'objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> pour chaque terminaison connexe.  
  
5.  Utilise la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> pour déplacer l'une des entités à partir de la collection.  
  
6.  Appelle la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> pour déterminer si l'objet a été supprimé de la collection.  
  
7.  Utilise la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> pour rajouter l'entité.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (TEntity[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!TEntity[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As TEntity(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;TEntity&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="TEntity[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tableau dans lequel effectuer la copie.</param>
        <param name="arrayIndex">Index de base zéro dans le tableau au niveau duquel commencer la copie.</param>
        <summary>Copie tout le contenu de la collection dans un tableau, en commençant à l’index spécifié du tableau cible.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d’objets qui sont contenus dans la collection.</summary>
        <value>Nombre d'éléments contenus dans l'objet <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.Data.Objects.DataClasses.EntityCollection%601.Count%2A> obtient le nombre d'entités actuellement dans la collection locale et ne reflète pas la taille de la collection dans la source de données. Un nombre zéro n'indique pas nécessairement que la collection connexe est vide. Pour déterminer la taille de collection dans la source de données, appelez la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> ou incluez l'objet connexe dans le chemin d'accès de la requête. Pour plus d’informations, consultez [le chargement des objets connexes](http://msdn.microsoft.com/library/452347d2-7b3b-44cd-9001-231299a28cb1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSourceQuery">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;TEntity&gt; CreateSourceQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!TEntity&gt; CreateSourceQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CreateSourceQuery" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSourceQuery () As ObjectQuery(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;TEntity&gt; ^ CreateSourceQuery();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une requête d’objet qui, lorsqu’elle est exécutée, retourne le même jeu d’objets que celui qui existe dans la collection actuelle.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectQuery`1" /> qui représente la collection d'entités.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utilisée pour obtenir une nouvelle instance de <xref:System.Data.Objects.ObjectQuery%601> qui retourne le même jeu d'objets. Ceci est utile comme point de départ pour une jointure, union ou requête filtrée plus complexe, ou pour retourner les mêmes objets dans un état détaché à l'aide de l'option <xref:System.Data.Objects.MergeOption.NoTracking>.  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> permet de filtrer les objets dans une <xref:System.Data.Objects.DataClasses.EntityCollection%601> pour vous permettre de lier uniquement des objets d’un type spécifique. Pour plus d’informations, consultez [liaison d’objets aux contrôles](http://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
   
  
## Examples  
 Cet exemple est basé sur une version modifiée de le. Cette version prend en charge l'héritage table par type avec `Course` comme type abstrait. Effectuez la procédure pas à pas pour modifier le modèle School pour prendre en charge de l’exemple d’héritage table par type utilisé dans cette rubrique.  
  
 Cet exemple montre comment utiliser <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> pour filtrer des objets dans une <xref:System.Data.Objects.DataClasses.EntityCollection%601> et une liaison uniquement avec les objets d’un type spécifique. Pour obtenir une version complète de cet exemple, consultez [Comment : lier des contrôles à des Types dérivés](http://msdn.microsoft.com/library/09730c14-3b7b-4563-af4a-7ecfa4e34bd5).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Lorsque l'objet est à l'état <see cref="F:System.Data.EntityState.Added" />.  
  
 - ou -  
  
 Lorsque l'objet est à l'état <see cref="F:System.Data.EntityState.Detached" /> avec un objet <see cref="T:System.Data.Objects.MergeOption" /> autre que <see cref="F:System.Data.Objects.MergeOption.NoTracking" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;TEntity&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;TEntity&gt; ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur utilisé pour itérer au sein des objets de la collection.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> qui itère au sein du jeu de valeurs mis en cache par <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'objet <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> est en lecture seule.</summary>
        <value>Retourne toujours <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Load(System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Data::Objects::MergeOption mergeOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="mergeOption">Spécifie comment les objets de cette collection doivent être fusionnés avec les objets qui ont pu être retournés à partir de requêtes précédentes contre le même objet <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Charge les objets connexes dans la collection, à l’aide de l’option de fusion spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Cette méthode appelle en interne `RelatedEnd.ValidateLoad` méthode avant le chargement de la collection, ce qui valide le fait qu’un appel à <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> a les conditions correctes. Le `RelatedEnd.ValidateLoad` méthode vérifie que :

* Valide <xref:System.Data.Objects.ObjectContext> existe.
* L’entité n’est pas dans un <xref:System.Data.EntityState.Deleted> état.
* <xref:System.Data.Objects.MergeOption> pour <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> doit être <xref:System.Data.Objects.MergeOption.NoTracking> si et seulement si l’entité source a été <xref:System.Data.Objects.MergeOption.NoTracking>. Si l’entité source a été récupérée avec n’importe quel autre <xref:System.Data.Objects.MergeOption>, le <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> <xref:System.Data.Objects.MergeOption> peut être tout sauf <xref:System.Data.Objects.MergeOption.NoTracking> (par exemple, l’entité a été chargée avec <xref:System.Data.Objects.MergeOption.OverwriteChanges> et <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> option peut être <xref:System.Data.Objects.MergeOption.AppendOnly>).
* Si `mergeOption` est <xref:System.Data.Objects.MergeOption.NoTracking>, <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> n’est pas appelée sur une entité déjà chargée et <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> n’est pas appelée sur un vide, non suivi <xref:System.Data.Objects.DataClasses.RelatedEnd>.
  
 Lorsque les objets de la collection sont déjà chargés dans le <xref:System.Data.Objects.ObjectContext>, le <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> méthode applique la <xref:System.Data.Objects.MergeOption> spécifié par le `mergeOption` paramètre. Pour plus d’informations, consultez [résolution d’identité, la gestion de l’état et le suivi des modifications](http://msdn.microsoft.com/library/3bd49311-0e72-4ea4-8355-38fe57036ba0).  
  
 Pour charger explicitement des objets connexes, vous devez appeler la `Load` méthode sur la terminaison connexe retournée par la propriété de navigation. Pour une relation un-à-plusieurs, appelez le <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> méthode sur <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Pour une relation un à un, appelez le <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> sur <xref:System.Data.Objects.DataClasses.EntityReference%601>. Cela charge les données d'objets connexes dans le contexte d'objet. Vous pouvez énumérer la collection de résultats retournés à l’aide un `foreach` boucle (`For Each...Next` en Visual Basic) et appeler de manière conditionnelle la `Load` méthode sur <xref:System.Data.Objects.DataClasses.EntityReference%601> et <xref:System.Data.Objects.DataClasses.EntityCollection%601> propriétés pour chaque entité dans les résultats.  
  
 Le <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> méthode charge ou non les objets connexes à partir de la source de données <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> est `true`.  
  
> [!NOTE]
>  Lorsque vous appelez la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> lors d'une énumération `foreach` (C#) ou `For Each` (Visual Basic), Object Services essaie d'ouvrir un nouveau lecteur de données. Cette opération échoue sauf si vous avez activé des ensembles de résultats actifs multiples (MARS) en spécifiant `multipleactiveresultsets=true` dans la chaîne de connexion. Vous pouvez également charger le résultat de la requête dans une collection <xref:System.Collections.Generic.List%601>. Cela ferme le lecteur de données et vous permet d'énumérer la collection pour charger des objets référencés.  
  
 La méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A?displayProperty=nameWithType> est synchronisée avec la méthode <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Cet exemple est basé sur le. Pour exécuter le code de cet exemple, vous devez déjà avoir ajouté le modèle de vente AdventureWorks Sales Model à votre projet et configuré ce dernier pour qu’il utilise Entity Framework. Pour ce faire, exécutez les procédures de [Comment : configurer manuellement un projet Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) et [Comment : définir manuellement les fichiers de modèle et de mappage](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Cet exemple charge les objets `SalesOrderHeader` connexes pour l'entité `Contact`.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querywithload)]
 [!code-vb[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querywithload)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollectionDeserialized">
      <MemberSignature Language="C#" Value="public void OnCollectionDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnCollectionDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnCollectionDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnCollectionDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnCollectionDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Contexte de diffusion en continu.</param>
        <summary>Utilisé en interne pour désérialiser des objets d'entité.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSerializing">
      <MemberSignature Language="C#" Value="public void OnSerializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnSerializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnSerializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnSerializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnSerializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnSerializing</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Contexte de diffusion en continu.</param>
        <summary>Utilisé en interne pour sérialiser des objets d'entité.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TEntity entity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Objet à supprimer de la collection.</param>
        <summary>Supprime un objet de la collection et marque la relation pour la suppression.</summary>
        <returns>
          <see langword="true" /> si l'élément a été supprimée avec succès ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> supprime également la relation entre l'objet source et l'objet qui est supprimé de la collection. Si la relation a une contrainte d'intégrité référentielle, l'appel de la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> sur un objet dépendant marque à la fois la relation et l'objet dépendant pour la suppression. Cela se produit car la contrainte indique que l'objet dépendant ne peut pas exister sans relation au parent. Pour plus d’informations, consultez [élément ReferentialConstraint (CSDL)](http://msdn.microsoft.com/library/24f96a80-85b5-4f2e-a14c-0e3eb6796fa0).  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> Retourne `false` lorsque l’objet spécifié n’est pas dans la collection.  
  
   
  
## Examples  
 Cet exemple est basé sur le. Pour exécuter le code de cet exemple, vous devez déjà avoir ajouté le modèle de vente AdventureWorks Sales Model à votre projet et configuré ce dernier pour qu’il utilise Entity Framework. Pour ce faire, exécutez les procédures de [Comment : configurer manuellement un projet Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) et [Comment : définir manuellement les fichiers de modèle et de mappage](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Cet exemple utilise la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> pour supprimer l'une des entités de la collection, puis appelle la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> afin de déterminer si l'objet a été supprimé de la collection.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          L’objet <paramref name="entity" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L’objet <paramref name="entity" /> n’est pas attaché au même contexte d’objet.  
  
 - ou -  
  
 L’objet <paramref name="entity" /> n’a pas de gestionnaire de relations valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur utilisé pour itérer au sein du jeu de valeurs mis en cache par <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> qui itère au sein du jeu de valeurs mis en cache par <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la collection d’entités connexe est constituée d’objets de collection.</summary>
        <value>Cette propriété retourne toujours <see langword="false" /> car l'objet <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> contient des objets et non des collections.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.Objects.DataClasses.EntityCollection%601> est castée en interface <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la collection sous la forme d'un objet <see cref="T:System.Collections.IList" /> utilisé pour la liaison de données.</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> d'objets entité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.Objects.DataClasses.EntityCollection%601> est castée en interface <xref:System.ComponentModel.IListSource>.  
  
 Cette méthode autorise la liaison de données à un objet <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Elle est appelée par le contrôle lié à la collection. Pour plus d’informations, consultez [liaison d’objets aux contrôles](http://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>