<Type Name="EntityReference&lt;TEntity&gt;" FullName="System.Data.Objects.DataClasses.EntityReference&lt;TEntity&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e77403439756f7e92b345c32d72c9f649b32e6fd" /><Meta Name="ms.sourcegitcommit" Value="7461f9e28c2f184bd1596e6f07c25a3f34984516" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/28/2019" /><Meta Name="ms.locfileid" Value="58551983" /></Metadata><TypeSignature Language="C#" Value="public sealed class EntityReference&lt;TEntity&gt; : System.Data.Objects.DataClasses.EntityReference where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityReference`1&lt;class TEntity&gt; extends System.Data.Objects.DataClasses.EntityReference" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.DataClasses.EntityReference`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityReference(Of TEntity)&#xA;Inherits EntityReference" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TEntity&gt;&#xA; where TEntity : classpublic ref class EntityReference sealed : System::Data::Objects::DataClasses::EntityReference" />
  <TypeSignature Language="F#" Value="type EntityReference&lt;'Entity (requires 'Entity : null)&gt; = class&#xA;    inherit EntityReference" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Data.Objects.DataClasses.EntityReference</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.DataContract</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TEntity">Type d'entité de la référence.</typeparam>
    <summary>Représente une terminaison connexe d'une association avec une multiplicité de zéro ou un.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.DataClasses.EntityReference%601> est retourné par une propriété de navigation lorsque la terminaison connexe a une multiplicité de zéro ou un. Pour plus d’informations, consultez [élément NavigationProperty (CSDL)](https://msdn.microsoft.com/library/5829a238-a50e-4c81-901d-7b54fc00f27e).  
  
 Un objet <xref:System.Data.Objects.DataClasses.EntityReference%601> peut avoir un objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> (relation un-à-plusieurs) ou <xref:System.Data.Objects.DataClasses.EntityReference%601> (relation un-à-un) correspondant à l'autre terminaison de la relation. Lorsque des objets <xref:System.Data.Objects.DataClasses.EntityReference%601> et <xref:System.Data.Objects.DataClasses.EntityCollection%601> modèlent des terminaisons opposées de la même relation, l'intégrité de la relation est maintenue au niveau de l'objet.  
  
 Cette classe ne peut pas être héritée.  
  
   
  
## Examples  
 Cet exemple indique comment utiliser l'objet <xref:System.Data.Objects.DataClasses.EntityReference%601> pour modifier une relation entre un objet `SalesOrderHeader` et un objet `Address` connexe qui représente l'adresse d'expédition pour la commande.  
  
 [!code-csharp[DP ObjectServices Concepts#ChangeObjectRelationship](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#changeobjectrelationship)]
 [!code-vb[DP ObjectServices Concepts#ChangeObjectRelationship](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#changeobjectrelationship)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityReference();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crée une instance de <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Attach : 'Entity -&gt; unit" Usage="entityReference.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Objet qui est attaché.</param>
        <summary>Crée une relation plusieurs-à-un ou un-à-un entre deux objets dans le contexte de l'objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.Objects.DataClasses.EntityReference%601.Attach%2A> est utilisée pour définir une relation entre un objet et un objet connexe lorsque les deux objets sont déjà attachés à un contexte d'objet. Définissez l'objet connexe à la propriété <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A> s'il n'est pas déjà attaché au contexte de l'objet. Lorsque les deux objets sont détachés, vous pouvez également définir la relation en définissant l'objet connexe à la propriété <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A>, puis en attachant l'objet racine dans le graphique d'objet. Pour plus d’informations, consultez [attachement et détachement des objets](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 L'objet associé à cet objet <xref:System.Data.Objects.DataClasses.EntityReference%601> et tous les objets qui y sont attachés doivent être à l'état <xref:System.Data.EntityState.Unchanged> ou <xref:System.Data.EntityState.Modified>.  
  
 Un objet à l'état <xref:System.Data.EntityState.Deleted> peut être attaché uniquement lorsque l'objet <xref:System.Data.Objects.ObjectStateManager> effectue déjà le suivi de l'instance de relation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Lorsque le paramètre <paramref name="entity" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Lorsque <paramref name="entity" /> ne peut pas être mis en rapport avec la terminaison connexe actuelle. Cela peut se produire lorsque l'association dans le schéma conceptuel ne prend pas en charge une relation entre les deux types.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSourceQuery">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;TEntity&gt; CreateSourceQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!TEntity&gt; CreateSourceQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.CreateSourceQuery" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSourceQuery () As ObjectQuery(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;TEntity&gt; ^ CreateSourceQuery();" />
      <MemberSignature Language="F#" Value="override this.CreateSourceQuery : unit -&gt; System.Data.Objects.ObjectQuery&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityReference.CreateSourceQuery " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une requête d'objet équivalente qui retourne l'objet connexe.</summary>
        <returns><see cref="T:System.Data.Objects.ObjectQuery`1" /> qui retourne l'objet connexe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d'obtenir une nouvelle instance de <xref:System.Data.Objects.ObjectQuery%601> qui, lorsqu'elle est exécutée, retourne l'objet connexe. Ceci est utile comme point de départ pour une jointure, union ou requête filtrée plus complexe, ou pour retourner l'objet référencé dans un état détaché à l'aide de l'option <xref:System.Data.Objects.MergeOption.NoTracking>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Lorsque l'objet est à l'état <see cref="F:System.Data.EntityState.Added" />.  
  
ou 
Lorsque l'objet est à l'état <see cref="F:System.Data.EntityState.Detached" /> avec un objet <see cref="P:System.Data.Objects.ObjectQuery.MergeOption" /> autre que <see cref="F:System.Data.Objects.MergeOption.NoTracking" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.Load(System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="override this.Load : System.Data.Objects.MergeOption -&gt; unit" Usage="entityReference.Load mergeOption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="mergeOption">Spécifie la manière dont l'objet doit être retourné s'il existe déjà dans <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Charge l'objet connexe pour <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" /> avec l'option de fusion spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour charger l'objet connexe.  
  
 Une fois chargé, l'objet connexe est accessible à partir de la propriété <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A>.  
  
 Pour charger explicitement des objets connexes, vous devez appeler la `Load` méthode sur la terminaison connexe retournée par la propriété de navigation. Dans le cas d'une relation un-à-plusieurs, appelez la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> sur <xref:System.Data.Objects.DataClasses.EntityCollection%601> ; dans le cas d'une relation un-à-un, appelez la méthode <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> sur <xref:System.Data.Objects.DataClasses.EntityReference%601>. Cela charge les données d'objets connexes dans le contexte d'objet. Lorsqu’une requête retourne des résultats, vous pouvez énumérer la collection d’objets à l’aide un `foreach` boucle (`For Each...Next` en Visual Basic) et appeler de manière conditionnelle la `Load` méthode sur <xref:System.Data.Objects.DataClasses.EntityReference%601> et <xref:System.Data.Objects.DataClasses.EntityCollection%601> propriétés pour chaque entité dans les résultats.  
  
 Le <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> méthode charge des objets connexes à partir de la source de données ou non <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> est `true`.  
  
> [!NOTE]
>  Lorsque vous appelez la méthode <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> lors d'une énumération `foreach` (C#) ou `For Each` (Visual Basic), Object Services essaie d'ouvrir un nouveau lecteur de données. Cette opération échoue sauf si vous avez activé des ensembles de résultats actifs multiples (MARS) en spécifiant `multipleactiveresultsets=true` dans la chaîne de connexion. Vous pouvez également charger le résultat de la requête dans une collection <xref:System.Collections.Generic.List%601>. Cela ferme le lecteur de données et vous permet d’énumérer la collection pour charger des objets référencés.  
 
Cette méthode appelle en interne `RelatedEnd.ValidateLoad` méthode avant de charger l’objet connexe, qui valide le fait qu’un appel à <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> a les conditions correctes. Le `RelatedEnd.ValidateLoad` méthode vérifie que :

* Valide <xref:System.Data.Objects.ObjectContext> existe.
* L’entité n’est pas dans un <xref:System.Data.EntityState.Deleted> état.
* <xref:System.Data.Objects.MergeOption> pour <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> doit être <xref:System.Data.Objects.MergeOption.NoTracking> si et seulement si l’entité source a été <xref:System.Data.Objects.MergeOption.NoTracking>. Si l’entité source a été récupérée avec n’importe quel autre <xref:System.Data.Objects.MergeOption>, le <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> <xref:System.Data.Objects.MergeOption> peut être tout sauf <xref:System.Data.Objects.MergeOption.NoTracking> (par exemple, l’entité ont pu été chargée avec <xref:System.Data.Objects.MergeOption.OverwriteChanges> et le <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> option puisse être <xref:System.Data.Objects.MergeOption.AppendOnly>).
* Si `mergeOption` est <xref:System.Data.Objects.MergeOption.NoTracking>, <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> n’est pas appelée sur une entité déjà chargée et <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> n’est pas appelée sur un non vide, suivies de non <xref:System.Data.Objects.DataClasses.RelatedEnd>.

 Lorsque l’objet connexe est déjà chargé dans le <xref:System.Data.Objects.ObjectContext>, le <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> méthode impose le <xref:System.Data.Objects.MergeOption> spécifié par le `mergeOption` paramètre. Pour plus d’informations, consultez [résolution d’identité, la gestion de l’état et le suivi des modifications](https://msdn.microsoft.com/library/3bd49311-0e72-4ea4-8355-38fe57036ba0).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La source de <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" /> est une <see langword="null" />.  
  
ou 
Une requête a retourné plusieurs terminaisons connexes.  
  
ou 
Une requête a retourné des terminaisons connexes nulles et une terminaison connexe était attendue.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="OnRefDeserialized">
      <MemberSignature Language="C#" Value="public void OnRefDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnRefDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.OnRefDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnRefDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnRefDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnRefDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityReference.OnRefDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="context">Flux sérialisé.</param>
        <summary>Cette méthode est utilisée en interne pour sérialiser des objets d'entité associée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSerializing">
      <MemberSignature Language="C#" Value="public void OnSerializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnSerializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.OnSerializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnSerializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnSerializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnSerializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityReference.OnSerializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnSerializing</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="context">Flux sérialisé.</param>
        <summary>Cette méthode est utilisée en interne pour sérialiser des objets d'entité associée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public TEntity Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TEntity Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityReference`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public Property Value As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TEntity Value { TEntity get(); void set(TEntity value); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'Entity with get, set" Usage="System.Data.Objects.DataClasses.EntityReference&lt;'Entity (requires 'Entity : null)&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Xml.Serialization.SoapIgnore</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Xml.Serialization.XmlIgnore</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet connexe retourné par <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" />.</summary>
        <value>Objet retourné par <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucune valeur n'est assignée si la valeur qui est définie est identique à la valeur actuelle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>