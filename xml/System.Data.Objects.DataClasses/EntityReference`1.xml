<Type Name="EntityReference&lt;TEntity&gt;" FullName="System.Data.Objects.DataClasses.EntityReference&lt;TEntity&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="948e47dfbd85b87b3148962ea0ea5cde3b04cd3a" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37678452" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EntityReference&lt;TEntity&gt; : System.Data.Objects.DataClasses.EntityReference where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityReference`1&lt;class TEntity&gt; extends System.Data.Objects.DataClasses.EntityReference" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.DataClasses.EntityReference`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityReference(Of TEntity)&#xA;Inherits EntityReference" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TEntity&gt;&#xA; where TEntity : classpublic ref class EntityReference sealed : System::Data::Objects::DataClasses::EntityReference" />
  <TypeSignature Language="F#" Value="type EntityReference&lt;'Entity (requires 'Entity : null)&gt; = class&#xA;    inherit EntityReference" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Data.Objects.DataClasses.EntityReference</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.DataContract</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TEntity">Type d'entité de la référence.</typeparam>
    <summary>Represents a related end of an association with a multiplicity of zero or one.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.DataClasses.EntityReference%601> est retourné par une propriété de navigation lorsque la terminaison connexe a une multiplicité de zéro ou un. Pour plus d’informations, consultez [élément NavigationProperty (CSDL)](http://msdn.microsoft.com/library/5829a238-a50e-4c81-901d-7b54fc00f27e).  
  
 Un objet <xref:System.Data.Objects.DataClasses.EntityReference%601> peut avoir un objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> (relation un-à-plusieurs) ou <xref:System.Data.Objects.DataClasses.EntityReference%601> (relation un-à-un) correspondant à l'autre terminaison de la relation. Lorsque des objets <xref:System.Data.Objects.DataClasses.EntityReference%601> et <xref:System.Data.Objects.DataClasses.EntityCollection%601> modèlent des terminaisons opposées de la même relation, l'intégrité de la relation est maintenue au niveau de l'objet.  
  
 Cette classe ne peut pas être héritée.  
  
   
  
## Examples  
 Cet exemple indique comment utiliser l'objet <xref:System.Data.Objects.DataClasses.EntityReference%601> pour modifier une relation entre un objet `SalesOrderHeader` et un objet `Address` connexe qui représente l'adresse d'expédition pour la commande.  
  
 [!code-csharp[DP ObjectServices Concepts#ChangeObjectRelationship](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#changeobjectrelationship)]
 [!code-vb[DP ObjectServices Concepts#ChangeObjectRelationship](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#changeobjectrelationship)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityReference();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Creates a new instance of <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Attach : 'Entity -&gt; unit" Usage="entityReference.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">The object being attached.</param>
        <summary>Creates a many-to-one or one-to-one relationship between two objects in the object context.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.Objects.DataClasses.EntityReference%601.Attach%2A> est utilisée pour définir une relation entre un objet et un objet connexe lorsque les deux objets sont déjà attachés à un contexte d'objet. Définissez l'objet connexe à la propriété <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A> s'il n'est pas déjà attaché au contexte de l'objet. Lorsque les deux objets sont détachés, vous pouvez également définir la relation en définissant l'objet connexe à la propriété <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A>, puis en attachant l'objet racine dans le graphique d'objet. Pour plus d’informations, consultez [attachement et détachement des objets](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 L'objet associé à cet objet <xref:System.Data.Objects.DataClasses.EntityReference%601> et tous les objets qui y sont attachés doivent être à l'état <xref:System.Data.EntityState.Unchanged> ou <xref:System.Data.EntityState.Modified>.  
  
 Un objet à l'état <xref:System.Data.EntityState.Deleted> peut être attaché uniquement lorsque l'objet <xref:System.Data.Objects.ObjectStateManager> effectue déjà le suivi de l'instance de relation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">When the <paramref name="entity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">When the <paramref name="entity" /> cannot be related to the current related end. This can occur when the association in the conceptual schema does not support a relationship between the two types.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSourceQuery">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;TEntity&gt; CreateSourceQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!TEntity&gt; CreateSourceQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.CreateSourceQuery" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSourceQuery () As ObjectQuery(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;TEntity&gt; ^ CreateSourceQuery();" />
      <MemberSignature Language="F#" Value="override this.CreateSourceQuery : unit -&gt; System.Data.Objects.ObjectQuery&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityReference.CreateSourceQuery " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an equivalent object query that returns the related object.</summary>
        <returns>An <see cref="T:System.Data.Objects.ObjectQuery`1" /> that returns the related object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d'obtenir une nouvelle instance de <xref:System.Data.Objects.ObjectQuery%601> qui, lorsqu'elle est exécutée, retourne l'objet connexe. Ceci est utile comme point de départ pour une jointure, union ou requête filtrée plus complexe, ou pour retourner l'objet référencé dans un état détaché à l'aide de l'option <xref:System.Data.Objects.MergeOption.NoTracking>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">When the object is in an <see cref="F:System.Data.EntityState.Added" /> state.  -or-  When the object is in a <see cref="F:System.Data.EntityState.Detached" /> state with a <see cref="P:System.Data.Objects.ObjectQuery.MergeOption" /> other than <see cref="F:System.Data.Objects.MergeOption.NoTracking" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.Load(System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="override this.Load : System.Data.Objects.MergeOption -&gt; unit" Usage="entityReference.Load mergeOption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="mergeOption">Specifies how the object should be returned if it already exists in the <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Loads the related object for this <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" /> with the specified merge option.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour charger l'objet connexe.  
  
 Une fois chargé, l'objet connexe est accessible à partir de la propriété <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A>.  
  
 Pour charger explicitement des objets connexes, vous devez appeler la méthode `Load` sur la terminaison connexe retournée par la propriété de navigation. Dans le cas d'une relation un-à-plusieurs, appelez la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> sur <xref:System.Data.Objects.DataClasses.EntityCollection%601> ; dans le cas d'une relation un-à-un, appelez la méthode <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> sur <xref:System.Data.Objects.DataClasses.EntityReference%601>. Cela charge les données d'objets connexes dans le contexte d'objet. Lorsqu’une requête retourne des résultats, vous pouvez énumérer la collection d’objets à l’aide un `foreach` boucle (`For Each...Next` en Visual Basic) et appeler de manière conditionnelle la `Load` méthode sur <xref:System.Data.Objects.DataClasses.EntityReference%601> et <xref:System.Data.Objects.DataClasses.EntityCollection%601> propriétés pour chaque entité dans les résultats.  
  
 Le <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> méthode charge des objets connexes à partir de la source de données ou non <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> est `true`.  
  
> [!NOTE]
>  Lorsque vous appelez la méthode <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> lors d'une énumération `foreach` (C#) ou `For Each` (Visual Basic), Object Services essaie d'ouvrir un nouveau lecteur de données. Cette opération échoue sauf si vous avez activé des ensembles de résultats actifs multiples (MARS) en spécifiant `multipleactiveresultsets=true` dans la chaîne de connexion. Vous pouvez également charger le résultat de la requête dans une collection <xref:System.Collections.Generic.List%601>. Cela ferme le lecteur de données et vous permet d’énumérer la collection pour charger des objets référencés.  
 
Cette méthode appelle en interne `RelatedEnd.ValidateLoad` méthode avant de charger l’objet connexe, qui valide le fait qu’un appel à <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> a les conditions correctes. Le `RelatedEnd.ValidateLoad` méthode vérifie que :

* Valide <xref:System.Data.Objects.ObjectContext> existe.
* L’entité n’est pas dans un <xref:System.Data.EntityState.Deleted> état.
* <xref:System.Data.Objects.MergeOption> pour <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> doit être <xref:System.Data.Objects.MergeOption.NoTracking> si et seulement si l’entité source a été <xref:System.Data.Objects.MergeOption.NoTracking>. Si l’entité source a été récupérée avec n’importe quel autre <xref:System.Data.Objects.MergeOption>, le <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> <xref:System.Data.Objects.MergeOption> peut être tout sauf <xref:System.Data.Objects.MergeOption.NoTracking> (par exemple, l’entité ont pu été chargée avec <xref:System.Data.Objects.MergeOption.OverwriteChanges> et le <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> option puisse être <xref:System.Data.Objects.MergeOption.AppendOnly>).
* Si `mergeOption` est <xref:System.Data.Objects.MergeOption.NoTracking>, <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> n’est pas appelée sur une entité déjà chargée et <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> n’est pas appelée sur un non vide, suivies de non <xref:System.Data.Objects.DataClasses.RelatedEnd>.

 Lorsque l’objet connexe est déjà chargé dans le <xref:System.Data.Objects.ObjectContext>, le <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> méthode impose le <xref:System.Data.Objects.MergeOption> spécifié par le `mergeOption` paramètre. Pour plus d’informations, consultez [résolution d’identité, la gestion de l’état et le suivi des modifications](http://msdn.microsoft.com/library/3bd49311-0e72-4ea4-8355-38fe57036ba0).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The source of the <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" /> is <see langword="null" />.  -or-  A query returned more than one related end.  -or-  A query returned zero related ends, and one related end was expected.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnRefDeserialized">
      <MemberSignature Language="C#" Value="public void OnRefDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnRefDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.OnRefDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnRefDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnRefDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnRefDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityReference.OnRefDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">The serialized stream.</param>
        <summary>This method is used internally to serialize related entity objects.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSerializing">
      <MemberSignature Language="C#" Value="public void OnSerializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnSerializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityReference`1.OnSerializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnSerializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnSerializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnSerializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityReference.OnSerializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnSerializing</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">The serialized stream.</param>
        <summary>This method is used internally to serialize related entity objects.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public TEntity Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TEntity Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityReference`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public Property Value As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TEntity Value { TEntity get(); void set(TEntity value); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'Entity with get, set" Usage="System.Data.Objects.DataClasses.EntityReference&lt;'Entity (requires 'Entity : null)&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Xml.Serialization.SoapIgnore</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Xml.Serialization.XmlIgnore</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the related object returned by this <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" />.</summary>
        <value>Objet retourné par cet objet <see cref="T:System.Data.Objects.DataClasses.EntityReference`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucune valeur n'est assignée si la valeur qui est définie est identique à la valeur actuelle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>