<Type Name="WindowsPrincipal" FullName="System.Security.Principal.WindowsPrincipal">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6f2b067005e56e12a01c0f99fc6ba3158cfeae33" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53458835" /></Metadata><TypeSignature Language="C#" Value="public class WindowsPrincipal : System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WindowsPrincipal extends System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="DocId" Value="T:System.Security.Principal.WindowsPrincipal" />
  <TypeSignature Language="VB.NET" Value="Public Class WindowsPrincipal&#xA;Inherits ClaimsPrincipal" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsPrincipal : System::Security::Claims::ClaimsPrincipal" />
  <TypeSignature Language="F#" Value="type WindowsPrincipal = class&#xA;    inherit ClaimsPrincipal" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Principal.Windows</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Claims.ClaimsPrincipal</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permet au code de vérifier l'appartenance à un groupe Windows d'un utilisateur Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.Principal.WindowsPrincipal> classe est principalement utilisée pour vérifier le rôle d’un utilisateur Windows. Le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> surcharges de méthode vous permettent de vérifier le rôle d’utilisateur à l’aide de différents contextes de rôle.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> surcharges de méthode. Le <xref:System.Security.Principal.WindowsBuiltInRole> énumération est utilisée comme source pour les identificateurs relatifs (RID) qui identifient les rôles intégrés. Les RID servent à déterminer les rôles du principal actuel.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsPrincipal (System.Security.Principal.WindowsIdentity ntIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.WindowsIdentity ntIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.#ctor(System.Security.Principal.WindowsIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ntIdentity As WindowsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsPrincipal(System::Security::Principal::WindowsIdentity ^ ntIdentity);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsPrincipal : System.Security.Principal.WindowsIdentity -&gt; System.Security.Principal.WindowsPrincipal" Usage="new System.Security.Principal.WindowsPrincipal ntIdentity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ntIdentity" Type="System.Security.Principal.WindowsIdentity" />
      </Parameters>
      <Docs>
        <param name="ntIdentity">Objet à partir duquel la nouvelle instance de <see cref="T:System.Security.Principal.WindowsPrincipal" /> doit être créée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Principal.WindowsPrincipal" /> à l'aide de l'objet <see cref="T:System.Security.Principal.WindowsIdentity" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Security.Principal.WindowsPrincipal> objet à partir du <xref:System.Security.Principal.WindowsIdentity> objet.  
  
 [!code-cpp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ntIdentity" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeviceClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; DeviceClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; DeviceClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeviceClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ DeviceClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__13))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__10))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient toutes les revendications de périphérique Windows à partir de cette entité.</summary>
        <value>Collection de toutes les revendications de périphériques Windows à partir de cette entité de sécurité.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public override System.Security.Principal.IIdentity Identity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity Identity" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Identity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ Identity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Identity : System.Security.Principal.IIdentity" Usage="System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identité de l'objet Principal actuel.</summary>
        <value>Objet <see cref="T:System.Security.Principal.WindowsIdentity" /> de l'entité de sécurité actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant récupère le nom de l’utilisateur à l’aide de la <xref:System.Security.Principal.WindowsPrincipal.Identity%2A> propriété de la <xref:System.Security.Principal.WindowsPrincipal> objet.  
  
 [!code-cpp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsInRole">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si l'objet Principal actuel appartient au groupe d'utilisateurs Windows spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il existe quatre surcharges pour cette méthode. Pour des raisons de performances, le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> surcharge est fortement recommandée.  
  
> [!IMPORTANT]
>  Le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthode n’est pas prise en charge sur Windows 98 ou Windows Millennium Edition.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (int rid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(int32 rid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (rid As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(int rid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : int -&gt; bool" Usage="windowsPrincipal.IsInRole rid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rid">RID du groupe d’utilisateurs Windows dans lequel rechercher l’état d’appartenance du principal.</param>
        <summary>Détermine si l'objet Principal actuel appartient au groupe d'utilisateurs Windows avec l'identificateur relatif (RID, Relative Identifier) spécifié.</summary>
        <returns><see langword="true" /> si l'entité de sécurité actuelle est membre du groupe d'utilisateurs Windows spécifié, autrement dit s'il appartient à un rôle particulier ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous testez pour des informations de rôle nouvellement créé, par exemple un nouvel utilisateur ou un nouveau groupe, il est important de se déconnecter et se connecter à forcer la propagation des informations de rôle au sein du domaine. Ne pas cela pourrait provoquer le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test doit retourner `false`. Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.  
  
 Pour des raisons de performances, le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> surcharge est recommandée comme surcharge préférable pour déterminer le rôle de l’utilisateur.  
  
> [!NOTE]
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Lorsque vous tentez d’effectuer une tâche qui nécessite des privilèges d’administrateur, vous pouvez élever dynamiquement votre rôle à l’aide de la boîte de dialogue de consentement. Le code qui exécute le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> (méthode) n’affiche pas la boîte de dialogue de consentement. Le code retourne la valeur false si vous êtes dans le rôle d’utilisateur standard, même si vous êtes dans le groupe Administrateurs intégré. Vous pouvez élever vos privilèges avant d’exécuter le code en double-cliquant sur l’icône d’application et en indiquant que vous souhaitez exécuter en tant qu’administrateur.  
  
 Identificateurs relatifs (RID) sont des composants de l’identificateur de sécurité d’un groupe d’utilisateurs Windows (SID) et sont prises en charge pour éviter les problèmes de localisation interplateforme. Plusieurs comptes d’utilisateur, les groupes locaux et les groupes globaux ont une valeur RID par défaut qui est une constante dans toutes les versions de Windows.  
  
 Par exemple, le RID du rôle BUILTIN\Administrators est 0 x 220. À l’aide de 0x220 comme paramètre d’entrée pour le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthode `true` est retourné si l’objet principal actuel est un administrateur.  
  
 Les tableaux suivants répertorient les valeurs RID par défaut.  
  
|Utilisateurs intégrés|RID|  
|---------------------|---------|  
|DOMAINNAME\Administrator|0x1F4|  
|DOMAINNAME\Guest|0x1F5|  
  
|Groupes globaux intégrés|RID|  
|-----------------------------|---------|  
|Administrateurs DOMAINNAME\Domain|0 x 200|  
|Utilisateurs DOMAINNAME\Domain|0x201|  
|DOMAINNAME\Domain invités|0x202|  
  
|Groupes locaux intégrés|RID|  
|----------------------------|---------|  
|BUILTIN\Administrateurs|0x220|  
|BUILTIN\Users|0x221|  
|BUILTIN\Guests|0x222|  
|Opérateurs d’ACE|0x224|  
|Builtin\opérateurs de serveur|0x225|  
|Opérateurs de BUILTIN\Print|0x226|  
|Builtin\opérateurs de sauvegarde|0x227|  
|BUILTIN\Replicator|0x228|  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthodes. Le <xref:System.Security.Principal.WindowsBuiltInRole> énumération est utilisée comme source pour les RID qui identifient les rôles intégrés. Les RID servent à déterminer les rôles du principal actuel.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.SecurityIdentifier sid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(class System.Security.Principal.SecurityIdentifier sid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.SecurityIdentifier)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (sid As SecurityIdentifier) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::SecurityIdentifier ^ sid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.SecurityIdentifier -&gt; bool" Usage="windowsPrincipal.IsInRole sid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sid" Type="System.Security.Principal.SecurityIdentifier" />
      </Parameters>
      <Docs>
        <param name="sid"><see cref="T:System.Security.Principal.SecurityIdentifier" /> qui identifie de manière unique un groupe d'utilisateurs Windows.</param>
        <summary>Détermine si l'objet Principal actuel appartient au groupe d'utilisateurs Windows avec l'identificateur de sécurité (SID) spécifié.</summary>
        <returns><see langword="true" /> si l'objet Principal actuel est membre du groupe d'utilisateurs Windows spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.Principal.SecurityIdentifier> identifie de façon unique un utilisateur ou groupe sur les implémentations de Windows 2000, Windows Server et Windows XP. Lorsque vous testez pour des informations de rôle nouvellement créé, par exemple un nouvel utilisateur ou un nouveau groupe, il est important de se déconnecter et se connecter à forcer la propagation des informations de rôle au sein du domaine. Ne pas cela pourrait provoquer le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test doit retourner `false`. Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.  
  
> [!NOTE]
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Lorsque vous tentez d’effectuer une tâche qui nécessite des privilèges d’administrateur, vous pouvez élever dynamiquement votre rôle à l’aide de la boîte de dialogue de consentement. Le code qui exécute le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> (méthode) n’affiche pas la boîte de dialogue de consentement. Le code retourne la valeur false si vous êtes dans le rôle d’utilisateur standard, même si vous êtes dans le groupe Administrateurs intégré. Vous pouvez élever vos privilèges avant d’exécuter le code en double-cliquant sur l’icône d’application et en indiquant que vous souhaitez exécuter en tant qu’administrateur.  
  
 Pour des raisons de performances, il s’agit de la surcharge préférable pour déterminer le rôle d’un utilisateur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29?displayProperty=nameWithType> (méthode). Le <xref:System.Security.Principal.WellKnownSidType.BuiltinAdministratorsSid> valeur d’énumération est utilisée pour déterminer si l’objet principal actuel est un administrateur. Pour l’exemple de code complet, consultez le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#5)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sid" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Windows a retourné une erreur Win32.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.WindowsBuiltInRole role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(valuetype System.Security.Principal.WindowsBuiltInRole role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.WindowsBuiltInRole)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (role As WindowsBuiltInRole) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::WindowsBuiltInRole role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.WindowsBuiltInRole -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.Security.Principal.WindowsBuiltInRole" />
      </Parameters>
      <Docs>
        <param name="role">Une des valeurs de <see cref="T:System.Security.Principal.WindowsBuiltInRole" />.</param>
        <summary>Détermine si l'objet Principal actuel appartient au groupe d'utilisateurs Windows avec le <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> spécifié.</summary>
        <returns><see langword="true" /> si l'objet Principal actuel est membre du groupe d'utilisateurs Windows spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous testez pour des informations de rôle nouvellement créé, par exemple un nouvel utilisateur ou un nouveau groupe, il est important de se déconnecter et se connecter à forcer la propagation des informations de rôle au sein du domaine. Ne pas cela pourrait provoquer le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test doit retourner `false`. Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.  
  
 Pour des raisons de performances, le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> surcharge est recommandée comme surcharge préférable pour déterminer le rôle de l’utilisateur.  
  
> [!NOTE]
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Lorsque vous tentez d’effectuer une tâche qui nécessite des privilèges d’administrateur, vous pouvez élever dynamiquement votre rôle à l’aide de la boîte de dialogue de consentement. Le code qui exécute le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> (méthode) n’affiche pas la boîte de dialogue de consentement. Le code retourne la valeur false si vous êtes dans le rôle d’utilisateur standard, même si vous êtes dans le groupe Administrateurs intégré. Vous pouvez élever vos privilèges avant d’exécuter le code en double-cliquant sur l’icône d’application et en indiquant que vous souhaitez exécuter en tant qu’administrateur.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Security.Principal.WindowsBuiltInRole> énumération est utilisée pour déterminer si l’objet principal actuel est un <xref:System.Security.Principal.WindowsBuiltInRole.Administrator>. Pour l’exemple de code complet, consultez le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#4)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="role" /> n’est pas une valeur de <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public override bool IsInRole (string role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsInRole(string role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsInRole (role As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsInRole(System::String ^ role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : string -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="role">Nom du groupe d'utilisateurs Windows pour lequel l'appartenance doit être vérifiée.</param>
        <summary>Détermine si l'objet Principal actuel appartient au groupe d'utilisateurs Windows avec le nom spécifié.</summary>
        <returns><see langword="true" /> si l'objet Principal actuel est membre du groupe d'utilisateurs Windows spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous testez pour des informations de rôle nouvellement créé, par exemple un nouvel utilisateur ou un nouveau groupe, il est important de se déconnecter et se connecter à forcer la propagation des informations de rôle au sein du domaine. Ne pas cela pourrait provoquer le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test doit retourner `false`. Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.  
  
 Pour des raisons de performances, le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> surcharge est recommandée comme surcharge préférable pour déterminer le rôle de l’utilisateur.  
  
> [!NOTE]
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Lorsque vous tentez d’effectuer une tâche qui nécessite des privilèges d’administrateur, vous pouvez élever dynamiquement votre rôle à l’aide de la boîte de dialogue de consentement. Le code qui exécute le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> (méthode) n’affiche pas la boîte de dialogue de consentement. Le code retourne la valeur false si vous êtes dans le rôle d’utilisateur standard, même si vous êtes dans le groupe Administrateurs intégré. Vous pouvez élever vos privilèges avant d’exécuter le code en double-cliquant sur l’icône d’application et en indiquant que vous souhaitez exécuter en tant qu’administrateur.  
  
 Pour les rôles intégrés, la `role` chaîne doit être sous la forme « BUILTIN\\*NomRôle*». Par exemple, pour tester l’appartenance au rôle d’administrateur Windows, la chaîne représentant le rôle doit être « BUILTIN\Administrators ». Notez que la barre oblique inverse peut doivent être échappés. Le tableau suivant répertorie les rôles intégrés.  
  
> [!NOTE]
>  L’orthographe des rôles BUILTIN dans le format de chaîne diffère de l’orthographe utilisée dans le <xref:System.Security.Principal.WindowsBuiltInRole> énumération. Par exemple, l’orthographe pour un administrateur dans l’énumération est « Administrateur », pas « administrateurs ». Lorsque vous utilisez cette surcharge, utilisez l’orthographe pour le rôle dans le tableau suivant.  
  
|Groupes locaux intégrés|  
|----------------------------|  
|BUILTIN\Administrateurs|  
|BUILTIN\Users|  
|BUILTIN\Guests|  
|Opérateurs d’ACE|  
|Builtin\opérateurs de serveur|  
|Opérateurs de BUILTIN\Print|  
|Builtin\opérateurs de sauvegarde|  
|BUILTIN\Replicator|  
  
 Pour les rôles spécifiques à l’ordinateur, le `role` chaîne doit être au format « NomOrdinateur\\*NomRôle*».  
  
 Pour les rôles spécifiques à un domaine, le `role` chaîne doit être sous la forme « DomainName\\*NomRôle*», par exemple, `"SomeDomain\Domain Users`».  
  
> [!NOTE]
>  Dans le .NET Framework version 1.0, la `role` paramètre respecte la casse. Dans le .NET Framework version 1.1 et ultérieure, le `role` paramètre respecte la casse.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> (méthode).  
  
 Les chaînes `BUILTIN\Administrators` et `BUILTIN\Users` servent à déterminer si l’objet principal actuel est un administrateur ou un utilisateur. Pour l’exemple de code complet, consultez le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#3)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la possibilité de manipuler l’objet principal. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
        <altmember cref="T:System.Security.Principal.WindowsBuiltInRole" />
      </Docs>
    </Member>
    <Member MemberName="UserClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; UserClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; UserClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UserClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ UserClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__11))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__8))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient toutes les revendications d'utilisateur Windows à partir de cette entité.</summary>
        <value>Collection de toutes les revendications d'utilisateurs Windows à partir de cette entité de sécurité.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>