<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2d2bcc9edb22ce616e169fae6c835a452b366252" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53301062" /></Metadata><TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="e3cee-101">Fournit la classe de base de laquelle les classes qui représentent des nœuds d'arborescence d'expression sont dérivées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-101">Provides the base class from which the classes that represent expression tree nodes are derived.</span></span> <span data-ttu-id="e3cee-102">Contient également des méthodes de fabrique <see langword="static" /> (<see langword="Shared" /> en Visual Basic) pour créer les divers types de nœuds.</span><span class="sxs-lookup"><span data-stu-id="e3cee-102">It also contains <see langword="static" /> (<see langword="Shared" /> in Visual Basic) factory methods to create the various node types.</span></span> <span data-ttu-id="e3cee-103">Il s'agit d'une classe <see langword="abstract" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-103">This is an <see langword="abstract" /> class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-104">L’exemple de code suivant montre comment créer une expression de bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-104">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="e3cee-105">L’expression de bloc se compose de deux <xref:System.Linq.Expressions.MethodCallExpression> objets et l’autre <xref:System.Linq.Expressions.ConstantExpression> objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-105">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-106">Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-106">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e3cee-107">Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-107">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType"><span data-ttu-id="e3cee-108"><see cref="T:System.Linq.Expressions.ExpressionType" /> à définir comme type de nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-108">The <see cref="T:System.Linq.Expressions.ExpressionType" /> to set as the node type.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-109"><see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-109">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="e3cee-110">Initialise une nouvelle instance de la classe <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-110">Initializes a new instance of the <see cref="T:System.Linq.Expressions.Expression" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-111">Ce constructeur est appelé à partir des constructeurs dans les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-111">This constructor is called from constructors in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="e3cee-112">Visiteur avec lequel visiter ce nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-112">The visitor to visit this node with.</span></span></param>
        <summary><span data-ttu-id="e3cee-113">Distribue à la méthode de visite spécifique à ce type de nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-113">Dispatches to the specific visit method for this node type.</span></span> <span data-ttu-id="e3cee-114">Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-114">For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-115">Résultat de la visite de ce nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-115">The result of visiting this node.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-116">Cette implémentation par défaut pour <xref:System.Linq.Expressions.ExpressionType.Extension> les appels de nœuds <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-116">This default implementation for <xref:System.Linq.Expressions.ExpressionType.Extension> nodes calls <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span> <span data-ttu-id="e3cee-117">Substituez cette méthode pour appeler une méthode plus spécifique sur une classe dérivée de visiteur de la <xref:System.Linq.Expressions.ExpressionVisitor> classe.</span><span class="sxs-lookup"><span data-stu-id="e3cee-117">Override this method to call into a more specific method on a derived visitor class of the <xref:System.Linq.Expressions.ExpressionVisitor> class.</span></span> <span data-ttu-id="e3cee-118">Toutefois, il doit toujours prendre en charge les visiteurs inconnus en appelant <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-118">However, it should still support unknown visitors by calling <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-119">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-119">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-120"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-120">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-121"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-121">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-122">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-122">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-123"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-124">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-124">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-125">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-125">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-126">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-126">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-127">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-127">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-128">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-128">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-129">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-129">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-130">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-130">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-131">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-131">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-132">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’addition, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-132">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-133">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-133">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-134">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-134">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-135">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-135">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-136">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-136">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-137">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-137">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-138">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-138">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-139">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-139">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-140">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-140">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-141">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-141">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-142">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-142">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-143">Le type du nœud est le type de résultat de l’opérateur d’addition prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-143">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="e3cee-144">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-144">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-145">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur d’addition prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-145">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-146">L’exemple de code suivant montre comment créer une expression qui ajoute deux entiers.</span><span class="sxs-lookup"><span data-stu-id="e3cee-146">The following code example shows how to create an expression that adds two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-147"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-147"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-148">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-148">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-149"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-149">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-150"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-150">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-151"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-151">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-152">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span> <span data-ttu-id="e3cee-153">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-153">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-154"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-155">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-155">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-156">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-156">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-157">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-157">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-158">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-158">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-159">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-159">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-160">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-160">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-161">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-161">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-162">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-162">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-163">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-163">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-164">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’addition, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-164">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-165">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-165">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-166">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-166">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-167">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-167">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-168">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-168">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-169">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-169">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-170">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-170">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-171">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-171">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-172">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-172">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-173">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-173">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-174">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-174">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-175">Le type du nœud est le type de résultat de l’opérateur d’addition prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-175">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="e3cee-176">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-176">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-177">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur d’addition prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-177">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-178"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-178"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-179"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-179"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-180"><paramref name="method" /> est <see langword="null" /> et l'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-180"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-181">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-181">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-182"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-182">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-183"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-183">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-184">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-184">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-185"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-186">L’exemple de code suivant montre comment créer une expression qui ajoute une valeur à une variable de type entier et puis assigne le résultat de l’opération à la variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-186">The following code example shows how to create an expression that adds a value to an integer variable and then assigns the result of the operation to the variable.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-187"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-187">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-188"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-188">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-189"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-189">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-190">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-190">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-191"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-192"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-192">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-193"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-193">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-194"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-194">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-195"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-196">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-197"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-198">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-198">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-199"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-199">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-200"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-200">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-201">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-202"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-203"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-204"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-205"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-205">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-206">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-207"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-208"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-209"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-210"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-211"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-212">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-212">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-213"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-214">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-214">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-215"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-215">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-216"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-216">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-217">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-218"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-219">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-219">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-220">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-220">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-221">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-221">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-222">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-222">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-223">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-223">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-224">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-224">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-225">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-225">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-226">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-226">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-227">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’addition, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-227">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-228">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-228">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-229">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-229">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-230">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-230">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-231">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-231">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-232">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-232">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-233">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-233">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-234">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-234">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-235">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-235">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-236">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-236">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-237">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-237">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-238">Le type du nœud est le type de résultat de l’opérateur d’addition prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-238">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="e3cee-239">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-239">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-240">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur d’addition prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-240">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-241"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-241"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-242">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-242">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-243"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-243">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-244"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-244">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-245"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-245">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-246">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-246">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span> <span data-ttu-id="e3cee-247">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-247">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-248"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-249">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-249">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-250">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-250">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-251">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-251">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-252">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-252">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-253">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-253">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-254">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-254">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-255">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-255">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-256">La méthode d’implémentation pour l’opération est choisie en fonction des règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="e3cee-256">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="e3cee-257">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-257">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-258">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’addition, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-258">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-259">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-259">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-260">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-260">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-261">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-261">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-262">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-262">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-263">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-263">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-264">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-264">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-265">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-265">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-266">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-266">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-267">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-267">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-268">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-268">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-269">Le type du nœud est le type de résultat de l’opérateur d’addition prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-269">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="e3cee-270">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-270">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-271">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur d’addition prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-271">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-272"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-272"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-273"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-273"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-274"><paramref name="method" /> est <see langword="null" /> et l'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-274"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-275">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-275">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-276"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-276">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-277"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-277">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-278">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-278">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-279"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-280">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-280">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-281">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-281">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-282">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-282">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-283">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-283">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-284">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-284">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-285">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-285">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-286">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-286">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-287">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-287">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-288">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `AND` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-288">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-289">Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-289">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-290">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-290">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-291">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-291">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-292">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-292">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-293">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-293">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-294">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-294">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-295">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-295">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-296">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-296">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-297">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-297">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-298">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-298">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-299">Le type du nœud est le type de résultat de prédéfinis au niveau du bit `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-299">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-300">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-300">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-301">Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis au niveau du bit `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-301">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-302">L’exemple de code suivant montre comment créer une expression qui représente une opération AND logique sur deux valeurs booléennes.</span><span class="sxs-lookup"><span data-stu-id="e3cee-302">The following code example shows how to create an expression that represents a logical AND operation on two Boolean values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-303"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-303"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-304">L'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-304">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-305"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-305">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-306"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-306">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-307"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-307">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-308">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-308">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span> <span data-ttu-id="e3cee-309">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-309">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-310"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-311">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-311">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-312">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-312">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-313">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-313">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-314">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-314">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-315">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-315">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-316">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-316">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-317">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-317">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-318">La méthode d’implémentation pour l’opération est choisie en fonction des règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="e3cee-318">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="e3cee-319">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-319">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-320">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `AND` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-320">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-321">Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-321">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-322">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-322">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-323">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-323">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-324">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-324">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-325">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-325">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-326">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-326">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-327">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-327">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-328">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-328">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-329">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-329">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-330">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-330">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-331">Le type du nœud est le type de résultat de prédéfinis au niveau du bit `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-331">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-332">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-332">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-333">Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis au niveau du bit `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-333">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-334"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-334"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-335"><paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-335"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-336"><paramref name="method" /> est <see langword="null" /> et l'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-336"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-337">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-337">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-338"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-338">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-339"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-339">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-340">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-340">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-341"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-342">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-342">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-343">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-343">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-344">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-344">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-345">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-345">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-346">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-346">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-347">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-347">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-348">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-348">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-349">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-349">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-350">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `AND` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-350">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="e3cee-351">L’instruction conditionnelle `AND` opérateur ne peut pas être surchargé en c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e3cee-351">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="e3cee-352">Toutefois, l’instruction conditionnelle `AND` opérateur est évalué à l’aide de l’opérateur de bits `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-352">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="e3cee-353">Par conséquent, une surcharge définie par l’utilisateur de l’opérateur de bits `AND` opérateur peut être la méthode d’implémentation pour ce type de nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-353">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="e3cee-354">Sinon, si `left`. Type et `right`. Type sont des types booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-354">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-355">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-355">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-356">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-356">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-357">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-357">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-358">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-358">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-359">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-359">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-360">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable, et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-360">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-361">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-361">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-362">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-362">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-363">`left`. Type et `right`. Type sont du même type booléen.</span><span class="sxs-lookup"><span data-stu-id="e3cee-363">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="e3cee-364">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-364">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-365">Le type du nœud est le type de résultat de l’instruction conditionnelle prédéfini `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-365">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-366">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-366">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-367">Le type du nœud est le type nullable qui correspond au type de résultat de l’instruction conditionnelle prédéfini `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-367">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-368">L’exemple de code suivant montre comment créer une expression qui effectue un opérateur logique et opération sur ses deux opérandes uniquement si le premier opérande prend la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-368">The following code example shows how to create an expression that performs a logical AND operation on its two operands only if the first operand evaluates to `true`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-369"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-369"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-370">L'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-370">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-371">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-371">-or-</span></span> 
 <span data-ttu-id="e3cee-372"><paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</span><span class="sxs-lookup"><span data-stu-id="e3cee-372"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-373"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-373">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-374"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-374">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-375"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-375">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-376">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true.</span><span class="sxs-lookup"><span data-stu-id="e3cee-376">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand is resolved to true.</span></span> <span data-ttu-id="e3cee-377">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-377">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-378"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-379">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-379">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-380">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-380">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-381">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-381">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-382">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-382">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-383">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-383">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-384">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-384">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-385">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-385">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-386">La méthode d’implémentation pour l’opération est choisie en fonction des règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="e3cee-386">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="e3cee-387">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-387">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-388">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `AND` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-388">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="e3cee-389">L’instruction conditionnelle `AND` opérateur ne peut pas être surchargé en c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e3cee-389">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="e3cee-390">Toutefois, l’instruction conditionnelle `AND` opérateur est évalué à l’aide de l’opérateur de bits `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-390">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="e3cee-391">Par conséquent, une surcharge définie par l’utilisateur de l’opérateur de bits `AND` opérateur peut être la méthode d’implémentation pour ce type de nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-391">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="e3cee-392">Sinon, si `left`. Type et `right`. Type sont des types booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-392">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-393">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-393">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-394">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-394">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-395">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-395">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-396">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-396">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-397">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-397">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-398">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable, et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-398">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-399">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-399">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-400">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-400">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-401">`left`. Type et `right`. Type sont du même type booléen.</span><span class="sxs-lookup"><span data-stu-id="e3cee-401">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="e3cee-402">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-402">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-403">Le type du nœud est le type de résultat de l’instruction conditionnelle prédéfini `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-403">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-404">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-404">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-405">Le type du nœud est le type nullable qui correspond au type de résultat de l’instruction conditionnelle prédéfini `AND` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-405">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-406"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-406"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-407"><paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-407"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-408"><paramref name="method" /> est <see langword="null" /> et l'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-408"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-409">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-409">-or-</span></span> 
 <span data-ttu-id="e3cee-410"><paramref name="method" /> est <see langword="null" /> et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</span><span class="sxs-lookup"><span data-stu-id="e3cee-410"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-411">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-411">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-412"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-412">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-413"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-413">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-414">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-414">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-415"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-416"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-416">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-417"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-417">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-418"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-418">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-419">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-420"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-421"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-422"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-423"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-423">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-424"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-425">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-426"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-427">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-427">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="e3cee-428">Expression qui représente le tableau multidimensionnel.</span><span class="sxs-lookup"><span data-stu-id="e3cee-428">An expression that represents the multidimensional array.</span></span></param>
        <param name="indexes"><span data-ttu-id="e3cee-429"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des expressions utilisées pour indexer le tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-429">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="e3cee-430">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau multidimensionnel.</span><span class="sxs-lookup"><span data-stu-id="e3cee-430">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="e3cee-431">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-431">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-432">L’expression qui représente le tableau peut être obtenue à l’aide de la <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> (méthode), ou via <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-432">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-433">L’exemple de code suivant montre comment modifier la valeur d’un élément dans un tableau multidimensionnel à l’aide de la `ArrayAccess` (méthode).</span><span class="sxs-lookup"><span data-stu-id="e3cee-433">The following code example shows how to change the value of an element in a multidimensional array by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="e3cee-434">Expression qui représente le tableau à indexer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-434">An expression representing the array to index.</span></span></param>
        <param name="indexes"><span data-ttu-id="e3cee-435">Tableau qui contient des expressions utilisées pour indexer le tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-435">An array that contains expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="e3cee-436">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-436">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
        <returns><span data-ttu-id="e3cee-437">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-437">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-438">L’expression qui représente le tableau peut être obtenue à l’aide de la <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> (méthode), ou via <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-438">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
 <span data-ttu-id="e3cee-439">Pour les tableaux multidimensionnels, utilisez la <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="e3cee-439">For multidimensional arrays, use the <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-440">L’exemple de code suivant montre comment modifier une valeur d’un élément de tableau à l’aide de la `ArrayAccess` (méthode).</span><span class="sxs-lookup"><span data-stu-id="e3cee-440">The following code example shows how to change a value of an array element by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-441">Crée un <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'application d'un opérateur index de tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-441">Creates an <see cref="T:System.Linq.Expressions.Expression" /> that represents applying an array index operator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="e3cee-442"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-442">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to.</span></span></param>
        <param name="indexes"><span data-ttu-id="e3cee-443"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-443">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-444">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang supérieur à un.</span><span class="sxs-lookup"><span data-stu-id="e3cee-444">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to an array of rank more than one.</span></span></summary>
        <returns><span data-ttu-id="e3cee-445"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-446">Chaque élément de `indexes` doit avoir <xref:System.Linq.Expressions.Expression.Type%2A> égal à <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-446">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="e3cee-447">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array` doit représenter un type de tableau dont le rang correspond au nombre d’éléments dans `indexes`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-447">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="e3cee-448">Si le rang de `array`. Le type est 1, cette méthode retourne un <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-448">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="e3cee-449">Le <xref:System.Linq.Expressions.BinaryExpression.Left%2A> propriété est définie sur `array` et <xref:System.Linq.Expressions.BinaryExpression.Right%2A> propriété est définie sur l’élément unique de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-449">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="e3cee-450">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de la <xref:System.Linq.Expressions.BinaryExpression> représente le type d’élément de `array`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-450">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="e3cee-451">Si le rang de `array`. Type plusieurs fois, cette méthode retourne un <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-451">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="e3cee-452">Le <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> propriété est définie sur le <xref:System.Reflection.MethodInfo> qui décrit la méthode d’instance publique `Get` sur le type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-452">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-453">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’indexation dans un tableau à deux dimensions.</span><span class="sxs-lookup"><span data-stu-id="e3cee-453">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-454"><paramref name="array" /> ou <paramref name="indexes" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-454"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-455"><paramref name="array" />.Type ne représente pas un type de tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-455"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="e3cee-456">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-456">-or-</span></span> 
<span data-ttu-id="e3cee-457">Le rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-457">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
<span data-ttu-id="e3cee-458">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-458">-or-</span></span> 
<span data-ttu-id="e3cee-459">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-459">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="e3cee-460"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-460">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="index"><span data-ttu-id="e3cee-461"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-461">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-462">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang un.</span><span class="sxs-lookup"><span data-stu-id="e3cee-462">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents applying an array index operator to an array of rank one.</span></span></summary>
        <returns><span data-ttu-id="e3cee-463"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-464">`index` doit représenter un index de type <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-464">`index` must represent an index of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="e3cee-465">Le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.BinaryExpression> est `null`, alors que les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sont définies sur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-465">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null`, and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="e3cee-466">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est égale au type d’élément de `array`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-466">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the element type of `array`.Type.</span></span> <span data-ttu-id="e3cee-467">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-467">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-468"><paramref name="array" /> ou <paramref name="index" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-468"><paramref name="array" /> or <paramref name="index" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-469"><paramref name="array" />.Type ne représente pas un type de tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-469"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="e3cee-470">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-470">-or-</span></span> 
 <span data-ttu-id="e3cee-471"><paramref name="array" />.Type représente un type de tableau dont le rang n'est pas 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-471"><paramref name="array" />.Type represents an array type whose rank is not 1.</span></span>  
  
<span data-ttu-id="e3cee-472">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-472">-or-</span></span> 
 <span data-ttu-id="e3cee-473"><paramref name="index" />.Type ne représente pas le type <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-473"><paramref name="index" />.Type does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="e3cee-474">Tableau d'instances <see cref="T:System.Linq.Expressions.Expression" />, index pour l'opération d'indexation de tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-474">An array of <see cref="T:System.Linq.Expressions.Expression" /> instances - indexes for the array index operation.</span></span></param>
        <param name="indexes"><span data-ttu-id="e3cee-475">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-475">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-476">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur d'index de tableau à un tableau multidimensionnel.</span><span class="sxs-lookup"><span data-stu-id="e3cee-476">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="e3cee-477"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-478">Chaque élément de `indexes` doit avoir <xref:System.Linq.Expressions.Expression.Type%2A> égal à <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-478">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="e3cee-479">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array` doit représenter un type de tableau dont le rang correspond au nombre d’éléments dans `indexes`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-479">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="e3cee-480">Si le rang de `array`. Le type est 1, cette méthode retourne un <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-480">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="e3cee-481">Le <xref:System.Linq.Expressions.BinaryExpression.Left%2A> propriété est définie sur `array` et <xref:System.Linq.Expressions.BinaryExpression.Right%2A> propriété est définie sur l’élément unique de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-481">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="e3cee-482">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de la <xref:System.Linq.Expressions.BinaryExpression> représente le type d’élément de `array`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-482">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="e3cee-483">Si le rang de `array`. Type plusieurs fois, cette méthode retourne un <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-483">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="e3cee-484">Le <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> propriété est définie sur le <xref:System.Reflection.MethodInfo> qui décrit la méthode d’instance publique `Get` sur le type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-484">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-485">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’indexation dans un tableau à deux dimensions.</span><span class="sxs-lookup"><span data-stu-id="e3cee-485">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-486"><paramref name="array" /> ou <paramref name="indexes" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-486"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-487"><paramref name="array" />.Type ne représente pas un type de tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-487"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="e3cee-488">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-488">-or-</span></span> 
<span data-ttu-id="e3cee-489">Le rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-489">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
<span data-ttu-id="e3cee-490">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-490">-or-</span></span> 
<span data-ttu-id="e3cee-491">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-491">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="e3cee-492"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-492">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-493">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression permettant d'obtenir la longueur d'un tableau unidimensionnel.</span><span class="sxs-lookup"><span data-stu-id="e3cee-493">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression for obtaining the length of a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="e3cee-494"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> et la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> égale à <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-495">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array` doit représenter un type tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-495">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type.</span></span>  
  
 <span data-ttu-id="e3cee-496">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est égal à <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-496">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is equal to <xref:System.Int32>.</span></span> <span data-ttu-id="e3cee-497">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété est `null`, alors que les <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> sont définies sur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-497">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`, and both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-498"><paramref name="array" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-498"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-499"><paramref name="array" />.Type ne représente pas un type de tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-499"><paramref name="array" />.Type does not represent an array type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-500"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-501"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-502">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-502">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-503"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-504">Le `Assign` expression copie une valeur pour les types valeur, et copie une référence pour les types référence.</span><span class="sxs-lookup"><span data-stu-id="e3cee-504">The `Assign` expression copies a value for value types, and it copies a reference for reference types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-505">L’exemple de code suivant montre comment créer une expression qui représente une opération d’assignation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-505">The following code example shows how to create an expression that represents an assignment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-506">Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un membre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-506">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="e3cee-507"><see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-507">A <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="expression"><span data-ttu-id="e3cee-508"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-509">Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un champ ou d'une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-509">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a field or property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-510"><see cref="T:System.Linq.Expressions.MemberAssignment" /> dont <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-511">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `expression` doit pouvoir être assigné au type représenté par le <xref:System.Reflection.FieldInfo.FieldType%2A> ou <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété du `member`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-511">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.FieldInfo.FieldType%2A> or <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of `member`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-512"><paramref name="member" /> ou <paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-512"><paramref name="member" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-513"><paramref name="member" /> ne représente pas un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-513"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="e3cee-514">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-514">-or-</span></span> 
<span data-ttu-id="e3cee-515">La propriété représentée par <paramref name="member" /> n'a pas d'accesseur <see langword="set" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-515">The property represented by <paramref name="member" /> does not have a <see langword="set" /> accessor.</span></span>  
  
<span data-ttu-id="e3cee-516">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-516">-or-</span></span> 
 <span data-ttu-id="e3cee-517"><paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-517"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="e3cee-518"><see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-518">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="expression"><span data-ttu-id="e3cee-519"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-520">Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un membre à l'aide d'une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-520">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-521"><see cref="T:System.Linq.Expressions.MemberAssignment" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> a la valeur <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property set to <paramref name="expression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-522">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `expression` doit pouvoir être assigné au type représenté par le <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété de la propriété accédée dans `propertyAccessor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-522">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the property accessed in `propertyAccessor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-523"><paramref name="propertyAccessor" /> ou <paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-523"><paramref name="propertyAccessor" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-524"><paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-524"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="e3cee-525">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-525">-or-</span></span> 
<span data-ttu-id="e3cee-526">La propriété à laquelle <paramref name="propertyAccessor" /> accède n’a pas d’accesseur <see langword="set" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-526">The property accessed by <paramref name="propertyAccessor" /> does not have a <see langword="set" /> accessor.</span></span>  
  
<span data-ttu-id="e3cee-527">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-527">-or-</span></span> 
 <span data-ttu-id="e3cee-528"><paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-528"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-529">Crée une <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-529">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="e3cee-530">Expressions contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-530">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-531">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-531">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="e3cee-532">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-532">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-533">Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-533">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="e3cee-534">Expressions contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-534">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-535">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-535">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="e3cee-536">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-536">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-537">Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-537">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-538">L’exemple de code suivant montre comment créer une expression de bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-538">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="e3cee-539">L’expression de bloc se compose de deux <xref:System.Linq.Expressions.MethodCallExpression> objets et l’autre <xref:System.Linq.Expressions.ConstantExpression> objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-539">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="e3cee-540">Variables contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-540">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="e3cee-541">Expressions contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-541">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-542">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</span><span class="sxs-lookup"><span data-stu-id="e3cee-542">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="e3cee-543">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-543">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-544">Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-544">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-545">L’exemple de code suivant montre comment passer un paramètre à une expression de bloc et de traiter ce paramètre dans un bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-545">The following code example shows how to pass a parameter to a block expression and process this parameter within a block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="e3cee-546">Variables contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-546">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="e3cee-547">Expressions contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-547">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-548">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</span><span class="sxs-lookup"><span data-stu-id="e3cee-548">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="e3cee-549">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-549">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-550">Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-550">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="e3cee-551">Première expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-551">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-552">Deuxième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-552">The second expression in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-553">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-553">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains two expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="e3cee-554">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-554">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-555">Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-555">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-556">Type de résultat du bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-556">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="e3cee-557">Expressions contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-557">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-558">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-558">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-559">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-559">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-560">Type de résultat du bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-560">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="e3cee-561">Expressions contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-561">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-562">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-562">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-563">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-563">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="e3cee-564">Première expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-564">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-565">Deuxième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-565">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-566">Troisième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-566">The third expression in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-567">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient trois expressions et aucune variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-567">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains three expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="e3cee-568">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-568">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-569">Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-569">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-570">Type de résultat du bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-570">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="e3cee-571">Variables contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-571">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="e3cee-572">Expressions contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-572">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-573">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</span><span class="sxs-lookup"><span data-stu-id="e3cee-573">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="e3cee-574">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-574">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-575">Type de résultat du bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-575">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="e3cee-576">Variables contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-576">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="e3cee-577">Expressions contenues dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-577">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-578">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</span><span class="sxs-lookup"><span data-stu-id="e3cee-578">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="e3cee-579">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-579">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="e3cee-580">Première expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-580">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-581">Deuxième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-581">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-582">Troisième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-582">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="e3cee-583">Quatrième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-583">The fourth expression in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-584">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient quatre expressions et aucune variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-584">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains four expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="e3cee-585">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-585">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-586">Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-586">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="e3cee-587">Première expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-587">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-588">Deuxième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-588">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-589">Troisième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-589">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="e3cee-590">Quatrième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-590">The fourth expression in the block.</span></span></param>
        <param name="arg4"><span data-ttu-id="e3cee-591">Cinquième expression contenue dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-591">The fifth expression in the block.</span></span></param>
        <summary><span data-ttu-id="e3cee-592">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient cinq expressions et aucune variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-592">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains five expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="e3cee-593">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-593">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-594">Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-594">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-595">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</span><span class="sxs-lookup"><span data-stu-id="e3cee-595">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-596"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-596">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="e3cee-597">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</span><span class="sxs-lookup"><span data-stu-id="e3cee-597">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-598"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-599">L’exemple suivant montre comment créer une expression qui contienne un <xref:System.Linq.Expressions.LoopExpression> objet qui utilise le <xref:System.Linq.Expressions.Expression.Break%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="e3cee-599">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LoopExpression> object that uses the <xref:System.Linq.Expressions.Expression.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-600"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-600">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="e3cee-601">Valeur qui sera passée à l'étiquette associée au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-601">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="e3cee-602">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</span><span class="sxs-lookup"><span data-stu-id="e3cee-602">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span> <span data-ttu-id="e3cee-603">La valeur passée à l'étiquette au moment du saut peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-603">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-604"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-605"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-605">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-606"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-606">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-607">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-607">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-608"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-609"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-609">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="e3cee-610">Valeur qui sera passée à l'étiquette associée au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-610">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-611"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-611">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-612">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-612">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span> <span data-ttu-id="e3cee-613">La valeur passée à l'étiquette au moment du saut peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-613">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-614"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-615">Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-615">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-616"><see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e3cee-616">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-617"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-617">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-618">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui ne prend pas d'arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-618">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-619"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-620">Pour représenter un appel à une `static` (`Shared` en Visual Basic) (méthode), passez `null` pour le `instance` paramètre lorsque vous appelez cette méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-620">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method.</span></span>  
  
 <span data-ttu-id="e3cee-621">Si `method` représente une méthode d’instance, le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `instance` doit pouvoir être assigné au type de déclaration de la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-621">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="e3cee-622">Le <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-622">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty.</span></span> <span data-ttu-id="e3cee-623">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est égale au type de retour de la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-623">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the return type of the method represented by `method`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-624">L’exemple de code suivant montre comment créer une expression qui appelle une méthode sans arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-624">The following code example shows how to create an expression that calls a method without arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-625"><paramref name="method" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-625"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-626">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-626">-or-</span></span> 
 <span data-ttu-id="e3cee-627"><paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d'instance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-627"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-628"><paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-628"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="e3cee-629"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</span><span class="sxs-lookup"><span data-stu-id="e3cee-629">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-630">Collection de <see cref="T:System.Linq.Expressions.Expression" /> qui représente les arguments de l'appel.</span><span class="sxs-lookup"><span data-stu-id="e3cee-630">A collection of <see cref="T:System.Linq.Expressions.Expression" /> that represents the call arguments.</span></span></param>
        <summary><span data-ttu-id="e3cee-631">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique (méthode partagée en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e3cee-631">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static (Shared in Visual Basic) method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-632"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="e3cee-633"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-633">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-634"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-634">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <summary><span data-ttu-id="e3cee-635">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) comportant un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-635">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that takes one argument.</span></span></summary>
        <returns><span data-ttu-id="e3cee-636"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-637">L’exemple suivant montre comment créer une expression qui appelle un `static` (`Shared` en Visual Basic) méthode qui prend un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-637">The following example demonstrates how to create an expression that calls a `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-638"><paramref name="method" /> a la valeur null.</span><span class="sxs-lookup"><span data-stu-id="e3cee-638"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="e3cee-639"><see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-639">A <see cref="T:System.Reflection.MethodInfo" /> that represents a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-640">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-640">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-641">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) comportant des arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-641">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that has arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-642"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-643">Si `arguments` n’est pas `null`, il doit avoir le même nombre d’éléments que le nombre de paramètres pour la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-643">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="e3cee-644">Chaque élément dans `arguments` ne doit pas être `null` et doit être assignable au paramètre correspondant de `method`, éventuellement après *mise entre guillemets*.</span><span class="sxs-lookup"><span data-stu-id="e3cee-644">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3cee-645">Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-645">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="e3cee-646">Citation signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-646">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="e3cee-647">Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-647">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="e3cee-648">Le <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est vide si `arguments` est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-648">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="e3cee-649">Sinon, elle contient les mêmes éléments que `arguments`, certains d'entre eux peuvent être mise entre guillemets.</span><span class="sxs-lookup"><span data-stu-id="e3cee-649">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="e3cee-650">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-650">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span> <span data-ttu-id="e3cee-651">La propriété <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-651">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-652"><paramref name="method" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-652"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-653">Le nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-653">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="e3cee-654">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-654">-or-</span></span> 
<span data-ttu-id="e3cee-655">Un ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-655">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-656"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</span><span class="sxs-lookup"><span data-stu-id="e3cee-656">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-657"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-657">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-658"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-659">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-659">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-660"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-661">Pour représenter un appel à une `static` (`Shared` en Visual Basic) (méthode), passez `null` pour le `instance` paramètre lorsque vous appelez cette méthode, ou appelez <xref:System.Linq.Expressions.Expression.Call%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="e3cee-661">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="e3cee-662">Si `method` représente une méthode d’instance, le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `instance` doit pouvoir être assigné au type de déclaration de la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-662">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="e3cee-663">Si `arguments` n’est pas `null`, il doit avoir le même nombre d’éléments que le nombre de paramètres pour la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-663">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="e3cee-664">Chaque élément dans `arguments` ne doit pas être `null` et doit être assignable au paramètre correspondant de `method`, éventuellement après *mise entre guillemets*.</span><span class="sxs-lookup"><span data-stu-id="e3cee-664">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3cee-665">Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-665">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="e3cee-666">Citation signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-666">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="e3cee-667">Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-667">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="e3cee-668">Le <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est vide si `arguments` est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-668">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="e3cee-669">Sinon, elle contient les mêmes éléments que `arguments`, certains d'entre eux peuvent être mise entre guillemets.</span><span class="sxs-lookup"><span data-stu-id="e3cee-669">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="e3cee-670">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-670">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-671"><paramref name="method" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-671"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-672">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-672">-or-</span></span> 
 <span data-ttu-id="e3cee-673"><paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d'instance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-673"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-674"><paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-674"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="e3cee-675">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-675">-or-</span></span> 
<span data-ttu-id="e3cee-676">Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-676">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="e3cee-677">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-677">-or-</span></span> 
<span data-ttu-id="e3cee-678">Un ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-678">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-679"><see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e3cee-679">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-680"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-680">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-681">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-681">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-682">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-682">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-683"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-684">Pour représenter un appel à une `static` (`Shared` en Visual Basic) (méthode), passez `null` pour le `instance` paramètre lorsque vous appelez cette méthode, ou appelez <xref:System.Linq.Expressions.Expression.Call%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="e3cee-684">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="e3cee-685">Si `method` représente une méthode d’instance, le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `instance` doit pouvoir être assigné au type de déclaration de la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-685">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="e3cee-686">Si `arguments` n’est pas `null`, il doit avoir le même nombre d’éléments que le nombre de paramètres pour la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-686">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="e3cee-687">Chaque élément dans `arguments` ne doit pas être `null` et doit être assignable au paramètre correspondant de `method`, éventuellement après *mise entre guillemets*.</span><span class="sxs-lookup"><span data-stu-id="e3cee-687">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3cee-688">Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-688">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="e3cee-689">Citation signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-689">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="e3cee-690">Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-690">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="e3cee-691">Le <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est vide si `arguments` est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-691">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="e3cee-692">Sinon, elle contient les mêmes éléments que `arguments`, certains d'entre eux peuvent être mise entre guillemets.</span><span class="sxs-lookup"><span data-stu-id="e3cee-692">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="e3cee-693">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode représentée par `method`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-693">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-694"><paramref name="method" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-694"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-695">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-695">-or-</span></span> 
 <span data-ttu-id="e3cee-696"><paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-696"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span>  
  
<span data-ttu-id="e3cee-697">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-697">-or-</span></span> 
 <span data-ttu-id="e3cee-698"><paramref name="arguments" /> n’est pas <see langword="null" /> et un ou plusieurs de ses éléments sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-698"><paramref name="arguments" /> is not <see langword="null" /> and one or more of its elements is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-699"><paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-699"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="e3cee-700">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-700">-or-</span></span> 
<span data-ttu-id="e3cee-701">Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-701">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="e3cee-702">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-702">-or-</span></span> 
<span data-ttu-id="e3cee-703">Un ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-703">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="e3cee-704"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-704">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-705"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-705">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-706"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-706">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="e3cee-707">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant deux arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-707">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-708"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-709"><paramref name="method" /> a la valeur null.</span><span class="sxs-lookup"><span data-stu-id="e3cee-709"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-710"><see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-710">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="e3cee-711">(Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</span><span class="sxs-lookup"><span data-stu-id="e3cee-711">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-712"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</span><span class="sxs-lookup"><span data-stu-id="e3cee-712">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-713"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-713">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-714"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-714">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="e3cee-715">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend deux arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-715">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-716"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-717">L’exemple de code suivant montre comment créer une expression qui appelle une méthode d’instance qui a deux arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-717">The following code example shows how to create an expression that calls an instance method that has two arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-718"><see cref="T:System.Linq.Expressions.Expression" /> dont la valeur de propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> fera l'objet d'une recherche de méthode spécifique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-718">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> property value will be searched for a specific method.</span></span></param>
        <param name="methodName"><span data-ttu-id="e3cee-719">Nom de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-719">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="e3cee-720">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-720">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="e3cee-721">Cet argument doit être null lorsque methodName spécifie une méthode non générique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-721">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-722">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-722">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represents the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="e3cee-723">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode en appelant la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-723">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-724"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> est égale à <paramref name="instance" />, dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'instance spécifiée, et dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-725">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode désignée par `methodName`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-725">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-726"><paramref name="instance" /> ou <paramref name="methodName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-726"><paramref name="instance" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-727">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="instance" />.Type ou ses types de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-727">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span>  
  
<span data-ttu-id="e3cee-728">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-728">-or-</span></span> 
<span data-ttu-id="e3cee-729">Plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="instance" />.Type ou ses types de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-729">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="e3cee-730"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-730">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-731"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-731">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-732"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-732">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-733"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-733">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="e3cee-734">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant trois arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-734">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-735"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-736"><paramref name="method" /> a la valeur null.</span><span class="sxs-lookup"><span data-stu-id="e3cee-736"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-737"><see cref="T:System.Type" /> qui spécifie le type contenant la méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-737">The <see cref="T:System.Type" /> that specifies the type that contains the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method.</span></span></param>
        <param name="methodName"><span data-ttu-id="e3cee-738">Nom de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-738">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="e3cee-739">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-739">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="e3cee-740">Cet argument doit être null lorsque methodName spécifie une méthode non générique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-740">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-741">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-741">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="e3cee-742">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) en appelant la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-742">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-743"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) spécifiée, et dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-744">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode désignée par `methodName`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-744">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span> <span data-ttu-id="e3cee-745">La propriété <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-745">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-746"><paramref name="type" /> ou <paramref name="methodName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-746"><paramref name="type" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-747">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="type" /> ou ses types de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-747">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span>  
  
<span data-ttu-id="e3cee-748">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-748">-or-</span></span> 
<span data-ttu-id="e3cee-749">Plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="type" /> ou ses types de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-749">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-750"><see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-750">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="e3cee-751">(Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</span><span class="sxs-lookup"><span data-stu-id="e3cee-751">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-752"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</span><span class="sxs-lookup"><span data-stu-id="e3cee-752">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-753"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-753">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-754"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-754">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-755"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-755">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="e3cee-756">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'appel d'une méthode qui prend trois arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-756">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-757"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="e3cee-758"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-758">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-759"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-759">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-760"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-760">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-761"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-761">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="e3cee-762"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-762">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <summary><span data-ttu-id="e3cee-763">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant quatre arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-763">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes four arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-764"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-765"><paramref name="method" /> a la valeur null.</span><span class="sxs-lookup"><span data-stu-id="e3cee-765"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="e3cee-766"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-766">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-767"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-767">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-768"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-768">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-769"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-769">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="e3cee-770"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-770">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <param name="arg4"><span data-ttu-id="e3cee-771"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le cinquième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-771">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fifth argument.</span></span></param>
        <summary><span data-ttu-id="e3cee-772">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant cinq arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-772">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes five arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-773"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-774"><paramref name="method" /> a la valeur null.</span><span class="sxs-lookup"><span data-stu-id="e3cee-774"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e3cee-775">Indique que le nœud peut être réduit à un nœud plus simple.</span><span class="sxs-lookup"><span data-stu-id="e3cee-775">Indicates that the node can be reduced to a simpler node.</span></span> <span data-ttu-id="e3cee-776">Si la valeur retournée est true, Reduce() peut être appelé pour produire la forme réduite.</span><span class="sxs-lookup"><span data-stu-id="e3cee-776">If this returns true, Reduce() can be called to produce the reduced form.</span></span></summary>
        <value><span data-ttu-id="e3cee-777">True si le nœud peut être réduit ; sinon, false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-777">True if the node can be reduced, otherwise false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-778">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-778">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="e3cee-779"><see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-780">Corps de l'instruction Catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-780">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="e3cee-781">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec une référence à l'objet <see cref="T:System.Exception" /> intercepté pour une utilisation dans le corps du gestionnaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-781">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with a reference to the caught <see cref="T:System.Exception" /> object for use in the handler body.</span></span></summary>
        <returns><span data-ttu-id="e3cee-782">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-782">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-783">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-783">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-784">Corps de l'instruction Catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-784">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="e3cee-785">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-785">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-786">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-786">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-787">Le <xref:System.Linq.Expressions.Expression.Type%2A> de <xref:System.Exception> à intercepter peut être spécifié mais aucune référence à la <xref:System.Exception> objet sera disponible pour une utilisation dans le <xref:System.Linq.Expressions.CatchBlock>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-787">The <xref:System.Linq.Expressions.Expression.Type%2A> of <xref:System.Exception> to be caught can be specified but no reference to the <xref:System.Exception> object will be available for use in the <xref:System.Linq.Expressions.CatchBlock>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="e3cee-788"><see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-789">Corps de l'instruction Catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-789">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="e3cee-790">Corps du filtre <see cref="T:System.Exception" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-790">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="e3cee-791">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" /> et une référence à l'objet <see cref="T:System.Exception" /> intercepté.</span><span class="sxs-lookup"><span data-stu-id="e3cee-791">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter and a reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="e3cee-792">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-792">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-793">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-793">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-794">Corps de l'instruction Catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-794">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="e3cee-795">Corps du filtre <see cref="T:System.Exception" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-795">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="e3cee-796">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> représentant une instruction Catch avec un filtre <see cref="T:System.Exception" />, mais aucune référence à l'objet <see cref="T:System.Exception" /> intercepté.</span><span class="sxs-lookup"><span data-stu-id="e3cee-796">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter but no reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="e3cee-797">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-797">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="e3cee-798"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</span><span class="sxs-lookup"><span data-stu-id="e3cee-798">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <summary><span data-ttu-id="e3cee-799">Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour la suppression d'un point de séquence.</span><span class="sxs-lookup"><span data-stu-id="e3cee-799">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</span></span></summary>
        <returns><span data-ttu-id="e3cee-800">Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour le nettoyage d'un point de séquence.</span><span class="sxs-lookup"><span data-stu-id="e3cee-800">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearning a sequence point.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-801">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion.</span><span class="sxs-lookup"><span data-stu-id="e3cee-801">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-802"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-802">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-803"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-803">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-804">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion.</span><span class="sxs-lookup"><span data-stu-id="e3cee-804">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-805"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-806">Le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.BinaryExpression> est `null` et <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sont définies sur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-806">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="e3cee-807">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est égale au type de résultat de l’opération de fusion.</span><span class="sxs-lookup"><span data-stu-id="e3cee-807">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the result type of the coalescing operation.</span></span> <span data-ttu-id="e3cee-808">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-808">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
#### <a name="result-type"></a><span data-ttu-id="e3cee-809">Type de résultat</span><span class="sxs-lookup"><span data-stu-id="e3cee-809">Result Type</span></span>  
 <span data-ttu-id="e3cee-810">Les règles suivantes déterminent le type de résultat :</span><span class="sxs-lookup"><span data-stu-id="e3cee-810">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="e3cee-811">Si `left`. Type représente un type nullable et `right`. Le type est implicitement convertible au type non nullable correspondant, le type de résultat est l’équivalent non nullable de `left`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-811">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="e3cee-812">Sinon, si `right`. Type est implicitement convertible en `left`. Type, le type de résultat est `left`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-812">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="e3cee-813">Sinon, si l’équivalent non nullable de `left`. Type est implicitement convertible en `right`. Type, le type de résultat est `right`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-813">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-814"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-814"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-815">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-816"><paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-816"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/088b1f0d-c1af-4fe1-b4b8-196fd5ea9132"><span data-ttu-id="e3cee-817">??</span><span class="sxs-lookup"><span data-stu-id="e3cee-817">??</span></span> <span data-ttu-id="e3cee-818">Opérateur (référence C#)</span><span class="sxs-lookup"><span data-stu-id="e3cee-818">Operator (C# Reference)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-819"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-819">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-820"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-820">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-821"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-821">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-822">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion, à partir d'une fonction de conversion.</span><span class="sxs-lookup"><span data-stu-id="e3cee-822">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation, given a conversion function.</span></span></summary>
        <returns><span data-ttu-id="e3cee-823"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-823">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-824">Le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.BinaryExpression> est `null` et <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sont définies sur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-824">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 <span data-ttu-id="e3cee-825">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.BinaryExpression> est égal au type de résultat de l’opération de fusion.</span><span class="sxs-lookup"><span data-stu-id="e3cee-825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is equal to the result type of the coalescing operation.</span></span>  
  
 <span data-ttu-id="e3cee-826">Les règles suivantes déterminent le type de résultat :</span><span class="sxs-lookup"><span data-stu-id="e3cee-826">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="e3cee-827">Si `left`. Type représente un type nullable et `right`. Le type est implicitement convertible au type non nullable correspondant, le type de résultat est l’équivalent non nullable de `left`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-827">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="e3cee-828">Sinon, si `right`. Type est implicitement convertible en `left`. Type, le type de résultat est `left`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-828">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="e3cee-829">Sinon, si l’équivalent non nullable de `left`. Type est implicitement convertible en `right`. Type, le type de résultat est `right`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-829">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-830"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-830"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-831"><paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-831"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span>  
  
<span data-ttu-id="e3cee-832">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-832">-or-</span></span> 
 <span data-ttu-id="e3cee-833"><paramref name="conversion" /> n'est pas <see langword="null" /> et <paramref name="conversion" />.Type est un type délégué qui ne prend pas exactement un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-833"><paramref name="conversion" /> is not <see langword="null" /> and <paramref name="conversion" />.Type is a delegate type that does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-834">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-834">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span>  
  
<span data-ttu-id="e3cee-835">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-835">-or-</span></span> 
<span data-ttu-id="e3cee-836">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> représente un type qui ne peut pas être assigné au type de paramètre du type délégué <paramref name="conversion" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-836">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-837">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-837">-or-</span></span> 
<span data-ttu-id="e3cee-838">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> n'est pas égale au type de retour du type délégué <paramref name="conversion" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-838">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="right" /> is not equal to the return type of the delegate type <paramref name="conversion" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-839">Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-839">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="e3cee-840"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-840">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="e3cee-841"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-841">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="e3cee-842"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-842">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-843">Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-843">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-844"><see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-844">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-845">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ConditionalExpression> est égale à la <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `ifTrue`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-845">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConditionalExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `ifTrue`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-846">L’exemple de code suivant montre comment créer une expression qui représente une instruction conditionnelle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-846">The following code example shows how to create an expression that represents a conditional statement.</span></span> <span data-ttu-id="e3cee-847">Si le premier argument prend la valeur `true`, le deuxième argument est exécutée ; sinon, le troisième argument est exécuté.</span><span class="sxs-lookup"><span data-stu-id="e3cee-847">If the first argument evaluates to `true`, the second argument is executed; otherwise, the third argument is executed.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-848"><paramref name="test" /> ou <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-848"><paramref name="test" /> or <paramref name="ifTrue" /> or <paramref name="ifFalse" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-849"><paramref name="test" />.Type n'est pas <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-849"><paramref name="test" />.Type is not <see cref="T:System.Boolean" />.</span></span>  
  
<span data-ttu-id="e3cee-850">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-850">-or-</span></span> 
 <span data-ttu-id="e3cee-851"><paramref name="ifTrue" />.Type n'est pas égal à <paramref name="ifFalse" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-851"><paramref name="ifTrue" />.Type is not equal to <paramref name="ifFalse" />.Type.</span></span></exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="e3cee-852"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="e3cee-853"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-853">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="e3cee-854"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-854">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-855"><see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-855">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-856">Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-856">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-857"><see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-857">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-858">Cette méthode permet d’unifier explicitement le type de résultat de l’expression conditionnelle dans les cas où les types de `ifTrue` et `ifFalse` expressions ne sont pas égales.</span><span class="sxs-lookup"><span data-stu-id="e3cee-858">This method allows explicitly unifying the result type of the conditional expression in cases where the types of `ifTrue` and `ifFalse` expressions are not equal.</span></span> <span data-ttu-id="e3cee-859">Types des deux `ifTrue` et `ifFalse` doit être implicitement référence peut être assigné au type de résultat.</span><span class="sxs-lookup"><span data-stu-id="e3cee-859">Types of both `ifTrue` and `ifFalse` must be implicitly reference assignable to the result type.</span></span> <span data-ttu-id="e3cee-860">Le `type` est autorisé à être <xref:System.Void>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-860">The `type` is allowed to be <xref:System.Void>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-861">Crée une <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-861">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e3cee-862"><see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-862">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-863">Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-863">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></summary>
        <returns><span data-ttu-id="e3cee-864"><see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-864">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-865">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ConstantExpression> est égal au type de `value`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-865">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConstantExpression> is equal to the type of `value`.</span></span> <span data-ttu-id="e3cee-866">Si `value` est `null`, <xref:System.Linq.Expressions.Expression.Type%2A> est égal à <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-866">If `value` is `null`, <xref:System.Linq.Expressions.Expression.Type%2A> is equal to <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="e3cee-867">Pour représenter `null`, vous pouvez également utiliser le <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> méthode, avec lequel vous pouvez spécifier explicitement le type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-867">To represent `null`, you can also use the <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> method, with which you can explicitly specify the type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-868">L’exemple de code suivant montre comment créer une expression qui représente une valeur constante.</span><span class="sxs-lookup"><span data-stu-id="e3cee-868">The following code example shows how to create an expression that represents a constant value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e3cee-869"><see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-869">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-870"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-870">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-871">Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-871">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></summary>
        <returns><span data-ttu-id="e3cee-872"><see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-872">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-873">Cette méthode peut être utile pour représenter des valeurs de types nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-873">This method can be useful for representing values of nullable types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-874">L’exemple de code suivant montre comment créer une expression qui représente une constante de type nullable et définissez sa valeur sur `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-874">The following code example shows how to create an expression that represents a constant of the nullable type and set its value to `null`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-875"><paramref name="type" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-875"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-876"><paramref name="value" /> n'est pas <see langword="null" /> et <paramref name="type" /> ne peut pas être assigné à partir du type dynamique de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-876"><paramref name="value" /> is not <see langword="null" /> and <paramref name="type" /> is not assignable from the dynamic type of <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-877">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue.</span><span class="sxs-lookup"><span data-stu-id="e3cee-877">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-878"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-878">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="e3cee-879">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue.</span><span class="sxs-lookup"><span data-stu-id="e3cee-879">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-880"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-880">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-881">L’exemple suivant montre comment créer une expression de boucle qui utilise le <xref:System.Linq.Expressions.Expression.Continue%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="e3cee-881">The following example demonstrates how to create a loop expression that uses the <xref:System.Linq.Expressions.Expression.Continue%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-882"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-882">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-883"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-883">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-884">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue avec le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-884">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-885"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-885">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-886">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion de type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-886">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-887"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-887">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-888"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-888">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-889">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion de type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-889">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-890"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-890">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-891">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-891">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-892">La propriété <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-892">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="e3cee-893">Si le nœud est levé, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-893">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="e3cee-894">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-894">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-895">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-895">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-896">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-896">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-897">Si deux `expression`. Type ou `type` est un type défini par l’utilisateur qui définit un opérateur de conversion implicite ou explicite, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-897">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-898">Sinon :</span><span class="sxs-lookup"><span data-stu-id="e3cee-898">Otherwise:</span></span>  
  
    -   <span data-ttu-id="e3cee-899">Si les deux `expression`. Type et `type` représentent des types numériques ou booléennes ou des types énumération nullable ou non nullable, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-899">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="e3cee-900">Si deux `expression`. Type ou `type` est un type référence et un conversion boxing explicite, unboxing ou conversion de référence existe à partir de `expression`. Type à `type`, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-900">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-901">Levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-901">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-902">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-902">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-903">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation et le type de retour de la méthode d’implémentation est assignable à `type`, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-903">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="e3cee-904">Si un ou deux de `expression`. Type ou `type` est un type valeur nullable et les types valeur non nullable correspondants sont égaux pour le type d’argument et le type de retour de la méthode d’implémentation, respectivement, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-904">If one or both of `expression`.Type or `type` is a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="e3cee-905">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-905">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-906">Si les deux `expression`. Type et `type` sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-906">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="e3cee-907">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-907">Otherwise the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-908">L’exemple de code suivant montre comment créer une expression qui représente une opération de conversion de type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-908">The following code example shows how to create an expression that represents a type convertion operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-909"><paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-909"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-910">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-910">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-911"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-911">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-912"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-912">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-913"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-913">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-914">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion pour laquelle la méthode d'implémentation est spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-914">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-915"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-915">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-916">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-916">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-917">La propriété <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-917">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="e3cee-918">Si le nœud est levé, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-918">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="e3cee-919">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-919">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-920">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-920">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-921">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-921">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-922">Si la méthode n’est pas `null`, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-922">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="e3cee-923">Il doit représenter un non void, `static` (`Shared` en Visual Basic) méthode qui prend un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-923">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="e3cee-924">Autrement, si `expression`. Type ou `type` est un type défini par l’utilisateur qui définit un opérateur de conversion implicite ou explicite, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-924">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-925">Sinon :</span><span class="sxs-lookup"><span data-stu-id="e3cee-925">Otherwise:</span></span>  
  
    -   <span data-ttu-id="e3cee-926">Si les deux `expression`. Type et `type` représentent des types numériques ou booléennes ou des types énumération nullable ou non nullable, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-926">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="e3cee-927">Si deux `expression`. Type ou `type` est un type référence et un conversion boxing explicite, unboxing ou conversion de référence existe à partir de `expression`. Type à `type`, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-927">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-928">Levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-928">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-929">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-929">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-930">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation et le type de retour de la méthode d’implémentation est assignable à `type`, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-930">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="e3cee-931">Si un ou les deux de `expression`. Type ou `type` sont un type valeur nullable et les types valeur non nullable correspondants sont respectivement égales pour le type d’argument et le type de retour de la méthode d’implémentation, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-931">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="e3cee-932">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-932">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-933">Si les deux `expression`. Type et `type` sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-933">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="e3cee-934">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-934">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-935"><paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-935"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-936"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-936"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-937">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-937">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
<span data-ttu-id="e3cee-938">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-938">-or-</span></span> 
 <span data-ttu-id="e3cee-939"><paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-939"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="e3cee-940">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-940">-or-</span></span> 
<span data-ttu-id="e3cee-941">Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-941">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
<span data-ttu-id="e3cee-942">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-942">-or-</span></span> 
 <span data-ttu-id="e3cee-943"><paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-943"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="e3cee-944">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-944">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-945">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible.</span><span class="sxs-lookup"><span data-stu-id="e3cee-945">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-946"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-946">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-947"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-947">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-948">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible.</span><span class="sxs-lookup"><span data-stu-id="e3cee-948">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
        <returns><span data-ttu-id="e3cee-949"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-949">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-950">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-950">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-951">La propriété <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-951">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="e3cee-952">Si le nœud est levé, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-952">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="e3cee-953">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-953">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-954">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-954">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-955">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-955">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-956">Si deux `expression`. Type ou `type` est un type défini par l’utilisateur qui définit un opérateur de conversion implicite ou explicite, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-956">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-957">Sinon :</span><span class="sxs-lookup"><span data-stu-id="e3cee-957">Otherwise:</span></span>  
  
    -   <span data-ttu-id="e3cee-958">Si les deux `expression`. Type et `type` représentent des types numériques ou booléennes ou des types énumération nullable ou non nullable, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-958">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="e3cee-959">Si deux `expression`. Type ou `type` est un type référence et un conversion boxing explicite, unboxing ou conversion de référence existe à partir de `expression`. Type à `type`, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-959">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-960">Levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-960">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-961">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-961">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-962">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation et le type de retour de la méthode d’implémentation est assignable à `type`, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-962">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="e3cee-963">Si un ou les deux de `expression`. Type ou `type` sont un type valeur nullable et les types valeur non nullable correspondants sont respectivement égales pour le type d’argument et le type de retour de la méthode d’implémentation, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-963">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="e3cee-964">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-964">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-965">Si les deux `expression`. Type et `type` sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-965">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="e3cee-966">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-966">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-967"><paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-967"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-968">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-968">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-969"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-969">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-970"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-970">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-971"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-971">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-972">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible et pour lequel la méthode d'implémentation est spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-972">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-973"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-973">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-974">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-974">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-975">La propriété <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-975">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="e3cee-976">Si le nœud est levé, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-976">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="e3cee-977">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-977">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-978">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-978">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-979">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-979">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-980">Si la méthode n’est pas `null`, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-980">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="e3cee-981">Il doit représenter un non void, `static` (`Shared` en Visual Basic) méthode qui prend un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-981">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="e3cee-982">Autrement, si `expression`. Type ou `type` est un type défini par l’utilisateur qui définit un opérateur de conversion implicite ou explicite, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-982">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-983">Sinon :</span><span class="sxs-lookup"><span data-stu-id="e3cee-983">Otherwise:</span></span>  
  
    -   <span data-ttu-id="e3cee-984">Si les deux `expression`. Type et `type` représentent des types numériques ou booléennes ou des types énumération nullable ou non nullable, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-984">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="e3cee-985">Si deux `expression`. Type ou `type` est un type référence et un conversion boxing explicite, unboxing ou conversion de référence existe à partir de `expression`. Type à `type`, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-985">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-986">Levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-986">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-987">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-987">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-988">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation et le type de retour de la méthode d’implémentation est assignable à `type`, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-988">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="e3cee-989">Si un ou les deux de `expression`. Type ou `type` sont un type valeur nullable et les types valeur non nullable correspondants sont respectivement égales pour le type d’argument et le type de retour de la méthode d’implémentation, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-989">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="e3cee-990">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-990">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-991">Si les deux `expression`. Type et `type` sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-991">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="e3cee-992">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-992">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-993"><paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-993"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-994"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-994"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-995">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-995">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
<span data-ttu-id="e3cee-996">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-996">-or-</span></span> 
 <span data-ttu-id="e3cee-997"><paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-997"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="e3cee-998">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-998">-or-</span></span> 
<span data-ttu-id="e3cee-999">Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-999">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
<span data-ttu-id="e3cee-1000">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1000">-or-</span></span> 
 <span data-ttu-id="e3cee-1001"><paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1001"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="e3cee-1002">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1002">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="e3cee-1003"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1003">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <param name="startLine"><span data-ttu-id="e3cee-1004">Ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1004">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="e3cee-1005">Doit être supérieure à 0.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1005">Must be greater than 0.</span></span></param>
        <param name="startColumn"><span data-ttu-id="e3cee-1006">Colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1006">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="e3cee-1007">Doit être supérieure à 0.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1007">Must be greater than 0.</span></span></param>
        <param name="endLine"><span data-ttu-id="e3cee-1008">Ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1008">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="e3cee-1009">Doit être supérieure ou égale à la ligne de début.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1009">Must be greater or equal than the start line.</span></span></param>
        <param name="endColumn"><span data-ttu-id="e3cee-1010">Colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1010">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="e3cee-1011">Si la ligne de fin est la même que la ligne de début, elle doit être supérieure ou égale à la colonne de début.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1011">If the end line is the same as the start line, it must be greater or equal than the start column.</span></span> <span data-ttu-id="e3cee-1012">Dans tous les cas, elle doit être supérieure à 0.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1012">In any case, must be greater than 0.</span></span></param>
        <summary><span data-ttu-id="e3cee-1013">Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> avec l'étendue spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1013">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> with the specified span.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1014">Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1014">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1015">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1015">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1016"><see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1016">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <summary><span data-ttu-id="e3cee-1017">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1017">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1018"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1018">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1019">Cette expression est fonctionnelle et ne modifie pas la valeur de l’objet qui lui est passé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1019">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1020">L’exemple de code suivant montre comment créer une expression qui soustrait 1 à partir d’une valeur donnée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1020">The following code example shows how to create an expression that substracts 1 from a given value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1021"><see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1021">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1022"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1022">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-1023">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1023">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1024"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1024">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1025">Cette expression est fonctionnelle et ne modifie pas la valeur de l’objet qui lui est passé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1025">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-1026"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1026">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1027">Crée un <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1027">Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1028"><see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1028">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-1029">L’exemple de code suivant montre comment créer une expression qui représente un valeur par défaut pour un type donné.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1029">The following code example shows how to create an expression that represents a default vaule for a given type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1030">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1030">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1031"><see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1031">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1032"><see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1032">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1033">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1033">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1034"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1034">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1035">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1035">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1036">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1036">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1037">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1037">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-1038">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1038">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-1039">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1039">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1040">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1040">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1041">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1041">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1042">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1042">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1043">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de division, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1043">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1044">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1044">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1045">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1045">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1046">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1046">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1047">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1047">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1048">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1048">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1049">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1049">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-1050">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1050">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1051">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1051">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-1052">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1052">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1053">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1053">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1054">Le type du nœud est le type de résultat de l’opérateur de division prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1054">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="e3cee-1055">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1055">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1056">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de division prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1056">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1057">L’exemple de code suivant montre comment créer une expression qui divise son premier argument par son deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1057">The following code example shows how to create an expression that divides divides its first argument by its second argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1058"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1058"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1059">L'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1059">The division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1060"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1060">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1061"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1061">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1062"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1062">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1063">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1063">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span> <span data-ttu-id="e3cee-1064">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1064">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1065"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1065">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1066">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1066">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1067">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1067">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1068">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1068">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-1069">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1069">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-1070">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1070">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1071">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1071">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1072">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1072">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1073">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1073">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1074">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1074">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-1075">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de division, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1075">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1076">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1076">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1077">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1077">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1078">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1078">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1079">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1079">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1080">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1080">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1081">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1081">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-1082">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1082">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1083">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1083">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-1084">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1084">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1085">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1085">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1086">Le type du nœud est le type de résultat de l’opérateur de division prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1086">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="e3cee-1087">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1087">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1088">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de division prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1088">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1089"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1089"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1090"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1090"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1091"><paramref name="method" /> est <see langword="null" /> et l'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1091"><paramref name="method" /> is <see langword="null" /> and the division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1092">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1092">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1093"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1093">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1094"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1094">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1095">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1095">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1096"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1096">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1097"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1097">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1098"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1098">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1099"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1099">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1100">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1100">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1101"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1101">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1102"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1102">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1103"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1103">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1104"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1104">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-1105"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1105">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1106">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1106">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1107"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1107">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1108">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1108">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="e3cee-1109">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1109">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="e3cee-1110">Type de résultat de l'expression dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1110">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-1111">Arguments de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1111">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-1112">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1112">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1113"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1113">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1114">Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1114">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="e3cee-1115">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1115">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="e3cee-1116">Type de résultat de l'expression dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1116">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-1117">Premier argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1117">The first argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-1118">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1118">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1119"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1119">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1120">Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1120">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="e3cee-1121">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1121">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="e3cee-1122">Type de résultat de l'expression dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1122">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-1123">Arguments de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1123">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-1124">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1124">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1125"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1125">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1126">Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1126">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="e3cee-1127">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1127">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="e3cee-1128">Type de résultat de l'expression dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1128">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-1129">Premier argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1129">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-1130">Deuxième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1130">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-1131">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1131">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1132"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1132">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1133">Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1133">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="e3cee-1134">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1134">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="e3cee-1135">Type de résultat de l'expression dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1135">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-1136">Premier argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1136">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-1137">Deuxième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1137">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-1138">Troisième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1138">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-1139">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1139">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1140"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1140">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1141">Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1141">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="e3cee-1142">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1142">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="e3cee-1143">Type de résultat de l'expression dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1143">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-1144">Premier argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1144">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-1145">Deuxième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1145">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-1146">Troisième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1146">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="e3cee-1147">Quatrième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1147">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-1148">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1148">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1149"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1149">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1150">Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1150">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1151">Crée un <see cref="T:System.Linq.Expressions.ElementInit" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1151">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="e3cee-1152"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1152">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-1153"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1153">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1154">Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> comme deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1154">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the second argument.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1155"><see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1155">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1156">Le `addMethod` paramètre doit représenter une méthode d’instance nommée « Add » (non respect de la casse).</span><span class="sxs-lookup"><span data-stu-id="e3cee-1156">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="e3cee-1157">La méthode add doit avoir le même nombre de paramètres que le nombre d’éléments dans `arguments`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1157">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="e3cee-1158">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément dans `arguments` doit pouvoir être assigné au type du paramètre correspondant de la méthode add, éventuellement après *mise entre guillemets*.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1158">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3cee-1159">Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1159">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="e3cee-1160">Citation signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1160">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="e3cee-1161">Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1161">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1162">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.ElementInit> qui représente l’appel le <xref:System.Collections.Generic.Dictionary%602.Add%2A> méthode pour initialiser un élément d’une collection de dictionnaires.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1162">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1163"><paramref name="addMethod" /> ou <paramref name="arguments" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1163"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1164">La méthode représentée par <paramref name="addMethod" /> n’est pas nommée « Add » (non-respect de la casse).</span><span class="sxs-lookup"><span data-stu-id="e3cee-1164">The method that <paramref name="addMethod" /> represents is not named "Add" (case insensitive).</span></span>  
  
<span data-ttu-id="e3cee-1165">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1165">-or-</span></span> 
<span data-ttu-id="e3cee-1166">La méthode représentée par <paramref name="addMethod" /> n’est pas une méthode d’instance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1166">The method that <paramref name="addMethod" /> represents is not an instance method.</span></span>  
  
<span data-ttu-id="e3cee-1167">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1167">-or-</span></span> 
 <span data-ttu-id="e3cee-1168">Le nombre d’éléments que contient <paramref name="arguments" /> ne correspond pas au nombre de paramètres de la méthode représentée par <paramref name="addMethod" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1168"><paramref name="arguments" /> does not contain the same number of elements as the number of parameters for the method that <paramref name="addMethod" /> represents.</span></span>  
  
<span data-ttu-id="e3cee-1169">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1169">-or-</span></span> 
<span data-ttu-id="e3cee-1170">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1170">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="e3cee-1171"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1171">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-1172">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1172">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1173">Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un tableau de valeurs comme deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1173">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an array of values as the second argument.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1174"><see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1174">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1175">Le `addMethod` paramètre doit représenter une méthode d’instance nommée « Add » (non respect de la casse).</span><span class="sxs-lookup"><span data-stu-id="e3cee-1175">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="e3cee-1176">La méthode add doit avoir le même nombre de paramètres que le nombre d’éléments dans `arguments`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1176">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="e3cee-1177">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément dans `arguments` doit pouvoir être assigné au type du paramètre correspondant de la méthode add, éventuellement après *mise entre guillemets*.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1177">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3cee-1178">Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1178">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="e3cee-1179">Citation signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1179">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="e3cee-1180">Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1180">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1181">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.ElementInit> qui représente l’appel le <xref:System.Collections.Generic.Dictionary%602.Add%2A> méthode pour initialiser un élément d’une collection de dictionnaires.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1181">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1182"><paramref name="addMethod" /> ou <paramref name="arguments" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1182"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1183">La méthode représentée par addMethod n'est pas nommée "Add" (non respect de la casse).</span><span class="sxs-lookup"><span data-stu-id="e3cee-1183">The method that addMethod represents is not named "Add" (case insensitive).</span></span>  
  
<span data-ttu-id="e3cee-1184">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1184">-or-</span></span> 
<span data-ttu-id="e3cee-1185">La méthode représentée par addMethod n'est pas une méthode d'instance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1185">The method that addMethod represents is not an instance method.</span></span>  
  
<span data-ttu-id="e3cee-1186">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1186">-or-</span></span> 
<span data-ttu-id="e3cee-1187">arguments ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par addMethod.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1187">arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.</span></span>  
  
<span data-ttu-id="e3cee-1188">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1188">-or-</span></span> 
<span data-ttu-id="e3cee-1189">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1189">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e3cee-1190">Crée une expression vide qui a le type <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1190">Creates an empty expression that has <see cref="T:System.Void" /> type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1191"><see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> est égale à <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1191">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1192">Une expression vide peut être utilisée dans lequel une expression est attendue, mais aucune action n’est souhaitée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1192">An empty expression can be used where an expression is expected but no action is desired.</span></span> <span data-ttu-id="e3cee-1193">Par exemple, vous pouvez utiliser une expression vide en tant que la dernière expression dans une expression de bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1193">For example, you can use an empty expression as the last expression in a block expression.</span></span> <span data-ttu-id="e3cee-1194">Dans ce cas, la valeur de retour de l’expression de bloc est void.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1194">In this case, the block expression's return value is void.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1195">L’exemple de code suivant montre comment créer une expression vide et l’ajouter à une expression de bloc.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1195">The following code example shows how to create an empty expression and add it to a block expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1196">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1197"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1197">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1198"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1198">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1199">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1199">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1200"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1200">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1201">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1201">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1202">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1202">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1203">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1203">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="e3cee-1204">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1204">Otherwise, it is `false`.</span></span> <span data-ttu-id="e3cee-1205">La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1205">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="e3cee-1206">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1206">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1207">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1207">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1208">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1208">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1209">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’égalité, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1209">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1210">Sinon, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1210">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1211">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1211">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1212">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1212">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1213">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1213">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1214">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1214">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1215">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1215">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="e3cee-1216">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1216">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1217">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1217">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1218">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1218">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1219">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1219">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1220">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1220">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-1221">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1221">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1222">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1222">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1223">L’exemple de code suivant montre comment créer une expression qui vérifie si les valeurs de ses deux arguments sont égaux.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1223">The following code example shows how to create an expression that checks whether the values of its two arguments are equal.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1224"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1224"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1225">L'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1225">The equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1226"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1226">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1227"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1227">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="e3cee-1228"><see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1228"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1229"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1229">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1230">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1230">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span> <span data-ttu-id="e3cee-1231">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1231">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1232"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1232">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1233">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1233">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1234">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1234">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1235">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1235">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="e3cee-1236">Sinon, elles sont toutes deux `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1236">Otherwise, they are both `false`.</span></span> <span data-ttu-id="e3cee-1237">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1237">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1238">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1238">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1239">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1239">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1240">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1240">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1241">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’égalité, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1241">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1242">Sinon, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1242">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1243">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1243">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1244">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1244">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1245">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1245">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1246">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1246">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1247">Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1247">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="e3cee-1248">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1248">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1249">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1249">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1250">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1250">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1251">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1251">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1252">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1252">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-1253">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1253">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1254">Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1254">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1255"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1255"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1256"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1256"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1257"><paramref name="method" /> est <see langword="null" /> et l'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1257"><paramref name="method" /> is <see langword="null" /> and the equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1258">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="XOR" /> au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1258">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1259"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1259">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1260"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1260">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1261">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation <see langword="XOR" /> au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1261">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1262"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1262">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1263">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1263">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1264">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1264">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1265">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1265">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-1266">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1266">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-1267">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1267">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1268">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1268">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1269">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1269">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1270">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1270">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1271">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge le `XOR` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1271">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1272">Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1272">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1273">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1273">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1274">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1274">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1275">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1275">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1276">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1276">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1277">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1277">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-1278">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1278">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1279">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1279">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-1280">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1280">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1281">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1281">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1282">Le type du nœud est le type de résultat de prédéfinis `XOR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1282">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-1283">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1283">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1284">Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis `XOR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1284">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1285">L’exemple de code suivant montre comment créer une expression qui représente l’opération XOR logique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1285">The following code example shows how to create an expression that represents the logical XOR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1286"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1286"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1287">L'opérateur <see langword="XOR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1287">The <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1288"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1288">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1289"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1289">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1290"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1290">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1291">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation <see langword="XOR" /> au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1291">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span> <span data-ttu-id="e3cee-1292">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1292">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1293"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1293">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1294">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1294">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1295">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1295">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1296">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1296">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-1297">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1297">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-1298">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1298">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1299">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1299">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1300">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1300">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1301">Les règles suivantes déterminent le choisie implémentation de méthode pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1301">The following rules determine the chosen implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1302">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1302">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1303">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge le `XOR` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1303">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1304">Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1304">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1305">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1305">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1306">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1306">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1307">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1307">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1308">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1308">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1309">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1309">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-1310">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1310">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1311">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1311">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-1312">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1312">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1313">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1313">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1314">Le type du nœud est le type de résultat de prédéfinis `XOR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1314">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-1315">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1315">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1316">Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis `XOR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1316">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1317"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1317"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1318"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1318"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1319"><paramref name="method" /> est <see langword="null" /> et l'opérateur <see langword="XOR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1319"><paramref name="method" /> is <see langword="null" /> and the <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1320">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation XOR au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1320">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1321"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1321">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1322"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1322">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1323">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1323">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1324"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1324">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1325"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1325">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1326"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1326">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1327"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1327">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1328">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1328">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1329"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1329">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1330"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1330">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1331"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1332"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1332">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-1333"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1333">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1334">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1334">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1335"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1335">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1336">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1336">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1337"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1337">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="e3cee-1338">Pour <see langword="static" /> (<see langword="Shared" /> en Visual Basic), <paramref name="expression" /> doit être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1338">For <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <paramref name="expression" /> must be <see langword="null" />.</span></span></param>
        <param name="field"><span data-ttu-id="e3cee-1339"><see cref="T:System.Reflection.FieldInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1339">The <see cref="T:System.Reflection.FieldInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1340">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1340">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1341"><see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1341">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1342">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égale à la <xref:System.Reflection.FieldInfo.FieldType%2A> propriété du `field`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1342">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of `field`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1343"><paramref name="field" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1343"><paramref name="field" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-1344">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1344">-or-</span></span> 
<span data-ttu-id="e3cee-1345">Le champ représenté par <paramref name="field" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1345">The field represented by <paramref name="field" /> is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1346"><paramref name="expression" />.Type ne peut pas être assigné au type de déclaration du champ représenté par <paramref name="field" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1346"><paramref name="expression" />.Type is not assignable to the declaring type of the field represented by <paramref name="field" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1347"><see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient un champ nommé <paramref name="fieldName" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1347">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a field named <paramref name="fieldName" />.</span></span> <span data-ttu-id="e3cee-1348">Cette valeur peut être null pour les champs statiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1348">This can be null for static fields.</span></span></param>
        <param name="fieldName"><span data-ttu-id="e3cee-1349">Nom d'un champ auquel accéder.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1349">The name of a field to be accessed.</span></span></param>
        <summary><span data-ttu-id="e3cee-1350">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ à partir du nom du champ.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1350">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field given the name of the field.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1351"><see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ désigné par <paramref name="fieldName" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1351">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.FieldInfo" /> that represents the field denoted by <paramref name="fieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1352">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égale à la <xref:System.Reflection.FieldInfo.FieldType%2A> propriété de la <xref:System.Reflection.FieldInfo> qui représente le champ désigné par `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1352">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of the <xref:System.Reflection.FieldInfo> that represents the field denoted by `fieldName`.</span></span>  
  
 <span data-ttu-id="e3cee-1353">Cette méthode recherche `expression`. Type et ses types de base pour un champ qui porte le nom `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1353">This method searches `expression`.Type and its base types for a field that has the name `fieldName`.</span></span> <span data-ttu-id="e3cee-1354">Champs publics sont prioritaires sur les champs non publics.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1354">Public fields are given preference over non-public fields.</span></span> <span data-ttu-id="e3cee-1355">Si un champ correspondant est trouvé, cette méthode passe `expression` et <xref:System.Reflection.FieldInfo> qui représente ce champ à <xref:System.Linq.Expressions.Expression.Field%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1355">If a matching field is found, this method passes `expression` and the <xref:System.Reflection.FieldInfo> that represents that field to <xref:System.Linq.Expressions.Expression.Field%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1356">L’exemple de code suivant montre comment créer une expression qui représente l’accès à un champ.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1356">The following code example shows how to create an expression that represents accessing a field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1357"><paramref name="expression" /> ou <paramref name="fieldName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1357"><paramref name="expression" /> or <paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1358">Aucun champ nommé <paramref name="fieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1358">No field named <paramref name="fieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1359">Objet conteneur du champ.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1359">The containing object of the field.</span></span> <span data-ttu-id="e3cee-1360">Cette valeur peut être null pour les champs statiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1360">This can be null for static fields.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-1361"><see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient le champ.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1361">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the field.</span></span></param>
        <param name="fieldName"><span data-ttu-id="e3cee-1362">Champ auquel accéder.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1362">The field to be accessed.</span></span></param>
        <summary><span data-ttu-id="e3cee-1363">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1363">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1364">Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1364">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="e3cee-1365">Tableau contenant jusqu'à seize objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué <see langword="System.Action" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1365">An array of up to sixteen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Action" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="e3cee-1366">Crée un objet <see cref="T:System.Type" /> qui représente un type délégué <c>System.Action</c> générique ayant des arguments de type spécifiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1366">Creates a <see cref="T:System.Type" /> object that represents a generic <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1367">Type d’un délégué <c>System.Action</c> qui a les arguments de type spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1367">The type of a <c>System.Action</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1368">Par exemple, si les éléments de `typeArgs` représentent les types `T1…Tn`, résultant <xref:System.Type> objet représente le type délégué construit `System.Action<T1,…,Tn>` en c# ou `System.Action(Of T1,…,Tn)` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1368">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Action<T1,…,Tn>` in C# or `System.Action(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1369"><paramref name="typeArgs" /> contient plus de seize éléments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1369"><paramref name="typeArgs" /> contains more than sixteen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1370"><paramref name="typeArgs" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1370"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="e3cee-1371">Arguments de type du délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1371">The type arguments of the delegate.</span></span></param>
        <summary><span data-ttu-id="e3cee-1372">Obtient un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué <c>System.Func</c> ou <c>System.Action</c> générique ayant des arguments de type spécifiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1372">Gets a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> or <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1373">Type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1373">The delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1374">Le dernier argument de type détermine le type de retour du délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1374">The last type argument determines the return type of the delegate.</span></span> <span data-ttu-id="e3cee-1375">Si aucune fonction ou Action n’est suffisamment grande, il génère un type délégué personnalisé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1375">If no Func or Action is large enough, it will generate a custom delegate type.</span></span>  
  
 <span data-ttu-id="e3cee-1376">Comme avec Func, le dernier argument est le type de retour.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1376">As with Func, the last argument is the return type.</span></span> <span data-ttu-id="e3cee-1377">Elle peut être définie à System.Void pour produire une Action.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1377">It can be set to System.Void to produce an Action.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="e3cee-1378">Tableau de un à dix-sept objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué <see langword="System.Func" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1378">An array of one to seventeen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Func" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="e3cee-1379">Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué <c>System.Func</c> générique ayant des arguments de type spécifiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1379">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> delegate type that has specific type arguments.</span></span> <span data-ttu-id="e3cee-1380">Le dernier argument de type spécifie le type de retour du délégué créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1380">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1381">Type d’un délégué <c>System.Func</c> qui a les arguments de type spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1381">The type of a <c>System.Func</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1382">`typeArgs` doit contenir au moins un et dix-sept au maximum des éléments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1382">`typeArgs` must contain at least one and at most seventeen elements.</span></span>  
  
 <span data-ttu-id="e3cee-1383">Par exemple, si les éléments de `typeArgs` représentent les types `T1…Tn`, résultant <xref:System.Type> objet représente le type délégué construit `System.Func<T1,…,Tn>` en c# ou `System.Func(Of T1,…,Tn)` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1383">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Func<T1,…,Tn>` in C# or `System.Func(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1384"><paramref name="typeArgs" /> contient moins d'un élément ou plus de dix sept éléments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1384"><paramref name="typeArgs" /> contains fewer than one or more than seventeen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1385"><paramref name="typeArgs" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1385"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1386">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1386">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-1387"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1387">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1388">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1388">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1389"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée et une valeur Null à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1389">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-1390">L’exemple suivant montre comment créer une expression qui contienne un <xref:System.Linq.Expressions.GotoExpression> objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1390">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.GotoExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-1391"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1391">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="e3cee-1392">Valeur qui sera passée à l'étiquette associée au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1392">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="e3cee-1393">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1393">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span> <span data-ttu-id="e3cee-1394">La valeur passée à l'étiquette au moment du saut peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1394">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1395"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1395">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-1396"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1396">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-1397"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1397">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1398">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1398">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1399"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1399">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-1400"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1400">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="e3cee-1401">Valeur qui sera passée à l'étiquette associée au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1401">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-1402"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1402">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1403">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1403">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span> <span data-ttu-id="e3cee-1404">La valeur passée à l'étiquette au moment du saut peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1404">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1405"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1405">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1406">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "supérieur à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1406">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1407"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1407">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1408"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1408">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1409">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "supérieur à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1409">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1410"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1410">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1411">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1411">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1412">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1412">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1413">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1413">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="e3cee-1414">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1414">Otherwise, it is `false`.</span></span> <span data-ttu-id="e3cee-1415">La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1415">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="e3cee-1416">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1416">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1417">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1417">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1418">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1418">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1419">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1419">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1420">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « supérieur à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1420">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1421">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1421">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1422">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1422">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1423">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1423">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1424">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1424">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1425">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1425">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1426">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1426">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="e3cee-1427">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1427">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1428">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1428">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1429">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1429">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1430">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1430">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1431">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1431">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-1432">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1432">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1433">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1433">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1434">L’exemple de code suivant montre comment créer une expression qui compare deux entiers.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1434">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1435"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1435"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1436">L'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1436">The "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1437"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1437">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1438"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1438">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="e3cee-1439"><see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1439"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1440"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1440">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1441">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "supérieur à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1441">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span> <span data-ttu-id="e3cee-1442">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1442">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1443"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1443">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1444">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1444">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1445">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1445">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1446">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1446">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="e3cee-1447">Sinon, elles sont toutes deux `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1447">Otherwise, they are both `false`.</span></span> <span data-ttu-id="e3cee-1448">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1448">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1449">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1449">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1450">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1450">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1451">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1451">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="e3cee-1452">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1452">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1453">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « supérieur à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1453">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1454">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1454">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1455">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1455">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1456">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1456">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1457">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1457">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1458">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1458">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1459">Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1459">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="e3cee-1460">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1460">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1461">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1461">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1462">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1462">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1463">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1463">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1464">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1464">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-1465">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1465">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1466">Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1466">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1467"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1467"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1468"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1468"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1469"><paramref name="method" /> est <see langword="null" /> et l'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1469"><paramref name="method" /> is <see langword="null" /> and the "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1470">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "supérieur ou égal à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1470">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1471"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1471">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1472"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1472">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1473">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "supérieur ou égal à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1473">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1474"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1474">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1475">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1475">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1476">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1476">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1477">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1477">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="e3cee-1478">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1478">Otherwise, it is `false`.</span></span> <span data-ttu-id="e3cee-1479">La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1479">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="e3cee-1480">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1480">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1481">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1481">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1482">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1482">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1483">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1483">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1484">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « supérieur ou égal à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1484">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1485">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1485">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1486">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1486">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1487">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1487">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1488">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1488">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1489">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1489">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1490">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1490">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="e3cee-1491">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1491">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1492">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1492">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1493">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1493">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1494">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1494">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1495">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1495">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-1496">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1496">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1497">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1497">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1498">L’exemple de code suivant montre comment créer une expression qui compare deux entiers.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1498">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1499"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1499"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1500">L'opérateur "supérieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1500">The "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1501"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1502"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1502">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="e3cee-1503"><see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1503"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1504"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1504">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1505">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "supérieur ou égal à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1506"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1506">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1507">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1507">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1508">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1508">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1509">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1509">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="e3cee-1510">Sinon, elles sont toutes deux `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1510">Otherwise, they are both `false`.</span></span> <span data-ttu-id="e3cee-1511">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1511">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1512">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1512">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1513">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1513">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1514">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1514">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1515">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1515">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1516">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « supérieur ou égal à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1516">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1517">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1517">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1518">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1518">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1519">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1519">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1520">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1520">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1521">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1521">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1522">Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1522">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="e3cee-1523">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1523">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1524">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1524">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1525">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1525">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1526">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1526">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1527">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1527">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-1528">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1528">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1529">Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1529">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1530"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1530"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1531"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1531"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1532"><paramref name="method" /> est <see langword="null" /> et l'opérateur "supérieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1532"><paramref name="method" /> is <see langword="null" /> and the "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="e3cee-1533"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1533">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="e3cee-1534"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1534">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1535">Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec une instruction <see langword="if" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1535">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with an <see langword="if" /> statement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1536"><see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1536">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, properties set to the specified values.</span></span> <span data-ttu-id="e3cee-1537">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ayant pour valeur l'expression par défaut et dont le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1537">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-1538">L’exemple de code suivant montre comment créer une expression qui représente un bloc conditionnel.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1538">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="e3cee-1539"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1539">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="e3cee-1540"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1540">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="e3cee-1541"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1541">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1542">Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec des instructions <see langword="if" /> et <see langword="else" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1542">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with <see langword="if" /> and <see langword="else" /> statements.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1543"><see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1543">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span> <span data-ttu-id="e3cee-1544">Le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1544">The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-1545">L’exemple de code suivant montre comment créer une expression qui représente un bloc conditionnel.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1545">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1546">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de la valeur de l'expression par 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1546">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1547"><see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1547">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <summary><span data-ttu-id="e3cee-1548">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de la valeur de l'expression par 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1548">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1549"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1549">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1550">Cette expression est fonctionnelle et ne modifie pas la valeur de l’objet qui lui est passé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1550">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1551">L’exemple de code suivant montre comment créer une expression qui représente une opération d’incrémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1551">The following code example shows how to create an expression that represents an increment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1552"><see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1552">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1553"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1553">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-1554">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de l'expression par 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1554">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1555"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1555">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1556">Cette expression est fonctionnelle et ne modifie pas la valeur de l’objet qui lui est passé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1556">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1557">Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1557">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1558"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression lambda ou le délégué auquel s'appliquer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1558">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-1559"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments auxquels le délégué ou l'expression lambda est appliquée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1559">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1560">Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1560">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1561"><see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l'expression lambda spécifiée aux arguments fournis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1561">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1562">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.InvocationExpression> représente le type de retour du délégué représenté par `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1562">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="e3cee-1563">Le <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.InvocationExpression> est vide si `arguments` est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1563">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="e3cee-1564">Sinon, elle contient les mêmes éléments que `arguments` mais certains de ces <xref:System.Linq.Expressions.Expression> objets peuvent être *entre guillemets*.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1564">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3cee-1565">Un élément sera mis entre guillemets uniquement si le paramètre correspondant du délégué représenté par `expression` est de type <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1565">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="e3cee-1566">Citation signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1566">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="e3cee-1567">Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1567">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1568">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.InvocationExpression> qui représente l’appel d’une expression lambda avec les arguments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1568">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1569"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1569"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1570"><paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1570"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
<span data-ttu-id="e3cee-1571">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1571">-or-</span></span> 
<span data-ttu-id="e3cee-1572">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1572">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1573"><paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1573"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1574"><see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué ou l'expression lambda à appliquer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1574">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-1575">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué ou l'expression lambda est appliquée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1575">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1576">Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1576">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1577"><see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l'expression lambda spécifiée aux arguments fournis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1577">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1578">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.InvocationExpression> représente le type de retour du délégué représenté par `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1578">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="e3cee-1579">Le <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.InvocationExpression> est vide si `arguments` est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1579">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="e3cee-1580">Sinon, elle contient les mêmes éléments que `arguments` mais certains de ces <xref:System.Linq.Expressions.Expression> objets peuvent être *entre guillemets*.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1580">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3cee-1581">Un élément sera mis entre guillemets uniquement si le paramètre correspondant du délégué représenté par `expression` est de type <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1581">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="e3cee-1582">Citation signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1582">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="e3cee-1583">Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1583">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1584">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.InvocationExpression> qui représente l’appel d’une expression lambda avec les arguments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1584">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1585"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1585"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1586"><paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1586"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
<span data-ttu-id="e3cee-1587">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1587">-or-</span></span> 
<span data-ttu-id="e3cee-1588">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1588">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1589"><paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1589"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1590">Indique si l'expression prend la valeur false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1590">Returns whether the expression evaluates to false.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1591"><see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1591">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="e3cee-1592">Indique si l'expression prend la valeur false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1592">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1593">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1593">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1594"><see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1594">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1595"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1595">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-1596">Indique si l'expression prend la valeur false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1596">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1597">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1597">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1598">Indique si l'expression prend la valeur true.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1598">Returns whether the expression evaluates to true.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1599"><see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1599">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="e3cee-1600">Indique si l'expression prend la valeur true.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1600">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1601">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1601">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-1602"><see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1602">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1603"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1603">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-1604">Indique si l'expression prend la valeur true.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1604">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1605">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1605">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1606">Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1606">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e3cee-1607">Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type void et aucun nom.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1607">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and no name.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1608">Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1608">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-1609">L’exemple suivant montre comment créer une expression qui contienne un <xref:System.Linq.Expressions.LabelTarget> objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1609">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LabelTarget> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-1610"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1610">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <summary><span data-ttu-id="e3cee-1611">Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette sans valeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1611">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label without a default value.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1612"><see cref="T:System.Linq.Expressions.LabelExpression" /> sans valeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1612">A <see cref="T:System.Linq.Expressions.LabelExpression" /> without a default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="e3cee-1613">Nom de l'étiquette.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1613">The name of the label.</span></span></param>
        <summary><span data-ttu-id="e3cee-1614">Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et le nom donné.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1614">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and the given name.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1615">Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1615">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-1616">Type de valeur passée lors de l'accès à l'étiquette.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1616">The type of value that is passed when jumping to the label.</span></span></param>
        <summary><span data-ttu-id="e3cee-1617">Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type donné.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1617">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1618">Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1618">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-1619">L’exemple suivant montre comment utiliser un <xref:System.Linq.Expressions.LabelTarget> objet dans une expression de boucle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1619">The following example demonstrates how to use a <xref:System.Linq.Expressions.LabelTarget> object in a loop expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-1620"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1620">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <param name="defaultValue"><span data-ttu-id="e3cee-1621">Valeur de ce <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via un flux de contrôle normal.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1621">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow.</span></span></param>
        <summary><span data-ttu-id="e3cee-1622">Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette avec la valeur par défaut donnée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1622">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label with the given default value.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1623"><see cref="T:System.Linq.Expressions.LabelExpression" /> avec la valeur par défaut donnée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1623">A <see cref="T:System.Linq.Expressions.LabelExpression" /> with the given default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-1624">Type de valeur passée lors de l'accès à l'étiquette.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1624">The type of value that is passed when jumping to the label.</span></span></param>
        <param name="name"><span data-ttu-id="e3cee-1625">Nom de l'étiquette.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1625">The name of the label.</span></span></param>
        <summary><span data-ttu-id="e3cee-1626">Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type et le nom donnés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1626">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type and name.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1627">Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1627">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1628">Crée une arborescence d'expression qui représente une expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1628">Creates an expression tree that represents a lambda expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-1629"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1629">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1630"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1630">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1631">Crée un LambdaExpression en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1631">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1632"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1632">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-1633"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1633">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1634">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1634">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1635">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1635">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1636"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1636">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1637">Le `parameters` paramètre ne doit pas avoir plus de seize éléments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1637">The `parameters` parameter must not have more than sixteen elements.</span></span>  
  
 <span data-ttu-id="e3cee-1638">Les éléments de `parameters` doit être égal aux expressions de paramètre de la référence `body`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1638">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="e3cee-1639">Cette méthode construit un type délégué approprié parmi les `System.Func` délégués génériques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1639">This method constructs an appropriate delegate type from one of the `System.Func` generic delegates.</span></span> <span data-ttu-id="e3cee-1640">Il passe ensuite le type de délégué à un de le <xref:System.Linq.Expressions.ExpressionType.Lambda> des méthodes de fabrique pour créer un <xref:System.Linq.Expressions.LambdaExpression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1640">It then passes the delegate type to one of the <xref:System.Linq.Expressions.ExpressionType.Lambda> factory methods to create a <xref:System.Linq.Expressions.LambdaExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1641"><paramref name="body" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1641"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-1642">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1642">-or-</span></span> 
<span data-ttu-id="e3cee-1643">Un ou plusieurs éléments de <paramref name="parameters" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1643">One or more elements of <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1644"><paramref name="parameters" /> contient plus de seize éléments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1644"><paramref name="parameters" /> contains more than sixteen elements.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-1645"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1645">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="e3cee-1646"><see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1646">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1647"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1647">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1648">Crée un LambdaExpression en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1648">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1649"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1649">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-1650"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1650">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="e3cee-1651"><see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1651">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1652">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1652">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1653">Crée un LambdaExpression en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1653">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1654"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1654">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-1655"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1655">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="e3cee-1656">Nom de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1656">The name for the lambda.</span></span> <span data-ttu-id="e3cee-1657">Utilisé pour l'émission des informations de débogage.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1657">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1658"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1659">Crée un LambdaExpression en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1659">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1660"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1660">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-1661"><see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1661">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-1662"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1662">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1663"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1663">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1664">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1664">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span> <span data-ttu-id="e3cee-1665">Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1665">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1666">Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1666">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1667">L’objet qui est retourné à partir de cette fonction est de type <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1667">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="e3cee-1668">Le <xref:System.Linq.Expressions.LambdaExpression> type est utilisé pour représenter l’objet retourné, car le type concret de l’expression lambda n’est pas connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1668">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="e3cee-1669">Le nombre de paramètres pour le type délégué représenté par`delegateType` doit être égale à la longueur de `parameters`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1669">The number of parameters for the delegate type represented by`delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="e3cee-1670">Les éléments de `parameters` doit être égal aux expressions de paramètre de la référence `body`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1670">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="e3cee-1671">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de l’objet résultant est égale à `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1671">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="e3cee-1672">Si `parameters` est `null`, le <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriété de l’objet résultant est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1672">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1673">L’exemple suivant montre comment créer une expression qui représente une expression lambda qui ajoute 1 à l’argument passé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1673">The following example demonstrates how to create an expression that represents a lambda expression that adds 1 to the passed argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1674"><paramref name="delegateType" /> ou <paramref name="body" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1674"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-1675">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1675">-or-</span></span> 
<span data-ttu-id="e3cee-1676">Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1676">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1677"><paramref name="delegateType" /> ne représente pas un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1677"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
<span data-ttu-id="e3cee-1678">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1678">-or-</span></span> 
 <span data-ttu-id="e3cee-1679"><paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1679"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="e3cee-1680">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1680">-or-</span></span> 
 <span data-ttu-id="e3cee-1681"><paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1681"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="e3cee-1682">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1682">-or-</span></span> 
<span data-ttu-id="e3cee-1683">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1683">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-1684"><see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1684">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-1685"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1685">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1686">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1686">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1687">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1687">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span> <span data-ttu-id="e3cee-1688">Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1688">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1689">Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1689">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1690">L’objet qui est retourné à partir de cette fonction est de type <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1690">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="e3cee-1691">Le <xref:System.Linq.Expressions.LambdaExpression> type est utilisé pour représenter l’objet retourné, car le type concret de l’expression lambda n’est pas connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1691">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="e3cee-1692">Le nombre de paramètres pour le type délégué représenté par `delegateType` doit être égale à la longueur de `parameters`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1692">The number of parameters for the delegate type represented by `delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="e3cee-1693">Les éléments de `parameters` doit être égal aux expressions de paramètre de la référence `body`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1693">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="e3cee-1694">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de l’objet résultant est égale à `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1694">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="e3cee-1695">Si `parameters` est `null`, le <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriété de l’objet résultant est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1695">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1696"><paramref name="delegateType" /> ou <paramref name="body" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1696"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-1697">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1697">-or-</span></span> 
<span data-ttu-id="e3cee-1698">Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1698">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1699"><paramref name="delegateType" /> ne représente pas un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1699"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
<span data-ttu-id="e3cee-1700">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1700">-or-</span></span> 
 <span data-ttu-id="e3cee-1701"><paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1701"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="e3cee-1702">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1702">-or-</span></span> 
 <span data-ttu-id="e3cee-1703"><paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1703"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="e3cee-1704">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1704">-or-</span></span> 
<span data-ttu-id="e3cee-1705">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1705">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-1706"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1706">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="e3cee-1707">Nom de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1707">The name for the lambda.</span></span> <span data-ttu-id="e3cee-1708">Utilisé pour l'émission des informations de débogage.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1708">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="e3cee-1709"><see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1709">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1710"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1710">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1711">Crée un LambdaExpression en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1711">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1712"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1712">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-1713"><see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1713">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-1714"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1714">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="e3cee-1715"><see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1715">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1716"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1716">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1717">Crée un LambdaExpression en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1717">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1718"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1718">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-1719"><see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1719">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-1720"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1720">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="e3cee-1721"><see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1721">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1722">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1722">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1723">Crée un LambdaExpression en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1723">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1724"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1724">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-1725"><see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1725">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-1726"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1726">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="e3cee-1727">Nom de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1727">The name for the lambda.</span></span> <span data-ttu-id="e3cee-1728">Utilisé pour l'émission des informations de débogage.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1728">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1729"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1729">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1730">Crée un LambdaExpression en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1730">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1731"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1731">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-1732"><see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1732">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-1733"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1733">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="e3cee-1734">Nom de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1734">The name for the lambda.</span></span> <span data-ttu-id="e3cee-1735">Utilisé pour l'émission des informations de débogage.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1735">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="e3cee-1736"><see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1736">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1737"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1737">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1738">Crée un LambdaExpression en commençant par construire un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1738">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1739"><see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1739">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="e3cee-1740">Type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1740">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="e3cee-1741"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1741">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1742"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1742">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1743">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1743">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1744"><see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1744">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1745">Le nombre de paramètres pour le type délégué `TDelegate` doit être égal au nombre d’éléments dans `parameters`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1745">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="e3cee-1746">Les éléments de `parameters` doit être égal aux expressions de paramètre de la référence `body`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1746">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="e3cee-1747">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de l’objet résultant représente le type `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1747">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="e3cee-1748">Si `parameters` est `null`, le <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriété de l’objet résultant est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1748">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1749"><paramref name="body" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1749"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-1750">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1750">-or-</span></span> 
<span data-ttu-id="e3cee-1751">Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1751">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1752"><paramref name="TDelegate" /> n'est pas un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1752"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
<span data-ttu-id="e3cee-1753">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1753">-or-</span></span> 
 <span data-ttu-id="e3cee-1754"><paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1754"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="e3cee-1755">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1755">-or-</span></span> 
 <span data-ttu-id="e3cee-1756"><paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1756"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="e3cee-1757">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1757">-or-</span></span> 
<span data-ttu-id="e3cee-1758">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1758">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="e3cee-1759">Type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1759">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="e3cee-1760"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1760">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1761">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1761">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1762">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1762">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1763"><see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1763">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1764">Le nombre de paramètres pour le type délégué `TDelegate` doit être égal au nombre d’éléments dans `parameters`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1764">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="e3cee-1765">Les éléments de `parameters` doit être égal aux expressions de paramètre de la référence`body`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1765">The elements of `parameters` must be reference equal to the parameter expressions in`body`.</span></span>  
  
 <span data-ttu-id="e3cee-1766">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de l’objet résultant représente le type `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1766">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="e3cee-1767">Si `parameters` est `null`, le <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriété de l’objet résultant est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1767">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1768"><paramref name="body" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1768"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-1769">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1769">-or-</span></span> 
<span data-ttu-id="e3cee-1770">Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1770">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1771"><paramref name="TDelegate" /> n'est pas un type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1771"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
<span data-ttu-id="e3cee-1772">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1772">-or-</span></span> 
 <span data-ttu-id="e3cee-1773"><paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1773"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="e3cee-1774">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1774">-or-</span></span> 
 <span data-ttu-id="e3cee-1775"><paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1775"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="e3cee-1776">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-1776">-or-</span></span> 
<span data-ttu-id="e3cee-1777">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1777">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="e3cee-1778">Type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1778">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="e3cee-1779"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1779">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="e3cee-1780"><see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1780">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1781"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1781">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1782">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1782">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1783"><see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1783">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="e3cee-1784">Type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1784">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="e3cee-1785"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1785">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="e3cee-1786"><see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1786">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1787">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1787">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1788">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1788">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1789"><see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1789">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="e3cee-1790">Type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1790">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="e3cee-1791"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1791">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="e3cee-1792">Nom de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1792">The name of the lambda.</span></span> <span data-ttu-id="e3cee-1793">Utilisé pour la génération des informations de débogage.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1793">Used for generating debugging information.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1794"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1794">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1795">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1795">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1796"><see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1796">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="e3cee-1797">Type délégué.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1797">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="e3cee-1798"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1798">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="e3cee-1799">Nom de l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1799">The name of the lambda.</span></span> <span data-ttu-id="e3cee-1800">Utilisé pour la génération des informations de débogage.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1800">Used for generating debugging info.</span></span></param>
        <param name="tailCall"><span data-ttu-id="e3cee-1801"><see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1801">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="e3cee-1802"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1802">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-1803">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1803">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1804"><see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1804">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1805">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1805">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1806"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1806">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1807"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1807">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1808">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1808">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1809"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1809">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1810">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1810">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1811">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1811">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1812">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1812">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-1813">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1813">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-1814">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1814">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1815">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1815">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1816">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1816">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1817">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1817">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1818">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de décalage vers la gauche, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1818">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1819">Sinon, si `left`. Le type est un type intégral (un des <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou les types nullables correspondants) et `right`. Est de type <xref:System.Int32>, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1819">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1820">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1820">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1821">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1821">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1822">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1822">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1823">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1823">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1824">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1824">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-1825">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1825">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1826">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1826">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-1827">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1827">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1828">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1828">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1829">Le type du nœud est le type de résultat de l’opérateur de décalage vers la gauche prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1829">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="e3cee-1830">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1830">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1831">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de décalage vers la gauche prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1831">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1832"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1832"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1833">L'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1833">The left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1834"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1834">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1835"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1835">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1836"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1836">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1837">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1837">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1838"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1838">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1839">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1839">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1840">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1840">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1841">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1841">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-1842">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1842">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-1843">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1843">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1844">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1844">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1845">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1845">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1846">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1846">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1847">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1847">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-1848">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de décalage vers la gauche, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1848">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1849">Sinon, si `left`. Le type est un type intégral (un des <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou les types nullables correspondants) et `right`. Est de type <xref:System.Int32>, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1849">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1850">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1850">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1851">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1851">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1852">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1852">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1853">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1853">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1854">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1854">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-1855">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1855">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1856">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1856">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-1857">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1857">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1858">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1858">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1859">Le type du nœud est le type de résultat de l’opérateur de décalage vers la gauche prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1859">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="e3cee-1860">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1860">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1861">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de décalage vers la gauche prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1861">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1862"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1862"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1863"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1863"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1864"><paramref name="method" /> est <see langword="null" /> et l'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1864"><paramref name="method" /> is <see langword="null" /> and the left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1865">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1865">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1866"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1866">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1867"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1867">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1868">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1868">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1869"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1869">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1870"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1870">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1871"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1871">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1872"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1872">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1873">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1873">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1874"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1874">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1875"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1875">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1876"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1876">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1877"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1877">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-1878"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1878">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1879">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1879">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1880"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1880">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1881">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "inférieur à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1881">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1882"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1882">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1883"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1883">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1884">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "inférieur à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1884">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1885"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1885">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1886">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1886">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1887">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1887">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1888">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1888">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="e3cee-1889">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1889">Otherwise, it is `false`.</span></span> <span data-ttu-id="e3cee-1890">La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1890">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="e3cee-1891">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1891">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1892">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1892">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1893">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1893">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1894">La méthode d’implémentation pour l’opération est choisie en fonction des règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1894">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="e3cee-1895">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « inférieur à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1895">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1896">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1896">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1897">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1897">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1898">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1898">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1899">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1899">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1900">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1900">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1901">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1901">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="e3cee-1902">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1902">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1903">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1903">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1904">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1904">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1905">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1905">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1906">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1906">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-1907">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1907">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1908">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1908">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1909">L’exemple de code suivant montre comment créer une expression qui compare deux entiers.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1909">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1910"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1910"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1911">L'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1911">The "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1912"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1912">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1913"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1913">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="e3cee-1914"><see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1914"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1915"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1915">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1916">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "inférieur à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1916">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1917"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1917">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1918">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1918">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1919">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1919">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1920">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1920">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="e3cee-1921">Sinon, elles sont toutes deux `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1921">Otherwise, they are both `false`.</span></span> <span data-ttu-id="e3cee-1922">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1922">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1923">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1923">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1924">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1924">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1925">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1925">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1926">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1926">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1927">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « inférieur à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1927">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1928">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1928">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1929">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1929">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1930">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1930">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1931">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1931">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1932">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1932">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1933">Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1933">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="e3cee-1934">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1934">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1935">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1935">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1936">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1936">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1937">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1937">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1938">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1938">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-1939">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1939">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1940">Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1940">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1941"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1941"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-1942"><paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1942"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1943"><paramref name="method" /> est <see langword="null" /> et l'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1943"><paramref name="method" /> is <see langword="null" /> and the "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-1944">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "inférieur ou égal à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1944">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1945"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1945">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1946"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1946">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1947">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique "inférieur ou égal à".</span><span class="sxs-lookup"><span data-stu-id="e3cee-1947">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1948"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1948">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1949">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1949">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1950">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1950">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1951">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1951">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="e3cee-1952">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1952">Otherwise, it is `false`.</span></span> <span data-ttu-id="e3cee-1953">La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1953">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="e3cee-1954">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1954">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1955">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1955">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1956">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1956">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1957">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1957">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1958">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « inférieur ou égal à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1958">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1959">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1959">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1960">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1960">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1961">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1961">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1962">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1962">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1963">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1963">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1964">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1964">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="e3cee-1965">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1965">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1966">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1966">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1967">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1967">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1968">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1968">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1969">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1969">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-1970">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1970">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-1971">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1971">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-1972">L’exemple de code suivant montre comment créer une expression qui compare deux entiers.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1972">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-1973"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1973"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-1974">L'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1974">The "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-1975"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1975">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-1976"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1976">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="e3cee-1977"><see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1977"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-1978"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1978">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-1979">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</span><span class="sxs-lookup"><span data-stu-id="e3cee-1979">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-1980"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1980">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-1981">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1981">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-1982">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1982">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-1983">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1983">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="e3cee-1984">Sinon, elles sont toutes deux `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1984">Otherwise, they are both `false`.</span></span> <span data-ttu-id="e3cee-1985">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1985">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-1986">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1986">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-1987">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-1987">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-1988">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-1988">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-1989">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1989">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1990">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « inférieur ou égal à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1990">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1991">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1991">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-1992">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-1992">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-1993">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1993">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-1994">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1994">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-1995">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1995">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-1996">Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1996">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="e3cee-1997">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1997">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-1998">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-1998">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-1999">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-1999">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2000">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2000">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2001">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2001">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-2002">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2002">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-2003">Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2003">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2004"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2004"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2005"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2005"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2006"><paramref name="method" /> est <see langword="null" /> et l'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2006"><paramref name="method" /> is <see langword="null" /> and the "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2007">Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2007">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="e3cee-2008"><see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2008">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2009"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2009">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2010">Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2010">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2011"><see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2011">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2012"><paramref name="member" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2012"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2013">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2013">-or-</span></span> 
<span data-ttu-id="e3cee-2014">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2014">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2015"><paramref name="member" /> ne représente pas un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2015"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="e3cee-2016">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2016">-or-</span></span> 
<span data-ttu-id="e3cee-2017">Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2017">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="e3cee-2018"><see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2018">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2019">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2019">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2020">Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2020">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2021"><see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2021">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2022"><paramref name="member" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2022"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2023">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2023">-or-</span></span> 
<span data-ttu-id="e3cee-2024">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2024">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2025"><paramref name="member" /> ne représente pas un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2025"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="e3cee-2026">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2026">-or-</span></span> 
<span data-ttu-id="e3cee-2027">Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2027">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="e3cee-2028"><see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2028">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2029"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2029">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2030">Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2030">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2031"><see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2031">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2032"><paramref name="propertyAccessor" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2032"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2033">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2033">-or-</span></span> 
<span data-ttu-id="e3cee-2034">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2034">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2035"><paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2035"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="e3cee-2036">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2036">-or-</span></span> 
<span data-ttu-id="e3cee-2037">Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2037">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="e3cee-2038"><see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2038">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2039">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2039">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2040">Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2040">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2041"><see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2041">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2042"><paramref name="propertyAccessor" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2042"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2043">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2043">-or-</span></span> 
<span data-ttu-id="e3cee-2044">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2044">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2045"><paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2045"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="e3cee-2046">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2046">-or-</span></span> 
<span data-ttu-id="e3cee-2047">Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2047">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2048">Crée une <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2048">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="e3cee-2049"><see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2049">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2050"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2050">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2051">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2051">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2052"><see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2052">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2053">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2053">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="e3cee-2054">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2054">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2055">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.ListInitExpression> qui représente l’initialisation d’une nouvelle instance de dictionnaire avec deux paires clé-valeur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2055">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2056"><paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2056"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2057">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2057">-or-</span></span> 
<span data-ttu-id="e3cee-2058">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2058">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2059"><paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2059"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="e3cee-2060"><see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2060">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2061"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2061">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2062">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée "Add" pour ajouter des éléments à une collection.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2062">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2063"><see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2063">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2064">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2064">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="e3cee-2065">Pour pouvoir utiliser cette surcharge de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Type ou son type de base doit déclarer une méthode unique nommée « Add » (non respect de la casse) qui prend exactement un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2065">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="e3cee-2066">Le type de l’argument doit être assignable à partir du type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du premier élément de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2066">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="e3cee-2067">Le <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriété de retourné <xref:System.Linq.Expressions.ListInitExpression> contient un élément de type <xref:System.Linq.Expressions.ElementInit> pour chaque élément de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2067">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="e3cee-2068">Le <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est une collection de singletons qui contient l’élément correspondant de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2068">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="e3cee-2069">Le <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> représente la méthode add qui a été détectée sur `newExpression`. Type ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2069">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="e3cee-2070">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2070">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2071"><paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2071"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2072">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2072">-or-</span></span> 
<span data-ttu-id="e3cee-2073">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2073">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2074"><paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2074"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2075">Il n’existe aucune méthode d’instance nommée « Add » (non-respect de la casse) déclaré dans <paramref name="newExpression" />.Type ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2075">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="e3cee-2076">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2076">-or-</span></span> 
<span data-ttu-id="e3cee-2077">La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2077">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
<span data-ttu-id="e3cee-2078">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2078">-or-</span></span> 
<span data-ttu-id="e3cee-2079">Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> n’est pas affectable au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2079">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="e3cee-2080">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2080">-or-</span></span> 
<span data-ttu-id="e3cee-2081">Il existe plusieurs méthodes compatibles à l'argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2081">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="e3cee-2082"><see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2082">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2083">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2083">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2084">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2084">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2085"><see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2085">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2086">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2086">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="e3cee-2087">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2087">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2088">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.ListInitExpression> qui représente l’initialisation d’une nouvelle instance de dictionnaire avec deux paires clé-valeur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2088">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2089"><paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2089"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2090">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2090">-or-</span></span> 
<span data-ttu-id="e3cee-2091">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2091">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2092"><paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2092"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="e3cee-2093"><see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2093">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2094">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2094">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2095">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée "Add" pour ajouter des éléments à une collection.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2095">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2096"><see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2096">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2097">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2097">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="e3cee-2098">Pour pouvoir utiliser cette surcharge de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Type ou son type de base doit déclarer une méthode unique nommée « Add » (non respect de la casse) qui prend exactement un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2098">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="e3cee-2099">Le type de l’argument doit être assignable à partir du type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du premier élément de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2099">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="e3cee-2100">Le <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriété de retourné <xref:System.Linq.Expressions.ListInitExpression> contient un élément de type <xref:System.Linq.Expressions.ElementInit> pour chaque élément de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2100">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="e3cee-2101">Le <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est une collection de singletons qui contient l’élément correspondant de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2101">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="e3cee-2102">Le <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> représente la méthode add qui a été détectée sur `newExpression`. Type ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2102">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="e3cee-2103">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2103">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2104"><paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2104"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2105">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2105">-or-</span></span> 
<span data-ttu-id="e3cee-2106">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2106">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2107"><paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2107"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2108">Il n’existe aucune méthode d’instance nommée « Add » (non-respect de la casse) déclaré dans <paramref name="newExpression" />.Type ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2108">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="e3cee-2109">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2109">-or-</span></span> 
<span data-ttu-id="e3cee-2110">La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2110">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
<span data-ttu-id="e3cee-2111">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2111">-or-</span></span> 
<span data-ttu-id="e3cee-2112">Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> n’est pas affectable au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2112">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="e3cee-2113">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2113">-or-</span></span> 
<span data-ttu-id="e3cee-2114">Il existe plusieurs méthodes compatibles à l'argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2114">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="e3cee-2115"><see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2115">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="e3cee-2116"><see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance nommée "Add" (non respect de la casse), qui ajoute un élément à une collection.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2116">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method named "Add" (case insensitive), that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2117"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2117">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2118">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2118">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2119"><see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2119">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2120">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2120">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="e3cee-2121">Si `addMethod` est `null`, `newExpression`. Type ou son type de base doit déclarer une méthode unique nommée « Add » (non respect de la casse) qui prend exactement un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2121">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="e3cee-2122">Si `addMethod` n’est pas `null`, il doit représenter une méthode d’instance nommée « Add » (non respect de la casse) qui a un seul paramètre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2122">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="e3cee-2123">Le type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `initializers` doit être assignable au type d’argument de la méthode add.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2123">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="e3cee-2124">Le <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriété de retourné <xref:System.Linq.Expressions.ListInitExpression> contient un élément de type <xref:System.Linq.Expressions.ElementInit> pour chaque élément de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2124">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="e3cee-2125">Le <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est une collection de singletons qui contient l’élément correspondant de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2125">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="e3cee-2126">Le <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est égal à `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2126">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="e3cee-2127">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2127">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2128"><paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2128"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2129">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2129">-or-</span></span> 
<span data-ttu-id="e3cee-2130">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2130">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2131"><paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2131"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
<span data-ttu-id="e3cee-2132">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2132">-or-</span></span> 
 <span data-ttu-id="e3cee-2133"><paramref name="addMethod" /> n'est pas <see langword="null" /> et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2133"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
<span data-ttu-id="e3cee-2134">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2134">-or-</span></span> 
 <span data-ttu-id="e3cee-2135"><paramref name="addMethod" /> n'est pas <see langword="null" /> et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2135"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2136"><paramref name="addMethod" /> est <see langword="null" /> et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2136"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="e3cee-2137"><see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2137">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="e3cee-2138"><see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance prenant un argument, qui ajoute un élément à une collection.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2138">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that takes one argument, that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2139">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2139">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2140">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2140">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2141"><see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2141">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2142">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2142">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="e3cee-2143">Si `addMethod` est `null`, `newExpression`. Type ou son type de base doit déclarer une méthode unique nommée « Add » (non respect de la casse) qui prend exactement un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2143">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="e3cee-2144">Si `addMethod` n’est pas `null`, il doit représenter une méthode d’instance nommée « Add » (non respect de la casse) qui a un seul paramètre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2144">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="e3cee-2145">Le type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `initializers` doit être assignable au type d’argument de la méthode add.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2145">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="e3cee-2146">Le <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriété de retourné <xref:System.Linq.Expressions.ListInitExpression> contient un élément de type <xref:System.Linq.Expressions.ElementInit> pour chaque élément de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2146">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="e3cee-2147">Le <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est une collection de singletons qui contient l’élément correspondant de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2147">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="e3cee-2148">Le <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est égal à `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2148">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="e3cee-2149">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2149">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2150"><paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2150"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2151">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2151">-or-</span></span> 
<span data-ttu-id="e3cee-2152">Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2152">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2153"><paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2153"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
<span data-ttu-id="e3cee-2154">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2154">-or-</span></span> 
 <span data-ttu-id="e3cee-2155"><paramref name="addMethod" /> n'est pas <see langword="null" /> et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2155"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
<span data-ttu-id="e3cee-2156">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2156">-or-</span></span> 
 <span data-ttu-id="e3cee-2157"><paramref name="addMethod" /> n'est pas <see langword="null" /> et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2157"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2158"><paramref name="addMethod" /> est <see langword="null" /> et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2158"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2159">Crée une <see cref="T:System.Linq.Expressions.LoopExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2159">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-2160">Corps de la boucle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2160">The body of the loop.</span></span></param>
        <summary><span data-ttu-id="e3cee-2161">Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2161">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2162">Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2162">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-2163">Corps de la boucle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2163">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="e3cee-2164">Cible d'instruction Break utilisée par le corps de la boucle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2164">The break target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="e3cee-2165">Crée un objet <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps et la cible d'instruction Break donnés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2165">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body and break target.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2166">Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2166">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-2167">L’exemple suivant montre comment créer une expression de bloc qui contienne un <xref:System.Linq.Expressions.LoopExpression> objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2167">The following example demonstrates how to create a block expression that contains a <xref:System.Linq.Expressions.LoopExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-2168">Corps de la boucle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2168">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="e3cee-2169">Cible d'instruction Break utilisée par le corps de la boucle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2169">The break target used by the loop body.</span></span></param>
        <param name="continue"><span data-ttu-id="e3cee-2170">Cible d'instruction Continue utilisée par le corps de la boucle.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2170">The continue target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="e3cee-2171">Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2171">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2172">Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2172">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2173">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> en appelant la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2173">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="e3cee-2174"><see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2174">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="e3cee-2175"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2175">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2176"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2176">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <summary><span data-ttu-id="e3cee-2177">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, à partir des opérandes gauche et droit, en appelant une méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2177">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2178"><see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2178">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2179">Le `binaryType` paramètre détermine les <xref:System.Linq.Expressions.BinaryExpression> méthode de fabrique appelle cette méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2179">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method calls.</span></span> <span data-ttu-id="e3cee-2180">Par exemple, si `binaryType` est <xref:System.Linq.Expressions.ExpressionType.Subtract>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2180">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2181">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> méthode pour créer un <xref:System.Linq.Expressions.BinaryExpression> qui représente la soustraction d’un nombre à partir d’un autre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2181">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> method to create a <xref:System.Linq.Expressions.BinaryExpression> that represents the subtraction of one number from another.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2182"><paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2182"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2183"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2183"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="e3cee-2184"><see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2184">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="e3cee-2185"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2185">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2186"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2186">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="e3cee-2187"><see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2187"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2188"><see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2188">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-2189">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit et la méthode d'implémentation, en appelant la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2189">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2190"><see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2190">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2191">Le `binaryType` paramètre détermine les <xref:System.Linq.Expressions.BinaryExpression> méthode de fabrique appellera cette méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2191">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="e3cee-2192">Par exemple, si `binaryType` est <xref:System.Linq.Expressions.ExpressionType.Subtract>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2192">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="e3cee-2193">Le `liftToNull` et `method` paramètres sont ignorés si la méthode de fabrique appropriée n’a pas de paramètre correspondant.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2193">The `liftToNull` and `method` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2194"><paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2194"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2195"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2195"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="e3cee-2196"><see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2196">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="e3cee-2197"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2197">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2198"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2198">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="e3cee-2199"><see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2199"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2200"><see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2200">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-2201"><see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2201">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function.</span></span> <span data-ttu-id="e3cee-2202">Ce paramètre est utilisé uniquement si <paramref name="binaryType" /> a la valeur <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou une assignation composée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2202">This parameter is used only if <paramref name="binaryType" /> is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> or compound assignment.</span></span></param>
        <summary><span data-ttu-id="e3cee-2203">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit, la méthode d'implémentation et la fonction de conversion de type, en appelant la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2203">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2204"><see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2204">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2205">Le `binaryType` paramètre détermine les <xref:System.Linq.Expressions.BinaryExpression> méthode de fabrique appellera cette méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2205">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="e3cee-2206">Par exemple, si `binaryType` est <xref:System.Linq.Expressions.ExpressionType.Subtract>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2206">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="e3cee-2207">Le `liftToNull`, `method` et `conversion` paramètres sont ignorés si la méthode de fabrique appropriée n’a pas de paramètre correspondant.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2207">The `liftToNull`, `method` and `conversion` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2208"><paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2208"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2209"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2209"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-2210">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2210">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="variable"><span data-ttu-id="e3cee-2211"><see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2211">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-2212">Corps de l'instruction Catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2212">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="e3cee-2213">Corps du filtre <see cref="T:System.Exception" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2213">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="e3cee-2214">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec les éléments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2214">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2215">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2215">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2216">`type` doit être non null et correspondre au type de `variable` (si elle est fournie).</span><span class="sxs-lookup"><span data-stu-id="e3cee-2216">`type` must be non-null and match the type of `variable` (if it is supplied).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2217">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2217">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-2218">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2218">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="e3cee-2219">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2219">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-2220">Arguments de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2220">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-2221">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2221">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2222"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2222">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-2223">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2223">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="e3cee-2224">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2224">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-2225">Argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2225">The argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-2226">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et un argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2226">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2227"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2227">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-2228">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2228">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="e3cee-2229">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2229">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-2230">Arguments de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2230">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-2231">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2231">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2232"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2232">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-2233">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2233">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="e3cee-2234">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2234">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-2235">Premier argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2235">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-2236">Deuxième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2236">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-2237">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et deux arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2237">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2238"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2238">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-2239">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2239">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="e3cee-2240">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2240">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-2241">Premier argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2241">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-2242">Deuxième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2242">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-2243">Troisième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2243">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-2244">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et trois arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2244">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2245"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2245">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e3cee-2246">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2246">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="e3cee-2247">Classeur de runtime de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2247">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="e3cee-2248">Premier argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2248">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="e3cee-2249">Deuxième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2249">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="e3cee-2250">Troisième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2250">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="e3cee-2251">Quatrième argument de l'opération dynamique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2251">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="e3cee-2252">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et quatre arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2252">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2253"><see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2253">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind"><span data-ttu-id="e3cee-2254"><see cref="T:System.Linq.Expressions.GotoExpressionKind" /> de <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2254">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</span></span></param>
        <param name="target"><span data-ttu-id="e3cee-2255"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2255">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="e3cee-2256">Valeur qui sera passée à l'étiquette associée au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2256">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-2257"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2257">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2258">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut du <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2258">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span></span> <span data-ttu-id="e3cee-2259">La valeur passée à l'étiquette au moment du saut peut également être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2259">The value passed to the label upon jumping can also be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2260"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à <paramref name="kind" />, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2260">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to <paramref name="kind" />, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-2261">Objet auquel la propriété appartient.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2261">The object to which the property belongs.</span></span> <span data-ttu-id="e3cee-2262">Doit avoir la valeur Null si la propriété est <see langword="static" /> (<see langword="shared" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e3cee-2262">It should be null if the property is <see langword="static" /> (<see langword="shared" /> in Visual Basic).</span></span></param>
        <param name="indexer"><span data-ttu-id="e3cee-2263"><see cref="T:System.Linq.Expressions.Expression" /> qui représente la propriété à indexer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2263">An <see cref="T:System.Linq.Expressions.Expression" /> representing the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-2264"><c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> en Visual Basic) contenant les arguments qui seront utilisés pour indexer la propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2264">An <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> in Visual Basic) that contains the arguments that will be used to index the property.</span></span></param>
        <summary><span data-ttu-id="e3cee-2265">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée dans un objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2265">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> that represents accessing an indexed property in an object.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2266">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2266">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-2267"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet auquel appartient le membre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2267">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the object that the member belongs to.</span></span> <span data-ttu-id="e3cee-2268">Cette valeur peut être null pour les membres statiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2268">This can be null for static members.</span></span></param>
        <param name="member"><span data-ttu-id="e3cee-2269"><see cref="T:System.Reflection.MemberInfo" /> qui décrit le champ ou la propriété auquel accéder.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2269">The <see cref="T:System.Reflection.MemberInfo" /> that describes the field or property to be accessed.</span></span></param>
        <summary><span data-ttu-id="e3cee-2270">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ ou à une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2270">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing either a field or a property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2271"><see cref="T:System.Linq.Expressions.MemberExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2271">The <see cref="T:System.Linq.Expressions.MemberExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2272">Cette méthode peut être utilisée pour créer un <xref:System.Linq.Expressions.MemberExpression> qui représente l’accès à un champ ou une propriété, selon le type de `member`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2272">This method can be used to create a <xref:System.Linq.Expressions.MemberExpression> that represents accessing either a field or a property, depending on the type of `member`.</span></span> <span data-ttu-id="e3cee-2273">Si `member` est de type <xref:System.Reflection.FieldInfo>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Field%2A> pour créer le <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2273">If `member` is of type <xref:System.Reflection.FieldInfo>, this method calls <xref:System.Linq.Expressions.Expression.Field%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span> <span data-ttu-id="e3cee-2274">Si `member` est de type <xref:System.Reflection.PropertyInfo>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Property%2A> pour créer le <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2274">If `member` is of type <xref:System.Reflection.PropertyInfo>, this method calls <xref:System.Linq.Expressions.Expression.Property%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2275"><paramref name="member" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2275"><paramref name="member" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2276"><paramref name="member" /> ne représente pas un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2276"><paramref name="member" /> does not represent a field or property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-2277">Type de résultat de l'expression Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2277">The result type of the try expression.</span></span> <span data-ttu-id="e3cee-2278">Si Null, le corps et tous les gestionnaires doivent avoir le même type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2278">If null, bodh and all handlers must have identical type.</span></span></param>
        <param name="body"><span data-ttu-id="e3cee-2279">Corps du bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2279">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="e3cee-2280">Corps du bloc Finally.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2280">The body of the finally block.</span></span> <span data-ttu-id="e3cee-2281">Passez la valeur Null si aucun bloc Finally n'est associé au bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2281">Pass null if the try block has no finally block associated with it.</span></span></param>
        <param name="fault"><span data-ttu-id="e3cee-2282">Corps du bloc Fault.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2282">The body of the fault block.</span></span> <span data-ttu-id="e3cee-2283">Passez la valeur Null si aucun bloc Fault n'est associé au bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2283">Pass null if the try block has no fault block associated with it.</span></span></param>
        <param name="handlers"><span data-ttu-id="e3cee-2284">Collection de <see cref="T:System.Linq.Expressions.CatchBlock" />s qui représente les instructions catch à associer au bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2284">A collection of <see cref="T:System.Linq.Expressions.CatchBlock" />s representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="e3cee-2285">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc Try avec les éléments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2285">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2286">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2286">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2287">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> en appelant la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2287">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="e3cee-2288"><see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2288">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="e3cee-2289"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2289">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-2290"><see cref="T:System.Type" /> qui spécifie le type de conversion (passez <see langword="null" /> le cas échéant).</span><span class="sxs-lookup"><span data-stu-id="e3cee-2290">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <summary><span data-ttu-id="e3cee-2291">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande, en appelant la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2291">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2292"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2292">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2293">Le `unaryType` paramètre détermine les <xref:System.Linq.Expressions.UnaryExpression> méthode de fabrique appelle cette méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2293">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="e3cee-2294">Par exemple, si `unaryType` est égal à <xref:System.Linq.Expressions.ExpressionType.Convert>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2294">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="e3cee-2295">Le `type`paramètre est ignoré si elle ne s’applique pas à la méthode de fabrique est appelée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2295">The `type`parameter is ignored if it does not apply to the factory method that is called.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2296"><paramref name="operand" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2296"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2297"><paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2297"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="e3cee-2298"><see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2298">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="e3cee-2299"><see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2299">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-2300"><see cref="T:System.Type" /> qui spécifie le type vers lequel convertir (passez <see langword="null" />, si non applicable).</span><span class="sxs-lookup"><span data-stu-id="e3cee-2300">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2301"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2301">The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-2302">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande et une méthode d'implémentation, en appelant la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2302">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2303"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2303">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2304">Le `unaryType` paramètre détermine les <xref:System.Linq.Expressions.UnaryExpression> méthode de fabrique appelle cette méthode.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2304">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="e3cee-2305">Par exemple, si `unaryType` est égal à <xref:System.Linq.Expressions.ExpressionType.Convert>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2305">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="e3cee-2306">Le `type` et `method` paramètres sont ignorés si elles ne s’appliquent pas à la méthode de fabrique est appelée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2306">The `type` and `method` parameters are ignored if they do not apply to the factory method that is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2307"><paramref name="operand" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2307"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2308"><paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2308"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2309">Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2309">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="e3cee-2310"><see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2310">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="e3cee-2311"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2311">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2312">Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2312">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2313"><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2313">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2314">Le `member` paramètre doit représenter un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2314">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2315"><paramref name="member" /> ou <paramref name="bindings" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2315"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2316"><paramref name="member" /> ne représente pas un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2316"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="e3cee-2317">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2317">-or-</span></span> 
<span data-ttu-id="e3cee-2318">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2318">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="e3cee-2319"><see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2319">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="e3cee-2320">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2320">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2321">Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2321">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2322"><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2322">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2323">Le `member` paramètre doit représenter un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2323">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2324"><paramref name="member" /> ou <paramref name="bindings" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2324"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2325"><paramref name="member" /> ne représente pas un champ ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2325"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="e3cee-2326">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2326">-or-</span></span> 
<span data-ttu-id="e3cee-2327">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2327">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="e3cee-2328"><see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2328">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="e3cee-2329"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2329">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2330">Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2330">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2331"><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2331">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2332"><paramref name="propertyAccessor" /> ou <paramref name="bindings" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2332"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2333"><paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2333"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="e3cee-2334">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2334">-or-</span></span> 
<span data-ttu-id="e3cee-2335">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2335">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="e3cee-2336"><see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2336">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="e3cee-2337">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2337">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2338">Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2338">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2339"><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2339">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2340"><paramref name="propertyAccessor" /> ou <paramref name="bindings" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2340"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2341"><paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2341"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="e3cee-2342">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2342">-or-</span></span> 
<span data-ttu-id="e3cee-2343">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2343">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2344">Représente une expression qui crée un nouvel objet et initialise une propriété de l'objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2344">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="e3cee-2345"><see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2345">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="e3cee-2346"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2346">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2347">Représente une expression qui crée un nouvel objet et initialise une propriété de l'objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2347">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2348"><see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2348">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2349">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberInitExpression> est égale à la <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2349">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2350">L’exemple suivant montre une expression qui crée un nouvel objet et initialise une propriété de l’objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2350">The following example demonstrates an expression that creates a new object and initializes a property of the object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2351"><paramref name="newExpression" /> ou <paramref name="bindings" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2351"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2352">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2352">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="e3cee-2353"><see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2353">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="e3cee-2354">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2354">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2355">Crée une <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2355">Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2356"><see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2356">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2357">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberInitExpression> est égale à la <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2357">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2358">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.MemberInitExpression> qui représente l’initialisation des deux membres d’un nouvel objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2358">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> method to create a <xref:System.Linq.Expressions.MemberInitExpression> that represents the initialization of two members of a new object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2359"><paramref name="newExpression" /> ou <paramref name="bindings" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2359"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2360">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2360">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2361">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2361">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2362"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2362">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2363"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2363">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2364">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2364">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2365"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2366">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2366">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-2367">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2367">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2368">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2368">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2369">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2369">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-2370">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2370">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-2371">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2371">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2372">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2372">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2373">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2373">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2374">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur modulo, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2374">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2375">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2375">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2376">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2376">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2377">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2377">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2378">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2378">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2379">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2379">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2380">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2380">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2381">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2381">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2382">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2382">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2383">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2383">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2384">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2384">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2385">Le type du nœud est le type de résultat de l’opérateur modulo prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2385">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="e3cee-2386">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2386">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-2387">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur modulo prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2387">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2388"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2388"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2389">L'opérateur modulo n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2389">The modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2390"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2390">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2391"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2391">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2392"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2392">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2393">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2393">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2394"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2395">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2395">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-2396">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2396">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2397">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2397">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2398">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2398">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-2399">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2399">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-2400">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2400">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2401">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2401">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2402">La méthode d’implémentation pour l’opération est choisie en fonction des règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2402">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="e3cee-2403">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2403">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-2404">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur modulo, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2404">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2405">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2405">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2406">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2406">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2407">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2407">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2408">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2408">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2409">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2409">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2410">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2410">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2411">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2411">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2412">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2412">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2413">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2413">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2414">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2414">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2415">Le type du nœud est le type de résultat de l’opérateur modulo prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2415">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="e3cee-2416">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2416">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-2417">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur modulo prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2417">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2418"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2418"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2419"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2419"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2420"><paramref name="method" /> est <see langword="null" /> et l'opérateur modulo n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2420"><paramref name="method" /> is <see langword="null" /> and the modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2421">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2421">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2422"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2423"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2423">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2424">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2424">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2425"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2426"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2427"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2428"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2428">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2429">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2429">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2430"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2431"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2432"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2432">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2433"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2433">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-2434"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2435">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2436"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2437">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2437">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2438"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2438">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2439"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2439">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2440">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2440">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2441"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2441">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2442">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2442">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-2443">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2443">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2444">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2444">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2445">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2445">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-2446">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2446">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-2447">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2447">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2448">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2448">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2449">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2449">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2450">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de multiplication, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2450">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2451">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2451">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2452">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2452">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2453">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2453">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2454">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2454">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2455">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2455">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2456">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2456">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2457">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2457">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2458">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2458">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2459">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2459">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2460">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2460">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2461">Le type du nœud est le type de résultat de l’opérateur de multiplication prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2461">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="e3cee-2462">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2462">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-2463">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de multiplication prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2463">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2464">L’exemple de code suivant montre comment créer une expression qui multiplie deux valeurs.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2464">The following code example shows how to create an expression that multiplies two values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2465"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2465"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2466">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2466">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2467"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2467">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2468"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2468">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2469"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2469">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2470">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2470">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2471"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2471">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2472">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2472">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-2473">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2473">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2474">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2474">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2475">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2475">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-2476">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2476">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-2477">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2477">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2478">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2478">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2479">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2479">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2480">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2480">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-2481">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de multiplication, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2481">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2482">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2482">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2483">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2483">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2484">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2484">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2485">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2485">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2486">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2486">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2487">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2487">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2488">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2488">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2489">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2489">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2490">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2490">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2491">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2491">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2492">Le type du nœud est le type de résultat de l’opérateur de multiplication prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2492">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="e3cee-2493">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2493">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-2494">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de multiplication prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2494">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2495"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2495"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2496"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2496"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2497"><paramref name="method" /> est <see langword="null" /> et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2497"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2498">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2498">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2499"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2499">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2500"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2501">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2501">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2502"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2502">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2503"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2503">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2504"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2504">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2505"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2505">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2506">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2506">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2507"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2507">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2508"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2509"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2509">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2510"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2510">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-2511"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2511">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2512">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2512">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2513"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2513">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2514">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2514">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2515"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2515">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2516"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2516">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2517">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2517">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2518"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2519"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2520"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2520">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2521"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2521">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2522">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2522">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2523"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2523">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2524"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2524">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2525"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2525">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2526"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2526">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-2527"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2527">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2528">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2528">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2529"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2529">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2530">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2530">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2531"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2532"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2533">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2533">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2534"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2535">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2535">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-2536">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2536">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2537">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2537">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2538">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2538">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-2539">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2539">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-2540">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2540">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2541">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2541">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2542">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2542">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2543">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de multiplication, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2543">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2544">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2544">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2545">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2545">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2546">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2546">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2547">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2547">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2548">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2548">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2549">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2549">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2550">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2550">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2551">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2551">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2552">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2552">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2553">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2553">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2554">Le type du nœud est le type de résultat de l’opérateur de multiplication prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2554">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="e3cee-2555">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2555">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-2556">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de multiplication prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2556">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2557"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2557"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2558">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2558">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2559"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2559">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2560"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2560">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2561"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2561">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2562">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2562">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2563"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2563">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2564">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2564">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-2565">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2565">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2566">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2566">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2567">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2567">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-2568">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2568">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-2569">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2569">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2570">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2570">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2571">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2571">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2572">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2572">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-2573">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de multiplication, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2573">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2574">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2574">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2575">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2575">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2576">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2576">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2577">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2577">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2578">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2578">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2579">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2579">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2580">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2580">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2581">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2581">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2582">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2582">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2583">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2583">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2584">Le type du nœud est le type de résultat de l’opérateur de multiplication prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2584">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="e3cee-2585">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2585">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-2586">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de multiplication prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2586">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2587"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2587"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2588"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2588"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2589"><paramref name="method" /> est <see langword="null" /> et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2589"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2590">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2590">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-2591"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2591">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2592">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2592">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2593"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2593">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2594">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2594">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-2595">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2595">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2596">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2596">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2597">Sinon, ils ont la valeur false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2597">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2598">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2598">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2599">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2599">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2600">Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur moins unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2600">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2601">Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2601">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2602">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2602">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2603">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2603">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2604">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2604">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2605">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2605">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2606">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2606">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2607">`expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2607">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2608">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2608">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2609">Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2609">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="e3cee-2610">Si `expression`. Type non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2610">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2611">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2611">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2612">L’exemple suivant montre comment créer une expression qui représente une opération de négation arithmétique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2612">The following example demonstrates how to create an expression that represents an arithmetic negation operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2613"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2613"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2614">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2614">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-2615"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2615">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2616"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2616">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2617">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2617">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2618"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2618">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2619">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2619">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-2620">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2620">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2621">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2621">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2622">Sinon, ils ont la valeur false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2622">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2623">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2623">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2624">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2624">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2625">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui prend un argument, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2625">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-2626">Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur moins unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2626">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2627">Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2627">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2628">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2628">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2629">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2629">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2630">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2630">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2631">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2631">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2632">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2632">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2633">`expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2633">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2634">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2634">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2635">Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2635">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="e3cee-2636">Si `expression`. Type non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2636">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2637">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2637">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2638"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2638"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2639"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2639"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2640"><paramref name="method" /> est <see langword="null" /> et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2640"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-2641">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2641">-or-</span></span> 
 <span data-ttu-id="e3cee-2642"><paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2642"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2643">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2643">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-2644"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2644">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2645">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2645">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2646"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2646">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2647">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2647">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-2648">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2648">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2649">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2649">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2650">Sinon, ils ont la valeur false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2650">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2651">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2651">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2652">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2652">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2653">Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur moins unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2653">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2654">Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2654">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2655">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2655">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2656">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2656">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2657">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2657">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2658">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2658">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2659">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2659">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2660">`expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2660">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2661">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2661">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2662">Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2662">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="e3cee-2663">Si `expression`. Type non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2663">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2664">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2664">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2665"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2665"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2666">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2666">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-2667"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2667">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2668"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2668">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2669">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2669">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span> <span data-ttu-id="e3cee-2670">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2670">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2671"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2671">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2672">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2672">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-2673">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2673">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2674">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2674">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2675">Sinon, ils ont la valeur false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2675">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2676">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2676">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2677">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2677">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2678">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui prend un argument, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2678">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-2679">Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur moins unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2679">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2680">Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2680">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2681">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2681">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2682">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2682">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2683">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2683">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2684">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2684">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2685">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2685">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2686">`expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2686">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2687">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2687">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2688">Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2688">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="e3cee-2689">Si `expression`. Type non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2689">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2690">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2690">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2691"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2691"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2692"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2692"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2693"><paramref name="method" /> est <see langword="null" /> et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2693"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-2694">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2694">-or-</span></span> 
 <span data-ttu-id="e3cee-2695"><paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2695"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2696">Crée une <see cref="T:System.Linq.Expressions.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2696">Creates a <see cref="T:System.Linq.Expressions.NewExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="e3cee-2697"><see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2697">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2698">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié qui ne prend pas d'arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2698">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2699"><see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2699">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2700">Le <xref:System.Linq.Expressions.NewExpression.Arguments%2A> et <xref:System.Linq.Expressions.NewExpression.Members%2A> propriétés des résultats de <xref:System.Linq.Expressions.NewExpression> sont des collections vides.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2700">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="e3cee-2701">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété représente le type de déclaration du constructeur représenté par `constructor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2701">The <xref:System.Linq.Expressions.Expression.Type%2A> property represents the declaring type of the constructor represented by `constructor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2702"><paramref name="constructor" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2702"><paramref name="constructor" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2703">Le constructeur représenté par <paramref name="constructor" /> a au moins un paramètre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2703">The constructor that <paramref name="constructor" /> represents has at least one parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-2704"><see cref="T:System.Type" /> ayant un constructeur qui ne prend pas d'arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2704">A <see cref="T:System.Type" /> that has a constructor that takes no arguments.</span></span></param>
        <summary><span data-ttu-id="e3cee-2705">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur sans paramètre du type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2705">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the parameterless constructor of the specified type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2706"><see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> égale à <see cref="T:System.Reflection.ConstructorInfo" />, laquelle représente le constructeur sans paramètre pour le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2706">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the <see cref="T:System.Reflection.ConstructorInfo" /> that represents the constructor without parameters for the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2707">Le `type` paramètre doit représenter un type qui a un constructeur sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2707">The `type` parameter must represent a type that has a constructor without parameters.</span></span>  
  
 <span data-ttu-id="e3cee-2708">Le <xref:System.Linq.Expressions.NewExpression.Arguments%2A> et <xref:System.Linq.Expressions.NewExpression.Members%2A> propriétés des résultats de <xref:System.Linq.Expressions.NewExpression> sont des collections vides.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2708">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="e3cee-2709">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est égale à `type`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2709">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2710">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.New%28System.Type%29> méthode pour créer un <xref:System.Linq.Expressions.NewExpression> qui représente la construction d’une nouvelle instance d’un objet de dictionnaire en appelant le constructeur sans paramètre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2710">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.New%28System.Type%29> method to create a <xref:System.Linq.Expressions.NewExpression> that represents constructing a new instance of a dictionary object by calling the constructor without parameters.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2711"><paramref name="type" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2711"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2712">Le type représenté par <paramref name="type" /> n'a pas de constructeur sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2712">The type that <paramref name="type" /> represents does not have a constructor without parameters.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="e3cee-2713"><see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2713">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-2714"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2714">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2715">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2715">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2716"><see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2716">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2717">Le `arguments` paramètre doit contenir le même nombre d’éléments que le nombre de paramètres pour le constructeur représenté par `constructor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2717">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="e3cee-2718">Si `arguments` est `null`, il est considéré comme vide et le <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2718">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="e3cee-2719">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> représente le type de déclaration du constructeur représenté par `constructor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2719">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="e3cee-2720">Le <xref:System.Linq.Expressions.NewExpression.Members%2A> propriété est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2720">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2721"><paramref name="constructor" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2721"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2722">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2722">-or-</span></span> 
<span data-ttu-id="e3cee-2723">Un élément de <paramref name="arguments" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2723">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2724">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2724">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="e3cee-2725">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2725">-or-</span></span> 
<span data-ttu-id="e3cee-2726">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2726">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="e3cee-2727"><see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2727">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-2728">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2728">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2729">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2729">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2730"><see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2730">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2731">Le `arguments` paramètre doit contenir le même nombre d’éléments que le nombre de paramètres pour le constructeur représenté par `constructor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2731">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="e3cee-2732">Si `arguments` est `null`, il est considéré comme vide et le <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2732">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="e3cee-2733">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> représente le type de déclaration du constructeur représenté par `constructor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2733">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="e3cee-2734">Le <xref:System.Linq.Expressions.NewExpression.Members%2A> propriété est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2734">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2735"><paramref name="constructor" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2735"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2736">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2736">-or-</span></span> 
<span data-ttu-id="e3cee-2737">Un élément de <paramref name="arguments" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2737">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2738">La longueur de <paramref name="arguments" /> correspond au nombre de paramètres du constructeur que <paramref name="constructor" /> représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2738">The length of <paramref name="arguments" /> does match the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="e3cee-2739">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2739">-or-</span></span> 
<span data-ttu-id="e3cee-2740">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2740">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="e3cee-2741"><see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2741">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-2742"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2742">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="e3cee-2743"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2743">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2744">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2744">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="e3cee-2745">Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2745">The members that access the constructor initialized fields are specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2746"><see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2746">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2747">Le `arguments` paramètre doit contenir le même nombre d’éléments que le nombre de paramètres pour le constructeur représenté par `constructor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2747">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="e3cee-2748">Si `arguments` est `null`, il est considéré comme vide et le <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2748">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="e3cee-2749">Si `members` est `null`, le <xref:System.Linq.Expressions.NewExpression.Members%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2749">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="e3cee-2750">Si `members` n’est pas `null`, il doit avoir le même nombre d’éléments en tant que `arguments` et chaque élément ne doit pas être `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2750">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="e3cee-2751">Chaque élément de `members` doit être un <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> qui représente un membre d’instance sur le type de déclaration du constructeur représenté par `constructor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2751">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="e3cee-2752">Si elle représente une propriété, la propriété doit avoir un `get` accesseur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2752">If it represents a property, the property must have a `get` accessor.</span></span> <span data-ttu-id="e3cee-2753">L’élément correspondant de `arguments` pour chaque élément de `members` doit avoir un <xref:System.Linq.Expressions.Expression.Type%2A> propriété qui représente un type qui ne peut être assigné au type du membre qui le `members` élément représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2753">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="e3cee-2754">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> représente le type de déclaration du constructeur qui `constructor` représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2754">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2755"><paramref name="constructor" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2755"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2756">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2756">-or-</span></span> 
<span data-ttu-id="e3cee-2757">Un élément de <paramref name="arguments" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2757">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2758">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2758">-or-</span></span> 
<span data-ttu-id="e3cee-2759">Un élément de <paramref name="members" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2759">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2760">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2760">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="e3cee-2761">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2761">-or-</span></span> 
<span data-ttu-id="e3cee-2762">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2762">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="e3cee-2763">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2763">-or-</span></span> 
<span data-ttu-id="e3cee-2764">Le paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2764">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
<span data-ttu-id="e3cee-2765">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2765">-or-</span></span> 
<span data-ttu-id="e3cee-2766">Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2766">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="e3cee-2767"><see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2767">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-2768"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2768">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="e3cee-2769">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2769">An array of <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2770">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2770">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="e3cee-2771">Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés sous forme de tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2771">The members that access the constructor initialized fields are specified as an array.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2772"><see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2772">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2773">Le `arguments` paramètre doit contenir le même nombre d’éléments que le nombre de paramètres pour le constructeur représenté par `constructor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2773">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="e3cee-2774">Si `arguments` est `null`, il est considéré comme vide et le <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2774">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="e3cee-2775">Si `members` est `null`, le <xref:System.Linq.Expressions.NewExpression.Members%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2775">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="e3cee-2776">Si `members` n’est pas `null`, il doit avoir le même nombre d’éléments en tant que `arguments` et chaque élément ne doit pas être `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2776">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="e3cee-2777">Chaque élément de `members` doit être un <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> qui représente un membre d’instance sur le type de déclaration du constructeur représenté par `constructor`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2777">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="e3cee-2778">Si elle représente une propriété, la propriété doit être en mesure de récupérer la valeur du champ associé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2778">If it represents a property, the property must be able to retrieve the value of the associated field.</span></span> <span data-ttu-id="e3cee-2779">L’élément correspondant de `arguments` pour chaque élément de `members` doit avoir un <xref:System.Linq.Expressions.Expression.Type%2A> propriété qui représente un type qui ne peut être assigné au type du membre qui le `members` élément représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2779">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="e3cee-2780">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> représente le type de déclaration du constructeur qui `constructor` représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2780">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2781"><paramref name="constructor" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2781"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2782">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2782">-or-</span></span> 
<span data-ttu-id="e3cee-2783">Un élément de <paramref name="arguments" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2783">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2784">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2784">-or-</span></span> 
<span data-ttu-id="e3cee-2785">Un élément de <paramref name="members" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2785">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2786">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2786">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="e3cee-2787">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2787">-or-</span></span> 
<span data-ttu-id="e3cee-2788">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2788">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="e3cee-2789">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2789">-or-</span></span> 
<span data-ttu-id="e3cee-2790">Le paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2790">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
<span data-ttu-id="e3cee-2791">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2791">-or-</span></span> 
<span data-ttu-id="e3cee-2792">Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2792">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2793">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2793">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-2794"><see cref="T:System.Type" /> qui représente le type d'élément du tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2794">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="e3cee-2795"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2795">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2796">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2796">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2797"><see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2797">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2798">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewArrayExpression> représente un type de tableau dont le rang est égal à la longueur de `bounds` et le type d’élément est `type`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2798">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="e3cee-2799">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `bounds` doit représenter un type intégral.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2799">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2800">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> méthode pour créer une arborescence d’expression qui représente la création d’un tableau de chaînes qui a un rang égal à 2.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2800">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2801"><paramref name="type" /> ou <paramref name="bounds" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2801"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2802">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2802">-or-</span></span> 
<span data-ttu-id="e3cee-2803">Un élément de <paramref name="bounds" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2803">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2804">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2804">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-2805"><see cref="T:System.Type" /> qui représente le type d'élément du tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2805">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="e3cee-2806">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2806">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2807">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2807">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2808"><see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2808">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2809">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewArrayExpression> représente un type de tableau dont le rang est égal à la longueur de `bounds` et le type d’élément est `type`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2809">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="e3cee-2810">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `bounds` doit représenter un type intégral.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2810">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2811">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> méthode pour créer une arborescence d’expression qui représente la création d’un tableau de chaînes qui a un rang égal à 2.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2811">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2812"><paramref name="type" /> ou <paramref name="bounds" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2812"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2813">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2813">-or-</span></span> 
<span data-ttu-id="e3cee-2814">Un élément de <paramref name="bounds" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2814">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2815">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2816">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2816">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-2817"><see cref="T:System.Type" /> qui représente le type d'élément du tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2817">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2818"><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2818">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2819">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2819">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2820"><see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2820">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2821">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `initializers` doit représenter un type qui ne peut être assigné au type représenté par `type`, éventuellement une fois l’opération *entre guillemets*.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2821">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3cee-2822">Un élément sera mis entre guillemets uniquement si `type` est <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2822">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="e3cee-2823">Citation signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2823">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="e3cee-2824">Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2824">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="e3cee-2825">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewArrayExpression> représente un type de tableau dont le rang est 1 et dont le type élément est `type`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2826">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> méthode pour créer une arborescence d’expression qui représente la création d’un tableau de chaînes unidimensionnel qui est initialisé avec une liste d’expressions de chaîne.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2826">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2827"><paramref name="type" /> ou <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2827"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2828">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2828">-or-</span></span> 
<span data-ttu-id="e3cee-2829">Un élément de <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2829">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2830">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément du paramètre <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type représenté par <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2830">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type that <paramref name="type" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-2831"><see cref="T:System.Type" /> qui représente le type d'élément du tableau.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2831">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="e3cee-2832">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2832">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-2833">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2833">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2834"><see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2834">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2835">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `initializers` doit représenter un type qui ne peut être assigné au type représenté par `type`, éventuellement une fois l’opération *entre guillemets*.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2835">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3cee-2836">Un élément sera mis entre guillemets uniquement si `type` est <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2836">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="e3cee-2837">Citation signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2837">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="e3cee-2838">Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2838">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="e3cee-2839">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewArrayExpression> représente un type de tableau dont le rang est 1 et dont le type élément est `type`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2839">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2840">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> méthode pour créer une arborescence d’expression qui représente la création d’un tableau de chaînes unidimensionnel qui est initialisé avec une liste d’expressions de chaîne.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2840">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2841"><paramref name="type" /> ou <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2841"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-2842">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2842">-or-</span></span> 
<span data-ttu-id="e3cee-2843">Un élément de <paramref name="initializers" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2843">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2844">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2844">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e3cee-2845">Obtient le type de nœud de ce <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2845">Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <value><span data-ttu-id="e3cee-2846">Une des valeurs de <see cref="T:System.Linq.Expressions.ExpressionType" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2846">One of the <see cref="T:System.Linq.Expressions.ExpressionType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2847">Le <xref:System.Linq.Expressions.Expression.NodeType%2A> propriété fournit une description plus spécialisée d’un <xref:System.Linq.Expressions.Expression> que simplement son type dérivé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2847">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property provides a more specialized description of an <xref:System.Linq.Expressions.Expression> than just its derived type.</span></span> <span data-ttu-id="e3cee-2848">Par exemple, un <xref:System.Linq.Expressions.BinaryExpression> peut être utilisé pour représenter de nombreuses sortes d’expressions binaires, comme une opération de division ou une opération « supérieure à ».</span><span class="sxs-lookup"><span data-stu-id="e3cee-2848">For example, a <xref:System.Linq.Expressions.BinaryExpression> can be used to represent many different kinds of binary expressions, such as a division operation or a "greater than" operation.</span></span> <span data-ttu-id="e3cee-2849">Le <xref:System.Linq.Expressions.Expression.NodeType%2A> propriété décrirait ces expressions binaires comme <xref:System.Linq.Expressions.ExpressionType.Divide> et <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectivement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2849">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property would describe these binary expressions as <xref:System.Linq.Expressions.ExpressionType.Divide> and <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectively.</span></span>  
  
 <span data-ttu-id="e3cee-2850">Le type CLR statique de l’expression qui le <xref:System.Linq.Expressions.Expression> représente de l’objet est représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2850">The static CLR type of the expression that the <xref:System.Linq.Expressions.Expression> object represents is represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2851">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2851">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-2852"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2853">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2853">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2854"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2854">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2855">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2855">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-2856">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2856">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2857">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2857">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2858">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2858">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2859">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2859">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2860">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2860">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2861">Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur not unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2861">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2862">Sinon, si `expression`. Type est un type numérique ou booléen, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2862">Otherwise, if `expression`.Type is a numeric or Boolean type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2863">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2863">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2864">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2864">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2865">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2865">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2866">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2866">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2867">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2867">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2868">`expression`. Le type est un type valeur nullable et le type non nullable correspondant est égal au type d’argument de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2868">`expression`.Type is a nullable value type and the corresponding non-nullable type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2869">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2869">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2870">Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2870">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="e3cee-2871">Si `expression`. Type non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2871">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2872">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2872">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-2873">L’exemple suivant montre comment créer une expression qui représente un opérateur logique pas d’opération.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2873">The following example demonstrates how to create an expression that represents a logical NOT operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2874"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2874"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2875">L'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2875">The unary not operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-2876"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2876">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2877"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2877">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2878">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2878">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span> <span data-ttu-id="e3cee-2879">La méthode d'implémentation peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2879">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2880"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2880">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2881">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2881">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-2882">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2882">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2883">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2883">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2884">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2884">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2885">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2885">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2886">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2886">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2887">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui prend un argument, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2887">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-2888">Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur not unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2888">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2889">Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2889">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2890">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2890">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2891">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2891">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2892">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2892">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2893">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2893">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2894">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2894">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2895">`expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2895">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2896">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2896">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2897">Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2897">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="e3cee-2898">Si `expression`. Type non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2898">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2899">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2899">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2900"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2900"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2901"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2901"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2902"><paramref name="method" /> est <see langword="null" /> et l'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2902"><paramref name="method" /> is <see langword="null" /> and the unary not operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-2903">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-2903">-or-</span></span> 
 <span data-ttu-id="e3cee-2904"><paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2904"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2905">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2905">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2906"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2906">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2907"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2907">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2908">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2908">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2909"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2909">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2910">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2910">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-2911">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2911">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2912">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2912">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="e3cee-2913">Sinon, elle a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2913">Otherwise, it is `false`.</span></span> <span data-ttu-id="e3cee-2914">La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2914">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="e3cee-2915">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2915">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-2916">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2916">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2917">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2917">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2918">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2918">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2919">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’inégalité, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2919">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2920">Sinon, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2920">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2921">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2921">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2922">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2922">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2923">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2923">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2924">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2924">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2925">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2925">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="e3cee-2926">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2926">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2927">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2927">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-2928">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2928">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2929">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2929">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2930">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2930">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-2931">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2931">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-2932">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2932">The type of the node is <xref:System.Boolean>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2933"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2933"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2934">L'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2934">The inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2935"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2935">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2936"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2936">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="e3cee-2937"><see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2937"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2938"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2938">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2939">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2939">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2940"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2940">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2941">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2941">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-2942">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2942">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2943">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2943">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="e3cee-2944">Sinon, elles sont toutes deux `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2944">Otherwise, they are both `false`.</span></span> <span data-ttu-id="e3cee-2945">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2945">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-2946">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2946">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2947">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2947">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2948">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2948">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2949">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2949">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2950">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’inégalité, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2950">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2951">Sinon, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2951">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2952">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2952">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2953">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2953">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2954">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2954">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2955">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2955">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2956">Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2956">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="e3cee-2957">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2957">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2958">Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2958">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="e3cee-2959">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2959">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2960">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2960">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2961">Le type du nœud est <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2961">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="e3cee-2962">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2962">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-2963">Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2963">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-2964"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2964"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-2965"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2965"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-2966"><paramref name="method" /> est <see langword="null" /> et l'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2966"><paramref name="method" /> is <see langword="null" /> and the inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2967">Retourne l'expression qui représente le complément à 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2967">Returns the expression representing the ones complement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-2968">Élément <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2968">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="e3cee-2969">Retourne l'expression qui représente le complément à 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2969">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2970">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2970">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-2971">Élément <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2971">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-2972"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2972">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-2973">Retourne l'expression qui représente le complément à 1.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2973">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2974">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2974">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-2975">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2975">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-2976"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2976">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-2977"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2977">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-2978">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2978">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-2979"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2979">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-2980">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2980">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-2981">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2981">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-2982">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2982">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-2983">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2983">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-2984">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2984">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-2985">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2985">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-2986">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-2986">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-2987">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2987">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-2988">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `OR` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2988">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2989">Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2989">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-2990">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-2990">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-2991">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2991">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2992">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2992">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2993">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2993">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-2994">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-2994">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-2995">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2995">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-2996">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2996">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-2997">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-2997">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-2998">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2998">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-2999">Le type du nœud est le type de résultat de prédéfinis au niveau du bit `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-2999">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3000">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3000">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3001">Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis au niveau du bit `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3001">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3002">L’exemple de code suivant montre comment créer une expression qui représente une opération OR logique.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3002">The following code example shows how to create an expression that represents a logical OR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3003"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3003"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3004">L'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3004">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3005"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3005">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3006"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3006">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3007"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3007">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3008">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3008">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3009"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3009">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3010">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3010">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3011">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3011">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3012">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3012">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3013">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3013">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3014">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3014">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3015">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3015">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3016">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3016">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3017">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3017">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3018">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3018">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3019">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `OR` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3019">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3020">Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3020">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3021">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3021">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3022">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3022">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3023">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3023">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3024">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3024">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3025">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3025">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3026">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3026">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3027">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3027">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3028">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3028">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3029">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3029">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3030">Le type du nœud est le type de résultat de prédéfinis au niveau du bit `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3030">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3031">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3031">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3032">Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis au niveau du bit `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3032">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3033"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3033"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3034"><paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3034"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3035"><paramref name="method" /> est <see langword="null" /> et l'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3035"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3036">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3036">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3037"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3037">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3038"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3038">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3039">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3039">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3040"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3040">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3041"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3041">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3042"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3042">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3043"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3043">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3044">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3044">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3045"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3045">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3046"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3046">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3047"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3047">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3048"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3048">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-3049"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3049">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3050">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3050">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3051"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3051">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3052">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si le premier opérateur a la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3052">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operator evaluates to <see langword="false" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3053"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3053">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3054"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3054">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3055">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3055">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3056"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3056">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3057">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3057">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3058">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3058">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3059">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3059">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3060">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3060">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3061">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3061">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3062">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3062">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3063">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3063">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3064">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3064">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3065">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `OR` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3065">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="e3cee-3066">L’instruction conditionnelle `OR` opérateur ne peut pas être surchargé en c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3066">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="e3cee-3067">Toutefois, l’instruction conditionnelle `OR` opérateur est évalué à l’aide de l’opérateur de bits `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3067">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="e3cee-3068">Par conséquent, une surcharge définie par l’utilisateur de l’opérateur de bits `OR` opérateur peut être la méthode d’implémentation pour ce type de nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3068">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="e3cee-3069">Sinon, si `left`. Type et `right`. Type sont des types booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3069">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3070">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3070">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3071">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3071">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3072">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3072">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3073">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3073">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3074">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3074">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3075">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable, et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3075">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3076">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3076">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3077">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3077">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3078">`left`. Type et `right`. Type sont du même type booléen.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3078">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="e3cee-3079">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3079">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3080">Le type du nœud est le type de résultat de l’instruction conditionnelle prédéfini `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3080">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3081">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3081">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3082">Le type du nœud est le type nullable qui correspond au type de résultat de l’instruction conditionnelle prédéfini `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3082">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3083">L’exemple de code suivant montre comment créer une expression qui représente un opérateur logique `OR` opération qui prend la valeur du deuxième opérande uniquement si le premier opérande prend la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3083">The following code example shows how to create an expression that represents a logical `OR` operation that evaluates the second operand only if the first operand evaluates to `false`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3084"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3084"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3085">L'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3085">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-3086">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-3086">-or-</span></span> 
 <span data-ttu-id="e3cee-3087"><paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3087"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3088"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3088">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3089"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3089">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3090"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3090">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3091">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3091">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3092"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3092">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3093">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3093">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3094">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3094">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3095">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3095">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3096">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3096">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3097">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3097">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3098">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3098">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3099">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3099">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3100">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3100">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3101">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3101">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-3102">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `OR` opérateur, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3102">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="e3cee-3103">L’instruction conditionnelle `OR` opérateur ne peut pas être surchargé en c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3103">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="e3cee-3104">Toutefois, l’instruction conditionnelle `OR` opérateur est évalué à l’aide de l’opérateur de bits `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3104">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="e3cee-3105">Par conséquent, une surcharge définie par l’utilisateur de l’opérateur de bits `OR` opérateur peut être la méthode d’implémentation pour ce type de nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3105">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="e3cee-3106">Sinon, si `left`. Type et `right`. Type sont des types booléens, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3106">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3107">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3107">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3108">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3108">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3109">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3109">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3110">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3110">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3111">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3111">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3112">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable, et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3112">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3113">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3113">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3114">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3114">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3115">`left`. Type et `right`. Type sont du même type booléen.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3115">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="e3cee-3116">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3116">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3117">Le type du nœud est le type de résultat de l’instruction conditionnelle prédéfini `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3117">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3118">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3118">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3119">Le type du nœud est le type nullable qui correspond au type de résultat de l’instruction conditionnelle prédéfini `OR` opérateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3119">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3120"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3120"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3121"><paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3121"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3122"><paramref name="method" /> est <see langword="null" /> et l'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3122"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-3123">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-3123">-or-</span></span> 
 <span data-ttu-id="e3cee-3124"><paramref name="method" /> est <see langword="null" /> et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3124"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3125">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3125">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-3126">Type du paramètre ou de la variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3126">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="e3cee-3127">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3127">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3128">Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3128">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-3129">L’exemple suivant montre comment créer un <xref:System.Linq.Expressions.MethodCallExpression> objet qui imprime la valeur d’un <xref:System.Linq.Expressions.ParameterExpression> objet.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3129">The following example demonstrates how to create a <xref:System.Linq.Expressions.MethodCallExpression> object that prints the value of a <xref:System.Linq.Expressions.ParameterExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-3130">Type du paramètre ou de la variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3130">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="e3cee-3131">Nom du paramètre ou de la variable, utilisé à des fins de débogage ou d'impression uniquement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3131">The name of the parameter or variable, used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="e3cee-3132">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3132">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3133"><see cref="T:System.Linq.Expressions.ParameterExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3133">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3134"><paramref name="type" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3134"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3135">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3135">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3136"><see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3136">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="e3cee-3137">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3137">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3138"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3138">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3139"><see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3139">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3140"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3140">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-3141">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3141">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3142"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3142">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3143">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3143">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3144"><see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3144">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="e3cee-3145">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3145">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3146"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3146">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3147"><see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3147">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3148"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3148">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-3149">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3149">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3150"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3150">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3151">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3151">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3152"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3152">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3153"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3153">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3154">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3154">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3155"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3155">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3156">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3156">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3157">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3157">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3158">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3158">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3159">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3159">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3160">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3160">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3161">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3161">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3162">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3162">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3163">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3163">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3164">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’élévation, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3164">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3165">Sinon, si `left`. Type et `right`. Type sont tous deux <xref:System.Double>, la méthode d’implémentation est <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3165">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3166">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3166">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="e3cee-3167">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3167">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3168">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3168">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3169">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3169">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3170">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3170">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3171">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3171">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3172"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3172"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3173">L'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3173">The exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-3174">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-3174">-or-</span></span> 
 <span data-ttu-id="e3cee-3175"><paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3175"><paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3176"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3176">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3177"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3177">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3178"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3178">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3179">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3179">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3180"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3180">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3181">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3181">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3182">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3182">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3183">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3183">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3184">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3184">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3185">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3185">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3186">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3186">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3187">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3187">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3188">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3188">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3189">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3189">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3190">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’élévation, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3190">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3191">Sinon, si `left`. Type et `right`. Type sont tous deux <xref:System.Double>, la méthode d’implémentation est <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3191">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3192">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3192">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="e3cee-3193">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3193">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3194">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3194">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3195">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3195">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3196">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3196">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3197">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3197">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3198"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3198"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3199"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3199"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3200"><paramref name="method" /> a la valeur <see langword="null" /> et l’opérateur d’élévation à une puissance n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3200"><paramref name="method" /> is <see langword="null" /> and the exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-3201">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-3201">-or-</span></span> 
 <span data-ttu-id="e3cee-3202"><paramref name="method" /> est <see langword="null" /> et <paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3202"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3203">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3203">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3204"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3205"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3205">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3206">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3207"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3208"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3209"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3210"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3211">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3211">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3212"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3212">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3213"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3213">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3214"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3214">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3215"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3215">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-3216"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3216">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3217">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3218"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3219">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3219">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3220"><see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3220">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="e3cee-3221">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3221">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3222"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3222">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3223"><see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3223">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3224"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3224">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-3225">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3225">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3226"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3226">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3227">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3227">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3228"><see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3228">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="e3cee-3229">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3229">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3230"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3230">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3231"><see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3231">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3232"><see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3232">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="e3cee-3233">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3233">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3234"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3234">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3235">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3235">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3236"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3236">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="e3cee-3237">Cette valeur peut être null pour les propriétés statiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3237">This can be null for static properties.</span></span></param>
        <param name="propertyAccessor"><span data-ttu-id="e3cee-3238"><see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3238">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <summary><span data-ttu-id="e3cee-3239">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété à l'aide d'une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3239">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3240"><see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3240">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3241">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égale à la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété du <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3241">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="e3cee-3242">Si la méthode représentée par `propertyAccessor` est `static` (`Shared` en Visual Basic), `expression` peut être `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3242">If the method represented by `propertyAccessor` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3243"><paramref name="propertyAccessor" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3243"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-3244">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-3244">-or-</span></span> 
<span data-ttu-id="e3cee-3245">La méthode représentée par <paramref name="propertyAccessor" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3245">The method that <paramref name="propertyAccessor" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3246"><paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3246"><paramref name="expression" />.Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />.</span></span>  
  
<span data-ttu-id="e3cee-3247">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-3247">-or-</span></span> 
<span data-ttu-id="e3cee-3248">La méthode représentée par <paramref name="propertyAccessor" /> n'est pas une méthode d'accesseur de propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3248">The method that <paramref name="propertyAccessor" /> represents is not a property accessor method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3249"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3249">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="e3cee-3250">Cette valeur peut être null pour les propriétés statiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3250">This can be null for static properties.</span></span></param>
        <param name="property"><span data-ttu-id="e3cee-3251"><see cref="T:System.Reflection.PropertyInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3251">The <see cref="T:System.Reflection.PropertyInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3252">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3252">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3253"><see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3253">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3254">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égale à la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété du <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3254">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="e3cee-3255">Si la propriété représentée par `property` est `static` (`Shared` en Visual Basic), `expression` peut être `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3255">If the property represented by `property` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3256"><paramref name="property" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3256"><paramref name="property" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e3cee-3257">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-3257">-or-</span></span> 
<span data-ttu-id="e3cee-3258">La propriété représentée par <paramref name="property" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3258">The property that <paramref name="property" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3259"><paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la propriété que <paramref name="property" /> représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3259"><paramref name="expression" />.Type is not assignable to the declaring type of the property that <paramref name="property" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3260"><see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété nommée <paramref name="propertyName" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3260">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property named <paramref name="propertyName" />.</span></span> <span data-ttu-id="e3cee-3261">Cette valeur peut être <see langword="null" /> pour les propriétés statiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3261">This can be <see langword="null" /> for static properties.</span></span></param>
        <param name="propertyName"><span data-ttu-id="e3cee-3262">Nom d'une propriété à laquelle accéder.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3262">The name of a property to be accessed.</span></span></param>
        <summary><span data-ttu-id="e3cee-3263">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3263">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3264"><see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété désignée par <paramref name="propertyName" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3264">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property denoted by <paramref name="propertyName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3265">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égale à la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété de la <xref:System.Reflection.PropertyInfo> qui représente la propriété désignée par `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3265">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the <xref:System.Reflection.PropertyInfo> that represents the property denoted by `propertyName`.</span></span>  
  
 <span data-ttu-id="e3cee-3266">Cette méthode recherche `expression`. Type et ses types de base pour une propriété qui porte le nom `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3266">This method searches `expression`.Type and its base types for a property that has the name `propertyName`.</span></span> <span data-ttu-id="e3cee-3267">Propriétés publiques sont prioritaires sur les propriétés non publiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3267">Public properties are given preference over non-public properties.</span></span> <span data-ttu-id="e3cee-3268">Si une propriété correspondante est trouvée, cette méthode passe `expression` et <xref:System.Reflection.PropertyInfo> qui représente cette propriété à <xref:System.Linq.Expressions.Expression.Property%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3268">If a matching property is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> that represents that property to <xref:System.Linq.Expressions.Expression.Property%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3269">L’exemple suivant montre comment créer une expression qui représente l’accès à une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3269">The following example shows how to create an expression that represents accessing a property.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3270"><paramref name="expression" /> ou <paramref name="propertyName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3270"><paramref name="expression" /> or <paramref name="propertyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3271">Aucune propriété nommée <paramref name="propertyName" /> n'est définie dans <paramref name="expression" />.Type ou ses types de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3271">No property named <paramref name="propertyName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-3272">Objet auquel la propriété appartient.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3272">The object to which the property belongs.</span></span> <span data-ttu-id="e3cee-3273">Si la propriété est statique/partagée, doit avoir la valeur Null.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3273">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="e3cee-3274"><see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3274">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-3275"><see cref="T:System.Collections.Generic.IEnumerable`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui sont utilisés pour indexer la propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3275">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="e3cee-3276">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3276">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3277">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3277">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-3278">Objet auquel la propriété appartient.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3278">The object to which the property belongs.</span></span> <span data-ttu-id="e3cee-3279">Si la propriété est statique/partagée, doit avoir la valeur Null.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3279">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="e3cee-3280"><see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3280">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-3281">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3281">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="e3cee-3282">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3282">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3283">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3283">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="e3cee-3284">Objet auquel la propriété appartient.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3284">The object to which the property belongs.</span></span> <span data-ttu-id="e3cee-3285">Si la propriété est statique/partagée, doit avoir la valeur Null.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3285">If the property is static/shared, it must be null.</span></span></param>
        <param name="propertyName"><span data-ttu-id="e3cee-3286">Nom de l'indexeur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3286">The name of the indexer.</span></span></param>
        <param name="arguments"><span data-ttu-id="e3cee-3287">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3287">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="e3cee-3288">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3288">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3289">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3289">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3290">Objet contenant la propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3290">The containing object of the property.</span></span> <span data-ttu-id="e3cee-3291">Cette valeur peut être null pour les propriétés statiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3291">This can be null for static properties.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-3292">Objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient la propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3292">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the property.</span></span></param>
        <param name="propertyName"><span data-ttu-id="e3cee-3293">Propriété à laquelle accéder.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3293">The property to be accessed.</span></span></param>
        <summary><span data-ttu-id="e3cee-3294">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui accède à une propriété.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3294">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> accessing a property.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3295">Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3295">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3296"><see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété ou un champ nommé <paramref name="propertyOrFieldName" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3296">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property or field named <paramref name="propertyOrFieldName" />.</span></span> <span data-ttu-id="e3cee-3297">Cette valeur peut être null pour les membres statiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3297">This can be null for static members.</span></span></param>
        <param name="propertyOrFieldName"><span data-ttu-id="e3cee-3298">Nom d'une propriété ou d'un champ auquel accéder.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3298">The name of a property or field to be accessed.</span></span></param>
        <summary><span data-ttu-id="e3cee-3299">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété ou un champ.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3299">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property or field.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3300"><see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> est égale à <paramref name="expression" />, et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> ou à <see cref="T:System.Reflection.FieldInfo" /> qui représente la propriété ou le champ désigné par <paramref name="propertyOrFieldName" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3300">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" /> that represents the property or field denoted by <paramref name="propertyOrFieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3301">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égale à la <xref:System.Reflection.PropertyInfo.PropertyType%2A> ou <xref:System.Reflection.FieldInfo.FieldType%2A> propriétés de la <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo>, respectivement, qui représente la propriété ou le champ désigné par `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3301">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> or <xref:System.Reflection.FieldInfo.FieldType%2A> properties of the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo>, respectively, that represents the property or field denoted by `propertyOrFieldName`.</span></span>  
  
 <span data-ttu-id="e3cee-3302">Cette méthode recherche `expression`. Type et ses types de base pour une propriété ou un champ qui porte le nom `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3302">This method searches `expression`.Type and its base types for a property or field that has the name `propertyOrFieldName`.</span></span> <span data-ttu-id="e3cee-3303">Champs et propriétés publics sont prioritaires sur les champs et propriétés non publiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3303">Public properties and fields are given preference over non-public properties and fields.</span></span> <span data-ttu-id="e3cee-3304">En outre, les propriétés sont prioritaires sur les champs.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3304">Also, properties are given preference over fields.</span></span> <span data-ttu-id="e3cee-3305">Si une propriété ou un champ correspondant est trouvé, cette méthode passe `expression` et <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo> qui représente cette propriété ou un champ à <xref:System.Linq.Expressions.Expression.Property%2A> ou <xref:System.Linq.Expressions.Expression.Field%2A>, respectivement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3305">If a matching property or field is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo> that represents that property or field to <xref:System.Linq.Expressions.Expression.Property%2A> or <xref:System.Linq.Expressions.Expression.Field%2A>, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3306">L’exemple suivant montre comment créer une expression qui représente l’accès à une propriété ou un champ.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3306">The following example shows how to create an expression that represents accessing a property or field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3307"><paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3307"><paramref name="expression" /> or <paramref name="propertyOrFieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3308">Aucune propriété ou aucun champ nommé <paramref name="propertyOrFieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3308">No property or field named <paramref name="propertyOrFieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3309"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3309">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3310">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression ayant une valeur de constante de type <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3310">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3311"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3311">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3312">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> représente le type construit <xref:System.Linq.Expressions.Expression%601>, où l’argument de type est le type représenté par `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3312">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents the constructed type <xref:System.Linq.Expressions.Expression%601>, where the type argument is the type represented by `expression`.Type.</span></span> <span data-ttu-id="e3cee-3313">La propriété <xref:System.Linq.Expressions.UnaryExpression.Method%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3313">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`.</span></span> <span data-ttu-id="e3cee-3314">Les deux <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3314">Both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3315"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3315"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e3cee-3316">Réduit le nœud en une expression plus simple.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3316">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="e3cee-3317">Si CanReduce retourne la valeur true, cela doit retourner une expression valide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3317">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="e3cee-3318">Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3318">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3319">Expression réduite.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3319">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e3cee-3320">Réduit le nœud en une expression plus simple.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3320">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="e3cee-3321">Si CanReduce retourne la valeur true, cela doit retourner une expression valide.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3321">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="e3cee-3322">Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3322">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3323">Expression réduite.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3323">The reduced expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3324">Contrairement à Reduce, cette méthode vérifie que le nœud réduit satisfait certains invariants.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3324">Unlike Reduce, this method checks that the reduced node satisfies certain invariants.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e3cee-3325">Réduit l'expression à un type de nœud connu (qui n'est pas un nœud Extension) ou retourne simplement l'expression s'il s'agit d'un type déjà connu.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3325">Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3326">Expression réduite.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3326">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3327"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3327">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3328"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3328">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3329">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité des références.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3329">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference equality comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3330"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3330">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3331"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3332"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3332">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3333">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité de référence.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3333">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3334"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3334">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3335">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3335">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e3cee-3336">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3336">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3337"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3337">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-3338">Nouveau <see cref="T:System.Type" /> d'une expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3338">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="e3cee-3339">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'une exception avec un type donné.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3339">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3340"><see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3340">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3341">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3341">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-3342"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3342">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3343">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3343">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3344"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3344">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-3345"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3345">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="e3cee-3346">Valeur qui sera passée à l'étiquette associée au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3346">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="e3cee-3347">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3347">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span> <span data-ttu-id="e3cee-3348">La valeur passée à l'étiquette au moment du saut peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3348">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3349"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3349">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-3350">L’exemple suivant montre comment créer une expression qui contienne le <xref:System.Linq.Expressions.Expression.Return%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="e3cee-3350">The following example demonstrates how to create an expression that contains the <xref:System.Linq.Expressions.Expression.Return%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-3351"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3351">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-3352"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3352">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3353">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3353">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3354"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3354">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e3cee-3355"><see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3355">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="e3cee-3356">Valeur qui sera passée à l'étiquette associée au moment du saut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3356">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-3357"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3357">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3358">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3358">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span> <span data-ttu-id="e3cee-3359">La valeur passée à l'étiquette au moment du saut peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3359">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3360"><see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut</span><span class="sxs-lookup"><span data-stu-id="e3cee-3360">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3361">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3361">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3362"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3362">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3363"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3363">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3364">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3364">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3365"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3366">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3366">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3367">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3367">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3368">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3368">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3369">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3369">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3370">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3370">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3371">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3371">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3372">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3372">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3373">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3373">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3374">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de décalage vers la droite, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3374">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3375">Sinon, si `left`. Le type est un type intégral (un des <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou les types nullables correspondants) et `right`. Est de type <xref:System.Int32>, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3375">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3376">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3376">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3377">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3377">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3378">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3378">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3379">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3379">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3380">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3380">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3381">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3381">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3382">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3382">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3383">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3383">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3384">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3384">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3385">Le type du nœud est le type de résultat de l’opérateur de décalage vers la droite prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3385">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3386">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3386">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3387">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de décalage vers la droite prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3387">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3388"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3388"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3389">L'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3389">The right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3390"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3390">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3391"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3391">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3392"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3392">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3393">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3393">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3394"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3395">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3395">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3396">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3396">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3397">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3397">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3398">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3398">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3399">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3399">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3400">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3400">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3401">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3401">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3402">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3402">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3403">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3403">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-3404">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de décalage vers la droite, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3404">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3405">Sinon, si `left`. Le type est un type intégral (un des <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou les types nullables correspondants) et `right`. Est de type <xref:System.Int32>, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3405">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3406">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3406">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3407">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3407">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3408">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3408">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3409">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3409">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3410">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3410">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3411">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3411">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3412">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3412">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3413">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3413">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3414">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3414">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3415">Le type du nœud est le type de résultat de l’opérateur de décalage vers la droite prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3415">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3416">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3416">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3417">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de décalage vers la droite prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3417">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3418"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3418"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3419"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3419"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3420"><paramref name="method" /> est <see langword="null" /> et l'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3420"><paramref name="method" /> is <see langword="null" /> and the right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3421">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3421">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3422"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3423"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3423">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3424">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3424">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3425"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3426"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3427"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3428"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3428">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3429">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3429">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3430"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3431"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3432"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3432">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3433"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3433">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-3434"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3435">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3436"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3437">Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3437">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="e3cee-3438">Collection d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3438">A collection of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-3439">Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3439">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3440">Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3440">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="e3cee-3441">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3441">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="e3cee-3442">Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3442">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3443">Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3443">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3444">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3444">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3445"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3445">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3446"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3446">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3447">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3447">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3448"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3448">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3449">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3449">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3450">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3450">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3451">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3451">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3452">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3452">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3453">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3453">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3454">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3454">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3455">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3455">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3456">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3456">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3457">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de soustraction, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3457">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3458">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3458">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3459">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3459">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3460">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3460">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3461">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3461">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3462">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3462">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3463">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3463">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3464">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3464">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3465">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3465">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3466">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3466">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3467">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3467">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3468">Le type du nœud est le type de résultat de l’opérateur de soustraction prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3468">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3469">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3469">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3470">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de soustraction prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3470">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3471">L’exemple de code suivant montre comment créer une expression qui soustrait l’argument du premier argument.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3471">The following code example shows how to create an expression that subtracts the argument from the first argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3472"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3472"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3473">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3473">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3474"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3474">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3475"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3475">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3476"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3476">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3477">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3477">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3478"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3478">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3479">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3479">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3480">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3480">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3481">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3481">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3482">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3482">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3483">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3483">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3484">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3484">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3485">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3485">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3486">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3486">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3487">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3487">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-3488">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de soustraction, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3488">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3489">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3489">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3490">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3490">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3491">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3491">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3492">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3492">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3493">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3493">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3494">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3494">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3495">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3495">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3496">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3496">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3497">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3497">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3498">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3498">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3499">Le type du nœud est le type de résultat de l’opérateur de soustraction prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3499">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3500">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3500">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3501">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de soustraction prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3501">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3502"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3502"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3503"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3503"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3504"><paramref name="method" /> est <see langword="null" /> et l'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3504"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3505">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3506"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3506">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3507"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3507">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3508">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3508">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3509"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3509">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3510"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3510">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3511"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3511">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3512"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3512">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3513">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3513">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3514"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3514">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3515"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3515">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3516"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3516">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3517"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3517">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-3518"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3518">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3519">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3519">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3520"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3520">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3521">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3521">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3522"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3522">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3523"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3523">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3524">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3524">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3525"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3525">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3526"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3526">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3527"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3527">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3528"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3528">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3529">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3529">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3530"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3530">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3531"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3532"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3533"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3533">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="e3cee-3534"><see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3534">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3535">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3535">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3536"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3536">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3537">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3537">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3538"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3538">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3539"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3539">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3540">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3540">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3541"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3541">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3542">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3542">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3543">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3543">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3544">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3544">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3545">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3545">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3546">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3546">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3547">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3547">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3548">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3548">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3549">Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3549">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3550">Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de soustraction, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3550">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3551">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3551">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3552">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3552">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3553">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3553">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3554">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3554">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3555">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3555">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3556">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3556">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3557">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3557">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3558">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3558">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3559">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3559">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3560">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3560">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3561">Le type du nœud est le type de résultat de l’opérateur de soustraction prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3561">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3562">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3562">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3563">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de soustraction prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3563">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3564"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3564"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3565">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3565">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e3cee-3566"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3566">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="e3cee-3567"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3567">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3568"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3568">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3569">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3569">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3570"><see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3570">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3571">Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3571">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="e3cee-3572">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3572">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3573">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3573">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3574">Sinon, elles sont `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3574">Otherwise, they are `false`.</span></span> <span data-ttu-id="e3cee-3575">La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3575">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="e3cee-3576">Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3576">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3577">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3577">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3578">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3578">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="e3cee-3579">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3579">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-3580">Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de soustraction, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3580">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3581">Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3581">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3582">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3582">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3583">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3583">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3584">Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3584">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3585">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3585">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3586">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3586">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3587">`left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’argument correspondant de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3587">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3588">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3588">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3589">Si la méthode d’implémentation est `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3589">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3590">Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3590">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3591">Le type du nœud est le type de résultat de l’opérateur de soustraction prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3591">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="e3cee-3592">Si `left`. Type et `right`. Type sont nullable, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3592">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="e3cee-3593">Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de soustraction prédéfini.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3593">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3594"><paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3594"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3595"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas deux arguments exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3595"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3596"><paramref name="method" /> est <see langword="null" /> et l'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3596"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3597">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3597">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="e3cee-3598">Valeur à tester pour chaque cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3598">The value to be tested against each case.</span></span></param>
        <param name="cases"><span data-ttu-id="e3cee-3599">Ensemble de cas pour cette expression de switch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3599">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="e3cee-3600">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> sans casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3600">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement without a default case.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3601">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3601">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3602">Tous les <xref:System.Linq.Expressions.SwitchCase> des objets dans un <xref:System.Linq.Expressions.SwitchExpression> objet doit avoir le même type, sauf si le <xref:System.Linq.Expressions.SwitchExpression> a le type `void`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3602">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="e3cee-3603">Chaque <xref:System.Linq.Expressions.SwitchCase> objet a implicite `break` instruction, ce qui signifie qu’il n’existe pas de passage implicite d’une étiquette case vers un autre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3603">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="e3cee-3604">Si `switchValue` ne correspond pas à un des cas, aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3604">If `switchValue` does not match any of the cases, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3605">L’exemple suivant montre comment créer une expression qui représente une instruction switch départemental sans casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3605">The following example demonstrates how to create an expression that represents a swtich statement without a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="e3cee-3606">Valeur à tester pour chaque cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3606">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="e3cee-3607">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3607">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="cases"><span data-ttu-id="e3cee-3608">Ensemble de cas pour cette expression de switch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3608">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="e3cee-3609">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3609">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3610">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3610">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3611">Tous les <xref:System.Linq.Expressions.SwitchCase> des objets dans un <xref:System.Linq.Expressions.SwitchExpression> objet doit avoir le même type, sauf si le <xref:System.Linq.Expressions.SwitchExpression> a le type `void`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3611">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="e3cee-3612">Chaque <xref:System.Linq.Expressions.SwitchCase> objet a implicite `break` instruction, ce qui signifie qu’il n’existe pas de passage implicite d’une étiquette case vers un autre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3612">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="e3cee-3613">Si `switchValue` ne correspond pas à un des cas, le cas par défaut représenté par `defaultBody` est exécuté.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3613">If `switchValue` does not match any of the cases, the default case represented by `defaultBody` is run.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3614">L’exemple suivant montre comment créer une expression qui représente une instruction de bascule qui a une casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3614">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="e3cee-3615">Valeur à tester pour chaque cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3615">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="e3cee-3616">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3616">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="e3cee-3617">Méthode de comparaison d'égalité à utiliser.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3617">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="e3cee-3618">Ensemble de cas pour cette expression de switch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3618">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="e3cee-3619">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3619">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3620">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3620">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="e3cee-3621">Valeur à tester pour chaque cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3621">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="e3cee-3622">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3622">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="e3cee-3623">Méthode de comparaison d'égalité à utiliser.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3623">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="e3cee-3624">Ensemble de cas pour cette expression de switch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3624">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="e3cee-3625">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3625">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3626">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3626">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-3627">Type de résultat du commutateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3627">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="e3cee-3628">Valeur à tester pour chaque cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3628">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="e3cee-3629">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3629">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="e3cee-3630">Méthode de comparaison d'égalité à utiliser.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3630">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="e3cee-3631">Ensemble de cas pour cette expression de switch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3631">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="e3cee-3632">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3632">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3633">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3633">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-3634">Type de résultat du commutateur.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3634">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="e3cee-3635">Valeur à tester pour chaque cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3635">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="e3cee-3636">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3636">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="e3cee-3637">Méthode de comparaison d'égalité à utiliser.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3637">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="e3cee-3638">Ensemble de cas pour cette expression de switch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3638">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="e3cee-3639">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3639">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3640">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3640">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3641">Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3641">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-3642">Corps du cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3642">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="e3cee-3643">Valeurs de test du cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3643">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="e3cee-3644">Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3644">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3645">Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3645">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3646">Tous les <xref:System.Linq.Expressions.SwitchCase> des objets dans un <xref:System.Linq.Expressions.SwitchExpression> objet doit avoir le même type, sauf si le <xref:System.Linq.Expressions.SwitchExpression> a le type `void`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3646">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="e3cee-3647">Chaque <xref:System.Linq.Expressions.SwitchCase> objet a implicite `break` instruction, ce qui signifie qu’il n’existe pas de passage implicite d’une étiquette case vers un autre.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3647">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3648">L’exemple suivant montre comment créer une expression qui représente une instruction de bascule qui a une casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3648">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-3649">Corps du cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3649">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="e3cee-3650">Valeurs de test du cas.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3650">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="e3cee-3651">Crée un <see cref="T:System.Linq.Expressions.SwitchCase" /> pour une utilisation dans un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3651">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3652">Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3652">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3653">Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3653">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="e3cee-3654"><see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3654">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3655">Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3655">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3656"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3656">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="e3cee-3657"><see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3657">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="e3cee-3658"><see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3658">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3659">Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3659">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3660"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ont la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3660">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="e3cee-3661"><see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3661">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="e3cee-3662"><see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3662">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="e3cee-3663"><see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3663">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3664">Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3664">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3665"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ont la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3665">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="e3cee-3666"><see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3666">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="e3cee-3667"><see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3667">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="e3cee-3668"><see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3668">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <param name="documentType"><span data-ttu-id="e3cee-3669"><see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3669">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3670">Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3670">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3671"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ont la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3671">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3672">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3672">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e3cee-3673">Élément <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3673">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="e3cee-3674">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3674">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3675">Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3675">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-3676">L’exemple suivant montre comment créer un <xref:System.Linq.Expressions.TryExpression> objet qui utilise le <xref:System.Linq.Expressions.Expression.Throw%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="e3cee-3676">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that uses the <xref:System.Linq.Expressions.Expression.Throw%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e3cee-3677">Élément <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3677">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-3678">Nouveau <see cref="T:System.Type" /> d'une expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3678">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="e3cee-3679">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception avec un type donné.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3679">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3680">Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3680">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e3cee-3681">Retourne une représentation textuelle d'<see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3681">Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3682">Représentation textuelle d'<see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3682">A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-3683">Corps du bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3683">The body of the try block.</span></span></param>
        <param name="handlers"><span data-ttu-id="e3cee-3684">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3684">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="e3cee-3685">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch mais ni une erreur, ni un bloc Finally.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3685">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and neither a fault nor finally block.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3686">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3686">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-3687">L’exemple suivant montre comment créer un <xref:System.Linq.Expressions.TryExpression> objet qui contient une instruction catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3687">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-3688">Corps du bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3688">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="e3cee-3689">Corps du bloc Finally.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3689">The body of the finally block.</span></span></param>
        <param name="handlers"><span data-ttu-id="e3cee-3690">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3690">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="e3cee-3691">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch et un bloc Finally.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3691">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and a finally block.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3692">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3692">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e3cee-3693">L’exemple suivant montre comment créer un <xref:System.Linq.Expressions.TryExpression> objet qui contient une instruction catch et une instruction finally.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3693">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement and a finally statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-3694">Corps du bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3694">The body of the try block.</span></span></param>
        <param name="fault"><span data-ttu-id="e3cee-3695">Corps du bloc Fault.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3695">The body of the fault block.</span></span></param>
        <summary><span data-ttu-id="e3cee-3696">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Fault et aucune instruction Catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3696">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a fault block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3697">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3697">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="e3cee-3698">Corps du bloc Try.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3698">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="e3cee-3699">Corps du bloc Finally.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3699">The body of the finally block.</span></span></param>
        <summary><span data-ttu-id="e3cee-3700">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Finally et aucune instruction Catch.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3700">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a finally block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3701">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3701">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="e3cee-3702">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Action.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3702">An array of Type objects that specify the type arguments for the System.Action delegate type.</span></span></param>
        <param name="actionType"><span data-ttu-id="e3cee-3703">Cette méthode retourne le type délégué System.Action générique qui comporte des arguments de type spécifiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3703">When this method returns, contains the generic System.Action delegate type that has specific type arguments.</span></span> <span data-ttu-id="e3cee-3704">Contient la valeur Null s'il n'y a aucun délégué System.Action générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3704">Contains null if there is no generic System.Action delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="e3cee-3705">Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Action générique qui comporte des arguments de type spécifiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3705">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3706">True si le type délégué System.Action générique a été créé pour un <paramref name="typeArgs" /> spécifique, false dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3706">true if generic System.Action delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="e3cee-3707">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Func.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3707">An array of Type objects that specify the type arguments for the System.Func delegate type.</span></span></param>
        <param name="funcType"><span data-ttu-id="e3cee-3708">Cette méthode retourne le type délégué System.Func générique qui comporte des arguments de type spécifiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3708">When this method returns, contains the generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="e3cee-3709">Contient la valeur Null s'il n'y a aucun délégué System.Func générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3709">Contains null if there is no generic System.Func delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="e3cee-3710">Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Func générique comportant des arguments de type spécifiques.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3710">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="e3cee-3711">Le dernier argument de type spécifie le type de retour du délégué créé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3711">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3712">True si le type délégué System.Func générique a été créé pour un <paramref name="typeArgs" /> spécifique, false dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3712">true if generic System.Func delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e3cee-3713">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3713">Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</span></span></summary>
        <value><span data-ttu-id="e3cee-3714"><see cref="T:System.Type" /> qui représente le type statique de l'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3714">The <see cref="T:System.Type" /> that represents the static type of the expression.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3715">Le <xref:System.Linq.Expressions.Expression.NodeType%2A> est le type du nœud d’arbre expression, tandis que le <xref:System.Linq.Expressions.Expression.Type%2A> représente le statique type common language runtime (CLR) de l’expression qui représente le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3715">The <xref:System.Linq.Expressions.Expression.NodeType%2A> is the type of the expression tree node, whereas the <xref:System.Linq.Expressions.Expression.Type%2A> represents the static common language runtime (CLR) type of the expression that the node represents.</span></span> <span data-ttu-id="e3cee-3716">Par exemple, deux nœuds de différents types de nœuds peuvent avoir le même <xref:System.Linq.Expressions.Expression.Type%2A>, comme illustré dans l’exemple de code suivant.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3716">For example, two nodes with different node types can have the same <xref:System.Linq.Expressions.Expression.Type%2A>, as shown in the following code example.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3717"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3717">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-3718"><see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3718">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3719">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une référence explicite ou une conversion boxing où la valeur <see langword="null" /> est fournie en cas d'échec de la conversion.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3719">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit reference or boxing conversion where <see langword="null" /> is supplied if the conversion fails.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3720"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3720">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3721">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3721">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is `null`.</span></span> <span data-ttu-id="e3cee-3722">Le <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `false`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3722">The <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> properties are both `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3723">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> méthode pour créer un <xref:System.Linq.Expressions.UnaryExpression> qui représente la conversion de référence d’une expression entière non nullable au type entier nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3723">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.UnaryExpression> that represents the reference conversion of a non-nullable integer expression to the nullable integer type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3724"><paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3724"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3725"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="T:System.Linq.Expressions.Expression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3725">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="T:System.Linq.Expressions.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-3726"><see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3726">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3727">Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> qui compare l'identité de type à l'exécution.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3727">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> that compares run-time type identity.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3728"><see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> et dont les propriétés <see cref="T:System.Linq.Expressions.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3728">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> and for which the <see cref="T:System.Linq.Expressions.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3729"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3729">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-3730"><see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3731">Crée une <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3731">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3732"><see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3732">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3733">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> représente <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3733">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3cee-3734">L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> méthode pour créer un <xref:System.Linq.Expressions.TypeBinaryExpression> qui représente un test de type d’une valeur de chaîne par rapport à la <xref:System.Int32> type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3734">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.TypeBinaryExpression> that represents a type test of a string value against the <xref:System.Int32> type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3735"><paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3735"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3736">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3736">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3737"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3737">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3738">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3738">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3739"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3739">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3740">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3740">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-3741">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3741">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3742">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3742">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3743">Sinon, ils ont la valeur false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3743">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3744">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3744">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3745">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3745">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3746">Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur plus unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3746">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3747">Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3747">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3748">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3748">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3749">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3749">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3750">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3750">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3751">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3751">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3752">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3752">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3753">`expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3753">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3754">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3754">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3755">Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3755">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="e3cee-3756">Si `expression`. Type non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3756">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3757">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3757">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3758"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3758"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3759">L'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3759">The unary plus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3760"><see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3760">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="e3cee-3761"><see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3761">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="e3cee-3762">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3762">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3763"><see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3763">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3764">Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3764">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="e3cee-3765">Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est définie sur le type du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3765">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="e3cee-3766">Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3766">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="e3cee-3767">Sinon, ils ont la valeur false.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3767">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="e3cee-3768">Méthode d’implémentation</span><span class="sxs-lookup"><span data-stu-id="e3cee-3768">Implementing Method</span></span>  
 <span data-ttu-id="e3cee-3769">Les règles suivantes déterminent la méthode d’implémentation pour l’opération :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3769">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="e3cee-3770">Si `method` n’est pas `null` et il représente un non void, `static` (`Shared` en Visual Basic) méthode qui prend un argument, il est la méthode d’implémentation pour le nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3770">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="e3cee-3771">Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur plus unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3771">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3772">Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3772">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="e3cee-3773">Type de nœud, levé ou Non levé</span><span class="sxs-lookup"><span data-stu-id="e3cee-3773">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="e3cee-3774">Si la méthode d’implémentation n’est pas `null`:</span><span class="sxs-lookup"><span data-stu-id="e3cee-3774">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="e3cee-3775">Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3775">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3776">Le type du nœud est le type de retour de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3776">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="e3cee-3777">Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :</span><span class="sxs-lookup"><span data-stu-id="e3cee-3777">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="e3cee-3778">`expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3778">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="e3cee-3779">Le type de retour de la méthode d’implémentation est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3779">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="e3cee-3780">Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3780">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="e3cee-3781">Si `expression`. Type non nullable, le nœud n’est pas levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3781">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="e3cee-3782">Sinon, le nœud est levé.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3782">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e3cee-3783"><paramref name="expression" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3783"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e3cee-3784"><paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3784"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e3cee-3785"><paramref name="method" /> est <see langword="null" /> et l'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3785"><paramref name="method" /> is <see langword="null" /> and the unary plus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="e3cee-3786">ou</span><span class="sxs-lookup"><span data-stu-id="e3cee-3786">-or-</span></span> 
 <span data-ttu-id="e3cee-3787"><paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3787"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="e3cee-3788">Objet <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer un unboxing.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3788">An <see cref="T:System.Linq.Expressions.Expression" /> to unbox.</span></span></param>
        <param name="type"><span data-ttu-id="e3cee-3789">Nouveau <see cref="T:System.Type" /> d'une expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3789">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="e3cee-3790">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente un unboxing explicite.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3790">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit unboxing.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3791">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3791">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e3cee-3792">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3792">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-3793">Type du paramètre ou de la variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3793">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="e3cee-3794">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3794">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3795">Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3795">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="e3cee-3796">Type du paramètre ou de la variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3796">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="e3cee-3797">Nom du paramètre ou de la variable.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3797">The name of the parameter or variable.</span></span> <span data-ttu-id="e3cee-3798">Ce nom est utilisé à des fins de débogage ou d'impression uniquement.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3798">This name is used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="e3cee-3799">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3799">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3800">Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3800">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="e3cee-3801">Instance de <see cref="T:System.Func`2" />.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3801">An instance of <see cref="T:System.Func`2" />.</span></span></param>
        <summary><span data-ttu-id="e3cee-3802">Réduit le nœud puis appelle le délégué visiteur sur l'expression réduite.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3802">Reduces the node and then calls the visitor delegate on the reduced expression.</span></span> <span data-ttu-id="e3cee-3803">La méthode lève une exception si le nœud n'est pas réductible.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3803">The method throws an exception if the node is not reducible.</span></span></summary>
        <returns><span data-ttu-id="e3cee-3804">Expression qui est visitée ou expression qui doit la remplacer dans l'arborescence.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3804">The expression being visited, or an expression which should replace it in the tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3cee-3805">Substituez cette méthode pour fournir une logique pour guider les enfants du nœud.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3805">Override this method to provide logic to walk the node's children.</span></span> <span data-ttu-id="e3cee-3806">Une implémentation classique appellera visiteur. Visitez sur chacun de ses enfants, et si un des deux change, elle doit retourner une nouvelle copie d’elle-même avec les enfants modifiés.</span><span class="sxs-lookup"><span data-stu-id="e3cee-3806">A typical implementation will call visitor.Visit on each of its children, and if any of them change, should return a new copy of itself with the modified children.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>