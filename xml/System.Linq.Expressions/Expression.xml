<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4e9615e4182e6b650a9cbb9024f593836bd0e0ca" />
    <Meta Name="ms.sourcegitcommit" Value="1b899505ed6d42225f2b3c9150bfdc080d0d1f9b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/28/2018" />
    <Meta Name="ms.locfileid" Value="32090632" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit la classe de base de laquelle sont dérivées les classes qui représentent des nœuds d’arborescence d’expression. Contient également des méthodes de fabrique <see langword="static" /> (<see langword="Shared" /> en Visual Basic) pour créer les divers types de nœuds. Il s'agit d'une classe <see langword="abstract" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment créer une expression de bloc. L’expression de bloc se compose de deux <xref:System.Linq.Expressions.MethodCallExpression> objets et l’autre <xref:System.Linq.Expressions.ConstantExpression> objet.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> à définir comme type de nœud.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé à partir des constructeurs dans les classes dérivées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
        <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
        <returns>Résultat de la visite de ce nœud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation par défaut pour <xref:System.Linq.Expressions.ExpressionType.Extension> les appels de nœuds <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>. Substituez cette méthode pour appeler une méthode plus spécifique sur une classe dérivée de visiteur de la <xref:System.Linq.Expressions.ExpressionVisitor> classe. Toutefois, il doit toujours prendre en charge les visiteurs inconnus en appelant <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’addition, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur d’addition prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur d’addition prédéfini.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui ajoute deux entiers.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité. La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’addition, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur d’addition prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur d’addition prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur d’addition n’est pas défini pour les types <paramref name="left" />. et <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui ajoute une valeur à une variable de type entier et puis assigne le résultat de l’opération à la variable.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’addition, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur d’addition prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur d’addition prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité. La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 La méthode d’implémentation pour l’opération est choisie selon les règles suivantes :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’addition, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur d’addition prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur d’addition prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur d’addition n’est pas défini pour les types <paramref name="left" />. et <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `AND` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de prédéfinis au niveau du bit `AND` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis au niveau du bit `AND` opérateur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente une opération AND logique sur deux valeurs booléennes.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit. La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 La méthode d’implémentation pour l’opération est choisie selon les règles suivantes :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `AND` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de prédéfinis au niveau du bit `AND` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis au niveau du bit `AND` opérateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="AND" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="true" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `AND` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
    > [!NOTE]
    >  L’attribut conditional `AND` opérateur ne peut pas être surchargé en c# ou Visual Basic. Toutefois, l’attribut conditional `AND` opérateur est évalué à l’aide de l’opérateur de bits `AND` opérateur. Par conséquent, une surcharge définie par l’utilisateur de l’opérateur de bits `AND` opérateur peut être la méthode d’implémentation pour ce type de nœud.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   `left`. Type et `right`. Type sont du même type booléen.  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’attribut conditional prédéfini `AND` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’attribut conditional prédéfini `AND` opérateur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui effectue un opérateur logique et opération sur ses deux opérandes uniquement si le premier opérande prend la valeur `true`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.  
  
 - ou -  
  
 <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true. La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 La méthode d’implémentation pour l’opération est choisie selon les règles suivantes :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `AND` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
    > [!NOTE]
    >  L’attribut conditional `AND` opérateur ne peut pas être surchargé en c# ou Visual Basic. Toutefois, l’attribut conditional `AND` opérateur est évalué à l’aide de l’opérateur de bits `AND` opérateur. Par conséquent, une surcharge définie par l’utilisateur de l’opérateur de bits `AND` opérateur peut être la méthode d’implémentation pour ce type de nœud.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   `left`. Type et `right`. Type sont du même type booléen.  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’attribut conditional prédéfini `AND` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’attribut conditional prédéfini `AND` opérateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="AND" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.  
  
 - ou -  
  
 <paramref name="method" /> est <see langword="null" /> et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">Expression qui représente le tableau multidimensionnel.</param>
        <param name="indexes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des expressions utilisées pour indexer le tableau.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau multidimensionnel.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’expression qui représente le tableau peut être obtenue à l’aide de la <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> (méthode), ou via <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment modifier la valeur d’un élément dans un tableau multidimensionnel à l’aide de la `ArrayAccess` (méthode).  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Expression qui représente le tableau à indexer.</param>
        <param name="indexes">Tableau qui contient des expressions utilisées pour indexer le tableau.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’expression qui représente le tableau peut être obtenue à l’aide de la <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> (méthode), ou via <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
 Pour les tableaux multidimensionnels, utilisez la <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment modifier une valeur d’un élément de tableau à l’aide de la `ArrayAccess` (méthode).  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'application d'un opérateur index de tableau.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale.</param>
        <param name="indexes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang supérieur à un.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque élément de `indexes` doit avoir <xref:System.Linq.Expressions.Expression.Type%2A> égal à <xref:System.Int32>. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array` doit représenter un type de tableau dont le rang correspond au nombre d’éléments de `indexes`.  
  
 Si le rang de `array`. Le type est 1, cette méthode retourne un <xref:System.Linq.Expressions.BinaryExpression>. Le <xref:System.Linq.Expressions.BinaryExpression.Left%2A> est définie sur `array` et <xref:System.Linq.Expressions.BinaryExpression.Right%2A> est définie sur l’élément unique de `indexes`. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de la <xref:System.Linq.Expressions.BinaryExpression> représente le type d’élément de `array`. Type.  
  
 Si le rang de `array`. Type est supérieur à un, cette méthode retourne un <xref:System.Linq.Expressions.MethodCallExpression>. Le <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> est définie sur le <xref:System.Reflection.MethodInfo> qui décrit la méthode d’instance publique `Get` sur le type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’indexation dans un tableau à deux dimensions.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ou <paramref name="indexes" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />.Type ne représente pas un type de tableau.  
  
 - ou -  
  
 Le rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="index">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang un.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` doit représenter un index de type <xref:System.Int32>.  
  
 Le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.BinaryExpression> est `null`, alors que les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ont la valeur `false`. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est égale au type d’élément de `array`. Type. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ou <paramref name="index" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />.Type ne représente pas un type de tableau.  
  
 - ou -  
  
 <paramref name="array" />.Type représente un type de tableau dont le rang n'est pas 1.  
  
 - ou -  
  
 <paramref name="index" />.Type ne représente pas le type <see cref="T:System.Int32" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Tableau d'instances <see cref="T:System.Linq.Expressions.Expression" />, index pour l'opération d'index de tableau.</param>
        <param name="indexes">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau multidimensionnel.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque élément de `indexes` doit avoir <xref:System.Linq.Expressions.Expression.Type%2A> égal à <xref:System.Int32>. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array` doit représenter un type de tableau dont le rang correspond au nombre d’éléments de `indexes`.  
  
 Si le rang de `array`. Le type est 1, cette méthode retourne un <xref:System.Linq.Expressions.BinaryExpression>. Le <xref:System.Linq.Expressions.BinaryExpression.Left%2A> est définie sur `array` et <xref:System.Linq.Expressions.BinaryExpression.Right%2A> est définie sur l’élément unique de `indexes`. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de la <xref:System.Linq.Expressions.BinaryExpression> représente le type d’élément de `array`. Type.  
  
 Si le rang de `array`. Type est supérieur à un, cette méthode retourne un <xref:System.Linq.Expressions.MethodCallExpression>. Le <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> est définie sur le <xref:System.Reflection.MethodInfo> qui décrit la méthode d’instance publique `Get` sur le type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’indexation dans un tableau à deux dimensions.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ou <paramref name="indexes" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />.Type ne représente pas un type de tableau.  
  
 - ou -  
  
 Le rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression permettant d'obtenir la longueur d'un tableau unidimensionnel.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> et la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> est égale à <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `array` doit représenter un type tableau.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est égal à <xref:System.Int32>. Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété `null`, alors que les <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> ont la valeur `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />.Type ne représente pas un type de tableau.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Assign` expression copie une valeur pour les types valeur, et copie une référence pour les types référence.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente une opération d’assignation.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un membre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un champ ou d'une propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égal à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> et dont <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `expression` doit pouvoir être assigné au type représenté par le <xref:System.Reflection.FieldInfo.FieldType%2A> ou <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété du `member`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> ou <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> ne représente pas un champ ou une propriété.  
  
 - ou -  
  
 La propriété représentée par <paramref name="member" /> n'a pas d'accesseur <see langword="set" />.  
  
 - ou -  
  
 <paramref name="expression" />. Le type n’est pas assignable au type de champ ou à la propriété que <paramref name="member" /> représente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un membre à l'aide d'une méthode d'accesseur de propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> a la valeur <paramref name="expression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `expression` doit pouvoir être assigné au type représenté par le <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété de la propriété accédée dans `propertyAccessor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> ou <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  
  
 - ou -  
  
 La propriété à laquelle <paramref name="propertyAccessor" /> accède n’a pas d’accesseur <see langword="set" />.  
  
 - ou -  
  
 <paramref name="expression" />. Le type n’est pas assignable au type de champ ou à la propriété que <paramref name="member" /> représente.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">Expressions contenues dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">Expressions contenues dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression de bloc. L’expression de bloc se compose de deux <xref:System.Linq.Expressions.MethodCallExpression> objets et l’autre <xref:System.Linq.Expressions.ConstantExpression> objet.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">Variables contenues dans le bloc.</param>
        <param name="expressions">Expressions contenues dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment passer un paramètre à une expression block et traiter ce paramètre dans un bloc.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Variables contenues dans le bloc.</param>
        <param name="expressions">Expressions contenues dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Première expression contenue dans le bloc.</param>
        <param name="arg1">Deuxième expression contenue dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Type de résultat du bloc.</param>
        <param name="expressions">Expressions contenues dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Type de résultat du bloc.</param>
        <param name="expressions">Expressions contenues dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Première expression contenue dans le bloc.</param>
        <param name="arg1">Deuxième expression contenue dans le bloc.</param>
        <param name="arg2">Troisième expression contenue dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient trois expressions et aucune variable.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Type de résultat du bloc.</param>
        <param name="variables">Variables contenues dans le bloc.</param>
        <param name="expressions">Expressions contenues dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Type de résultat du bloc.</param>
        <param name="variables">Variables contenues dans le bloc.</param>
        <param name="expressions">Expressions contenues dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Première expression contenue dans le bloc.</param>
        <param name="arg1">Deuxième expression contenue dans le bloc.</param>
        <param name="arg2">Troisième expression contenue dans le bloc.</param>
        <param name="arg3">Quatrième expression contenue dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient quatre expressions et aucune variable.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Première expression contenue dans le bloc.</param>
        <param name="arg1">Deuxième expression contenue dans le bloc.</param>
        <param name="arg2">Troisième expression contenue dans le bloc.</param>
        <param name="arg3">Quatrième expression contenue dans le bloc.</param>
        <param name="arg4">Cinquième expression contenue dans le bloc.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’expression de bloc est exécutée, elle retourne la valeur de la dernière expression dans le bloc.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer une expression qui contienne un <xref:System.Linq.Expressions.LoopExpression> objet qui utilise le <xref:System.Linq.Expressions.Expression.Break%2A> (méthode).  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui ne prend aucun argument.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour représenter un appel à une `static` (`Shared` en Visual Basic) méthode, passez `null` pour la `instance` paramètre lorsque vous appelez cette méthode.  
  
 Si `method` représente une méthode d’instance, le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `instance` doit pouvoir être assigné au type de déclaration de la méthode représentée par `method`.  
  
 Le <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est vide. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est égale au type de retour de la méthode représentée par `method`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui appelle une méthode sans arguments.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
        <param name="arguments">Collection de <see cref="T:System.Linq.Expressions.Expression" /> qui représente les arguments de l'appel.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique (méthode partagée en Visual Basic).</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) qui prend un seul argument.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer une expression qui appelle un `static` (`Shared` en Visual Basic) méthode qui prend un argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
        <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) comportant des arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `arguments` n’est pas `null`, il doit avoir le même nombre d’éléments que le nombre de paramètres pour la méthode représentée par `method`. Chaque élément `arguments` ne doit pas être `null` et doit pouvoir être assigné au paramètre correspondant de `method`, éventuellement après *devis*.  
  
> [!NOTE]
>  Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>. Guillemets signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud. Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.  
  
 Le <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est vide si `arguments` est `null`. Sinon, elle contient les mêmes éléments que `arguments`, certains d'entre eux peuvent être mis entre guillemets.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode représentée par `method`. La propriété <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> a la valeur `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.  
  
 - ou -  
  
 Un ou plusieurs des éléments des <paramref name="arguments" /> n’est pas assignable au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour représenter un appel à une `static` (`Shared` en Visual Basic) méthode, passez `null` pour le `instance` paramètre lorsque vous appelez cette méthode, ou appelez <xref:System.Linq.Expressions.Expression.Call%2A> à la place.  
  
 Si `method` représente une méthode d’instance, le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `instance` doit pouvoir être assigné au type de déclaration de la méthode représentée par `method`.  
  
 Si `arguments` n’est pas `null`, il doit avoir le même nombre d’éléments que le nombre de paramètres pour la méthode représentée par `method`. Chaque élément `arguments` ne doit pas être `null` et doit pouvoir être assigné au paramètre correspondant de `method`, éventuellement après *devis*.  
  
> [!NOTE]
>  Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>. Guillemets signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud. Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.  
  
 Le <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est vide si `arguments` est `null`. Sinon, elle contient les mêmes éléments que `arguments`, certains d'entre eux peuvent être mis entre guillemets.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode représentée par `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.  
  
 - ou -  
  
 Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.  
  
 - ou -  
  
 Un ou plusieurs des éléments des <paramref name="arguments" /> n’est pas assignable au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
        <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour représenter un appel à une `static` (`Shared` en Visual Basic) méthode, passez `null` pour le `instance` paramètre lorsque vous appelez cette méthode, ou appelez <xref:System.Linq.Expressions.Expression.Call%2A> à la place.  
  
 Si `method` représente une méthode d’instance, le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `instance` doit pouvoir être assigné au type de déclaration de la méthode représentée par `method`.  
  
 Si `arguments` n’est pas `null`, il doit avoir le même nombre d’éléments que le nombre de paramètres pour la méthode représentée par `method`. Chaque élément `arguments` ne doit pas être `null` et doit pouvoir être assigné au paramètre correspondant de `method`, éventuellement après *devis*.  
  
> [!NOTE]
>  Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>. Guillemets signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud. Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.  
  
 Le <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est vide si `arguments` est `null`. Sinon, elle contient les mêmes éléments que `arguments`, certains d'entre eux peuvent être mis entre guillemets.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode représentée par `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.  
  
 - ou -  
  
 <paramref name="arguments" /> n’est pas <see langword="null" /> et un ou plusieurs de ses éléments sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.  
  
 - ou -  
  
 Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.  
  
 - ou -  
  
 Un ou plusieurs des éléments des <paramref name="arguments" /> n’est pas assignable au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant deux arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance. (Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend deux arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui appelle une méthode d’instance qui a deux arguments.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> dont la valeur de propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> fera l'objet d'une recherche de méthode spécifique.</param>
        <param name="methodName">Nom de la méthode.</param>
        <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique. Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
        <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode en appelant la méthode de fabrique appropriée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> est égale à <paramref name="instance" />, dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'instance spécifiée, et dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode représentée par `methodName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ou <paramref name="methodName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="instance" />.Type ou ses types de base.  
  
 - ou -  
  
 Plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="instance" />.Type ou ses types de base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant trois arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> qui spécifie le type contenant la méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) spécifiée.</param>
        <param name="methodName">Nom de la méthode.</param>
        <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique. Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
        <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) en appelant la méthode de fabrique appropriée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) spécifiée, et dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MethodCallExpression> est égal au type de retour de la méthode représentée par `methodName`. La propriété <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> a la valeur `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="methodName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="type" /> ou ses types de base.  
  
 - ou -  
  
 Plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="type" /> ou ses types de base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance. (Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend trois arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
        <param name="arg3">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant quatre arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
        <param name="arg3">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
        <param name="arg4">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant cinq arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique que le nœud peut être réduit à un nœud plus simple. Si la valeur retournée est true, Reduce() peut être appelé pour produire la forme réduite.</summary>
        <value>True si le nœud peut être réduit ; sinon, false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">
          <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
        <param name="body">Corps de l'instruction Catch.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec une référence à l'objet <see cref="T:System.Exception" /> intercepté pour une utilisation dans le corps du gestionnaire.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
        <param name="body">Corps de l'instruction Catch.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> de <xref:System.Exception> à intercepter peut être spécifié mais aucune référence à la <xref:System.Exception> objet sera disponible pour une utilisation dans le <xref:System.Linq.Expressions.CatchBlock>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">
          <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
        <param name="body">Corps de l'instruction Catch.</param>
        <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" /> et une référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
        <param name="body">Corps de l'instruction Catch.</param>
        <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" />, sans référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour la suppression d'un point de séquence.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour le nettoyage d'un point de séquence.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.BinaryExpression> est `null` et <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ont la valeur `false`. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est égale au type de résultat de l’opération de fusion. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
#### <a name="result-type"></a>Type de résultat  
 Les règles suivantes déterminent le type de résultat :  
  
-   Si `left`. Type représente un type nullable et `right`. Le type est implicitement convertible en type non nullable correspondant, le type de résultat est l’équivalent non nullable de `left`. Type.  
  
-   Sinon, si `right`. Le type est implicitement convertible en `left`. Est de type, le type de résultat `left`. Type.  
  
-   Sinon, si l’équivalent non nullable de `left`. Le type est implicitement convertible en `right`. Est de type, le type de résultat `right`. Type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.</exception>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion, à partir d'une fonction de conversion.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.BinaryExpression> est `null` et <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ont la valeur `false`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.BinaryExpression> est égal au type de résultat de l’opération de fusion.  
  
 Les règles suivantes déterminent le type de résultat :  
  
-   Si `left`. Type représente un type nullable et `right`. Le type est implicitement convertible en type non nullable correspondant, le type de résultat est l’équivalent non nullable de `left`. Type.  
  
-   Sinon, si `right`. Le type est implicitement convertible en `left`. Est de type, le type de résultat `left`. Type.  
  
-   Sinon, si l’équivalent non nullable de `left`. Le type est implicitement convertible en `right`. Est de type, le type de résultat `right`. Type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.  
  
 - ou -  
  
 <paramref name="conversion" /> n'est pas <see langword="null" /> et <paramref name="conversion" />.Type est un type délégué qui ne prend pas exactement un argument.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> représente un type qui ne peut pas être assigné au type de paramètre du type délégué <paramref name="conversion" />.Type.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> n'est pas égale au type de retour du type délégué <paramref name="conversion" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
        <param name="ifFalse">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ConditionalExpression> est égal à la <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `ifTrue`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente une instruction conditionnelle. Si le premier argument prend la valeur `true`, le deuxième argument est exécutée ; sinon, le troisième argument est exécuté.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="test" /> ou <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="test" />.Type n'est pas <see cref="T:System.Boolean" />.  
  
 - ou -  
  
 <paramref name="ifTrue" />.Type n'est pas égal à <paramref name="ifFalse" />.Type.</exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
        <param name="ifFalse">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’unifier explicitement le type de résultat de l’expression conditionnelle dans les cas où les types de `ifTrue` et `ifFalse` expressions ne sont pas égales. Types de `ifTrue` et `ifFalse` doit être implicitement référence peut être assigné au type de résultat. Le `type` est autorisé à être <xref:System.Void>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ConstantExpression> est égal au type de `value`. Si `value` est `null`, <xref:System.Linq.Expressions.Expression.Type%2A> est égal à <xref:System.Object>.  
  
 Pour représenter `null`, vous pouvez également utiliser le <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> méthode, avec lequel vous pouvez spécifier explicitement le type.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente une valeur constante.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utile pour représenter des valeurs de types nullable.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente une constante du type nullable et définissez sa valeur sur `null`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> n'est pas <see langword="null" /> et <paramref name="type" /> ne peut pas être assigné à partir du type dynamique de <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer une expression de boucle qui utilise le <xref:System.Linq.Expressions.Expression.Continue%2A> (méthode).  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue avec le type spécifié.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion de type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion de type.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. La propriété <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> a la valeur `false`. Si le nœud est levé, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> est `true`. Sinon, il s'agit de `false`.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le paramètre `expression`. Type ou `type` est un type défini par l’utilisateur qui définit un opérateur de conversion implicite ou explicite, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon :  
  
    -   Si les deux `expression`. Type et `type` représentent des types numériques ou booléennes ou des types énumération nullable ou non nullable, la méthode d’implémentation est `null`.  
  
    -   Si le paramètre `expression`. Type ou `type` est un type référence et une conversion boxing explicite, unboxing ou conversion de référence existe à partir de `expression`. Type de `type`, la méthode d’implémentation est `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation et le type de retour de la méthode d’implémentation est assignable à `type`, le nœud n’est pas levé.  
  
-   Si un ou deux de `expression`. Type ou `type` est un type valeur nullable et les types de valeur non nullable correspondants sont égaux pour le type d’argument et le type de retour de la méthode d’implémentation, respectivement, le nœud est levé.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si les deux `expression`. Type et `type` sont non nullable, le nœud n’est pas levé.  
  
-   Dans le cas contraire, le nœud est levé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente une opération de conversion de type.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion pour laquelle la méthode d'implémentation est spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. La propriété <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> a la valeur `false`. Si le nœud est levé, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> est `true`. Sinon, il s'agit de `false`.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si la méthode n’est pas `null`, il s’agit de la méthode d’implémentation. Il doit représenter un non void `static` (`Shared` en Visual Basic) méthode qui prend un argument.  
  
-   Sinon, si le paramètre `expression`. Type ou `type` est un type défini par l’utilisateur qui définit un opérateur de conversion implicite ou explicite, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon :  
  
    -   Si les deux `expression`. Type et `type` représentent des types numériques ou booléennes ou des types énumération nullable ou non nullable, la méthode d’implémentation est `null`.  
  
    -   Si le paramètre `expression`. Type ou `type` est un type référence et une conversion boxing explicite, unboxing ou conversion de référence existe à partir de `expression`. Type de `type`, la méthode d’implémentation est `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation et le type de retour de la méthode d’implémentation est assignable à `type`, le nœud n’est pas levé.  
  
-   Si un ou les deux de `expression`. Type ou `type` sont un type valeur nullable et les types de valeur non nullable correspondants sont égaux pour le type d’argument et le type de retour de la méthode d’implémentation, respectivement, le nœud est levé.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si les deux `expression`. Type et `type` sont non nullable, le nœud n’est pas levé.  
  
-   Dans le cas contraire, le nœud est levé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.  
  
 - ou -  
  
 <paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.  
  
 - ou -  
  
 Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.  
  
 - ou -  
  
 <paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. La propriété <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> a la valeur `false`. Si le nœud est levé, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> est `true`. Sinon, il s'agit de `false`.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le paramètre `expression`. Type ou `type` est un type défini par l’utilisateur qui définit un opérateur de conversion implicite ou explicite, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon :  
  
    -   Si les deux `expression`. Type et `type` représentent des types numériques ou booléennes ou des types énumération nullable ou non nullable, la méthode d’implémentation est `null`.  
  
    -   Si le paramètre `expression`. Type ou `type` est un type référence et une conversion boxing explicite, unboxing ou conversion de référence existe à partir de `expression`. Type de `type`, la méthode d’implémentation est `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation et le type de retour de la méthode d’implémentation est assignable à `type`, le nœud n’est pas levé.  
  
-   Si un ou les deux de `expression`. Type ou `type` sont un type valeur nullable et les types de valeur non nullable correspondants sont égaux pour le type d’argument et le type de retour de la méthode d’implémentation, respectivement, le nœud est levé.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si les deux `expression`. Type et `type` sont non nullable, le nœud n’est pas levé.  
  
-   Dans le cas contraire, le nœud est levé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible et pour lequel la méthode d'implémentation est spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. La propriété <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> a la valeur `false`. Si le nœud est levé, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> est `true`. Sinon, il s'agit de `false`.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si la méthode n’est pas `null`, il s’agit de la méthode d’implémentation. Il doit représenter un non void `static` (`Shared` en Visual Basic) méthode qui prend un argument.  
  
-   Sinon, si le paramètre `expression`. Type ou `type` est un type défini par l’utilisateur qui définit un opérateur de conversion implicite ou explicite, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon :  
  
    -   Si les deux `expression`. Type et `type` représentent des types numériques ou booléennes ou des types énumération nullable ou non nullable, la méthode d’implémentation est `null`.  
  
    -   Si le paramètre `expression`. Type ou `type` est un type référence et une conversion boxing explicite, unboxing ou conversion de référence existe à partir de `expression`. Type de `type`, la méthode d’implémentation est `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type ne peut être assigné au type d’argument de la méthode d’implémentation et le type de retour de la méthode d’implémentation est assignable à `type`, le nœud n’est pas levé.  
  
-   Si un ou les deux de `expression`. Type ou `type` sont un type valeur nullable et les types de valeur non nullable correspondants sont égaux pour le type d’argument et le type de retour de la méthode d’implémentation, respectivement, le nœud est levé.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si les deux `expression`. Type et `type` sont non nullable, le nœud n’est pas levé.  
  
-   Dans le cas contraire, le nœud est levé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.  
  
 - ou -  
  
 <paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.  
  
 - ou -  
  
 Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.  
  
 - ou -  
  
 <paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
        <param name="startLine">Ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Doit être supérieure à 0.</param>
        <param name="startColumn">Colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Doit être supérieure à 0.</param>
        <param name="endLine">Ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Doit être supérieure ou égale à la ligne de début.</param>
        <param name="endColumn">Colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Si la ligne de fin est la même que la ligne de début, elle doit être supérieure ou égale à la colonne de début. Dans tous les cas, elle doit être supérieure à 0.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> avec l'étendue spécifiée.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette expression est fonctionnelle et ne modifie pas la valeur de l’objet passé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui soustrait 1 à partir d’une valeur donnée.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette expression est fonctionnelle et ne modifie pas la valeur de l’objet passé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente un valeur par défaut pour un type donné.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de division, les <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de division prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de division prédéfini.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui divise son premier argument par son deuxième argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique. La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de division, les <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de division prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de division prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur de division n’est pas défini pour les types <paramref name="left" />. et <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="returnType">Type de résultat de l'expression dynamique.</param>
        <param name="arguments">Arguments de l'opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="returnType">Type de résultat de l'expression dynamique.</param>
        <param name="arg0">Premier argument de l'opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="returnType">Type de résultat de l'expression dynamique.</param>
        <param name="arguments">Arguments de l'opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="returnType">Type de résultat de l'expression dynamique.</param>
        <param name="arg0">Premier argument de l'opération dynamique.</param>
        <param name="arg1">Deuxième argument de l’opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="returnType">Type de résultat de l'expression dynamique.</param>
        <param name="arg0">Premier argument de l'opération dynamique.</param>
        <param name="arg1">Deuxième argument de l’opération dynamique.</param>
        <param name="arg2">Troisième argument de l’opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="returnType">Type de résultat de l'expression dynamique.</param>
        <param name="arg0">Premier argument de l'opération dynamique.</param>
        <param name="arg1">Deuxième argument de l’opération dynamique.</param>
        <param name="arg2">Troisième argument de l’opération dynamique.</param>
        <param name="arg3">Quatrième argument de l'opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriété du résultat est déduite à partir des types des arguments et le type de retour spécifié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> comme deuxième argument.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `addMethod` paramètre doit représenter une méthode d’instance nommée « Add » (non respect de la casse). La méthode add doit avoir le même nombre de paramètres que le nombre d’éléments dans `arguments`. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `arguments` doit pouvoir être assigné au type du paramètre correspondant de la méthode add, éventuellement après *devis*.  
  
> [!NOTE]
>  Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>. Guillemets signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud. Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.ElementInit> qui représente l’appel du <xref:System.Collections.Generic.Dictionary%602.Add%2A> méthode pour initialiser un élément d’une collection de dictionnaires.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> ou <paramref name="arguments" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La méthode représentée par <paramref name="addMethod" /> n’est pas nommée « Add » (non-respect de la casse).  
  
 - ou -  
  
 La méthode représentée par <paramref name="addMethod" /> n’est pas une méthode d’instance.  
  
 - ou -  
  
 Le nombre d’éléments que contient <paramref name="arguments" /> ne correspond pas au nombre de paramètres de la méthode représentée par <paramref name="addMethod" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="arguments" /> n’est pas affectable au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
        <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un tableau de valeurs comme deuxième argument.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `addMethod` paramètre doit représenter une méthode d’instance nommée « Add » (non respect de la casse). La méthode add doit avoir le même nombre de paramètres que le nombre d’éléments dans `arguments`. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `arguments` doit pouvoir être assigné au type du paramètre correspondant de la méthode add, éventuellement après *devis*.  
  
> [!NOTE]
>  Un élément sera mis entre guillemets uniquement si le paramètre de méthode correspondant est de type <xref:System.Linq.Expressions.Expression>. Guillemets signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud. Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.ElementInit> qui représente l’appel du <xref:System.Collections.Generic.Dictionary%602.Add%2A> méthode pour initialiser un élément d’une collection de dictionnaires.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> ou <paramref name="arguments" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La méthode représentée par addMethod n'est pas nommée "Add" (non respect de la casse).  
  
 - ou -  
  
 La méthode représentée par addMethod n'est pas une méthode d'instance.  
  
 - ou -  
  
 arguments ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par addMethod.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="arguments" /> n’est pas affectable au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une expression vide qui a le type <see cref="T:System.Void" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> est égale à <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une expression vide peut être utilisée où une expression est attendue, mais aucune action n’est pas souhaitée. Par exemple, vous pouvez utiliser une expression vide en tant que la dernière expression dans une expression de bloc. Dans ce cas, la valeur de retour de l’expression de bloc est void.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression vide et l’ajouter à une expression de bloc.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`. Sinon, il s'agit de `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`. Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’égalité, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est <xref:System.Boolean>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui vérifie si les valeurs de ses deux arguments sont égales.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="liftToNull">
          <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité. La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`. Dans le cas contraire, elles sont toutes deux `false`. Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’égalité, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="XOR" /> au niveau du bit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation <see langword="XOR" /> au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge le `XOR` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de la `XOR` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis `XOR` opérateur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente l’opération XOR logique.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur <see langword="XOR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation <see langword="XOR" /> au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur. La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent l’implémentation de méthode pour l’opération sélectionné :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge le `XOR` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de la `XOR` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis `XOR` opérateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="XOR" /> n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation XOR au niveau du bit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale. Pour <see langword="static" /> (<see langword="Shared" /> en Visual Basic), <c>expression</c> doit avoir la valeur <see langword="null" />.</param>
        <param name="field">
          <see cref="T:System.Reflection.FieldInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égal à la <xref:System.Reflection.FieldInfo.FieldType%2A> propriété du `field`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> est <see langword="null" />.  
  
 - ou -  
  
 Le champ représenté par <paramref name="field" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration du champ représenté par <paramref name="field" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient un champ nommé <c>fieldName</c>. Cette valeur peut être null pour les champs static.</param>
        <param name="fieldName">Nom d'un champ auquel accéder.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ à partir du nom du champ.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ désigné par <paramref name="fieldName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égal à la <xref:System.Reflection.FieldInfo.FieldType%2A> propriété de la <xref:System.Reflection.FieldInfo> qui représente le champ désigné par `fieldName`.  
  
 Cette méthode recherche `expression`. Type et ses types de base pour un champ qui porte le nom `fieldName`. Champs publics sont prioritaires sur les champs non publics. Si un champ correspondant est trouvé, cette méthode passe `expression` et <xref:System.Reflection.FieldInfo> qui représente ce champ à <xref:System.Linq.Expressions.Expression.Field%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente l’accès à un champ.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="fieldName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Aucun champ nommé <paramref name="fieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Objet conteneur du champ. Cette valeur peut être null pour les champs static.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient le champ.</param>
        <param name="fieldName">Champ auquel accéder.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Tableau contenant jusqu'à seize objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué <see langword="System.Action" />.</param>
        <summary>Crée un objet <see cref="T:System.Type" /> qui représente un type délégué <c>System.Action</c> générique ayant des arguments de type spécifiques.</summary>
        <returns>Type d’un délégué <c>System.Action</c> qui a les arguments de type spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, si les éléments de `typeArgs` représentent les types `T1…Tn`, résultant <xref:System.Type> objet représente le type délégué construit `System.Action<T1,…,Tn>` en c# ou `System.Action(Of T1,…,Tn)` en Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" /> contient plus de seize éléments.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Arguments de type du délégué.</param>
        <summary>Obtient un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué <c>System.Func</c> ou <c>System.Action</c> générique ayant des arguments de type spécifiques.</summary>
        <returns>Type de délégué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dernier argument de type détermine le type de retour du délégué. Si aucune fonction ou Action n’est assez grande, elle génère un type délégué personnalisé.  
  
 Comme avec Func, le dernier argument est le type de retour. Elle peut être définie à System.Void pour produire une Action.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Tableau contenant entre un et dix-sept objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué <see langword="System.Func" />.</param>
        <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué <c>System.Func</c> générique ayant des arguments de type spécifiques. Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
        <returns>Type d’un délégué <c>System.Func</c> qui a les arguments de type spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `typeArgs` doit contenir au moins un et dix-sept au maximum des éléments.  
  
 Par exemple, si les éléments de `typeArgs` représentent les types `T1…Tn`, résultant <xref:System.Type> objet représente le type délégué construit `System.Func<T1,…,Tn>` en c# ou `System.Func(Of T1,…,Tn)` en Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" /> contient moins d'un élément ou plus de dix sept éléments.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer une expression qui contienne un <xref:System.Linq.Expressions.GotoExpression> objet.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ».</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ».</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`. Sinon, il s'agit de `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « supérieur à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est <xref:System.Boolean>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui compare deux entiers.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="liftToNull">
          <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ». La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`. Dans le cas contraire, elles sont toutes deux `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « supérieur à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`. Sinon, il s'agit de `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « supérieur ou égal à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est <xref:System.Boolean>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui compare deux entiers.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur "supérieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="liftToNull">
          <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`. Dans le cas contraire, elles sont toutes deux `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « supérieur ou égal à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur “supérieur à ou égal à” n'est pas défini pour les types <paramref name="left" /> et <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec une instruction <see langword="if" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ont les valeurs spécifiées. Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ayant pour valeur l'expression par défaut et dont le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente un bloc conditionnel.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
        <param name="ifFalse">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec des instructions <see langword="if" /> et <see langword="else" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées. Le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente un bloc conditionnel.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de la valeur de l'expression par 1.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de la valeur de l'expression par 1.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette expression est fonctionnelle et ne modifie pas la valeur de l’objet qui lui est passé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente une opération d’incrément.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de l'expression par 1.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette expression est fonctionnelle et ne modifie pas la valeur de l’objet qui lui est passé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression lambda ou le délégué auquel appliquer.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments auxquels le délégué ou l'expression lambda sont appliqués.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l'expression lambda spécifiée aux arguments fournis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.InvocationExpression> représente le type de retour du délégué qui est représenté par `expression`. Type.  
  
 Le <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.InvocationExpression> est vide si `arguments` est `null`. Sinon, elle contient les mêmes éléments que `arguments` mais certains de ces <xref:System.Linq.Expressions.Expression> objets peuvent être *entre guillemets*.  
  
> [!NOTE]
>  Un élément sera mis entre guillemets uniquement si le paramètre correspondant du délégué représenté par `expression` est de type <xref:System.Linq.Expressions.Expression>. Guillemets signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud. Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.InvocationExpression> qui représente l’appel d’une expression lambda avec des arguments spécifiés.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué ou l'expression lambda à appliquer.</param>
        <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué ou l'expression lambda est appliquée.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l'expression lambda spécifiée aux arguments fournis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.InvocationExpression> représente le type de retour du délégué qui est représenté par `expression`. Type.  
  
 Le <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.InvocationExpression> est vide si `arguments` est `null`. Sinon, elle contient les mêmes éléments que `arguments` mais certains de ces <xref:System.Linq.Expressions.Expression> objets peuvent être *entre guillemets*.  
  
> [!NOTE]
>  Un élément sera mis entre guillemets uniquement si le paramètre correspondant du délégué représenté par `expression` est de type <xref:System.Linq.Expressions.Expression>. Guillemets signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud. Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `arguments`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.InvocationExpression> qui représente l’appel d’une expression lambda avec des arguments spécifiés.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indique si l'expression prend la valeur false.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
        <summary>Indique si l'expression prend la valeur false.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Indique si l'expression prend la valeur false.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indique si l'expression prend la valeur true.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
        <summary>Indique si l'expression prend la valeur true.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Indique si l'expression prend la valeur true.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type void et aucun nom.</summary>
        <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer une expression qui contienne un <xref:System.Linq.Expressions.LabelTarget> objet.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette sans valeur par défaut.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LabelExpression" /> sans valeur par défaut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l'étiquette.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et le nom donné.</summary>
        <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type donné.</summary>
        <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Linq.Expressions.LabelTarget> objet dans une expression de boucle.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
        <param name="defaultValue">Valeur de ce <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via un flux de contrôle normal.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette avec la valeur par défaut donnée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LabelExpression" /> avec la valeur par défaut donnée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
        <param name="name">Nom de l'étiquette.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type et le nom donnés.</summary>
        <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une arborescence d’expression qui représente une expression lambda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `parameters` paramètre ne doit pas contenir plus de seize éléments.  
  
 Les éléments de `parameters` doit être égal à dans les expressions de paramètre de référence `body`.  
  
 Cette méthode construit un type délégué approprié parmi les `System.Func` délégués génériques. Il passe ensuite le type de délégué à un de le <xref:System.Linq.Expressions.ExpressionType.Lambda> des méthodes de fabrique pour créer un <xref:System.Linq.Expressions.LambdaExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> est <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="parameters" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameters" /> contient plus de seize éléments.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="tailCall">
          <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="tailCall">
          <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
        <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="name">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
        <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet qui est retourné à partir de cette fonction est de type <xref:System.Linq.Expressions.Expression%601>. Le <xref:System.Linq.Expressions.LambdaExpression> type est utilisé pour représenter l’objet retourné, car le type concret de l’expression lambda n’est pas connu au moment de la compilation.  
  
 Le nombre de paramètres pour le type de délégué représenté par`delegateType` doit être égale à la longueur de `parameters`.  
  
 Les éléments de `parameters` doit être égal à dans les expressions de paramètre de référence `body`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de l’objet résultant est égale à `delegateType`. Si `parameters` est `null`, le <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriété de l’objet résultant est une collection vide.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une expression qui représente une expression lambda qui ajoute 1 à l’argument passé.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> ou <paramref name="body" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> ne représente pas un type délégué.  
  
 - ou -  
  
 <paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.  
  
 - ou -  
  
 <paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
        <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet qui est retourné à partir de cette fonction est de type <xref:System.Linq.Expressions.Expression%601>. Le <xref:System.Linq.Expressions.LambdaExpression> type est utilisé pour représenter l’objet retourné, car le type concret de l’expression lambda n’est pas connu au moment de la compilation.  
  
 Le nombre de paramètres pour le type de délégué représenté par `delegateType` doit être égale à la longueur de `parameters`.  
  
 Les éléments de `parameters` doit être égal à dans les expressions de paramètre de référence `body`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de l’objet résultant est égale à `delegateType`. Si `parameters` est `null`, le <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriété de l’objet résultant est une collection vide.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> ou <paramref name="body" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> ne représente pas un type délégué.  
  
 - ou -  
  
 <paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.  
  
 - ou -  
  
 <paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="name">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
        <param name="tailCall">
          <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="tailCall">
          <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="tailCall">
          <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
        <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="name">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="name">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
        <param name="tailCall">
          <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Type délégué.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nombre de paramètres pour le type délégué `TDelegate` doit être égal au nombre d’éléments de `parameters`.  
  
 Les éléments de `parameters` doit être égal à dans les expressions de paramètre de référence `body`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de l’objet résultant représente le type `TDelegate`. Si `parameters` est `null`, le <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriété de l’objet résultant est une collection vide.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> est <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" /> n'est pas un type délégué.  
  
 - ou -  
  
 <paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.  
  
 - ou -  
  
 <paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Type délégué.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nombre de paramètres pour le type délégué `TDelegate` doit être égal au nombre d’éléments de `parameters`.  
  
 Les éléments de `parameters` doit être égal à dans les expressions de paramètre de référence`body`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de l’objet résultant représente le type `TDelegate`. Si `parameters` est `null`, le <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriété de l’objet résultant est une collection vide.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> est <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" /> n'est pas un type délégué.  
  
 - ou -  
  
 <paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.  
  
 - ou -  
  
 <paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Type de délégué.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="tailCall">
          <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Type de délégué.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="tailCall">
          <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
        <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Type de délégué.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="name">Nom de l'expression lambda. Utilisé pour la génération des informations de débogage.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Type de délégué.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
        <param name="name">Nom de l'expression lambda. Utilisé pour la génération des informations de débogage.</param>
        <param name="tailCall">
          <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de décalage vers la gauche, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Le type est un type intégral (un des <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou les types nullables correspondants) et `right`. Est de type <xref:System.Int32>, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de décalage vers la gauche prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de décalage vers la gauche prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de décalage vers la gauche, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Le type est un type intégral (un des <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou les types nullables correspondants) et `right`. Est de type <xref:System.Int32>, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de décalage vers la gauche prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de décalage vers la gauche prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`. Sinon, il s'agit de `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 La méthode d’implémentation pour l’opération est choisie selon les règles suivantes :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « inférieur à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est <xref:System.Boolean>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui compare deux entiers.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="liftToNull">
          <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`. Dans le cas contraire, elles sont toutes deux `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « inférieur à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> a la valeur <see langword="null" /> et l’opérateur « inférieur à » n’est pas défini pour <paramref name="left" />.Type. et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`. Sinon, il s'agit de `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « inférieur ou égal à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est <xref:System.Boolean>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui compare deux entiers.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="liftToNull">
          <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`. Dans le cas contraire, elles sont toutes deux `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur « inférieur ou égal à », le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> est <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> ne représente pas un champ ou une propriété.  
  
 - ou -  
  
 Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
        <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> est <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> ne représente pas un champ ou une propriété.  
  
 - ou -  
  
 Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
        <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> est <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  
  
 - ou -  
  
 Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
        <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
        <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> est <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  
  
 - ou -  
  
 Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.ListInitExpression> qui représente l’initialisation d’une nouvelle instance de dictionnaire avec deux paires clé-valeur.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.  
  
 Pour pouvoir utiliser cette surcharge de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Type ou son type de base doit déclarer une méthode unique nommée « Add » (non respect de la casse) qui prend un seul argument. Le type de l’argument doit être assignable à partir du type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du premier élément de `initializers`.  
  
 Le <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriété retourné <xref:System.Linq.Expressions.ListInitExpression> contient un élément de type <xref:System.Linq.Expressions.ElementInit> pour chaque élément de `initializers`. Le <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est une collection de singletons qui contient l’élément correspondant de `initializers`. Le <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> représente la méthode add a été détectée sur `newExpression`. Type ou son type de base.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il n’existe aucune méthode d’instance nommée « Add » (non-respect de la casse) déclaré dans <paramref name="newExpression" />.Type ou son type de base.  
  
 - ou -  
  
 La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.  
  
 - ou -  
  
 Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> n’est pas affectable au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.  
  
 - ou -  
  
 Plusieurs méthodes compatibles avec des arguments nommées « Add » (non-respect de la casse) existent sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
        <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.ListInitExpression> qui représente l’initialisation d’une nouvelle instance de dictionnaire avec deux paires clé-valeur.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
        <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.  
  
 Pour pouvoir utiliser cette surcharge de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Type ou son type de base doit déclarer une méthode unique nommée « Add » (non respect de la casse) qui prend un seul argument. Le type de l’argument doit être assignable à partir du type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du premier élément de `initializers`.  
  
 Le <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriété retourné <xref:System.Linq.Expressions.ListInitExpression> contient un élément de type <xref:System.Linq.Expressions.ElementInit> pour chaque élément de `initializers`. Le <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est une collection de singletons qui contient l’élément correspondant de `initializers`. Le <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> représente la méthode add a été détectée sur `newExpression`. Type ou son type de base.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il n’existe aucune méthode d’instance nommée « Add » (non-respect de la casse) déclaré dans <paramref name="newExpression" />.Type ou son type de base.  
  
 - ou -  
  
 La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.  
  
 - ou -  
  
 Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> n’est pas affectable au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.  
  
 - ou -  
  
 Plusieurs méthodes compatibles avec des arguments nommées « Add » (non-respect de la casse) existent sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
        <param name="addMethod">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance nommée "Add" (non respect de la casse), qui ajoute un élément à une collection.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.  
  
 Si `addMethod` est `null`, `newExpression`. Type ou son type de base doit déclarer une méthode unique nommée « Add » (non respect de la casse) qui prend un seul argument. Si `addMethod` n’est pas `null`, il doit représenter une méthode d’instance nommée « Add » (non respect de la casse) qui a un seul paramètre. Le type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `initializers` doit pouvoir être assigné au type d’argument de la méthode add.  
  
 Le <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriété retourné <xref:System.Linq.Expressions.ListInitExpression> contient un élément de type <xref:System.Linq.Expressions.ElementInit> pour chaque élément de `initializers`. Le <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est une collection de singletons qui contient l’élément correspondant de `initializers`. Le <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est égal à `addMethod`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.  
  
 - ou -  
  
 <paramref name="addMethod" /> n'est pas <see langword="null" /> et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.  
  
 - ou -  
  
 <paramref name="addMethod" /> n'est pas <see langword="null" /> et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" /> est <see langword="null" /> et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
        <param name="addMethod">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance prenant un argument, qui ajoute un élément à une collection.</param>
        <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression` doit représenter un type qui implémente <xref:System.Collections.IEnumerable>.  
  
 Si `addMethod` est `null`, `newExpression`. Type ou son type de base doit déclarer une méthode unique nommée « Add » (non respect de la casse) qui prend un seul argument. Si `addMethod` n’est pas `null`, il doit représenter une méthode d’instance nommée « Add » (non respect de la casse) qui a un seul paramètre. Le type représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `initializers` doit pouvoir être assigné au type d’argument de la méthode add.  
  
 Le <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriété retourné <xref:System.Linq.Expressions.ListInitExpression> contient un élément de type <xref:System.Linq.Expressions.ElementInit> pour chaque élément de `initializers`. Le <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est une collection de singletons qui contient l’élément correspondant de `initializers`. Le <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriété de chaque élément de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> est égal à `addMethod`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.ListInitExpression> est égal à `newExpression`. Type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.  
  
 - ou -  
  
 <paramref name="addMethod" /> n'est pas <see langword="null" /> et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.  
  
 - ou -  
  
 <paramref name="addMethod" /> n'est pas <see langword="null" /> et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" /> est <see langword="null" /> et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Corps de la boucle.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">Corps de la boucle.</param>
        <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
        <summary>Crée un objet <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps et la cible d'instruction Break donnés.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer une expression block qui contient un <xref:System.Linq.Expressions.LoopExpression> objet.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">Corps de la boucle.</param>
        <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
        <param name="continue">Cible d'instruction Continue utilisée par le corps de la boucle.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> en appelant la méthode de fabrique appropriée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, à partir des opérandes gauche et droit, en appelant une méthode de fabrique appropriée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `binaryType` paramètre détermine les <xref:System.Linq.Expressions.BinaryExpression> cette méthode appelle de méthode de fabrique. Par exemple, si `binaryType` est <xref:System.Linq.Expressions.ExpressionType.Subtract>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Subtract%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> méthode pour créer un <xref:System.Linq.Expressions.BinaryExpression> qui représente la soustraction d’un nombre d’un autre.  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
        <param name="liftToNull">
          <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit et la méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `binaryType` paramètre détermine les <xref:System.Linq.Expressions.BinaryExpression> méthode de fabrique appelle cette méthode. Par exemple, si `binaryType` est <xref:System.Linq.Expressions.ExpressionType.Subtract>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Subtract%2A>. Le `liftToNull` et `method` paramètres sont ignorés si la méthode de fabrique appropriée n’a pas de paramètre correspondant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
        <param name="liftToNull">
          <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type. Ce paramètre est utilisé uniquement si <c>binaryType</c> a la valeur <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou est une assignation composée.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit, la méthode d'implémentation et la fonction de conversion de type, en appelant la méthode de fabrique appropriée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `binaryType` paramètre détermine les <xref:System.Linq.Expressions.BinaryExpression> méthode de fabrique appelle cette méthode. Par exemple, si `binaryType` est <xref:System.Linq.Expressions.ExpressionType.Subtract>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Subtract%2A>. Le `liftToNull`, `method` et `conversion` paramètres sont ignorés si la méthode de fabrique appropriée n’a pas de paramètre correspondant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
        <param name="variable">
          <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
        <param name="body">Corps de l'instruction Catch.</param>
        <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec les éléments spécifiés.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type` doit être non null et correspond au type de `variable` (si elle est fournie).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="arguments">Arguments de l'opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="arg0">Argument de l'opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et un argument.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="arguments">Arguments de l'opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="arg0">Premier argument de l'opération dynamique.</param>
        <param name="arg1">Deuxième argument de l’opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et deux arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="arg0">Premier argument de l'opération dynamique.</param>
        <param name="arg1">Deuxième argument de l’opération dynamique.</param>
        <param name="arg2">Troisième argument de l’opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et trois arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Classeur de runtime de l'opération dynamique.</param>
        <param name="arg0">Premier argument de l'opération dynamique.</param>
        <param name="arg1">Deuxième argument de l’opération dynamique.</param>
        <param name="arg2">Troisième argument de l’opération dynamique.</param>
        <param name="arg3">Quatrième argument de l'opération dynamique.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et quatre arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind">
          <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> du <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut du <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> spécifié. La valeur passée à l'étiquette au moment du saut peut également être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à <paramref name="kind" />, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Objet auquel la propriété appartient. Doit avoir la valeur Null si la propriété est <see langword="static" /> (<see langword="shared" /> en Visual Basic).</param>
        <param name="indexer">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente la propriété à indexer.</param>
        <param name="arguments">
          <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> en Visual Basic) contenant les arguments qui seront utilisés pour indexer la propriété.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée dans un objet.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet auquel appartient le membre. Cette valeur peut être null pour les membres statiques.</param>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> qui décrit le champ ou la propriété auquel accéder.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ ou à une propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer un <xref:System.Linq.Expressions.MemberExpression> qui représente l’accès à un champ ou une propriété, selon le type de `member`. Si `member` est de type <xref:System.Reflection.FieldInfo>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Field%2A> pour créer le <xref:System.Linq.Expressions.MemberExpression>. Si `member` est de type <xref:System.Reflection.PropertyInfo>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Property%2A> pour créer le <xref:System.Linq.Expressions.MemberExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> ne représente pas un champ ou une propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Type de résultat de l'expression Try. Si Null, le corps et tous les gestionnaires doivent avoir le même type.</param>
        <param name="body">Corps du bloc Try.</param>
        <param name="finally">Corps du bloc Finally. Passez la valeur Null si aucun bloc Finally n'est associé au bloc Try.</param>
        <param name="fault">Corps du bloc Fault. Passez la valeur Null si aucun bloc Fault n'est associé au bloc Try.</param>
        <param name="handlers">Collection de <see cref="T:System.Linq.Expressions.CatchBlock" />s qui représente les instructions catch à associer au bloc Try.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc Try avec les éléments spécifiés.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> en appelant la méthode de fabrique appropriée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
        <param name="operand">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
        <param name="type">
          <see cref="T:System.Type" /> qui spécifie le type vers lequel convertir (passez <see langword="null" />, si non applicable).</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande, en appelant la méthode de fabrique appropriée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `unaryType` paramètre détermine les <xref:System.Linq.Expressions.UnaryExpression> cette méthode appelle de méthode de fabrique. Par exemple, si `unaryType` est égal à <xref:System.Linq.Expressions.ExpressionType.Convert>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Convert%2A>. Le `type`paramètre est ignoré si elle ne s’applique pas à la méthode de fabrique est appelée.  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
        <param name="operand">
          <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
        <param name="type">
          <see cref="T:System.Type" /> qui spécifie le type vers lequel convertir (passez <see langword="null" />, si non applicable).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande et une méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `unaryType` paramètre détermine les <xref:System.Linq.Expressions.UnaryExpression> cette méthode appelle de méthode de fabrique. Par exemple, si `unaryType` est égal à <xref:System.Linq.Expressions.ExpressionType.Convert>, cette méthode appelle <xref:System.Linq.Expressions.Expression.Convert%2A>. Le `type` et `method` paramètres sont ignorés si elles ne s’appliquent pas à la méthode de fabrique est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
        <param name="bindings">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `member` paramètre doit représenter un champ ou une propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> ou <paramref name="bindings" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> ne représente pas un champ ou une propriété.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
        <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `member` paramètre doit représenter un champ ou une propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> ou <paramref name="bindings" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> ne représente pas un champ ou une propriété.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
        <param name="bindings">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
        <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Représente une expression qui crée un nouvel objet et initialise une propriété de l'objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
        <param name="bindings">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
        <summary>Représente une expression qui crée un nouvel objet et initialise une propriété de l'objet.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberInitExpression> est égal à la <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression`.  
  
   
  
## Examples  
 L’exemple suivant montre une expression qui crée un nouvel objet et initialise une propriété de l’objet.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="bindings" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
        <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberInitExpression> est égal à la <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `newExpression`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> méthode pour créer un <xref:System.Linq.Expressions.MemberInitExpression> qui représente l’initialisation des deux membres d’un nouvel objet.  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="bindings" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur modulo, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur modulo prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur modulo prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur modulo n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 La méthode d’implémentation pour l’opération est choisie selon les règles suivantes :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur modulo, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur modulo prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur modulo prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur modulus n’est pas défini pour les types <paramref name="left" /> et <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de multiplication, les <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de multiplication prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de multiplication prédéfini.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui multiplie deux valeurs.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de multiplication, les <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de multiplication prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de multiplication prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de multiplication, les <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de multiplication prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de multiplication prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de multiplication, les <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de multiplication prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de multiplication prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Dans le cas contraire, ils ont la valeur false.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur moins unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type. Si `expression`. Type non nullable, le nœud n’est pas levé. Sinon, le nœud est levé.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une expression qui représente une opération de négation arithmétique.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Dans le cas contraire, ils ont la valeur false.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui prend un argument, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur moins unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type. Si `expression`. Type non nullable, le nœud n’est pas levé. Sinon, le nœud est levé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.  
  
 - ou -  
  
 <paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Dans le cas contraire, ils ont la valeur false.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur moins unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type. Si `expression`. Type non nullable, le nœud n’est pas levé. Sinon, le nœud est levé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité. La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Dans le cas contraire, ils ont la valeur false.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui prend un argument, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur moins unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type. Si `expression`. Type non nullable, le nœud n’est pas levé. Sinon, le nœud est levé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.  
  
 - ou -  
  
 <paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié qui ne prend pas d'arguments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.NewExpression.Arguments%2A> et <xref:System.Linq.Expressions.NewExpression.Members%2A> propriétés des résultats de <xref:System.Linq.Expressions.NewExpression> sont des collections vides. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété représente le type de déclaration du constructeur représenté par `constructor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le constructeur représenté par <paramref name="constructor" /> a au moins un paramètre.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> ayant un constructeur qui ne prend pas d'arguments.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur sans paramètre du type spécifié.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> égale à <see cref="T:System.Reflection.ConstructorInfo" />, laquelle représente le constructeur sans paramètre pour le type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `type` paramètre doit représenter un type qui a un constructeur sans paramètre.  
  
 Le <xref:System.Linq.Expressions.NewExpression.Arguments%2A> et <xref:System.Linq.Expressions.NewExpression.Members%2A> propriétés des résultats de <xref:System.Linq.Expressions.NewExpression> sont des collections vides. Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété est égale à `type`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.New%28System.Type%29> méthode pour créer un <xref:System.Linq.Expressions.NewExpression> qui représente la construction d’une nouvelle instance d’un objet de dictionnaire en appelant le constructeur sans paramètre.  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le type représenté par <paramref name="type" /> n'a pas de constructeur sans paramètres.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `arguments` paramètre doit contenir le même nombre d’éléments que le nombre de paramètres du constructeur représenté par `constructor`. Si `arguments` est `null`, il est considéré comme vide et la <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> représente le type de déclaration du constructeur représenté par `constructor`. Le <xref:System.Linq.Expressions.NewExpression.Members%2A> propriété est une collection vide.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> est <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="arguments" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
        <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `arguments` paramètre doit contenir le même nombre d’éléments que le nombre de paramètres du constructeur représenté par `constructor`. Si `arguments` est `null`, il est considéré comme vide et la <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> représente le type de déclaration du constructeur représenté par `constructor`. Le <xref:System.Linq.Expressions.NewExpression.Members%2A> propriété est une collection vide.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> est <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="arguments" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="arguments" /> correspond au nombre de paramètres du constructeur que <paramref name="constructor" /> représente.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
        <param name="members">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés. Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `arguments` paramètre doit contenir le même nombre d’éléments que le nombre de paramètres du constructeur représenté par `constructor`. Si `arguments` est `null`, il est considéré comme vide et la <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.  
  
 Si `members` est `null`, le <xref:System.Linq.Expressions.NewExpression.Members%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide. Si `members` n’est pas `null`, il doit avoir le même nombre d’éléments en tant que `arguments` et chaque élément ne doit pas être `null`. Chaque élément de `members` doit être un <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> qui représente un membre d’instance sur le type de déclaration du constructeur représenté par `constructor`. S’il représente une propriété, la propriété doit avoir un `get` accesseur. L’élément correspondant de `arguments` pour chaque élément de `members` doit avoir un <xref:System.Linq.Expressions.Expression.Type%2A> propriété qui représente un type qui ne peut être assigné au type du membre qui le `members` élément représente.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> représente le type de déclaration du constructeur qui `constructor` représente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> est <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="arguments" /> est <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="members" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.  
  
 - ou -  
  
 Le paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.  
  
 - ou -  
  
 Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
        <param name="members">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés. Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés sous forme de tableau.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `arguments` paramètre doit contenir le même nombre d’éléments que le nombre de paramètres du constructeur représenté par `constructor`. Si `arguments` est `null`, il est considéré comme vide et la <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide.  
  
 Si `members` est `null`, le <xref:System.Linq.Expressions.NewExpression.Members%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> est une collection vide. Si `members` n’est pas `null`, il doit avoir le même nombre d’éléments en tant que `arguments` et chaque élément ne doit pas être `null`. Chaque élément de `members` doit être un <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> qui représente un membre d’instance sur le type de déclaration du constructeur représenté par `constructor`. S’il représente une propriété, la propriété doit être en mesure de récupérer la valeur du champ associé. L’élément correspondant de `arguments` pour chaque élément de `members` doit avoir un <xref:System.Linq.Expressions.Expression.Type%2A> propriété qui représente un type qui ne peut être assigné au type du membre qui le `members` élément représente.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewExpression> représente le type de déclaration du constructeur qui `constructor` représente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> est <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="arguments" /> est <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="members" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.  
  
 - ou -  
  
 Le paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.  
  
 - ou -  
  
 Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
        <param name="bounds">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewArrayExpression> représente un type de tableau dont le rang est égal à la longueur de `bounds` et dont le type d’élément est `type`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `bounds` doit représenter un type intégral.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> méthode pour créer une arborescence d’expression qui représente la création d’un tableau de chaînes qui a le rang 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="bounds" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="bounds" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
        <param name="bounds">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewArrayExpression> représente un type de tableau dont le rang est égal à la longueur de `bounds` et dont le type d’élément est `type`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `bounds` doit représenter un type intégral.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> méthode pour créer une arborescence d’expression qui représente la création d’un tableau de chaînes qui a le rang 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="bounds" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="bounds" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `initializers` doit représenter un type qui ne peut être assigné au type représenté par `type`, éventuellement une fois qu’il *entre guillemets*.  
  
> [!NOTE]
>  Un élément sera mis entre guillemets uniquement si `type` est <xref:System.Linq.Expressions.Expression>. Guillemets signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud. Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `initializers`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewArrayExpression> représente un type de tableau dont le rang est 1 et dont le type d’élément `type`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> méthode pour créer une arborescence d’expression qui représente la création d’un tableau de chaînes unidimensionnel qui est initialisée avec une liste d’expressions de chaîne.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="initializers" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément du paramètre <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type représenté par <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
        <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété de chaque élément de `initializers` doit représenter un type qui ne peut être assigné au type représenté par `type`, éventuellement une fois qu’il *entre guillemets*.  
  
> [!NOTE]
>  Un élément sera mis entre guillemets uniquement si `type` est <xref:System.Linq.Expressions.Expression>. Guillemets signifie que l’élément est encapsulé dans un <xref:System.Linq.Expressions.ExpressionType.Quote> nœud. Le nœud résultant est un <xref:System.Linq.Expressions.UnaryExpression> dont <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriété est l’élément de `initializers`.  
  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.NewArrayExpression> représente un type de tableau dont le rang est 1 et dont le type d’élément `type`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> méthode pour créer une arborescence d’expression qui représente la création d’un tableau de chaînes unidimensionnel qui est initialisée avec une liste d’expressions de chaîne.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="initializers" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de nœud de ce <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <value>Une des valeurs de <see cref="T:System.Linq.Expressions.ExpressionType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.NodeType%2A> propriété fournit une description plus spécialisée d’un <xref:System.Linq.Expressions.Expression> que simplement son type dérivé. Par exemple, un <xref:System.Linq.Expressions.BinaryExpression> peut être utilisé pour représenter différents types d’expressions binaires, comme une opération de division ou une opération « supérieure à ». Le <xref:System.Linq.Expressions.Expression.NodeType%2A> décrire ces expressions binaires en tant que propriété <xref:System.Linq.Expressions.ExpressionType.Divide> et <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectivement.  
  
 Le type CLR statique de l’expression qui le <xref:System.Linq.Expressions.Expression> représente de l’objet est représenté par le <xref:System.Linq.Expressions.Expression.Type%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur not unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon, si `expression`. Le type est un type numérique ou booléen, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `expression`. Le type est un type valeur nullable et le type non nullable correspondant est égal au type d’argument de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type. Si `expression`. Type non nullable, le nœud n’est pas levé. Sinon, le nœud est levé.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une expression qui représente un opérateur logique pas d’opération.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément. La méthode d'implémentation peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui prend un argument, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur not unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type. Si `expression`. Type non nullable, le nœud n’est pas levé. Sinon, le nœud est levé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.  
  
 - ou -  
  
 <paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true`. Sinon, il s'agit de `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> a toujours la valeur `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’inégalité, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est <xref:System.Boolean>:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est <xref:System.Boolean>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="liftToNull">
          <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propriété est `true` et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriété est égale à `liftToNull`. Dans le cas contraire, elles sont toutes deux `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’inégalité, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé ; en outre, le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`:  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est <xref:System.Boolean>.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est <xref:System.Boolean>.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est nullable <xref:System.Boolean> si `liftToNull` est `true` ou <xref:System.Boolean> si `liftToNull` est `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne l'expression qui représente le complément à 1.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Retourne l'expression qui représente le complément à 1.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Retourne l'expression qui représente le complément à 1.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `OR` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de prédéfinis au niveau du bit `OR` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis au niveau du bit `OR` opérateur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente une opération OR logique.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `OR` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types intégraux ou booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de prédéfinis au niveau du bit `OR` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de prédéfinis au niveau du bit `OR` opérateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="OR" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si le premier opérateur a la valeur <see langword="false" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="false" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `OR` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
    > [!NOTE]
    >  L’attribut conditional `OR` opérateur ne peut pas être surchargé en c# ou Visual Basic. Toutefois, l’attribut conditional `OR` opérateur est évalué à l’aide de l’opérateur de bits `OR` opérateur. Par conséquent, une surcharge définie par l’utilisateur de l’opérateur de bits `OR` opérateur peut être la méthode d’implémentation pour ce type de nœud.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   `left`. Type et `right`. Type sont du même type booléen.  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’attribut conditional prédéfini `OR` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’attribut conditional prédéfini `OR` opérateur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui représente un opérateur logique `OR` opération qui prend la valeur du deuxième opérande uniquement si le premier opérande prend la valeur `false`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.  
  
 - ou -  
  
 <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="false" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de bits `OR` (opérateur), le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
    > [!NOTE]
    >  L’attribut conditional `OR` opérateur ne peut pas être surchargé en c# ou Visual Basic. Toutefois, l’attribut conditional `OR` opérateur est évalué à l’aide de l’opérateur de bits `OR` opérateur. Par conséquent, une surcharge définie par l’utilisateur de l’opérateur de bits `OR` opérateur peut être la méthode d’implémentation pour ce type de nœud.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types booléens, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   `left`. Type et `right`. Type sont du même type booléen.  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’attribut conditional prédéfini `OR` opérateur.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’attribut conditional prédéfini `OR` opérateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="OR" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.  
  
 - ou -  
  
 <paramref name="method" /> est <see langword="null" /> et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type du paramètre ou de la variable.</param>
        <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
        <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Linq.Expressions.MethodCallExpression> objet qui imprime la valeur d’un <xref:System.Linq.Expressions.ParameterExpression> objet.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type du paramètre ou de la variable.</param>
        <param name="name">Nom du paramètre ou de la variable, utilisé à des fins de débogage ou d'impression uniquement.</param>
        <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ParameterExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’élévation, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont <xref:System.Double>, la méthode d’implémentation est <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.  
  
 - ou -  
  
 <paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur d’élévation, le <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont <xref:System.Double>, la méthode d’implémentation est <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> a la valeur <see langword="null" /> et l’opérateur d’élévation à une puissance n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.  
  
 - ou -  
  
 <paramref name="method" /> a la valeur <see langword="null" /> et <paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale. Cette valeur peut être null pour les propriétés statiques.</param>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété à l'aide d'une méthode d'accesseur de propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égal à la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété du <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Si la méthode représentée par `propertyAccessor` est `static` (`Shared` en Visual Basic), `expression` peut être `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> est <see langword="null" />.  
  
 - ou -  
  
 La méthode représentée par <paramref name="propertyAccessor" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="propertyAccessor" />.  
  
 - ou -  
  
 La méthode représentée par <paramref name="propertyAccessor" /> n'est pas une méthode d'accesseur de propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale. Cette valeur peut être null pour les propriétés statiques.</param>
        <param name="property">
          <see cref="T:System.Reflection.PropertyInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égal à la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété du <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Si la propriété représentée par `property` est `static` (`Shared` en Visual Basic), `expression` peut être `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="property" /> est <see langword="null" />.  
  
 - ou -  
  
 La propriété représentée par <paramref name="property" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la propriété que <paramref name="property" /> représente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété nommée <c>propertyName</c>. Cette valeur peut être <see langword="null" /> pour les propriétés statiques.</param>
        <param name="propertyName">Nom d'une propriété à laquelle accéder.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente le champ désigné par <paramref name="propertyName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égal à la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété de la <xref:System.Reflection.PropertyInfo> qui représente la propriété désignée par `propertyName`.  
  
 Cette méthode recherche `expression`. Type et ses types de base pour une propriété qui porte le nom `propertyName`. Propriétés publiques sont prioritaires sur les propriétés non publiques. Si une propriété correspondante est trouvée, cette méthode passe `expression` et <xref:System.Reflection.PropertyInfo> qui représente cette propriété à <xref:System.Linq.Expressions.Expression.Property%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une expression qui représente l’accès à une propriété.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="propertyName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Aucune propriété nommée <paramref name="propertyName" /> n'est définie dans <paramref name="expression" />.Type ou ses types de base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Objet auquel la propriété appartient. Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
        <param name="indexer">
          <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Objet auquel la propriété appartient. Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
        <param name="indexer">
          <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
        <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Objet auquel la propriété appartient. Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
        <param name="propertyName">Nom de l'indexeur.</param>
        <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Objet contenant la propriété. Cette valeur peut être null pour les propriétés statiques.</param>
        <param name="type">Objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient la propriété.</param>
        <param name="propertyName">Propriété à laquelle accéder.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui accède à une propriété.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété ou un champ nommé <c>propertyOrFieldName</c>. Cette valeur peut être null pour les membres statiques.</param>
        <param name="propertyOrFieldName">Nom d'une propriété ou d'un champ auquel accéder.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété ou un champ.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> est égale à <paramref name="expression" />, et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> ou à <see cref="T:System.Reflection.FieldInfo" /> qui représente la propriété ou le champ désigné par <paramref name="propertyOrFieldName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.MemberExpression> est égal à la <xref:System.Reflection.PropertyInfo.PropertyType%2A> ou <xref:System.Reflection.FieldInfo.FieldType%2A> propriétés de la <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo>, respectivement, qui représente la propriété ou le champ désigné par `propertyOrFieldName`.  
  
 Cette méthode recherche `expression`. Type et ses types de base pour une propriété ou un champ qui porte le nom `propertyOrFieldName`. Les champs et les propriétés publiques sont prioritaires sur les champs et les propriétés non publiques. En outre, les propriétés sont prioritaires sur les champs. Si une propriété ou un champ correspondant est trouvé, cette méthode passe `expression` et <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo> qui représente cette propriété ou un champ à <xref:System.Linq.Expressions.Expression.Property%2A> ou <xref:System.Linq.Expressions.Expression.Field%2A>, respectivement.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une expression qui représente l’accès à une propriété ou un champ.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Aucune propriété ou aucun champ nommé <paramref name="propertyOrFieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression ayant une valeur de constante de type <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> représente le type construit <xref:System.Linq.Expressions.Expression%601>, où l’argument de type est le type représenté par `expression`. Type. La propriété <xref:System.Linq.Expressions.UnaryExpression.Method%2A> a la valeur `null`. Les deux <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> sont `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réduit le nœud en une expression plus simple. Si CanReduce retourne la valeur true, cela doit retourner une expression valide. Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
        <returns>Expression réduite.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réduit le nœud en une expression plus simple. Si CanReduce retourne la valeur true, cela doit retourner une expression valide. Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
        <returns>Expression réduite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à Reduce, cette méthode vérifie que le nœud réduit satisfait certains invariants.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réduit l’expression à un type de nœud connu (qui n’est pas un nœud Extension) ou retourne simplement l’expression s’il s’agit d’un type déjà connu.</summary>
        <returns>Expression réduite.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité des références.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité des références.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'une exception avec un type donné.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer une expression qui contienne le <xref:System.Linq.Expressions.Expression.Return%2A> (méthode).  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
        <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de décalage vers la droite, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Le type est un type intégral (un des <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou les types nullables correspondants) et `right`. Est de type <xref:System.Int32>, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de décalage vers la droite prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de décalage vers la droite prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de décalage vers la droite, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Le type est un type intégral (un des <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou les types nullables correspondants) et `right`. Est de type <xref:System.Int32>, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de décalage vers la droite prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de décalage vers la droite prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">Collection d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
        <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
        <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de soustraction, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de soustraction prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de soustraction prédéfini.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une expression qui soustrait l’argument du premier argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de soustraction, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de soustraction prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de soustraction prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <param name="conversion">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation sélectionnée pour l’opération :  
  
-   Si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de soustraction, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de soustraction prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de soustraction prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Résultant <xref:System.Linq.Expressions.BinaryExpression> a le <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriété définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Sinon, elles sont `false`. La propriété <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> a la valeur `null`.  
  
 Les informations suivantes décrivent la méthode d’implémentation, le type de nœud, et indique si un nœud est levé.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui accepte deux arguments, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Sinon, si le <xref:System.Linq.Expressions.Expression.Type%2A> propriété du `left` ou `right` représente un type défini par l’utilisateur qui surcharge l’opérateur de soustraction, la <xref:System.Reflection.MethodInfo> qui représente cette méthode est la méthode d’implémentation.  
  
-   Sinon, si `left`. Type et `right`. Type sont des types numériques, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `left`. Type et `right`. Type peuvent être assignés à des types d’arguments correspondants de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `left`. Type et `right`. Type sont deux types de valeur dont au moins un est nullable et les types non nullable correspondants sont égaux aux types d’arguments correspondants de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`:  
  
-   Si `left`. Type et `right`. Type sont non nullable, le nœud n’est pas levé. Le type du nœud est le type de résultat de l’opérateur de soustraction prédéfini.  
  
-   Si `left`. Type et `right`. Type sont nullable, le nœud est levé. Le type du nœud est le type nullable qui correspond au type de résultat de l’opérateur de soustraction prédéfini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Valeur à tester pour chaque cas.</param>
        <param name="cases">Ensemble de cas pour cette expression de switch.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> sans casse par défaut.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les <xref:System.Linq.Expressions.SwitchCase> des objets dans une <xref:System.Linq.Expressions.SwitchExpression> objet doit avoir le même type, sauf si le <xref:System.Linq.Expressions.SwitchExpression> a le type `void`.  
  
 Chaque <xref:System.Linq.Expressions.SwitchCase> objet a implicite `break` instruction, ce qui signifie qu’il n’y a pas de passage implicite d’une étiquette case vers un autre.  
  
 Si `switchValue` ne correspond pas à un des cas, aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une expression qui représente une instruction switch départemental sans casse par défaut.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Valeur à tester pour chaque cas.</param>
        <param name="defaultBody">Résultat du commutateur si <c>switchValue</c> ne correspond à aucun des cas.</param>
        <param name="cases">Ensemble de cas pour cette expression de switch.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les <xref:System.Linq.Expressions.SwitchCase> des objets dans une <xref:System.Linq.Expressions.SwitchExpression> objet doit avoir le même type, sauf si le <xref:System.Linq.Expressions.SwitchExpression> a le type `void`.  
  
 Chaque <xref:System.Linq.Expressions.SwitchCase> objet a implicite `break` instruction, ce qui signifie qu’il n’y a pas de passage implicite d’une étiquette case vers un autre.  
  
 Si `switchValue` ne correspond pas à un des cas, la casse par défaut représentée par `defaultBody` est exécuté.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une expression qui représente une instruction de bascule qui a une casse par défaut.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">Valeur à tester pour chaque cas.</param>
        <param name="defaultBody">Résultat du commutateur si <c>switchValue</c> ne correspond à aucun des cas.</param>
        <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
        <param name="cases">Ensemble de cas pour cette expression de switch.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Valeur à tester pour chaque cas.</param>
        <param name="defaultBody">Résultat du commutateur si <c>switchValue</c> ne correspond à aucun des cas.</param>
        <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
        <param name="cases">Ensemble de cas pour cette expression de switch.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Type de résultat du commutateur.</param>
        <param name="switchValue">Valeur à tester pour chaque cas.</param>
        <param name="defaultBody">Résultat du commutateur si <c>switchValue</c> ne correspond à aucun des cas.</param>
        <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
        <param name="cases">Ensemble de cas pour cette expression de switch.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Type de résultat du commutateur.</param>
        <param name="switchValue">Valeur à tester pour chaque cas.</param>
        <param name="defaultBody">Résultat du commutateur si <c>switchValue</c> ne correspond à aucun des cas.</param>
        <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
        <param name="cases">Ensemble de cas pour cette expression de switch.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Corps du cas.</param>
        <param name="testValues">Valeurs de test du cas.</param>
        <summary>Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les <xref:System.Linq.Expressions.SwitchCase> des objets dans une <xref:System.Linq.Expressions.SwitchExpression> objet doit avoir le même type, sauf si le <xref:System.Linq.Expressions.SwitchExpression> a le type `void`.  
  
 Chaque <xref:System.Linq.Expressions.SwitchCase> objet a implicite `break` instruction, ce qui signifie qu’il n’y a pas de passage implicite d’une étiquette case vers un autre.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une expression qui représente une instruction de bascule qui a une casse par défaut.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Corps du cas.</param>
        <param name="testValues">Valeurs de test du cas.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchCase" /> pour une utilisation dans un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
        <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> a la valeur spécifiée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
        <param name="language">
          <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
        <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ont la valeur spécifiée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
        <param name="language">
          <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
        <param name="languageVendor">
          <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
        <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ont la valeur spécifiée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
        <param name="language">
          <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
        <param name="languageVendor">
          <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
        <param name="documentType">
          <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> doit être égale.</param>
        <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ont la valeur spécifiée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception.</summary>
        <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Linq.Expressions.TryExpression> objet qui utilise le <xref:System.Linq.Expressions.Expression.Throw%2A> (méthode).  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la levée d'une exception avec un type donné.</summary>
        <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>Représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Corps du bloc Try.</param>
        <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch mais ni une erreur, ni un bloc Finally.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Linq.Expressions.TryExpression> objet qui contient une instruction catch.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Corps du bloc Try.</param>
        <param name="finally">Corps du bloc Finally.</param>
        <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch et un bloc Finally.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Linq.Expressions.TryExpression> objet qui contient une instruction catch et une instruction finally.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Corps du bloc Try.</param>
        <param name="fault">Corps du bloc Fault.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Fault et aucune instruction Catch.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Corps du bloc Try.</param>
        <param name="finally">Corps du bloc Finally.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Finally et aucune instruction Catch.</summary>
        <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Tableau d’objets Type qui spécifient les arguments de type pour le type délégué System.Action.</param>
        <param name="actionType">Cette méthode retourne le type délégué System.Action générique qui comporte des arguments de type spécifiques. Contient la valeur null s’il n’existe aucun délégué System.Action générique qui correspond au <c>typeArgs</c>. Ce paramètre est passé sans être initialisé.</param>
        <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
        <returns>True si le type délégué System.Action générique a été créé pour un <paramref name="typeArgs" /> spécifique, false dans le cas contraire.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Tableau d’objets Type qui spécifient les arguments de type pour le type délégué System.Func.</param>
        <param name="funcType">Cette méthode retourne le type délégué System.Func générique qui comporte des arguments de type spécifiques. Contient la valeur null s’il n’existe aucun délégué System.Func générique qui correspond au <c>typeArgs</c>. Ce paramètre est passé sans être initialisé.</param>
        <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Func générique comportant des arguments de type spécifiques. Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
        <returns>true si le type délégué System.Func générique a été créé pour un <paramref name="typeArgs" /> spécifique ; sinon, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
        <value>
          <see cref="T:System.Type" /> qui représente le type statique de l'expression.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.NodeType%2A> est le type de l’arborescence d’expression, alors que le <xref:System.Linq.Expressions.Expression.Type%2A> représente le statique type common language runtime (CLR) de l’expression que le nœud représente. Par exemple, deux nœuds de différents types de nœuds peuvent avoir le même <xref:System.Linq.Expressions.Expression.Type%2A>, comme illustré dans l’exemple de code suivant.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <param name="type">
          <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une référence explicite ou une conversion boxing où la valeur <see langword="null" /> est fournie en cas d'échec de la conversion.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est `null`. Le <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `false`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> méthode pour créer un <xref:System.Linq.Expressions.UnaryExpression> qui représente la conversion de référence d’une expression entière non nullable au type entier nullable.  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="T:System.Linq.Expressions.Expression" /> doit être égale.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> qui compare l'identité de type à l'exécution.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> et dont les propriétés <see cref="T:System.Linq.Expressions.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> doit être égale.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.Expression.Type%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> représente <xref:System.Boolean>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> méthode pour créer un <xref:System.Linq.Expressions.TypeBinaryExpression> qui représente un test de type d’une valeur de chaîne par rapport à la <xref:System.Int32> type.  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Dans le cas contraire, ils ont la valeur false.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur plus unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type. Si `expression`. Type non nullable, le nœud n’est pas levé. Sinon, le nœud est levé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriété des résultats de <xref:System.Linq.Expressions.UnaryExpression> est définie sur la méthode d’implémentation. Le <xref:System.Linq.Expressions.Expression.Type%2A> est définie sur le type du nœud. Si le nœud est levé, les <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> et <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriétés sont toutes deux `true`. Dans le cas contraire, ils ont la valeur false.  
  
#### <a name="implementing-method"></a>Méthode d’implémentation  
 Les règles suivantes déterminent la méthode d’implémentation pour l’opération :  
  
-   Si `method` n’est pas `null` et qu’il représente un non void `static` (`Shared` en Visual Basic) méthode qui prend un argument, il s’agit de la méthode d’implémentation pour le nœud.  
  
-   Si `expression`. Le type est un type défini par l’utilisateur qui définit l’opérateur plus unaire, le <xref:System.Reflection.MethodInfo> qui représente cet opérateur est la méthode d’implémentation.  
  
-   Sinon, si `expression`. Le type est un type numérique, la méthode d’implémentation est `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Type de nœud, levé ou Non levé  
 Si la méthode d’implémentation n’est pas `null`:  
  
-   Si `expression`. Type peut être assigné au type d’argument de la méthode d’implémentation, le nœud n’est pas levé. Le type du nœud est le type de retour de la méthode d’implémentation.  
  
-   Si les deux conditions suivantes sont satisfaites, le nœud est levé et le type du nœud est le type nullable qui correspond au type de retour de la méthode d’implémentation :  
  
    -   `expression`. Le type est un type valeur nullable et le type de valeur non nullable correspondant est égal au type d’argument de la méthode d’implémentation.  
  
    -   Le type de retour de la méthode d’implémentation est un type valeur non nullable.  
  
 Si la méthode d’implémentation est `null`, le type du nœud est `expression`. Type. Si `expression`. Type non nullable, le nœud n’est pas levé. Sinon, le nœud est levé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> est <see langword="null" /> et l'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.  
  
 - ou -  
  
 <paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Objet <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer un unboxing.</param>
        <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
        <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente un unboxing explicite.</summary>
        <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type du paramètre ou de la variable.</param>
        <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
        <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type du paramètre ou de la variable.</param>
        <param name="name">Nom du paramètre ou de la variable. Ce nom est utilisé à des fins de débogage ou d'impression uniquement.</param>
        <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
        <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">Instance de <see cref="T:System.Func`2" />.</param>
        <summary>Réduit le nœud puis appelle le délégué visiteur sur l'expression réduite. La méthode lève une exception si le nœud n'est pas réductible.</summary>
        <returns>Expression qui est visitée ou expression qui doit la remplacer dans l’arborescence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituez cette méthode pour fournir la logique pour accompagner les enfants du nœud. Une implémentation classique appellera visiteur. Visitez sur chacun de ses enfants, et si une des deux change, elle doit retourner une nouvelle copie d’elle-même avec les enfants modifiés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>