<Type Name="SqlConnection" FullName="System.Data.SqlClient.SqlConnection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4d14e75d09d6c6b0876d67016720bdcdae71e5d5" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37672713" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlConnection : System.Data.Common.DbConnection, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlConnection extends System.Data.Common.DbConnection implements class System.Data.IDbConnection, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlClient.SqlConnection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlConnection&#xA;Inherits DbConnection&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlConnection sealed : System::Data::Common::DbConnection, ICloneable, IDisposable" />
  <TypeSignature Language="F#" Value="type SqlConnection = class&#xA;    inherit DbConnection&#xA;    interface IDbConnection&#xA;    interface ICloneable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.SqlClient</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbConnection</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("InfoMessage")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une connexion à une base de données SQL Server. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.SqlClient.SqlConnection> objet représente une session unique à une source de données SQL Server. Avec un système de base de données client/serveur, il est équivalent à une connexion réseau au serveur. <xref:System.Data.SqlClient.SqlConnection> est utilisé conjointement avec <xref:System.Data.SqlClient.SqlDataAdapter> et <xref:System.Data.SqlClient.SqlCommand> pour augmenter les performances lors de la connexion à une base de données Microsoft SQL Server. Pour tous les produits de SQL Server par des tiers et d’autres sources de données pris en charge OLE DB, utilisez <xref:System.Data.OleDb.OleDbConnection>.  
  
 Lorsque vous créez une instance de <xref:System.Data.SqlClient.SqlConnection>, toutes les propriétés sont définies sur leurs valeurs initiales. Pour obtenir la liste de ces valeurs, consultez le <xref:System.Data.SqlClient.SqlConnection> constructeur.  
  
 Consultez <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> pour obtenir la liste des mots clés dans une chaîne de connexion.  
  
 Si le <xref:System.Data.SqlClient.SqlConnection> est hors de portée, il ne sera pas fermé. Par conséquent, vous devez fermer explicitement la connexion en appelant `Close` ou `Dispose`. `Close` et `Dispose` sont fonctionnellement équivalents. Si le regroupement de connexions valeur `Pooling` a la valeur `true` ou `yes`, la connexion sous-jacente est retournée au pool de connexions. Quant à eux, si `Pooling` a la valeur `false` ou `no`, la connexion au serveur sous-jacente est fermée.  
  
> [!NOTE]
>  Les événements de connexion et de déconnexion ne seront pas déclenchés sur le serveur si une connexion est récupérée depuis le pool de connexions ou qu’elle est retournée au pool, car elle n’est pas réellement fermée lorsqu’elle est retournée au pool. Pour plus d’informations, consultez [Regroupement de connexions SQL Server (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md).  
  
 Pour vous assurer que les connexions sont toujours fermées, ouvrez la connexion à l’intérieur d’un `using` bloquer, comme indiqué dans le fragment de code suivant. Cela garantit que la connexion est fermée automatiquement lorsque le code quitte le bloc.  
  
```vb  
Using connection As New SqlConnection(connectionString)  
    connection.Open()  
    ' Do work here; connection closed on following line.  
End Using  
  
```  
  
```csharp  
using (SqlConnection connection = new SqlConnection(connectionString))  
    {  
        connection.Open();  
        // Do work here; connection closed on following line.  
    }  
```  
  
> [!NOTE]
>  Pour déployer des applications hautes performances, vous devez utiliser le regroupement de connexions. Lorsque vous utilisez le fournisseur de données .NET Framework pour SQL Server, vous n’êtes pas obligé d’activer le regroupement de connexions, car le fournisseur gère automatiquement, mais vous pouvez modifier certains paramètres. Pour plus d’informations, consultez [Regroupement de connexions SQL Server (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md).  
  
 Si un <xref:System.Data.SqlClient.SqlException> est généré par la méthode exécutant un <xref:System.Data.SqlClient.SqlCommand>, le <xref:System.Data.SqlClient.SqlConnection> reste ouvert lorsque le niveau de gravité est inférieur ou égal à 19. Lorsque le niveau de gravité est supérieur ou égal à 20, le serveur ferme normalement le <xref:System.Data.SqlClient.SqlConnection>. L'utilisateur peut toutefois rouvrir la connexion et continuer.  
  
 Une application qui crée une instance de la <xref:System.Data.SqlClient.SqlConnection> objet peut exiger de tous les appelants directs et indirects dispose des autorisations suffisantes pour le code en définissant des demandes de sécurité déclaratives ou impératives. <xref:System.Data.SqlClient.SqlConnection> effectue des demandes de sécurité à l’aide de la <xref:System.Data.SqlClient.SqlClientPermission> objet. Les utilisateurs peuvent vérifier que leur code dispose des autorisations suffisantes à l’aide de la <xref:System.Data.SqlClient.SqlClientPermissionAttribute> objet. Les utilisateurs et administrateurs peuvent également utiliser le [Caspol.exe (outil de stratégie de sécurité d’accès de Code)](~/docs/framework/tools/caspol-exe-code-access-security-policy-tool.md) pour modifier la stratégie de sécurité aux niveaux ordinateur, utilisateur et entreprise. Pour plus d’informations, consultez l’article [Sécurité](http://msdn.microsoft.com/library/9a9621d7-8883-4a4f-a874-65e8e09e20a6). Pour obtenir un exemple qui montre comment utiliser les demandes de sécurité, consultez [Code Access Security and ADO.NET](~/docs/framework/data/adonet/code-access-security.md).  
  
 Pour plus d’informations sur la gestion des messages d’avertissement et d’informations à partir du serveur, consultez [les événements de connexion](~/docs/framework/data/adonet/connection-events.md). Erreurs du moteur SQL Server et les messages d’erreur sont documentés dans la documentation en ligne de SQL Server.  
  
> [!CAUTION]
>  Vous pouvez forcer TCP au lieu de la mémoire partagée. Vous pouvez le faire en ajoutant le préfixe tcp : au nom du serveur dans la connexion de chaîne, ou vous pouvez utiliser localhost.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlCommand> et un <xref:System.Data.SqlClient.SqlConnection>. Le <xref:System.Data.SqlClient.SqlConnection> est ouvert et défini en tant que le <xref:System.Data.SqlClient.SqlCommand.Connection%2A> pour le <xref:System.Data.SqlClient.SqlCommand>. L’exemple appelle ensuite <xref:System.Data.SqlClient.SqlCommand.ExecuteNonQuery%2A>. Pour ce faire, le <xref:System.Data.SqlClient.SqlCommand.ExecuteNonQuery%2A> est passée à une chaîne de connexion et une chaîne de requête qui est une [!INCLUDE[tsql](~/includes/tsql-md.md)] instruction INSERT. La connexion est fermée automatiquement lorsque le code quitte l’à l’aide de bloc.  
  
 [!code-csharp[Classic WebData SqlCommand.ExecuteNonQuery Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlCommand.ExecuteNonQuery Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlCommand.ExecuteNonQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlCommand.ExecuteNonQuery Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.SqlClient.SqlConnection" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.SqlClient.SqlConnection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une nouvelle instance de <xref:System.Data.SqlClient.SqlConnection> est créé, la lecture/écriture propriétés sont définies sur les valeurs initiales suivantes, sauf si elles sont spécifiquement définis à l’aide de leurs mots clés associés dans le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> propriété.  
  
|Propriétés|Valeur initiale|  
|----------------|-------------------|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>|une chaîne vide ( » »)|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionTimeout%2A>|15|  
|<xref:System.Data.SqlClient.SqlConnection.Database%2A>|une chaîne vide ( » »)|  
|<xref:System.Data.SqlClient.SqlConnection.DataSource%2A>|une chaîne vide ( » »)|  
  
 Vous pouvez modifier la valeur de ces propriétés uniquement à l’aide du <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> propriété. Le <xref:System.Data.SqlClient.SqlConnectionStringBuilder> classe fournit les fonctionnalités pour créer et gérer le contenu de chaînes de connexion.  
  
   
  
## Examples  
 L’exemple suivant crée et ouvre un <xref:System.Data.SqlClient.SqlConnection>.  
  
 [!code-csharp[Classic WebData SqlConnection.SqlConnection Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.SqlConnection Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlConnection (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.SqlClient.SqlConnection : string -&gt; System.Data.SqlClient.SqlConnection" Usage="new System.Data.SqlClient.SqlConnection connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Connexion utilisée pour ouvrir la base de données SQL Server.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.SqlClient.SqlConnection" /> pendant la réception d’une chaîne contenant une chaîne de connexion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une nouvelle instance de <xref:System.Data.SqlClient.SqlConnection> est créé, la lecture/écriture propriétés sont définies sur les valeurs initiales suivantes, sauf si elles sont spécifiquement définis à l’aide de leurs mots clés associés dans le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> propriété.  
  
|Propriétés|Valeur initiale|  
|----------------|-------------------|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>|`connectionString`|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionTimeout%2A>|15|  
|<xref:System.Data.SqlClient.SqlConnection.Database%2A>|une chaîne vide ( » »)|  
|<xref:System.Data.SqlClient.SqlConnection.DataSource%2A>|une chaîne vide ( » »)|  
  
 Vous pouvez modifier la valeur de ces propriétés uniquement à l’aide du <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> propriété. Le <xref:System.Data.SqlClient.SqlConnection> classe fournit les fonctionnalités pour créer et gérer le contenu de chaînes de connexion.  
  
   
  
## Examples  
 L’exemple suivant crée et ouvre un <xref:System.Data.SqlClient.SqlConnection>.  
  
 [!code-csharp[Classic WebData SqlConnection.SqlConnection1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.SqlConnection1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlConnection (string connectionString, System.Data.SqlClient.SqlCredential credential);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString, class System.Data.SqlClient.SqlCredential credential) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.#ctor(System.String,System.Data.SqlClient.SqlCredential)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;xamarinandroid-7.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String, credential As SqlCredential)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection(System::String ^ connectionString, System::Data::SqlClient::SqlCredential ^ credential);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public SqlConnection (string connectionString, System.Data.SqlClient.SqlCredential cred);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString, class System.Data.SqlClient.SqlCredential cred) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String, cred As SqlCredential)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection(System::String ^ connectionString, System::Data::SqlClient::SqlCredential ^ cred);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="new System.Data.SqlClient.SqlConnection : string * System.Data.SqlClient.SqlCredential -&gt; System.Data.SqlClient.SqlConnection" Usage="new System.Data.SqlClient.SqlConnection (connectionString, cred)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" Index="0" />
        <Parameter Name="credential" Type="System.Data.SqlClient.SqlCredential" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="cred" Type="System.Data.SqlClient.SqlCredential" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="connectionString">Une chaîne de connexion qui n'utilise aucun des mots clés de chaîne de connexion suivants : <see langword="Integrated Security = true" />, <see langword="UserId" />, ou <see langword="Password" />; ou qui n'utilise pas <see langword="ContextConnection = true" />.</param>
        <param name="credential">To be added.</param>
        <param name="cred">To be added.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.SqlClient.SqlConnection" /> en fonction d'une chaîne de connexion qui n'utilise pas <see langword="Integrated Security = true" /> et un objet <see cref="T:System.Data.SqlClient.SqlCredential" /> qui contient l'ID d'utilisateur et le mot de passe.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessToken">
      <MemberSignature Language="C#" Value="public string AccessToken { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessToken" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.AccessToken" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessToken As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessToken { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessToken : string with get, set" Usage="System.Data.SqlClient.SqlConnection.AccessToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le jeton d’accès pour la connexion.</summary>
        <value>Jeton d’accès pour la connexion.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginDbTransaction">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbTransaction BeginDbTransaction (System.Data.IsolationLevel isolationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbTransaction BeginDbTransaction(valuetype System.Data.IsolationLevel isolationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginDbTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbTransaction ^ BeginDbTransaction(System::Data::IsolationLevel isolationLevel);" />
      <MemberSignature Language="F#" Value="override this.BeginDbTransaction : System.Data.IsolationLevel -&gt; System.Data.Common.DbTransaction" Usage="sqlConnection.BeginDbTransaction isolationLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isolationLevel" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="isolationLevel">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginTransaction">
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence une transaction de base de données.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction () As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction();" />
      <MemberSignature Language="F#" Value="override this.BeginTransaction : unit -&gt; System.Data.SqlClient.SqlTransaction" Usage="sqlConnection.BeginTransaction " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence une transaction de base de données.</summary>
        <returns>Objet représentant la nouvelle transaction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande correspond à l’implémentation de SQL Server de BEGIN TRANSACTION.  
  
 Vous devez explicitement valider ou restaurer la transaction en utilisant le <xref:System.Data.SqlClient.SqlTransaction.Commit%2A> ou <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> (méthode). Pour vous assurer que le fournisseur de données .NET Framework pour le modèle de gestion des transactions SQL Server fonctionne correctement, évitez d’utiliser d’autres modèles de gestion des transactions, tel que celui fourni par SQL Server.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un niveau d’isolation, le niveau d’isolation par défaut est utilisé. Pour spécifier un niveau d’isolation avec la <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> (méthode), utilisez la surcharge qui accepte le `iso` paramètre (<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>). Le niveau d’isolement défini pour une transaction persiste après la fin de la transaction et jusqu'à ce que la connexion est fermée ou supprimée. Définition de l’isolation au niveau **instantané** dans une base de données où le niveau d’isolement de capture instantanée n’est pas activé ne lève pas d’exception. La transaction se termine en utilisant le niveau d’isolation par défaut.  
  
> [!CAUTION]
>  Si une transaction est démarrée et un niveau 16 ou plus se produit sur le serveur, la transaction n’est pas restaurée ; jusqu'à ce que le <xref:System.Data.SqlClient.SqlDataReader.Read%2A> méthode est appelée. Aucune exception n’est levée **ExecuteReader**.  
  
> [!CAUTION]
>  Lorsque votre requête retourne une grande quantité de données et les appels `BeginTransaction`, un <xref:System.Data.SqlClient.SqlException> est levée, car SQL Server n’autorise pas les transactions parallèles lors de l’utilisation de MARS. Pour éviter ce problème, associez toujours une transaction avec la commande, la connexion ou les deux avant que tous les lecteurs sont ouverts.  
  
 Pour plus d’informations sur les transactions SQL Server, consultez « Transactions explicites » et « Codage de Transactions performantes » dans la documentation en ligne de SQL Server.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et un <xref:System.Data.SqlClient.SqlTransaction>. Il montre également comment utiliser le <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>, un <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>, et <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> méthodes.  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Les transactions parallèles ne sont pas autorisées quand vous utilisez MARS (Multiple Active Result Sets).</exception>
        <exception cref="T:System.InvalidOperationException">Les transactions parallèles ne sont pas prises en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction (System.Data.IsolationLevel iso);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction(valuetype System.Data.IsolationLevel iso) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction (iso As IsolationLevel) As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction(System::Data::IsolationLevel iso);" />
      <MemberSignature Language="F#" Value="override this.BeginTransaction : System.Data.IsolationLevel -&gt; System.Data.SqlClient.SqlTransaction" Usage="sqlConnection.BeginTransaction iso" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iso" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="iso">Niveau d’isolement sous lequel la transaction doit s’exécuter.</param>
        <summary>Commence une transaction de base de données avec le niveau d’isolement spécifié.</summary>
        <returns>Objet représentant la nouvelle transaction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande correspond à l’implémentation de SQL Server de BEGIN TRANSACTION.  
  
 Vous devez explicitement valider ou restaurer la transaction en utilisant le <xref:System.Data.SqlClient.SqlTransaction.Commit%2A> ou <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> (méthode). Pour vous assurer que le fournisseur de données .NET Framework pour le modèle de gestion des transactions SQL Server fonctionne correctement, évitez d’utiliser d’autres modèles de gestion des transactions, tel que celui fourni par SQL Server.  
  
> [!NOTE]
>  Une fois qu’une transaction est validée ou restaurée, le niveau d’isolation de la transaction persiste pour toutes les commandes suivantes qui sont en mode autocommit (valeur par défaut de SQL Server). Cela peut produire des résultats inattendus, comme un niveau d’isolation REPEATABLE READ persiste et empêche les autres utilisateurs en dehors d’une ligne. Pour réinitialiser le niveau d’isolation pour la valeur par défaut (READ COMMITTED), exécutez le [!INCLUDE[tsql](~/includes/tsql-md.md)] instruction définir TRANSACTION ISOLATION LEVEL READ COMMITTED, ou appelez <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A?displayProperty=nameWithType> suivie immédiatement de <xref:System.Data.SqlClient.SqlTransaction.Commit%2A?displayProperty=nameWithType>. Pour plus d’informations sur les niveaux d’isolation de SQL Server, voir « Isolation Levels dans la base de données Engine » dans la documentation en ligne de SQL Server.  
  
 Pour plus d’informations sur les transactions SQL Server, consultez « Transactions explicites » et « Codage de Transactions performantes » dans la documentation en ligne de SQL Server.  
  
> [!CAUTION]
>  Lorsque votre requête retourne une grande quantité de données et les appels `BeginTransaction`, un <xref:System.Data.SqlClient.SqlException> est levée, car SQL Server n’autorise pas les transactions parallèles lors de l’utilisation de MARS. Pour éviter ce problème, associez toujours une transaction avec la commande, la connexion ou les deux avant que tous les lecteurs sont ouverts.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et un <xref:System.Data.SqlClient.SqlTransaction>. Il montre également comment utiliser le <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>, un <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>, et <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> méthodes.  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Les transactions parallèles ne sont pas autorisées quand vous utilisez MARS (Multiple Active Result Sets).</exception>
        <exception cref="T:System.InvalidOperationException">Les transactions parallèles ne sont pas prises en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction (string transactionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction(string transactionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction (transactionName As String) As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction(System::String ^ transactionName);" />
      <MemberSignature Language="F#" Value="override this.BeginTransaction : string -&gt; System.Data.SqlClient.SqlTransaction" Usage="sqlConnection.BeginTransaction transactionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="transactionName">Nom de la transaction.</param>
        <summary>Commence une transaction de base de données avec le nom de transaction spécifié.</summary>
        <returns>Objet représentant la nouvelle transaction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande correspond à l’implémentation de SQL Server de BEGIN TRANSACTION.  
  
 La longueur de la `transactionName` paramètre ne doit pas dépasser 32 caractères ; sinon une exception sera levée.  
  
 La valeur dans le `transactionName` paramètre peut être utilisé dans les appels ultérieurs à <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> et dans le `savePoint` paramètre de la <xref:System.Data.SqlClient.SqlTransaction.Save%2A> (méthode).  
  
 Vous devez explicitement valider ou restaurer la transaction en utilisant le <xref:System.Data.SqlClient.SqlTransaction.Commit%2A> ou <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> (méthode). Pour vous assurer que le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] fournisseur de données de modèle de gestion des transactions SQL Server effectue correctement, évitez d’utiliser d’autres modèles de gestion des transactions, tel que celui fourni par SQL Server.  
  
 Pour plus d’informations sur les transactions SQL Server, consultez « Transactions explicites » et « Codage de Transactions performantes » dans la documentation en ligne de SQL Server.  
  
> [!CAUTION]
>  Lorsque votre requête retourne une grande quantité de données et les appels `BeginTransaction`, un <xref:System.Data.SqlClient.SqlException> est levée, car SQL Server n’autorise pas les transactions parallèles lors de l’utilisation de MARS. Pour éviter ce problème, associez toujours une transaction avec la commande, la connexion ou les deux avant que tous les lecteurs sont ouverts.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et un <xref:System.Data.SqlClient.SqlTransaction>. Il montre également comment utiliser le <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>, un <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>, et <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> méthodes.  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Les transactions parallèles ne sont pas autorisées quand vous utilisez MARS (Multiple Active Result Sets).</exception>
        <exception cref="T:System.InvalidOperationException">Les transactions parallèles ne sont pas prises en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction (System.Data.IsolationLevel iso, string transactionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction(valuetype System.Data.IsolationLevel iso, string transactionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction(System.Data.IsolationLevel,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction (iso As IsolationLevel, transactionName As String) As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction(System::Data::IsolationLevel iso, System::String ^ transactionName);" />
      <MemberSignature Language="F#" Value="override this.BeginTransaction : System.Data.IsolationLevel * string -&gt; System.Data.SqlClient.SqlTransaction" Usage="sqlConnection.BeginTransaction (iso, transactionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iso" Type="System.Data.IsolationLevel" />
        <Parameter Name="transactionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="iso">Niveau d’isolement sous lequel la transaction doit s’exécuter.</param>
        <param name="transactionName">Nom de la transaction.</param>
        <summary>Commence une transaction de base de données avec le niveau d’isolement et le nom de transaction spécifiés.</summary>
        <returns>Objet représentant la nouvelle transaction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande correspond à l’implémentation de SQL Server de BEGIN TRANSACTION.  
  
 La valeur dans le `transactionName` paramètre peut être utilisé dans les appels ultérieurs à <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> et dans le `savePoint` paramètre de la <xref:System.Data.SqlClient.SqlTransaction.Save%2A> (méthode).  
  
 Vous devez explicitement valider ou restaurer la transaction en utilisant le <xref:System.Data.SqlClient.SqlTransaction.Commit%2A> ou <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> (méthode). Pour vous assurer que le modèle de gestion de transaction SQL Server fonctionne correctement, évitez d’utiliser d’autres modèles de gestion des transactions, tel que celui fourni par SQL Server.  
  
> [!NOTE]
>  Une fois qu’une transaction est validée ou restaurée, le niveau d’isolation de la transaction persiste pour toutes les commandes suivantes qui sont en mode autocommit (valeur par défaut de SQL Server). Cela peut produire des résultats inattendus, comme un niveau d’isolation REPEATABLE READ persiste et empêche les autres utilisateurs en dehors d’une ligne. Pour réinitialiser le niveau d’isolation pour la valeur par défaut (READ COMMITTED), exécutez le [!INCLUDE[tsql](~/includes/tsql-md.md)] instruction définir TRANSACTION ISOLATION LEVEL READ COMMITTED, ou appelez <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A?displayProperty=nameWithType> suivie immédiatement de <xref:System.Data.SqlClient.SqlTransaction.Commit%2A?displayProperty=nameWithType>. Pour plus d’informations sur les niveaux d’isolation de SQL Server, voir « Isolation Levels dans la base de données Engine » dans la documentation en ligne de SQL Server.  
  
 Pour plus d’informations sur les transactions SQL Server, consultez « Transactions explicites » et « Codage de Transactions performantes » dans la documentation en ligne de SQL Server.  
  
> [!CAUTION]
>  Lorsque votre requête retourne une grande quantité de données et les appels `BeginTransaction`, un <xref:System.Data.SqlClient.SqlException> est levée, car SQL Server n’autorise pas les transactions parallèles lors de l’utilisation de MARS. Pour éviter ce problème, associez toujours une transaction avec la commande, la connexion ou les deux avant que tous les lecteurs sont ouverts.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et un <xref:System.Data.SqlClient.SqlTransaction>. Il montre également comment utiliser le <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>, un <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>, et <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> méthodes.  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Les transactions parallèles ne sont pas autorisées quand vous utilisez MARS (Multiple Active Result Sets).</exception>
        <exception cref="T:System.InvalidOperationException">Les transactions parallèles ne sont pas prises en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChangeDatabase">
      <MemberSignature Language="C#" Value="public override void ChangeDatabase (string database);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ChangeDatabase(string database) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ChangeDatabase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ChangeDatabase (database As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ChangeDatabase(System::String ^ database);" />
      <MemberSignature Language="F#" Value="override this.ChangeDatabase : string -&gt; unit" Usage="sqlConnection.ChangeDatabase database" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.ChangeDatabase(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="database" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="database">Nom de la base de données à utiliser à la place de la base de données actuelle.</param>
        <summary>Modifie la base de données actuelle d'une connexion <see cref="T:System.Data.SqlClient.SqlConnection" /> établie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur fournie dans le `database` paramètre doit être un nom de base de données valide. Le `database` paramètre ne peut pas contenir une valeur null, une chaîne vide ou une chaîne de caractères vides uniquement.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et affiche certaines de ses propriétés en lecture seule.  
  
 [!code-csharp[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de la base de données n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">La connexion n'est pas ouverte.</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">Impossible de modifier la base de données.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChangePassword">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Change le mot de passe SQL Server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChangePassword">
      <MemberSignature Language="C#" Value="public static void ChangePassword (string connectionString, string newPassword);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangePassword(string connectionString, string newPassword) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangePassword (connectionString As String, newPassword As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangePassword(System::String ^ connectionString, System::String ^ newPassword);" />
      <MemberSignature Language="F#" Value="static member ChangePassword : string * string -&gt; unit" Usage="System.Data.SqlClient.SqlConnection.ChangePassword (connectionString, newPassword)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="newPassword" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Chaîne de connexion qui contient assez d'informations pour se connecter au serveur à utiliser. La chaîne de connexion doit contenir l'ID d'utilisateur et le mot de passe actuel.</param>
        <param name="newPassword">Le nouveau mot de passe à définir. Ce mot de passe doit se conformer à la stratégie de sécurité par mot de passe éventuellement définie sur le serveur, notamment la longueur minimale, les exigences en termes de caractères spécifiques, etc.</param>
        <summary>Remplace le mot de passe SQL Server de l’utilisateur indiqué dans la chaîne de connexion par le nouveau mot de passe fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez SQL Server sur Windows Server, les développeurs peuvent tirer parti des fonctionnalités qui permet à l’application cliente de fournir actuel et un nouveau mot de passe afin de modifier le mot de passe existant. Les applications peuvent implémenter des fonctionnalités telles qu’invitant l’utilisateur pour un nouveau mot de passe lors de la connexion initiale si l’ancien modèle a expiré, et cette opération peut être effectuée sans intervention de l’administrateur.  
  
 Le <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A> méthode modifie le mot de passe SQL Server pour l’utilisateur indiqué dans la liste fournie `connectionString` paramètre à la valeur fournie dans le `newPassword` paramètre. Si la chaîne de connexion inclut l’option pour la sécurité intégrée (autrement dit, « Integrated Security = True » ou l’équivalent), une exception est levée.  
  
 Pour déterminer que le mot de passe a expiré, en appelant le <xref:System.Data.SqlClient.SqlConnection.Open%2A> méthode déclenche un <xref:System.Data.SqlClient.SqlException>. Afin d’indiquer que le mot de passe qui est contenue dans la chaîne de connexion doit être réinitialisé, le <xref:System.Data.SqlClient.SqlException.Number%2A> propriété pour l’exception contient la valeur d’état 18487 ou 18488. La première valeur (18487) indique que le mot de passe a expiré et la seconde (18488) indique que le mot de passe doit être réinitialisé avant de vous connecter.  
  
 Cette méthode ouvre sa propre connexion au serveur demande la modification de mot de passe et ferme la connexion dès qu’elle est terminée. Cette connexion est extraite, ni ne retournée pour le pool de connexions SQL Server.  
  
   
  
## Examples  
 Voici un exemple simple de la modification d’un mot de passe :  
  
```  
class Program {  
   static void Main(string[] args) {  
      System.Data.SqlClient.SqlConnection.ChangePassword(  
        "Data Source=a_server;Initial Catalog=a_database;UID=user;PWD=old_password",   
       "new_password");  
   }  
}  
  
```  
  
```  
Module Module1  
    Sub Main()  
System.Data.SqlClient.SqlConnection.ChangePassword(  
        "Data Source=a_server;Initial Catalog=a_database;UID=user;PWD=old_password",   
       "new_password")  
    End Sub  
End Module  
  
```  
  
 L’application console suivante montre les problèmes liés à la modification de mot de passe d’un utilisateur, car le mot de passe actuel a expiré.  
  
 [!code-csharp[DataWorks SqlConnection.ChangePassword#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlConnection.ChangePassword/CS/source.cs#1)]
 [!code-vb[DataWorks SqlConnection.ChangePassword#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlConnection.ChangePassword/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La chaîne de connexion inclut l’option pour utiliser la sécurité intégrée.  Ou Le <paramref name="newPassword" /> dépasse 128 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="connectionString" /> ou <paramref name="newPassword" /> paramètre est null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChangePassword">
      <MemberSignature Language="C#" Value="public static void ChangePassword (string connectionString, System.Data.SqlClient.SqlCredential credential, System.Security.SecureString newSecurePassword);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangePassword(string connectionString, class System.Data.SqlClient.SqlCredential credential, class System.Security.SecureString newSecurePassword) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.Data.SqlClient.SqlCredential,System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangePassword (connectionString As String, credential As SqlCredential, newSecurePassword As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangePassword(System::String ^ connectionString, System::Data::SqlClient::SqlCredential ^ credential, System::Security::SecureString ^ newSecurePassword);" />
      <MemberSignature Language="F#" Value="static member ChangePassword : string * System.Data.SqlClient.SqlCredential * System.Security.SecureString -&gt; unit" Usage="System.Data.SqlClient.SqlConnection.ChangePassword (connectionString, credential, newSecurePassword)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="credential" Type="System.Data.SqlClient.SqlCredential" />
        <Parameter Name="newSecurePassword" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="connectionString">Chaîne de connexion qui contient assez d'informations pour se connecter à un serveur. La chaîne de connexion ne doit pas utiliser les mots clés de chaîne de connexion suivants : <see langword="Integrated Security = true" />, <see langword="UserId" />, <see langword="Password" /> ou <see langword="ContextConnection = true" />.</param>
        <param name="credential">Objet <see cref="T:System.Data.SqlClient.SqlCredential" />.</param>
        <param name="newSecurePassword">Nouveau mot de passe. <c>newSecurePassword</c> doit être en lecture seule. Le mot de passe doit également se conformer à la stratégie de sécurité par mot de passe éventuellement définie sur le serveur, notamment la longueur minimale, les exigences en termes de caractères spécifiques, etc.</param>
        <summary>Change le mot de passe SQL Server pour l’utilisateur indiqué dans l’objet <see cref="T:System.Data.SqlClient.SqlCredential" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">1.  La chaîne de connexion contient n'importe quelle combinaison d'<see langword="UserId" />, de <see langword="Password" />, ou de <see langword="Integrated Security=true" />.  2.  La chaîne de connexion contient <see langword="Context Connection=true" />.  3.  <paramref name="newSecurePassword" /> dépasse 128 caractères.  4.  <paramref name="newSecurePassword" /> n'est pas en lecture seule.  5.  <paramref name="newSecurePassword" /> est une chaîne vide.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs des paramètres (<paramref name="connectionString" />, <paramref name="credential" />, ou <paramref name="newSecurePassword" />) ont la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearAllPools">
      <MemberSignature Language="C#" Value="public static void ClearAllPools ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearAllPools() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ClearAllPools" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearAllPools ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearAllPools();" />
      <MemberSignature Language="F#" Value="static member ClearAllPools : unit -&gt; unit" Usage="System.Data.SqlClient.SqlConnection.ClearAllPools " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vide le pool de connexions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> réinitialise (ou vide) le pool de connexions. S’il existe des connexions en cours d’utilisation au moment de l’appel, elles sont marquées de manière appropriée et seront ignorées (au lieu d’être retournées au pool) lorsque <xref:System.Data.SqlClient.SqlConnection.Close%2A> est appelée sur ces derniers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearPool">
      <MemberSignature Language="C#" Value="public static void ClearPool (System.Data.SqlClient.SqlConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearPool(class System.Data.SqlClient.SqlConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ClearPool(System.Data.SqlClient.SqlConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearPool (connection As SqlConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearPool(System::Data::SqlClient::SqlConnection ^ connection);" />
      <MemberSignature Language="F#" Value="static member ClearPool : System.Data.SqlClient.SqlConnection -&gt; unit" Usage="System.Data.SqlClient.SqlConnection.ClearPool connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.SqlClient.SqlConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Data.SqlClient.SqlConnection" /> à effacer du pool.</param>
        <summary>Vide le pool de connexions associé à la connexion spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A> Efface le pool de connexions est associé le `connection`. Si des connexions supplémentaires associées `connection` sont en cours d’utilisation au moment de l’appel, elles sont marquées de manière appropriée et sont ignorées (au lieu d’être retournées au pool) lorsque <xref:System.Data.SqlClient.SqlConnection.Close%2A> est appelée sur ces derniers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientConnectionId">
      <MemberSignature Language="C#" Value="public Guid ClientConnectionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ClientConnectionId" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ClientConnectionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientConnectionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ClientConnectionId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientConnectionId : Guid" Usage="System.Data.SqlClient.SqlConnection.ClientConnectionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ID de connexion de la tentative de connexion la plus récente, que la tentative ait réussi ou échoué.</summary>
        <value>ID de connexion de la tentative de connexion la plus récente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ClientConnectionId%2A> fonctionne quel que soit la version du serveur que vous vous connectez à, mais les journaux des événements étendus et écriture sur les erreurs de mémoire tampon en anneau de connectivité ne seront pas présents dans [!INCLUDE[sskatmai_r2](~/includes/sskatmai-r2-md.md)] et versions antérieures.  
  
 Vous pouvez rechercher l’ID de connexion dans le journal des événements étendus pour voir si l’échec était sur le serveur si l’événement étendu pour la journalisation des ID de connexion est activée. Vous pouvez également trouver l’ID de connexion dans la mémoire tampon en anneau de connexion ([résolution des problèmes de connectivité dans SQL Server 2008 avec la mémoire tampon en anneau de connectivité](http://go.microsoft.com/fwlink/?LinkId=207752)) pour certaines des erreurs de connexion. Si l’ID de connexion n’est pas dans la mémoire tampon en anneau de connexion, vous pouvez supposer une erreur réseau.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="sqlConnection.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme la connexion à la base de données. C'est la méthode recommandée de fermeture d'une connexion ouverte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.SqlClient.SqlConnection.Close%2A> méthode annule les transactions en attente. Il libère la connexion au pool de connexions ou que vous ferme la connexion si le regroupement de connexions est désactivé.  
  
> [!NOTE]
>  Démarré à l’aide de transactions en attente [!INCLUDE[tsql](~/includes/tsql-md.md)] ou <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> sont restaurées automatiquement lorsque la connexion est réinitialisée si le regroupement de connexions est activé. Si le regroupement de connexions est désactivé, la transaction est restaurée après `SqlConnection.Close` est appelée. Transactions démarrées via <xref:System.Transactions> sont contrôlées via le `System.Transactions` infrastructure et sont pas affectées par `SqlConnection.Close`.  
  
 Une application peut appeler <xref:System.Data.SqlClient.SqlConnection.Close%2A> plusieurs fois. Aucune exception n’est générée.  
  
 Si le <xref:System.Data.SqlClient.SqlConnection> est hors de portée, il ne sera pas fermé. Par conséquent, vous devez fermer explicitement la connexion en appelant `Close` ou `Dispose`. `Close` et `Dispose` sont fonctionnellement équivalents. Si le regroupement de connexions valeur `Pooling` a la valeur `true` ou `yes`, la connexion sous-jacente est retournée au pool de connexions. En revanche, si `Pooling` a la valeur `false` ou `no`, le sous-jacente de connexion au serveur est fermée.  
  
> [!NOTE]
>  Les événements de connexion et de déconnexion ne seront pas déclenchés sur le serveur si une connexion est récupérée depuis le pool de connexions ou qu’elle est retournée au pool, car elle n’est pas réellement fermée lorsqu’elle est retournée au pool. Pour plus d’informations, consultez [Regroupement de connexions SQL Server (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md).  
  
> [!CAUTION]
>  N’appelez pas `Close` ou `Dispose` sur une connexion, un DataReader ou tout autre objet managé dans le `Finalize` méthode de votre classe. Dans un finaliseur, vous devez libérer uniquement les ressources non managées que votre classe possède directement. Si votre classe ne possède pas de ressource non managée, n'incluez pas une méthode `Finalize` dans la définition de classe. Pour plus d’informations, consultez [Garbage Collection](~/docs/standard/garbage-collection/index.md).  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection>, l’ouvre et affiche certaines de ses propriétés. La connexion est fermée automatiquement à la fin de la `using` bloc.  
  
 [!code-csharp[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Erreur de connexion qui s’est produite lors de l’établissement de la connexion.</exception>
      </Docs>
    </Member>
    <Member MemberName="ColumnEncryptionKeyCacheTtl">
      <MemberSignature Language="C#" Value="public static TimeSpan ColumnEncryptionKeyCacheTtl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan ColumnEncryptionKeyCacheTtl" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ColumnEncryptionKeyCacheTtl" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ColumnEncryptionKeyCacheTtl As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan ColumnEncryptionKeyCacheTtl { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ColumnEncryptionKeyCacheTtl : TimeSpan with get, set" Usage="System.Data.SqlClient.SqlConnection.ColumnEncryptionKeyCacheTtl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée de vie des entrées de la clé de chiffrement de colonne du cache de clé de chiffrement de colonne pour la fonctionnalité [Always Encrypted](/sql/relational-databases/security/encryption/always-encrypted-database-engine). La valeur par défaut est 2 heures. 0 signifie aucune mise en cache.</summary>
        <value>L’intervalle de temps.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnEncryptionQueryMetadataCacheEnabled">
      <MemberSignature Language="C#" Value="public static bool ColumnEncryptionQueryMetadataCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ColumnEncryptionQueryMetadataCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ColumnEncryptionQueryMetadataCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ColumnEncryptionQueryMetadataCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ColumnEncryptionQueryMetadataCacheEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ColumnEncryptionQueryMetadataCacheEnabled : bool with get, set" Usage="System.Data.SqlClient.SqlConnection.ColumnEncryptionQueryMetadataCacheEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la mise en cache des métadonnées de requête est activée (true) ou non (false) pour les requêtes paramétrables qui s’exécutent sur des bases de données [Always Encrypted](/sql/relational-databases/security/encryption/always-encrypted-database-engine). La valeur par défaut est true.</summary>
        <value>Retourne la valeur true si la mise en cache des métadonnées de requête est activée ; sinon, false. La valeur par défaut est true.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les requêtes paramétrables, SqlClient en effectuant un aller-retour vers SQL Server pour les métadonnées de paramètre, voir le paramètre auquel il faut chiffrer et de quelle manière (les clés et les algorithmes qui doivent être utilisés). Si l’application appelle plusieurs fois à la même requête, un aller-retour supplémentaire est effectué sur le serveur chaque fois, ce qui dégrade les performances de l’application.  
  
 Avec **ColumnEncryptionQueryMetadataCacheEnabled** définie sur true, si la même requête est appelée plusieurs fois, l’aller-retour vers le serveur est alors qu’une seule fois. Le cache a un paramètre de taille de Max non configurable qui est défini sur les requêtes de 2000.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnEncryptionTrustedMasterKeyPaths">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.IList&lt;string&gt;&gt; ColumnEncryptionTrustedMasterKeyPaths { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.IList`1&lt;string&gt;&gt; ColumnEncryptionTrustedMasterKeyPaths" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ColumnEncryptionTrustedMasterKeyPaths" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ColumnEncryptionTrustedMasterKeyPaths As IDictionary(Of String, IList(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::IList&lt;System::String ^&gt; ^&gt; ^ ColumnEncryptionTrustedMasterKeyPaths { System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::IList&lt;System::String ^&gt; ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ColumnEncryptionTrustedMasterKeyPaths : System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.IList&lt;string&gt;&gt;" Usage="System.Data.SqlClient.SqlConnection.ColumnEncryptionTrustedMasterKeyPaths" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.IList&lt;System.String&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Permet de définir une liste de chemins de clés approuvés pour un serveur de base de données. Si le pilote reçoit un chemin de clé qui ne figure pas dans la liste pendant le traitement d’une requête d’application, celle-ci échouera. Cette propriété fournit une protection supplémentaire contre les attaques de sécurité impliquant un serveur SQL Server compromis qui fournit de faux chemins de clés, et pouvant entraîner une fuite des informations d’identification du magasin de clés.</summary>
        <value>Liste des chemins de clés principales approuvés pour le chiffrement de la colonne.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectionString">
      <MemberSignature Language="C#" Value="public override string ConnectionString { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionString" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ConnectionString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionString { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionString : string with get, set" Usage="System.Data.SqlClient.SqlConnection.ConnectionString" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.ConnectionString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.SQL.Design.SqlConnectionStringEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la chaîne utilisée pour ouvrir une base de données SQL Server.</summary>
        <value>Chaîne de connexion comportant le nom de la base de données source et d'autres paramètres nécessaires à l'établissement de la connexion initiale. La valeur par défaut est une chaîne vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> est similaire à une chaîne de connexion OLE DB, mais n’est pas identique. Contrairement à OLE DB ou ADO, la chaîne de connexion qui est retournée est identique à l’ensemble d’utilisateurs <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>, moins les informations de sécurité si la valeur Persist Security Info est définie sur `false` (valeur par défaut). Le fournisseur de données .NET Framework pour SQL Server ne pas conserver ou retourner le mot de passe dans une chaîne de connexion, sauf si vous affectez à Persist Security Info `true`.  
  
 Vous pouvez utiliser le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> propriété pour se connecter à une base de données. L’exemple suivant illustre une chaîne de connexion par défaut.  
  
```  
"Persist Security Info=False;Integrated Security=true;Initial Catalog=Northwind;server=(local)"  
```  
  
 Utilisez la nouvelle <xref:System.Data.SqlClient.SqlConnectionStringBuilder> pour construire des chaînes de connexion valides au moment de l’exécution. Pour plus d’informations, consultez [Builders de chaînes de connexion](~/docs/framework/data/adonet/connection-string-builders.md).  
  
 Le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> propriété peut être définie uniquement lorsque la connexion est fermée. La plupart des valeurs de chaîne de connexion ont des propriétés en lecture seule correspondantes. Lorsque la chaîne de connexion est définie, ces propriétés sont mises à jour, sauf si une erreur est détectée. Dans ce cas, aucune des propriétés sont mises à jour. <xref:System.Data.SqlClient.SqlConnection> propriétés retournent uniquement les paramètres qui sont contenus dans le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>.  
  
 Pour vous connecter à un ordinateur local, spécifiez « (local) » pour le serveur. Si un nom de serveur n’est pas spécifié, une connexion est tentée à l’instance par défaut sur l’ordinateur local.  
  
 Réinitialiser le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> sur une connexion fermée rétablit toutes les valeurs de chaîne de connexion (et les propriétés associées), y compris le mot de passe. Par exemple, si vous définissez une chaîne de connexion qui inclut » base de données = AdventureWorks », puis réinitialisez la chaîne de connexion à « Source de données = myserver ; Integrated Security = true », le <xref:System.Data.SqlClient.SqlConnection.Database%2A> propriété n’est plus définie à « AdventureWorks ».  
  
 La chaîne de connexion est analysée immédiatement après avoir été défini. Si les erreurs de syntaxe sont détectées lors de l’analyse, une exception runtime, tels que <xref:System.ArgumentException>, est généré. Vous trouverez d’autres erreurs uniquement lorsqu’une tentative est faite pour ouvrir la connexion.  
  
 Le format de chaîne de connexion de base inclut une série de paires mot clé/valeur séparées par des points-virgules. Le signe égal (=) sert de lien entre chaque mot clé et sa valeur. Pour inclure les valeurs qui contiennent un point-virgule, un caractère guillemet unique ou un caractère guillemet double, la valeur doit être placée entre guillemets doubles. Si la valeur contient un point-virgule et un caractère guillemet double, la valeur peut être placée entre guillemets simples. Le guillemet simple est également utile si la valeur commence par un caractère de guillemet double. À l’inverse, le guillemet double peut être utilisé si la valeur commence par un guillemet simple. Si la valeur contient des caractères de guillemet simple et guillemet double, le caractère guillemet permettant de délimiter la valeur doit être double chaque fois qu’il se trouve dans la valeur.  
  
 Pour inclure des espaces de début ou de fin dans la valeur de chaîne, la valeur doit être placée entre dans les guillemets simples ou des guillemets doubles. Les espaces de début ou de fin autour d’entier, booléen ou valeurs énumérées sont ignorés, même si entourée de guillemets. Toutefois, les espaces au sein d’un mot clé de chaîne littérale ou une valeur sont conservés. Des guillemets simples ou doubles peuvent servir au sein d’une chaîne de connexion sans délimiteurs (par exemple, Data Source = my'Server ou la Source de données = mon serveur »), sauf si un caractère guillemet est le premier ou dernier caractère dans la valeur.  
  
 Mots clés ne respectent pas la casse.  
  
 Le tableau suivant répertorie les noms valides pour les valeurs de mot clé dans le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>.  
  
  La liste suivante contient les noms valides pour les valeurs au sein de regroupement de connexions le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>. Pour plus d’informations, consultez [Regroupement de connexions SQL Server (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md).  
  
-   Durée de vie de connexion (ou Load Balance Timeout)  
  
-   Enlist  
  
-   Max Pool Size  
  
-   Min Pool Size  
  
-   Pooling  
  
 Lorsque vous définissez un mot clé ou des valeurs qui requièrent une valeur booléenne de regroupement de connexions, vous pouvez utiliser « Oui » au lieu de « true » et « non » au lieu de 'false'. Valeurs entières sont représentées sous forme de chaînes.  
  
> [!NOTE]
>  Le fournisseur de données .NET Framework pour SQL Server utilise son propre protocole pour communiquer avec SQL Server. Par conséquent, il ne prend pas en charge l’utilisation d’un nom de source de données ODBC (DSN) lors de la connexion à SQL Server, car elle n’ajoute pas d’une couche ODBC.  
  
> [!NOTE]
>  Fichiers UDL (UDL) ne sont pas pris en charge pour le fournisseur de données .NET Framework pour SQL Server.  
  
> [!CAUTION]
>  Dans cette version, l’application doit utiliser attention lors de la construction d’une chaîne de connexion basée sur l’entrée d’utilisateur (par exemple, lors de la récupération des informations d’ID et mot de passe utilisateur à partir d’une boîte de dialogue et leur ajout à la chaîne de connexion). L’application doit s’assurer qu’un utilisateur ne peut pas incorporer des paramètres de chaîne de connexion supplémentaires dans ces valeurs (par exemple, entrer un mot de passe en tant que » validpassword ; database = somedb » dans une tentative d’attachement à une autre base de données). Si vous avez besoin construire des chaînes de connexion basées sur l’entrée d’utilisateur, utilisez la nouvelle <xref:System.Data.SqlClient.SqlConnectionStringBuilder>, qui valide la chaîne de connexion et permet d’éliminer ce problème. Consultez [générateurs de chaînes de connexion](~/docs/framework/data/adonet/connection-string-builders.md) pour plus d’informations.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et définit le <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> propriété avant d’ouvrir la connexion.  
  
 [!code-csharp[Classic WebData SqlConnection.ConnectionString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.ConnectionString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argument de chaîne de connexion non valide a été fourni ou un argument de chaîne de connexion obligatoire n’a pas été fourni.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionTimeout">
      <MemberSignature Language="C#" Value="public override int ConnectionTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ConnectionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ConnectionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ConnectionTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ConnectionTimeout { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionTimeout : int" Usage="System.Data.SqlClient.SqlConnection.ConnectionTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.ConnectionTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la durée d'attente préalable à l'établissement d'une connexion avant que la tentative ne soit abandonnée et qu'une erreur ne soit générée.</summary>
        <value>Durée d'attente (en secondes) préalable à l'établissement d'une connexion. La valeur par défaut est de 15 secondes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez définir la durée d’attente de la connexion à un délai d’attente à l’aide de la `Connect Timeout` ou `Connection Timeout` mots clés dans la chaîne de connexion. La valeur 0 indique aucune limite et doivent être évitée dans un <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> , car une tentative de connexion attend indéfiniment.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et définit le `Connection Timeout` à 30 secondes dans la chaîne de connexion. Le code ouvre la connexion et affiche le <xref:System.Data.SqlClient.SqlConnection.ConnectionTimeout%2A> propriété dans la fenêtre de console.  
  
 [!code-csharp[Classic WebData SqlConnection.ConnectionTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.ConnectionTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur définie est inférieure à 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand CreateCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand CreateCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.CreateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCommand () As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ CreateCommand();" />
      <MemberSignature Language="F#" Value="override this.CreateCommand : unit -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlConnection.CreateCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée et retourne un objet <see cref="T:System.Data.SqlClient.SqlCommand" /> associé à <see cref="T:System.Data.SqlClient.SqlConnection" />.</summary>
        <returns>Objet <see cref="T:System.Data.SqlClient.SqlCommand" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[SqlConnection_CreateCommand#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/sqlconnection_createcommand/cs/source.cs#1)]
 [!code-vb[SqlConnection_CreateCommand#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/sqlconnection_createcommand/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDbCommand">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbCommand CreateDbCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbCommand CreateDbCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.CreateDbCommand" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateDbCommand () As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbCommand ^ CreateDbCommand();" />
      <MemberSignature Language="F#" Value="override this.CreateDbCommand : unit -&gt; System.Data.Common.DbCommand" Usage="sqlConnection.CreateDbCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credential">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCredential Credential { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.SqlClient.SqlCredential Credential" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.Credential" />
      <MemberSignature Language="VB.NET" Value="Public Property Credential As SqlCredential" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SqlClient::SqlCredential ^ Credential { System::Data::SqlClient::SqlCredential ^ get(); void set(System::Data::SqlClient::SqlCredential ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credential : System.Data.SqlClient.SqlCredential with get, set" Usage="System.Data.SqlClient.SqlConnection.Credential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’objet <see cref="T:System.Data.SqlClient.SqlCredential" /> pour cette connexion.</summary>
        <value>Objet <see cref="T:System.Data.SqlClient.SqlCredential" /> pour cette connexion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Persist Security Info = true` est nécessaire pour obtenir la valeur de la <xref:System.Data.SqlClient.SqlCredential> avec l’objet <xref:System.Data.SqlClient.SqlConnection.Credential%2A>.  
  
 La valeur par défaut de <xref:System.Data.SqlClient.SqlConnection.Credential%2A> a la valeur null.  
  
 Un <xref:System.InvalidOperationException> exception sera levée :  
  
-   Si <xref:System.Data.SqlClient.SqlConnection.Credential%2A> est défini sur une connexion ouverte.  
  
-   Si <xref:System.Data.SqlClient.SqlConnection.Credential%2A> est définie lorsque `Context Connection=true`.  
  
-   Si <xref:System.Data.SqlClient.SqlConnection.Credential%2A> est définie lorsque `Integrated Security = true`.  
  
-   Si <xref:System.Data.SqlClient.SqlConnection.Credential%2A> est définie lorsque la chaîne de connexion utilise `Password`.  
  
-   Si <xref:System.Data.SqlClient.SqlConnection.Credential%2A> est définie lorsque la chaîne de connexion utilise `UserID`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCredential Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.SqlClient.SqlCredential Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As SqlCredential" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SqlClient::SqlCredential ^ Credentials { System::Data::SqlClient::SqlCredential ^ get(); void set(System::Data::SqlClient::SqlCredential ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Data.SqlClient.SqlCredential with get, set" Usage="System.Data.SqlClient.SqlConnection.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Database">
      <MemberSignature Language="C#" Value="public override string Database { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Database" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.Database" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Database As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Database { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Database : string" Usage="System.Data.SqlClient.SqlConnection.Database" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.Database</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de la base de données active ou de la base de données à utiliser une fois la connexion ouverte.</summary>
        <value>Nom de la base de données active ou de la base de données à utiliser une fois la connexion ouverte. La valeur par défaut est une chaîne vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.SqlClient.SqlConnection.Database%2A> propriété met à jour dynamiquement. Si vous modifiez la base de données actuelle à l’aide un [!INCLUDE[tsql](~/includes/tsql-md.md)] instruction ou le <xref:System.Data.SqlClient.SqlConnection.ChangeDatabase%2A> (méthode), un message d’information est envoyé et la propriété est automatiquement mis à jour.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et affiche certaines de ses propriétés en lecture seule.  
  
 [!code-csharp[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public override string DataSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DataSource As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DataSource { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSource : string" Usage="System.Data.SqlClient.SqlConnection.DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de l’instance de SQL Server à laquelle se connecter.</summary>
        <value>Le nom de l’instance de SQL Server à laquelle se connecter. La valeur par défaut est une chaîne vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Le <xref:System.Data.SqlClient.SqlConnection.DataSource%2A> retourne de la propriété `null` si la chaîne de connexion pour le <xref:System.Data.SqlClient.SqlConnection> est « connexion contextuelle = true ».  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et affiche certaines de ses propriétés en lecture seule.  
  
 [!code-csharp[Classic WebData SqlConnection.DataSource Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.DataSource Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.DataSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.DataSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DbProviderFactory">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbProviderFactory DbProviderFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbProviderFactory DbProviderFactory" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.DbProviderFactory" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DbProviderFactory As DbProviderFactory" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Data::Common::DbProviderFactory ^ DbProviderFactory { System::Data::Common::DbProviderFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DbProviderFactory : System.Data.Common.DbProviderFactory" Usage="System.Data.SqlClient.SqlConnection.DbProviderFactory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbProviderFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="sqlConnection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnlistDistributedTransaction">
      <MemberSignature Language="C#" Value="public void EnlistDistributedTransaction (System.EnterpriseServices.ITransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnlistDistributedTransaction(class System.EnterpriseServices.ITransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.EnlistDistributedTransaction(System.EnterpriseServices.ITransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnlistDistributedTransaction (transaction As ITransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnlistDistributedTransaction(System::EnterpriseServices::ITransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.EnlistDistributedTransaction : System.EnterpriseServices.ITransaction -&gt; unit" Usage="sqlConnection.EnlistDistributedTransaction transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.EnterpriseServices.ITransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Référence à un <see cref="T:System.EnterpriseServices.ITransaction" /> existant dans lequel s’inscrire.</param>
        <summary>S’inscrit dans la transaction spécifiée en tant que transaction distribuée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Data.SqlClient.SqlConnection.EnlistTransaction%2A> méthode pour s’inscrire dans une transaction distribuée. Étant donné qu’il inscrit une connexion dans un <xref:System.Transactions.Transaction> instance, **EnlistTransaction** tire parti des fonctionnalités disponibles dans le <xref:System.Transactions> espace de noms pour la gestion des transactions distribuées, à la ** EnlistDistributedTransaction** à cet effet. Pour plus d’informations, consultez [Transactions distribuées](~/docs/framework/data/adonet/distributed-transactions.md).  
  
 Vous pouvez continuer à s’inscrire dans une transaction distribuée existante à l’aide du **EnlistDistributedTransaction** méthode si l’inscription automatique est désactivée. L’inscription dans une transaction distribuée existante permet de s’assurer que, si la transaction est validée ou restaurée, les modifications apportées par le code dans la source de données sont également validées ou restaurées.  
  
 `EnlistDistributedTransaction` Retourne une exception si le <xref:System.Data.SqlClient.SqlConnection> a déjà démarré une transaction à l’aide <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>. Toutefois, si la transaction est une transaction locale démarrée dans la source de données (par exemple, en exécutant explicitement l’instruction BEGIN TRANSACTION en utilisant un <xref:System.Data.SqlClient.SqlCommand> objet), **EnlistDistributedTransaction** restaure le transaction locale et s’inscrit dans la transaction distribuée existante comme demandé. Vous ne recevez pas de notification indiquant que la transaction locale a été restaurée, et êtes responsable de la gestion des éventuelles transactions locales non lancées à l’aide de <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnlistTransaction">
      <MemberSignature Language="C#" Value="public override void EnlistTransaction (System.Transactions.Transaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EnlistTransaction(class System.Transactions.Transaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.EnlistTransaction(System.Transactions.Transaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EnlistTransaction(System::Transactions::Transaction ^ transaction);" />
      <MemberSignature Language="F#" Value="override this.EnlistTransaction : System.Transactions.Transaction -&gt; unit" Usage="sqlConnection.EnlistTransaction transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Transactions.Transaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Référence à un <see cref="T:System.Transactions.Transaction" /> existant dans lequel s’inscrire.</param>
        <summary>S’inscrit dans la transaction spécifiée en tant que transaction distribuée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Data.SqlClient.SqlConnection.EnlistTransaction%2A> méthode pour s’inscrire dans une transaction distribuée. Étant donné qu’il inscrit une connexion dans un <xref:System.Transactions.Transaction> instance, **EnlistTransaction** tire parti des fonctionnalités disponibles dans le <xref:System.Transactions> espace de noms pour la gestion des transactions distribuées, à la ** EnlistDistributedTransaction**, qui utilise un **System.EnterpriseServices.ITransaction** objet. Il possède également une sémantique légèrement différente : dès qu’une connexion est explicitement inscrite sur une transaction, il ne peut pas être désinscrit ou inscrite dans une autre transaction jusqu'à ce que la première transaction se termine. Pour plus d’informations sur les transactions distribuées, consultez [les Transactions distribuées](~/docs/framework/data/adonet/distributed-transactions.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FireInfoMessageEventOnUserErrors">
      <MemberSignature Language="C#" Value="public bool FireInfoMessageEventOnUserErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FireInfoMessageEventOnUserErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property FireInfoMessageEventOnUserErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FireInfoMessageEventOnUserErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.FireInfoMessageEventOnUserErrors : bool with get, set" Usage="System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la propriété <see cref="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" />.</summary>
        <value>
          <see langword="true" /> si la propriété <see cref="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" /> a été définie ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous définissez <xref:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors%2A> à `true`, les erreurs qui ont été précédemment traitées comme des exceptions sont maintenant gérées en tant que <xref:System.Data.SqlClient.SqlConnection.InfoMessage> événements. Tous les événements se déclenchent immédiatement et sont gérés par le Gestionnaire d’événements. Si est <xref:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors%2A> a la valeur `false`, puis <xref:System.Data.SqlClient.SqlConnection.InfoMessage> les événements sont gérés à la fin de la procédure.  
  
> [!NOTE]
>  Une erreur avec un niveau de gravité de 17 ou plus, le serveur d’arrêter le traitement de la commande doit être gérée comme une exception. Dans ce cas, une exception est levée, indépendamment de la manière dont l'erreur est gérée dans l'événement <xref:System.Data.SqlClient.SqlConnection.InfoMessage>.  
  
 Pour plus d’informations sur l’utilisation des événements, consultez [les événements de connexion](~/docs/framework/data/adonet/connection-events.md). Pour plus d’informations sur les erreurs générées par le moteur SQL Server, consultez la documentation en ligne de SQL Server.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les informations de schéma pour la source de données de ce <see cref="T:System.Data.SqlClient.SqlConnection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous tentez de récupérer les informations de schéma pour plusieurs procédures stockées avec version, le schéma de la plus récente uniquement est retourné. Pour plus d’informations sur les procédures stockées avec version, consultez la documentation en ligne de SQL Server.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchema () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchema();" />
      <MemberSignature Language="F#" Value="override this.GetSchema : unit -&gt; System.Data.DataTable" Usage="sqlConnection.GetSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les informations de schéma pour la source de données de ce <see cref="T:System.Data.SqlClient.SqlConnection" />. Pour plus d’informations sur le schéma, consultez [Collections de schémas SQL Server](http://msdn.microsoft.com/library/ms254969.aspx).</summary>
        <returns>
          <see cref="T:System.Data.DataTable" /> qui contient les informations de schéma.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchema (string collectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchema(string collectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.GetSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchema (collectionName As String) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchema(System::String ^ collectionName);" />
      <MemberSignature Language="F#" Value="override this.GetSchema : string -&gt; System.Data.DataTable" Usage="sqlConnection.GetSchema collectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="collectionName">Indique le nom du schéma à retourner.</param>
        <summary>Retourne des informations de schéma pour la source de données de ce <see cref="T:System.Data.SqlClient.SqlConnection" /> à l'aide de la chaîne spécifiée pour le nom de schéma.</summary>
        <returns>
          <see cref="T:System.Data.DataTable" /> qui contient les informations de schéma.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devrez peut-être les informations de schéma de la base de données, les tables ou les colonnes. Cet exemple :  
  
-   Utilise GetSchema pour obtenir des informations de schéma.  
  
-   Utilisez des restrictions de schéma pour obtenir les informations spécifiées.  
  
-   Obtient les informations de schéma de la base de données, des tables et des colonnes.  
  
 Avant d’exécuter l’exemple, vous devez créer la base de données, à l’aide de ce qui suit [!INCLUDE[tsql](~/includes/tsql-md.md)]:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 [Comment obtenir les informations de schéma de base de données](https://code.msdn.microsoft.com/How-to-Get-Schema-b66d62e2) a des versions de c# et Visual Basic de cet exemple de code dans un projet Visual Studio.  
  
```  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
      using (SqlConnection conn = new SqlConnection("Data Source=(local);Initial Catalog=MySchool;Integrated Security=True;Asynchronous Processing=true;")) {  
         conn.Open();  
  
         // Get the Meta Data for Supported Schema Collections  
         DataTable metaDataTable = conn.GetSchema("MetaDataCollections");  
  
         Console.WriteLine("Meta Data for Supported Schema Collections:");  
         ShowDataTable(metaDataTable, 25);  
         Console.WriteLine();  
  
         // Get the schema information of Databases in your instance  
         DataTable databasesSchemaTable = conn.GetSchema("Databases");  
  
         Console.WriteLine("Schema Information of Databases:");  
         ShowDataTable(databasesSchemaTable, 25);  
         Console.WriteLine();  
  
         // First, get schema information of all the tables in current database;  
         DataTable allTablesSchemaTable = conn.GetSchema("Tables");  
  
         Console.WriteLine("Schema Information of All Tables:");  
         ShowDataTable(allTablesSchemaTable, 20);  
         Console.WriteLine();  
  
         // You can specify the Catalog, Schema, Table Name, Table Type to get   
         // the specified table(s).  
         // You can use four restrictions for Table, so you should create a 4 members array.  
         String[] tableRestrictions = new String[4];  
  
         // For the array, 0-member represents Catalog; 1-member represents Schema;   
         // 2-member represents Table Name; 3-member represents Table Type.   
         // Now we specify the Table Name of the table what we want to get schema information.  
         tableRestrictions[2] = "Course";  
  
         DataTable courseTableSchemaTable = conn.GetSchema("Tables", tableRestrictions);  
  
         Console.WriteLine("Schema Information of Course Tables:");  
         ShowDataTable(courseTableSchemaTable, 20);  
         Console.WriteLine();  
  
         // First, get schema information of all the columns in current database.  
         DataTable allColumnsSchemaTable = conn.GetSchema("Columns");  
  
         Console.WriteLine("Schema Information of All Columns:");  
         ShowColumns(allColumnsSchemaTable);  
         Console.WriteLine();  
  
         // You can specify the Catalog, Schema, Table Name, Column Name to get the specified column(s).  
         // You can use four restrictions for Column, so you should create a 4 members array.  
         String[] columnRestrictions = new String[4];  
  
         // For the array, 0-member represents Catalog; 1-member represents Schema;   
         // 2-member represents Table Name; 3-member represents Column Name.   
         // Now we specify the Table_Name and Column_Name of the columns what we want to get schema information.  
         columnRestrictions[2] = "Course";  
         columnRestrictions[3] = "DepartmentID";  
  
         DataTable departmentIDSchemaTable = conn.GetSchema("Columns", columnRestrictions);  
  
         Console.WriteLine("Schema Information of DepartmentID Column in Course Table:");  
         ShowColumns(departmentIDSchemaTable);  
         Console.WriteLine();  
  
         // First, get schema information of all the IndexColumns in current database  
         DataTable allIndexColumnsSchemaTable = conn.GetSchema("IndexColumns");  
  
         Console.WriteLine("Schema Information of All IndexColumns:");  
         ShowIndexColumns(allIndexColumnsSchemaTable);  
         Console.WriteLine();  
  
         // You can specify the Catalog, Schema, Table Name, Constraint Name, Column Name to   
         // get the specified column(s).  
         // You can use five restrictions for Column, so you should create a 5 members array.  
         String[] indexColumnsRestrictions = new String[5];  
  
         // For the array, 0-member represents Catalog; 1-member represents Schema;   
         // 2-member represents Table Name; 3-member represents Constraint Name;4-member represents Column Name.   
         // Now we specify the Table_Name and Column_Name of the columns what we want to get schema information.  
         indexColumnsRestrictions[2] = "Course";  
         indexColumnsRestrictions[4] = "CourseID";  
  
         DataTable courseIdIndexSchemaTable = conn.GetSchema("IndexColumns", indexColumnsRestrictions);  
  
         Console.WriteLine("Index Schema Information of CourseID Column in Course Table:");  
         ShowIndexColumns(courseIdIndexSchemaTable);  
         Console.WriteLine();  
      }  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   private static void ShowDataTable(DataTable table, Int32 length) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-" + length + "}", col.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         foreach (DataColumn col in table.Columns) {  
            if (col.DataType.Equals(typeof(DateTime)))  
               Console.Write("{0,-" + length + ":d}", row[col]);  
            else if (col.DataType.Equals(typeof(Decimal)))  
               Console.Write("{0,-" + length + ":C}", row[col]);  
            else  
               Console.Write("{0,-" + length + "}", row[col]);  
         }  
         Console.WriteLine();  
      }  
   }  
  
   private static void ShowDataTable(DataTable table) {  
      ShowDataTable(table, 14);  
   }  
  
   private static void ShowColumns(DataTable columnsTable) {  
      var selectedRows = from info in columnsTable.AsEnumerable()  
                         select new {  
                            TableCatalog = info["TABLE_CATALOG"],  
                            TableSchema = info["TABLE_SCHEMA"],  
                            TableName = info["TABLE_NAME"],  
                            ColumnName = info["COLUMN_NAME"],  
                            DataType = info["DATA_TYPE"]  
                         };  
  
      Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", "TableCatalog", "TABLE_SCHEMA",  
          "TABLE_NAME", "COLUMN_NAME", "DATA_TYPE");  
      foreach (var row in selectedRows) {  
         Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", row.TableCatalog,  
             row.TableSchema, row.TableName, row.ColumnName, row.DataType);  
      }  
   }  
  
   private static void ShowIndexColumns(DataTable indexColumnsTable) {  
      var selectedRows = from info in indexColumnsTable.AsEnumerable()  
                         select new {  
                            TableSchema = info["table_schema"],  
                            TableName = info["table_name"],  
                            ColumnName = info["column_name"],  
                            ConstraintSchema = info["constraint_schema"],  
                            ConstraintName = info["constraint_name"],  
                            KeyType = info["KeyType"]  
                         };  
  
      Console.WriteLine("{0,-14}{1,-11}{2,-14}{3,-18}{4,-16}{5,-8}", "table_schema", "table_name", "column_name", "constraint_schema", "constraint_name", "KeyType");  
      foreach (var row in selectedRows) {  
         Console.WriteLine("{0,-14}{1,-11}{2,-14}{3,-18}{4,-16}{5,-8}", row.TableSchema,  
             row.TableName, row.ColumnName, row.ConstraintSchema, row.ConstraintName, row.KeyType);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionName" /> est spécifié comme étant Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchema (string collectionName, string[] restrictionValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchema(string collectionName, string[] restrictionValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.GetSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchema (collectionName As String, restrictionValues As String()) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchema(System::String ^ collectionName, cli::array &lt;System::String ^&gt; ^ restrictionValues);" />
      <MemberSignature Language="F#" Value="override this.GetSchema : string * string[] -&gt; System.Data.DataTable" Usage="sqlConnection.GetSchema (collectionName, restrictionValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionName" Type="System.String" />
        <Parameter Name="restrictionValues" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="collectionName">Indique le nom du schéma à retourner.</param>
        <param name="restrictionValues">Ensemble de valeurs de restriction pour le schéma demandé.</param>
        <summary>Retourne des informations de schéma pour la source de données de ce <see cref="T:System.Data.SqlClient.SqlConnection" /> à l'aide de la chaîne spécifiée pour le nom de schéma et du tableau de chaînes spécifié pour les valeurs de restriction.</summary>
        <returns>
          <see cref="T:System.Data.DataTable" /> qui contient les informations de schéma.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `restrictionValues` paramètre peut fournir *n* valeurs de profondeur, qui sont spécifiées par la collection de restrictions pour un regroupement spécifique. Pour définir les valeurs d’une restriction donnée et pas définir les valeurs d’autres restrictions, vous devez définir les restrictions précédentes `null` , puis entrer la valeur appropriée pour la restriction que vous souhaitez spécifier une valeur pour.  
  
 Un exemple de ceci est la collection de « Tables ». Si la collection « Tables » a trois restrictions--de base de données, de propriétaire, et--nom de la table et que vous souhaitez récupérer uniquement les tables associées au propriétaire « Carl », vous devez passer les valeurs suivantes : null, « Carl ». Si une valeur de restriction n’est pas passée, les valeurs par défaut sont utilisés pour cette restriction. C’est le même mappage que le passage `null`, ce qui est différent du passage d’une chaîne vide pour la valeur du paramètre. Dans ce cas, la chaîne vide (" ») est considéré comme étant la valeur du paramètre spécifié.  
  
 Pour un exemple de code illustrant <xref:System.Data.SqlClient.SqlConnection.GetSchema%2A>, consultez <xref:System.Data.SqlClient.SqlConnection.GetSchema%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionName" /> est spécifié comme étant Null.</exception>
        <altmember cref="M:System.Data.SqlClient.SqlConnection.GetSchema" />
      </Docs>
    </Member>
    <Member MemberName="InfoMessage">
      <MemberSignature Language="C#" Value="public event System.Data.SqlClient.SqlInfoMessageEventHandler InfoMessage;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.SqlClient.SqlInfoMessageEventHandler InfoMessage" />
      <MemberSignature Language="DocId" Value="E:System.Data.SqlClient.SqlConnection.InfoMessage" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InfoMessage As SqlInfoMessageEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::SqlClient::SqlInfoMessageEventHandler ^ InfoMessage;" />
      <MemberSignature Language="F#" Value="member this.InfoMessage : System.Data.SqlClient.SqlInfoMessageEventHandler " Usage="member this.InfoMessage : System.Data.SqlClient.SqlInfoMessageEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlInfoMessageEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand SQL Server retourne un message d’avertissement ou d’information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les clients qui souhaitent traiter les avertissements ou messages d’information envoyés par le serveur doivent créer un <xref:System.Data.SqlClient.SqlInfoMessageEventHandler> délégué à l’écoute à cet événement.  
  
 Le <xref:System.Data.SqlClient.SqlConnection.InfoMessage> événement se produit lorsqu’un message avec un niveau de gravité de 10 ou moins est retourné par SQL Server. Les messages qui ont un niveau de gravité compris entre 11 et 20 déclenchent une erreur et les messages ayant un niveau de gravité supérieur à 20 provoquent la fermeture de la connexion. Pour plus d’informations sur les niveaux d’erreur SQL Server, consultez « Gravité des erreurs du moteur de base de données » dans la documentation en ligne de SQL Server.  
  
 Pour plus d’informations et un exemple, consultez [les événements de connexion](~/docs/framework/data/adonet/connection-events.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public override void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.Open" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Open();" />
      <MemberSignature Language="F#" Value="override this.Open : unit -&gt; unit" Usage="sqlConnection.Open " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.Open</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ouvre une connexion de base de données avec les paramètres de propriété spécifiés par le <see cref="P:System.Data.SqlClient.SqlConnection.ConnectionString" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.SqlClient.SqlConnection> établit une connexion ouverte à partir du pool de connexion si celle-ci est disponible. Sinon, il établit une nouvelle connexion à une instance de SQL Server.  
  
> [!NOTE]
>  Si le <xref:System.Data.SqlClient.SqlConnection> est hors de portée, il n’est pas fermé. Par conséquent, vous devez fermer explicitement la connexion en appelant <xref:System.Data.SqlClient.SqlConnection.Close%2A>.  
  
> [!NOTE]
>  Si vous spécifiez un numéro de port autre que 1433 lorsque vous essayez de vous connecter à une instance de SQL Server et à l’aide d’un protocole autre que TCP/IP, le <xref:System.Data.SqlClient.SqlConnection.Open%2A> méthode échoue. Pour spécifier un numéro de port autre que 1433, incluez « server = machinename, numéro de port » dans la chaîne de connexion, utilisez le protocole TCP/IP.  
  
> [!NOTE]
>  Le fournisseur de données .NET Framework pour SQL Server requiert l’autorisation de sécurité avec « Permet aux appels aux assemblys non gérés » activée (<xref:System.Security.Permissions.SecurityPermission> avec <xref:System.Security.Permissions.SecurityPermissionFlag> définie sur `UnmanagedCode`) pour ouvrir un <xref:System.Data.SqlClient.SqlConnection> avec SQL Debugging activé.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection>, il ouvre et affiche certaines de ses propriétés. La connexion est fermée automatiquement à la fin de la `using` bloc.  
  
 [!code-csharp[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossible d’ouvrir une connexion sans spécifier un serveur ou une source de données.  ou La connexion est déjà ouverte.</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">Une erreur de connexion s’est produite lors de l’ouverture de la connexion. Si la propriété <see cref="P:System.Data.SqlClient.SqlException.Number" /> contient la valeur 18487 ou 18488, cela indique que le mot de passe spécifié a expiré ou doit être réinitialisé. Pour plus d’informations, consultez la méthode <see cref="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)" />.  La balise <see langword="&lt;system.data.localdb&gt;" /> dans le fichier app.config comprend des éléments non valides ou inconnus.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Il existe deux entrées portant le même nom dans la section <see langword="&lt;localdbinstances&gt;" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task OpenAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task OpenAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ OpenAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.OpenAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sqlConnection.OpenAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Instruction d'annulation.</param>
        <summary>Version asynchrone de <see cref="M:System.Data.SqlClient.SqlConnection.Open" />, qui ouvre une connexion de base de données avec les paramètres de propriété spécifiés par <see cref="P:System.Data.SqlClient.SqlConnection.ConnectionString" />. Le jeton d'annulation peut être utilisé pour demander l'abandon de l'opération avant que le délai d'attente de connexion s'écoule.  Les exceptions seront propagées via la tâche retournée. Si le délai d’attente de connexion s’écoule sans connexion réussie, la tâche retournée est marquée comme défaillante avec une exception. L'implémentation retourne une tâche sans bloquer le thread appelant pour les connexions regroupées et non regroupées.</summary>
        <returns>Tâche représentant l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après avoir appelé <xref:System.Data.SqlClient.SqlConnection.OpenAsync%2A>, <xref:System.Data.SqlClient.SqlConnection.State%2A> doit retourner <xref:System.Data.ConnectionState.Connecting> jusqu'à retourné <xref:System.Threading.Tasks.Task> est terminée. Ensuite, si la connexion a réussi, <xref:System.Data.SqlClient.SqlConnection.State%2A> doit retourner <xref:System.Data.ConnectionState.Open>. Si la connexion échoue, <xref:System.Data.SqlClient.SqlConnection.State%2A> doit retourner <xref:System.Data.ConnectionState.Closed>.  
  
 Un appel à <xref:System.Data.SqlClient.SqlConnection.Close%2A> tente d’annuler ou fermer le correspondantes <xref:System.Data.SqlClient.SqlConnection.OpenAsync%2A> appeler.  
  
 Pour plus d’informations sur la programmation asynchrone dans le fournisseur de données .NET Framework pour SQL Server, consultez [programmation asynchrone](~/docs/framework/data/adonet/asynchronous-programming.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Appels multiples de <see cref="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" /> pour la même instance avant la fin de la tâche.  
  
 <see langword="Context Connection=true" /> est spécifié dans la chaîne de connexion.  Aucune connexion n’était disponible à partir du pool de connexions avant la fin du délai d’expiration de la connexion.</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">Toute erreur retournée par SQL Server qui s’est produite à l’ouverture de la connexion.</exception>
      </Docs>
    </Member>
    <Member MemberName="PacketSize">
      <MemberSignature Language="C#" Value="public int PacketSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PacketSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.PacketSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PacketSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PacketSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PacketSize : int" Usage="System.Data.SqlClient.SqlConnection.PacketSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille (en octets) des paquets réseau permettant de communiquer avec une instance de SQL Server.</summary>
        <value>Taille (en octets) des paquets réseau. La valeur par défaut est 8000.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une application effectue des opérations de copie en bloc, ou envoie ou reçoit de grandes quantités de données text ou image, une taille de paquet supérieure à la valeur par défaut peut améliorer les performances, car elle force le réseau moins lisent et écrivent des opérations. Si une application envoie et reçoit de petites quantités d’informations, vous pouvez définir la taille des paquets de 512 octets (à l’aide de la valeur de la taille du paquet dans la <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>), ce qui est suffisant pour la plupart des opérations de transfert de données. Pour la plupart des applications, la taille de paquet par défaut est préférable.  
  
 <xref:System.Data.SqlClient.SqlConnection.PacketSize%2A> peut être une valeur comprise entre 512 et 32 767 octets. Une exception est générée si la valeur est en dehors de cette plage.  
  
 La valeur par défaut à un nombre supérieure à 8000 entraîne les paquets utilisent l’allocateur MultiPage sur l’instance de SQL Server au lieu de l’allocateur SinglePage beaucoup plus efficace, ce qui réduit l’évolutivité globale de SQL Server. Pour plus d’informations sur l’utilisation de mémoire par SQL Server, consultez [Architecture de la mémoire](http://go.microsoft.com/fwlink/?LinkId=143705) dans la documentation en ligne de SQL Server.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection>, y compris le paramètre le `Packet Size` à 512 dans la chaîne de connexion. Il affiche le <xref:System.Data.SqlClient.SqlConnection.PacketSize%2A> et <xref:System.Data.SqlClient.SqlConnection.ServerVersion%2A> propriétés dans la fenêtre de console.  
  
 [!code-csharp[Classic WebData SqlConnection.PacketSize Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.PacketSize Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.PacketSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.PacketSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterColumnEncryptionKeyStoreProviders">
      <MemberSignature Language="C#" Value="public static void RegisterColumnEncryptionKeyStoreProviders (System.Collections.Generic.IDictionary&lt;string,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt; customProviders);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterColumnEncryptionKeyStoreProviders(class System.Collections.Generic.IDictionary`2&lt;string, class System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt; customProviders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterColumnEncryptionKeyStoreProviders (customProviders As IDictionary(Of String, SqlColumnEncryptionKeyStoreProvider))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterColumnEncryptionKeyStoreProviders(System::Collections::Generic::IDictionary&lt;System::String ^, System::Data::SqlClient::SqlColumnEncryptionKeyStoreProvider ^&gt; ^ customProviders);" />
      <MemberSignature Language="F#" Value="static member RegisterColumnEncryptionKeyStoreProviders : System.Collections.Generic.IDictionary&lt;string, System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt; -&gt; unit" Usage="System.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders customProviders" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customProviders" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt;" />
      </Parameters>
      <Docs>
        <param name="customProviders">Fournisseurs personnalisés</param>
        <summary>Inscrit les fournisseurs de magasin de clés de chiffrement de colonne.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetStatistics">
      <MemberSignature Language="C#" Value="public void ResetStatistics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetStatistics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ResetStatistics" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetStatistics ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetStatistics();" />
      <MemberSignature Language="F#" Value="member this.ResetStatistics : unit -&gt; unit" Usage="sqlConnection.ResetStatistics " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si le recueil de statistiques est activé, toutes les valeurs sont rétablies à zéro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la collecte de statistiques ne sont pas activé et que cette méthode est appelée, aucune erreur n’est levée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RetrieveStatistics">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary RetrieveStatistics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IDictionary RetrieveStatistics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.RetrieveStatistics" />
      <MemberSignature Language="VB.NET" Value="Public Function RetrieveStatistics () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IDictionary ^ RetrieveStatistics();" />
      <MemberSignature Language="F#" Value="member this.RetrieveStatistics : unit -&gt; System.Collections.IDictionary" Usage="sqlConnection.RetrieveStatistics " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une collection de statistiques de paires nom/valeur au moment où la méthode est appelée.</summary>
        <returns>Retourne une référence de type <see cref="T:System.Collections.IDictionary" /> des éléments <see cref="T:System.Collections.DictionaryEntry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est appelée, les valeurs récupérées sont celles au point actuel dans le temps. Si vous continuez à l’aide de la connexion, les valeurs sont incorrectes. Vous devez exécuter de nouveau la méthode pour obtenir les valeurs les plus récentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerVersion">
      <MemberSignature Language="C#" Value="public override string ServerVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServerVersion" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ServerVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ServerVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ServerVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVersion : string" Usage="System.Data.SqlClient.SqlConnection.ServerVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une chaîne comportant la version de l’instance de SQL Server à laquelle le client est connecté.</summary>
        <value>La version de l’instance de SQL Server.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La version est au format *##. ##. ###*, où les deux premiers chiffres sont la version principale, les deux chiffres suivants à la version secondaire, et les quatre derniers chiffres sont la version release. La chaîne est au format *major.minor.build*, où major et minor correspondent exactement deux chiffres et build est exactement quatre chiffres.  
  
 <xref:System.Data.SqlClient.SqlConnection.ServerVersion%2A> a été appelé alors que la tâche retournée n’était pas terminée et que la connexion n’a pas été ouverte après un appel à <xref:System.Data.SqlClient.SqlConnection.OpenAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et affiche le <xref:System.Data.SqlClient.SqlConnection.ServerVersion%2A> propriété.  
  
 [!code-csharp[Classic WebData ISqlConnection.ServerVersion Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData ISqlConnection.ServerVersion Example/CS/source.cs#1)]
 [!code-vb[Classic WebData ISqlConnection.ServerVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData ISqlConnection.ServerVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connexion est fermée.  
  
 <see cref="P:System.Data.SqlClient.SqlConnection.ServerVersion" /> a été appelé alors que la tâche retournée n’était pas terminée et que la connexion n’a pas été ouverte après un appel à <see cref="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public override System.Data.ConnectionState State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.ConnectionState State" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.State" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property State As ConnectionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::ConnectionState State { System::Data::ConnectionState get(); };" />
      <MemberSignature Language="F#" Value="member this.State : System.Data.ConnectionState" Usage="System.Data.SqlClient.SqlConnection.State" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.State</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConnectionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique l’état de <see cref="T:System.Data.SqlClient.SqlConnection" /> pendant la dernière opération réseau exécutée sur la connexion.</summary>
        <value>Énumération <see cref="T:System.Data.ConnectionState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourne un <xref:System.Data.ConnectionState> énumération indiquant l’état de la <xref:System.Data.SqlClient.SqlConnection>. Fermeture et réouverture de la connexion seront actualisée de la valeur de <xref:System.Data.SqlClient.SqlConnection.State%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChange">
      <MemberSignature Language="C#" Value="public event System.Data.StateChangeEventHandler StateChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.StateChangeEventHandler StateChange" />
      <MemberSignature Language="DocId" Value="E:System.Data.SqlClient.SqlConnection.StateChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChange As StateChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::StateChangeEventHandler ^ StateChange;" />
      <MemberSignature Language="F#" Value="member this.StateChange : System.Data.StateChangeEventHandler " Usage="member this.StateChange : System.Data.StateChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Data.DataSysDescription("DbConnection_StateChange")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.StateChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatisticsEnabled">
      <MemberSignature Language="C#" Value="public bool StatisticsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StatisticsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.StatisticsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property StatisticsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StatisticsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.StatisticsEnabled : bool with get, set" Usage="System.Data.SqlClient.SqlConnection.StatisticsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quand la valeur est <see langword="true" />, active la collecte de statistiques pour la connexion actuelle.</summary>
        <value>Retourne <see langword="true" /> si la collecte de statistiques est activée ; sinon, <see langword="false" />. <see langword="false" /> est la valeur par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’activation de collecte des statistiques a un effet mineur, mais mesurable sur les performances et doit donc être activé uniquement lorsque cela est nécessaire.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbConnection.BeginTransaction">
      <MemberSignature Language="C#" Value="System.Data.IDbTransaction IDbConnection.BeginTransaction ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Data.IDbTransaction System.Data.IDbConnection.BeginTransaction() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.System#Data#IDbConnection#BeginTransaction" />
      <MemberSignature Language="VB.NET" Value="Function BeginTransaction () As IDbTransaction Implements IDbConnection.BeginTransaction" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Data::IDbTransaction ^ System.Data.IDbConnection.BeginTransaction() = System::Data::IDbConnection::BeginTransaction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.BeginTransaction</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbTransaction</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbConnection.BeginTransaction">
      <MemberSignature Language="C#" Value="System.Data.IDbTransaction IDbConnection.BeginTransaction (System.Data.IsolationLevel iso);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Data.IDbTransaction System.Data.IDbConnection.BeginTransaction(valuetype System.Data.IsolationLevel iso) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.System#Data#IDbConnection#BeginTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="VB.NET" Value="Function BeginTransaction (iso As IsolationLevel) As IDbTransaction Implements IDbConnection.BeginTransaction" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Data::IDbTransaction ^ System.Data.IDbConnection.BeginTransaction(System::Data::IsolationLevel iso) = System::Data::IDbConnection::BeginTransaction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.BeginTransaction(System.Data.IsolationLevel)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iso" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="iso">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbConnection.CreateCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand IDbConnection.CreateCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Data.IDbCommand System.Data.IDbConnection.CreateCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.System#Data#IDbConnection#CreateCommand" />
      <MemberSignature Language="VB.NET" Value="Function CreateCommand () As IDbCommand Implements IDbConnection.CreateCommand" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Data::IDbCommand ^ System.Data.IDbConnection.CreateCommand() = System::Data::IDbConnection::CreateCommand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.CreateCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet qui est une copie de l'instance actuelle.</summary>
        <returns>Nouvel objet qui est une copie de cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.SqlClient.SqlConnection> est castée en interface <xref:System.ICloneable>.  
  
 Ce membre est uniquement pris en charge par le .NET Compact Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkstationId">
      <MemberSignature Language="C#" Value="public string WorkstationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WorkstationId" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.WorkstationId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkstationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WorkstationId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkstationId : string" Usage="System.Data.SqlClient.SqlConnection.WorkstationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une chaîne qui identifie le client de la base de données.</summary>
        <value>Chaîne qui identifie le client de la base de données. S'il n'est pas spécifié, nom de l'ordinateur client. Si aucun des deux n'est spécifié, la valeur est une chaîne vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, la chaîne contient le nom réseau du client. Le <xref:System.Data.SqlClient.SqlConnection.WorkstationId%2A> propriété correspond à la `Workstation ID` propriété chaîne de connexion.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.SqlClient.SqlConnection> et affiche le <xref:System.Data.SqlClient.SqlConnection.WorkstationId%2A> propriété.  
  
 [!code-csharp[Classic WebData SqlConnection.WorkstationId Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.WorkstationId Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.WorkstationId Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.WorkstationId Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>