<Namespace Name="System.Runtime.Remoting.Lifetime">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5ac8c7510ea8c5026f390f2936bebfb8b315c4f4" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/10/2018" />
    <Meta Name="ms.locfileid" Value="30735633" />
  </Metadata>
  <Docs>
    <summary>L'espace de noms <see cref="N:System.Runtime.Remoting.Lifetime" /> contient des classes qui gèrent la durée de vie d'objets existants.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, un garbage collection distribué utilise des décomptes de références et le test ping pour contrôler la durée de vie des objets. Cela fonctionne bien quand il existe quelques clients par service, mais n’évolue pas bien lorsqu’il existe des milliers de clients par service. Le service de durée de vie de la communication à distance associe un bail à chaque service et supprime un service à l’expiration du bail. Le service de durée de vie peut prendre la fonction d’un garbage collector distribué classique et s’adapte bien lorsque le nombre de clients par serveur augmente.  
  
 Chaque domaine d’application contient un gestionnaire de bail qui est chargé de contrôler les baux dans son domaine. Tous les baux sont examinés périodiquement pour des durées de bail expiré. Si un bail a expiré, un ou plusieurs des sponsors du bail sont appelés et la possibilité de renouveler le bail. Si aucun des commanditaires décide de renouveler le bail, le Gestionnaire de bail supprime le bail et l’objet peut être collecté par le garbage collector. Le Gestionnaire de bail gère une liste avec des baux, triées par durée de bail restante. Les baux avec le moins longtemps restant sont stockés en haut de la liste.  
  
 ]]></format>
    </remarks>
  </Docs>
</Namespace>