<Type Name="DataGridViewCell" FullName="System.Windows.Forms.DataGridViewCell">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f0967001138fb1d8578d7ebd3acfbd4fb661955a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30640943" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class DataGridViewCell : System.Windows.Forms.DataGridViewElement, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DataGridViewCell extends System.Windows.Forms.DataGridViewElement implements class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.DataGridViewCell" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DataGridViewCell&#xA;Inherits DataGridViewElement&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataGridViewCell abstract : System::Windows::Forms::DataGridViewElement, ICloneable, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.DataGridViewElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.DataGridViewCellConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une cellule dans un contrôle <see cref="T:System.Windows.Forms.DataGridView" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell> classe représente une cellule individuelle dans un <xref:System.Windows.Forms.DataGridView> contrôle. Vous pouvez récupérer des cellules via le <xref:System.Windows.Forms.DataGridViewRow.Cells%2A> collection d’un <xref:System.Windows.Forms.DataGridViewRow>.  
  
 La ligne et colonne pour un <xref:System.Windows.Forms.DataGridViewCell> identifier l’emplacement de la cellule dans le <xref:System.Windows.Forms.DataGridView>. Une cellule standard contient des données spécifiques à la ligne et colonne dans laquelle elle est contenue. La cellule peut être personnalisée de plusieurs façons en définissant ses propriétés et en gérant les événements associés.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce type. Pour plus d’informations sur cet exemple, consultez [Comment : ajouter des info-bulles à des cellules dans un contrôle Windows Forms DataGridView](~/docs/framework/winforms/controls/add-tooltips-to-individual-cells-in-a-wf-datagridview-control.md).  
  
 [!code-cpp[System.Windows.Forms.DataGridViewCell.ToolTipText#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCell.ToolTipText/cpp/datagridviewcell.tooltiptext.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataGridViewCell.ToolTipText#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCell.ToolTipText/CS/datagridviewcell.tooltiptext.cs#1)]
 [!code-vb[System.Windows.Forms.DataGridViewCell.ToolTipText#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCell.ToolTipText/VB/datagridviewcell.tooltiptext.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Lorsque vous dérivez de <see cref="T:System.Windows.Forms.DataGridViewCell" /> et ajoutez de nouvelles propriétés à la classe dérivée, veillez à substituer la <see cref="M:System.Windows.Forms.DataGridViewCell.Clone" /> méthode pour copier les nouvelles propriétés lors des opérations de clonage. Vous devez également appeler la classe de base <see cref="M:System.Windows.Forms.DataGridViewCell.Clone" /> méthode afin que les propriétés de la classe de base soient copiées dans la nouvelle cellule.</para>
    </block>
    <altmember cref="T:System.Windows.Forms.DataGridView" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IDisposable" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataGridViewCell ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataGridViewCell();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.DataGridViewCell" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Forms.DataGridViewCell.DataGridViewCellAccessibleObject" /> assigné à <see cref="T:System.Windows.Forms.DataGridViewCell" />.</summary>
        <value>
          <see cref="T:System.Windows.Forms.DataGridViewCell.DataGridViewCellAccessibleObject" /> assigné à <see cref="T:System.Windows.Forms.DataGridViewCell" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour contrôler l’instance retournée par cette méthode, substituez le <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> (méthode).  
  
 Si aucun <xref:System.Windows.Forms.AccessibleObject> n'est actuellement assigné au contrôle, une nouvelle instance est créée.  
  
> [!NOTE]
>  Pour obtenir ou définir le <xref:System.Windows.Forms.Control.AccessibilityObject%2A> propriété, vous devez ajouter une référence à la `Accessibility` assembly installé avec le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
 Pour plus d’informations sur les objets accessibles, consultez la section « Active Accessibility » de la bibliothèque MSDN à [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="AdjustCellBorderStyle">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DataGridViewAdvancedBorderStyle AdjustCellBorderStyle (System.Windows.Forms.DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStyleInput, System.Windows.Forms.DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStylePlaceholder, bool singleVerticalBorderAdded, bool singleHorizontalBorderAdded, bool isFirstDisplayedColumn, bool isFirstDisplayedRow);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.DataGridViewAdvancedBorderStyle AdjustCellBorderStyle(class System.Windows.Forms.DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStyleInput, class System.Windows.Forms.DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStylePlaceholder, bool singleVerticalBorderAdded, bool singleHorizontalBorderAdded, bool isFirstDisplayedColumn, bool isFirstDisplayedRow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.AdjustCellBorderStyle(System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AdjustCellBorderStyle (dataGridViewAdvancedBorderStyleInput As DataGridViewAdvancedBorderStyle, dataGridViewAdvancedBorderStylePlaceholder As DataGridViewAdvancedBorderStyle, singleVerticalBorderAdded As Boolean, singleHorizontalBorderAdded As Boolean, isFirstDisplayedColumn As Boolean, isFirstDisplayedRow As Boolean) As DataGridViewAdvancedBorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::DataGridViewAdvancedBorderStyle ^ AdjustCellBorderStyle(System::Windows::Forms::DataGridViewAdvancedBorderStyle ^ dataGridViewAdvancedBorderStyleInput, System::Windows::Forms::DataGridViewAdvancedBorderStyle ^ dataGridViewAdvancedBorderStylePlaceholder, bool singleVerticalBorderAdded, bool singleHorizontalBorderAdded, bool isFirstDisplayedColumn, bool isFirstDisplayedRow);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridViewAdvancedBorderStyle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataGridViewAdvancedBorderStyleInput" Type="System.Windows.Forms.DataGridViewAdvancedBorderStyle" />
        <Parameter Name="dataGridViewAdvancedBorderStylePlaceholder" Type="System.Windows.Forms.DataGridViewAdvancedBorderStyle" />
        <Parameter Name="singleVerticalBorderAdded" Type="System.Boolean" />
        <Parameter Name="singleHorizontalBorderAdded" Type="System.Boolean" />
        <Parameter Name="isFirstDisplayedColumn" Type="System.Boolean" />
        <Parameter Name="isFirstDisplayedRow" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataGridViewAdvancedBorderStyleInput">
          <see cref="T:System.Windows.Forms.DataGridViewAdvancedBorderStyle" /> qui représente le style de bordure de cellule à modifier.</param>
        <param name="dataGridViewAdvancedBorderStylePlaceholder">
          <see cref="T:System.Windows.Forms.DataGridViewAdvancedBorderStyle" /> qui est utilisé pour stocker les modifications intermédiaires apportées au style de bordure de cellule.</param>
        <param name="singleVerticalBorderAdded">
          <see langword="true" /> pour ajouter une bordure verticale à la cellule ; sinon, <see langword="false" />.</param>
        <param name="singleHorizontalBorderAdded">
          <see langword="true" /> pour ajouter une bordure horizontale à la cellule ; sinon, <see langword="false" />.</param>
        <param name="isFirstDisplayedColumn">
          <see langword="true" /> si la cellule d'hébergement figure dans la première colonne visible ; sinon, <see langword="false" />.</param>
        <param name="isFirstDisplayedRow">
          <see langword="true" /> si la cellule d'hébergement figure dans la première ligne visible ; sinon, <see langword="false" />.</param>
        <summary>Modifie le style de bordure de cellule d'entrée en fonction des critères spécifiés.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.DataGridViewAdvancedBorderStyle" /> modifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridView> contrôler l’appelle en interne la <xref:System.Windows.Forms.DataGridViewCell.AdjustCellBorderStyle%2A> méthode pour déterminer l’apparence des bordures des cellules. Le <xref:System.Windows.Forms.DataGridView> contrôle utilise généralement la valeur de la <xref:System.Windows.Forms.DataGridView.AdvancedCellBorderStyle%2A> propriété pour la `dataGridViewAdvancedBorderStyleInput` paramètre.  
  
 Le <xref:System.Windows.Forms.DataGridViewAdvancedCellBorderStyle.OutsetPartial?displayProperty=nameWithType> valeur n’est pas pris en charge comme style d’entrée pour les cellules.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la <xref:System.Windows.Forms.DataGridViewCell.AdjustCellBorderStyle%2A> méthode pour personnaliser les bordures des cellules. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Windows.Forms.DataGridViewAdvancedBorderStyle> classe.  
  
 [!code-csharp[System.Windows.Forms.DataGridViewAdvancedBorderStyle#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewAdvancedBorderStyle/CS/advancedborderstyle.cs#20)]
 [!code-vb[System.Windows.Forms.DataGridViewAdvancedBorderStyle#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewAdvancedBorderStyle/VB/advancedborderstyle.vb#20)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Substituez cette méthode si vous souhaitez personnaliser l’apparence des bordures des cellules.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.InheritedStyle" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.GetInheritedStyle(System.Windows.Forms.DataGridViewCellStyle,System.Int32,System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.HasStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Style" />
      </Docs>
    </Member>
    <Member MemberName="BorderWidths">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle BorderWidths (System.Windows.Forms.DataGridViewAdvancedBorderStyle advancedBorderStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle BorderWidths(class System.Windows.Forms.DataGridViewAdvancedBorderStyle advancedBorderStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.BorderWidths(System.Windows.Forms.DataGridViewAdvancedBorderStyle)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BorderWidths (advancedBorderStyle As DataGridViewAdvancedBorderStyle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle BorderWidths(System::Windows::Forms::DataGridViewAdvancedBorderStyle ^ advancedBorderStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="advancedBorderStyle" Type="System.Windows.Forms.DataGridViewAdvancedBorderStyle" />
      </Parameters>
      <Docs>
        <param name="advancedBorderStyle">
          <see cref="T:System.Windows.Forms.DataGridViewAdvancedBorderStyle" /> dont les marges doivent être calculées.</param>
        <summary>Retourne <see cref="T:System.Drawing.Rectangle" /> qui représente les largeurs de toutes les marges de cellule.</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" /> qui représente les largeurs de toutes les marges de cellule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La largeur de la bordure de cellule par défaut est un pixel. Utilisez ce qui suit <xref:System.Windows.Forms.DataGridViewAdvancedCellBorderStyle> valeurs pour modifier la largeur de la bordure :  
  
-   Le <xref:System.Windows.Forms.DataGridViewAdvancedCellBorderStyle.None> valeur indique une largeur de 0 pixel.  
  
-   Le <xref:System.Windows.Forms.DataGridViewAdvancedCellBorderStyle.OutsetDouble> ou <xref:System.Windows.Forms.DataGridViewAdvancedCellBorderStyle.InsetDouble> valeurs augmentent la largeur par défaut de 1 pixel.  
  
 En outre, si le <xref:System.Windows.Forms.DataGridViewRow.DividerHeight%2A> est définie pour la cellule propriétaire de la ligne, la hauteur du rectangle est augmentée par la valeur de <xref:System.Windows.Forms.DataGridViewRow.DividerHeight%2A>. Si le <xref:System.Windows.Forms.DataGridViewColumn.DividerWidth%2A> est définie pour la cellule propriétaire de la colonne, augmente la largeur du rectangle de la valeur de <xref:System.Windows.Forms.DataGridViewColumn.DividerWidth%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.DataGridViewCell.BorderWidths%2A> méthode de la <xref:System.Windows.Forms.DataGridViewCell> classe pour déterminer la zone de dessin disponible dans une cellule. Cet exemple de code fait partie d’un exemple plus complet fourni dans [Comment : désactiver les boutons d’une colonne de bouton dans le contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/disable-buttons-in-a-button-column-in-the-datagrid.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridView.DisabledButtons#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.DisabledButtons/CS/form1.cs#20)]
 [!code-vb[System.Windows.Forms.DataGridView.DisabledButtons#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.DisabledButtons/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellBorderStyle" />
        <altmember cref="T:System.Windows.Forms.DataGridViewAdvancedCellBorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="ClickUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool ClickUnsharesRow (System.Windows.Forms.DataGridViewCellEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ClickUnsharesRow(class System.Windows.Forms.DataGridViewCellEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.ClickUnsharesRow(System.Windows.Forms.DataGridViewCellEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ClickUnsharesRow (e As DataGridViewCellEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ClickUnsharesRow(System::Windows::Forms::DataGridViewCellEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellEventArgs" /> qui contient les données passées à la méthode <see cref="M:System.Windows.Forms.DataGridViewCell.OnClick(System.Windows.Forms.DataGridViewCellEventArgs)" />.</param>
        <summary>Indique si la ligne de la cellule est partagée ou non lorsque l'utilisateur clique sur la cellule.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.ClickUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnClick%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnClick%2A> a pour effet de l’annulation du partage de la ligne de la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie exacte de cette cellule.</summary>
        <returns>
          <see cref="T:System.Object" /> qui représente le <see cref="T:System.Windows.Forms.DataGridViewCell" /> cloné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Remplacer la <xref:System.Windows.Forms.DataGridViewCell.Clone%2A> méthode chaque fois que vous dérivez de la <xref:System.Windows.Forms.DataGridViewCell> classe et ajoutez de nouvelles propriétés à la classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution du <see cref="M:System.Windows.Forms.DataGridViewCell.Clone" /> méthode dans une classe dérivée, appelle la classe de base <see cref="M:System.Windows.Forms.DataGridViewCell.Clone" /> méthode afin que les propriétés de la classe de base sont copiées vers la nouvelle cellule et veillez à également copier les valeurs de toutes les propriétés qui ont été ajoutées à la classe dérivée.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="ColumnIndex">
      <MemberSignature Language="C#" Value="public int ColumnIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ColumnIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ColumnIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ColumnIndex { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'index de colonne pour cette cellule.</summary>
        <value>Index de la colonne qui contient la cellule ; -1 si la cellule n'est pas contenue dans une colonne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index de colonne pour la ligne qui contient les en-têtes de ligne a la valeur -1.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.DataGridViewCell.ColumnIndex%2A> propriété pour déterminer les colonnes à rechercher des valeurs entières. Dans cet exemple, les cellules de la `Description` colonne sont ignorés lorsque le contenu des cellules sélectionnées est additionné. Cet exemple fait partie d’un exemple plus complet disponible dans le <xref:System.Windows.Forms.DataGridView.SelectionChanged?displayProperty=nameWithType> événement.  
  
 [!code-csharp[System.Windows.Forms.DataGridViewSelectionSum#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewSelectionSum/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.DataGridViewSelectionSum#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewSelectionSum/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.RowIndex" />
      </Docs>
    </Member>
    <Member MemberName="ContentBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ContentBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ContentBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.ContentBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ContentBounds { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le rectangle englobant qui définit la zone de contenu de la cellule.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> qui englobe le contenu de la cellule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le rectangle retourné indique les coordonnées clientes, en pixels.  
  
 Cette propriété appelle la <xref:System.Windows.Forms.DataGridViewCell.GetContentBounds%2A> méthode à obtenir sa valeur. Pour la base de <xref:System.Windows.Forms.DataGridViewCell> type, cette valeur est <xref:System.Drawing.Rectangle.Empty>.  
  
 Pour obtenir le rectangle englobant de la cellule plutôt que le contenu des cellules, utilisez le <xref:System.Windows.Forms.DataGridView.GetCellDisplayRectangle%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La ligne qui contient la cellule est une ligne partagée.  
  
 - ou -  
  
 La cellule est une cellule d'en-tête de colonne.</exception>
        <exception cref="T:System.InvalidOperationException">La valeur de la propriété <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieure à 0, pour indiquer que la cellule est une cellule d'en-tête de ligne.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.GetCellDisplayRectangle(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.GetContentBounds(System.Drawing.Graphics,System.Windows.Forms.DataGridViewCellStyle,System.Int32)" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Size" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.PreferredSize" />
        <altmember cref="F:System.Drawing.Rectangle.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ContentClickUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool ContentClickUnsharesRow (System.Windows.Forms.DataGridViewCellEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ContentClickUnsharesRow(class System.Windows.Forms.DataGridViewCellEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.ContentClickUnsharesRow(System.Windows.Forms.DataGridViewCellEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ContentClickUnsharesRow (e As DataGridViewCellEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ContentClickUnsharesRow(System::Windows::Forms::DataGridViewCellEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellEventArgs" /> qui contient les données passées à la méthode <see cref="M:System.Windows.Forms.DataGridViewCell.OnContentClick(System.Windows.Forms.DataGridViewCellEventArgs)" />.</param>
        <summary>Indique si la ligne de la cellule est partagée ou non lorsque l'utilisateur clique sur le contenu de la cellule.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.ContentClickUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnContentClick%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnContentClick%2A> a pour effet de l’annulation du partage de la ligne de la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnContentClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ContentDoubleClickUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool ContentDoubleClickUnsharesRow (System.Windows.Forms.DataGridViewCellEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ContentDoubleClickUnsharesRow(class System.Windows.Forms.DataGridViewCellEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.ContentDoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ContentDoubleClickUnsharesRow (e As DataGridViewCellEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ContentDoubleClickUnsharesRow(System::Windows::Forms::DataGridViewCellEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellEventArgs" /> qui contient les données passées à la méthode <see cref="M:System.Windows.Forms.DataGridViewCell.OnContentDoubleClick(System.Windows.Forms.DataGridViewCellEventArgs)" />.</param>
        <summary>Indique si la ligne de la cellule est partagée ou non lorsque l'utilisateur double-clique sur le contenu de la cellule.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.ContentDoubleClickUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnContentDoubleClick%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnContentDoubleClick%2A> a pour effet de l’annulation du partage de la ligne de la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnContentDoubleClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le menu contextuel associé à la cellule.</summary>
        <value>
          <see cref="T:System.Windows.Forms.ContextMenuStrip" /> associé à la cellule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété indique le menu contextuel qui s’affiche généralement lorsque l’utilisateur clique sur la cellule.  
  
 Lorsque le <xref:System.Windows.Forms.DataGridView> contrôle <xref:System.Windows.Forms.DataGridView.DataSource%2A> est définie ou son <xref:System.Windows.Forms.DataGridView.VirtualMode%2A> propriété est `true`, obtention de la valeur de la <xref:System.Windows.Forms.DataGridViewCell.ContextMenuStrip%2A> propriété déclenche le <xref:System.Windows.Forms.DataGridView.CellContextMenuStripNeeded> événement du contrôle et retourne la valeur de la <xref:System.Windows.Forms.DataGridViewCellContextMenuStripNeededEventArgs.ContextMenuStrip%2A?displayProperty=nameWithType> la propriété spécifiée dans l’événement gestionnaire. S’il n’y a aucun gestionnaire pour l’événement, obtenir la valeur de la <xref:System.Windows.Forms.DataGridViewCell.ContextMenuStrip%2A> propriété retourne la valeur précédemment spécifiée ou sa valeur par défaut `null`.  
  
 Gère la <xref:System.Windows.Forms.DataGridView.CellContextMenuStripNeeded> événement est particulièrement utile lorsque vous travaillez avec de grandes quantités de données pour éviter de trop handicaper les performances lors de la définition de la cellule <xref:System.Windows.Forms.DataGridViewCell.ContextMenuStrip%2A> valeur pour plusieurs cellules. Pour plus d’informations, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 La modification de cette propriété déclenche le <xref:System.Windows.Forms.DataGridView.CellContextMenuStripChanged> événement sur le propriétaire <xref:System.Windows.Forms.DataGridView>, s’il en existe.  
  
 Vous pouvez également spécifier des menus contextuels pour des lignes plutôt que des cellules en définissant la ligne <xref:System.Windows.Forms.DataGridViewRow.ContextMenuStrip%2A> propriété ni aucune gestion la <xref:System.Windows.Forms.DataGridView> du contrôle <xref:System.Windows.Forms.DataGridView.RowContextMenuStripNeeded> événement. La cellule <xref:System.Windows.Forms.DataGridViewCell.ContextMenuStrip%2A> paramètre de propriété substitue à la ligne <xref:System.Windows.Forms.DataGridViewRow.ContextMenuStrip%2A> paramètre de propriété et le <xref:System.Windows.Forms.DataGridView.CellContextMenuStripNeeded> remplacements d’événements à la fois le <xref:System.Windows.Forms.DataGridView.RowContextMenuStripNeeded> événement et la ligne <xref:System.Windows.Forms.DataGridViewRow.ContextMenuStrip%2A> paramètre de propriété. Vous pouvez spécifier `null` pour un menu contextuel cellule, toutefois, pour empêcher le remplacement un menu contextuel de ligne.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellContextMenuStripChanged" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellContextMenuStripNeeded" />
        <altmember cref="P:System.Windows.Forms.DataGridView.DataSource" />
        <altmember cref="P:System.Windows.Forms.DataGridView.VirtualMode" />
        <altmember cref="E:System.Windows.Forms.DataGridView.RowContextMenuStripNeeded" />
        <altmember cref="P:System.Windows.Forms.DataGridViewRow.ContextMenuStrip" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.GetInheritedContextMenuStrip(System.Int32)" />
        <altmember cref="T:System.Windows.Forms.ContextMenuStrip" />
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet accessible pour le <see cref="T:System.Windows.Forms.DataGridViewCell" />.</summary>
        <returns>Nouveau <see cref="T:System.Windows.Forms.DataGridViewCell.DataGridViewCellAccessibleObject" /> pour le <see cref="T:System.Windows.Forms.DataGridViewCell" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n'avez pas explicitement appelé la méthode <xref:System.Windows.Forms.DataGridViewCell.CreateAccessibilityInstance%2A>, elle sera appelée lorsque la propriété <xref:System.Windows.Forms.DataGridViewCell.AccessibilityObject%2A> sera référencée.  
  
> [!NOTE]
>  Pour obtenir ou définir <xref:System.Windows.Forms.DataGridViewCell.AccessibilityObject%2A>, vous devez ajouter une référence à la `Accessibility` assembly installé avec le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCell.DataGridViewCellAccessibleObject" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.AccessibilityObject" />
        <altmember cref="N:Accessibility" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNewRowValue">
      <MemberSignature Language="C#" Value="public virtual object DefaultNewRowValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultNewRowValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.DefaultNewRowValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefaultNewRowValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ DefaultNewRowValue { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur par défaut d'une cellule contenue dans la ligne des nouveaux enregistrements.</summary>
        <value>
          <see cref="T:System.Object" /> représentant la valeur par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.DefaultNewRowValue%2A> propriété dans la classe de base <xref:System.Windows.Forms.DataGridViewCell> retourne toujours `null`. Toutefois, cette propriété peut être substituée dans les classes dérivées de cellule pour retourner les autres valeurs par défaut.  
  
 La valeur retournée par cette propriété s’affiche si la cellule est dans la ligne pour les nouveaux enregistrements. Cette valeur peut être remplacée par un gestionnaire pour le <xref:System.Windows.Forms.DataGridView.DefaultValuesNeeded?displayProperty=nameWithType> événement lorsque le focus passe à la ligne pour les nouveaux enregistrements.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la <xref:System.Windows.Forms.DataGridViewCell.DefaultNewRowValue%2A> propriété dans un `CalendarCell` classe qui dérive de <xref:System.Windows.Forms.DataGridViewTextBoxCell>. Cet exemple fait partie d’un exemple de code plus complet fourni dans [Comment : héberger des contrôles dans les cellules DataGridView Windows Forms](~/docs/framework/winforms/controls/how-to-host-controls-in-windows-forms-datagridview-cells.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewCalendarColumn#200](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/CS/datagridviewcalendarcolumn.cs#200)]
 [!code-vb[System.Windows.Forms.DataGridViewCalendarColumn#200](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/VB/datagridviewcalendarcolumn.vb#200)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Value" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.FormattedValue" />
      </Docs>
    </Member>
    <Member MemberName="DetachEditingControl">
      <MemberSignature Language="C#" Value="public virtual void DetachEditingControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DetachEditingControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.DetachEditingControl" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DetachEditingControl ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DetachEditingControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime le contrôle d’édition de la cellule de <see cref="T:System.Windows.Forms.DataGridView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridView> appelle cette méthode lorsque la cellule active héberge un contrôle d’édition et le mode édition prend fin. Cette méthode supprime le <xref:System.Windows.Forms.DataGridView.EditingControl%2A> à partir de la <xref:System.Windows.Forms.DataGridView.EditingPanel%2A>, puis supprime le <xref:System.Windows.Forms.DataGridView.EditingPanel%2A> à partir de la <xref:System.Windows.Forms.Control.Controls%2A> collection de la <xref:System.Windows.Forms.DataGridView>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette cellule n'est pas associée à <see cref="T:System.Windows.Forms.DataGridView" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Windows.Forms.DataGridView.EditingControl" /> du <see cref="T:System.Windows.Forms.DataGridView" /> associé a la valeur <see langword="null" />. C'est le cas, par exemple, lorsque le contrôle n'est pas en mode édition.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridView.EditingControl" />
        <altmember cref="P:System.Windows.Forms.DataGridView.EditingPanel" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.InitializeEditingControl(System.Int32,System.Object,System.Windows.Forms.DataGridViewCellStyle)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.PositionEditingControl(System.Boolean,System.Boolean,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Windows.Forms.DataGridViewCellStyle,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.EditType" />
      </Docs>
    </Member>
    <Member MemberName="Displayed">
      <MemberSignature Language="C#" Value="public virtual bool Displayed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Displayed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.Displayed" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Displayed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Displayed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la cellule est actuellement affichée à l’écran.</summary>
        <value>
          <see langword="true" /> si la cellule est affichée intégralement ou partiellement à l’écran ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour déterminer si une cellule spécifique a été atteint hors écran.  
  
 Si la cellule <xref:System.Windows.Forms.DataGridViewCell.Visible%2A> valeur de propriété est `false`, cette propriété retourne `false` également.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Visible" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par le <see cref="T:System.Windows.Forms.DataGridViewCell" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Windows.Forms.DataGridViewCell" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode <xref:System.Windows.Forms.DataGridViewCell.Dispose%2A> une fois que vous avez terminé d'utiliser <xref:System.Windows.Forms.DataGridViewCell>. La méthode <xref:System.Windows.Forms.DataGridViewCell.Dispose%2A> rend le <xref:System.Windows.Forms.DataGridViewCell> inutilisable. Après avoir appelé <xref:System.Windows.Forms.DataGridViewCell.Dispose%2A>, vous devez libérer toutes les références à la <xref:System.Windows.Forms.DataGridViewCell> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Windows.Forms.DataGridViewCell> occupée. Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours <xref:System.Windows.Forms.DataGridViewCell.Dispose%2A> avant de libérer votre dernière référence à <xref:System.Windows.Forms.DataGridViewCell>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Windows.Forms.DataGridViewCell> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Windows.Forms.DataGridViewCell" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose` appelle la méthode protégée `Dispose(Boolean)` méthode avec la `disposing` paramètre la valeur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` la valeur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Windows.Forms.DataGridViewCell>. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see langword="Dispose(Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClickUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleClickUnsharesRow (System.Windows.Forms.DataGridViewCellEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool DoubleClickUnsharesRow(class System.Windows.Forms.DataGridViewCellEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.DoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DoubleClickUnsharesRow (e As DataGridViewCellEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool DoubleClickUnsharesRow(System::Windows::Forms::DataGridViewCellEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellEventArgs" /> qui contient les données passées à la méthode <see cref="M:System.Windows.Forms.DataGridViewCell.OnDoubleClick(System.Windows.Forms.DataGridViewCellEventArgs)" />.</param>
        <summary>Indique si la ligne de la cellule est partagée ou non lorsque l'utilisateur double-clique sur la cellule.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.DoubleClickUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnDoubleClick%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnDoubleClick%2A> a pour effet de l’annulation du partage de la ligne de la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnDoubleClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="EditedFormattedValue">
      <MemberSignature Language="C#" Value="public object EditedFormattedValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object EditedFormattedValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.EditedFormattedValue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditedFormattedValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ EditedFormattedValue { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur actuelle mise en forme de la cellule, que la cellule soit en mode édition ou non et que la valeur ait été validée ou non.</summary>
        <value>Valeur actuelle mise en forme de <see cref="T:System.Windows.Forms.DataGridViewCell" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur actuelle de la cellule ou de contrôle d’édition si la cellule est en mode édition. Sinon, la mise en route de la valeur de cette propriété convertit la valeur de cellule en une valeur d’affichage équivalente du type indiqué par la <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> propriété. Cela déclenche la <xref:System.Windows.Forms.DataGridView.CellFormatting?displayProperty=nameWithType> événement que vous pouvez gérer pour personnaliser la conversion de valeur.  
  
 Si la mise en forme échoue, le <xref:System.Windows.Forms.DataGridView.DataError?displayProperty=nameWithType> événement se produit. S’il n’existe aucun gestionnaire pour cet événement ou le gestionnaire affecte la <xref:System.Windows.Forms.DataGridViewDataErrorEventArgs.ThrowException%2A?displayProperty=nameWithType> propriété `true`, une exception est levée.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.DataGridViewCell.EditedFormattedValue%2A> propriété. Dans cet exemple, le <xref:System.Windows.Forms.DataGridView.IsCurrentCellDirty%2A> propriété est utilisée pour déterminer si contenu de la cellule en cours ont été modifié et non validé et, si la cellule a été modifiée, la valeur modifiée est utilisée. Cet exemple fait partie d’un exemple plus complet disponible dans le <xref:System.Windows.Forms.DataGridView.SelectionChanged?displayProperty=nameWithType> événement.  
  
 [!code-csharp[System.Windows.Forms.DataGridViewSelectionSum#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewSelectionSum/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.DataGridViewSelectionSum#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewSelectionSum/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La ligne qui contient la cellule est une ligne partagée.  
  
 - ou -  
  
 La cellule est une cellule d'en-tête de colonne.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <exception cref="T:System.Exception">La mise en forme a échoué et soit il n'y a aucun gestionnaire pour l'événement <see cref="E:System.Windows.Forms.DataGridView.DataError" /> du contrôle <see cref="T:System.Windows.Forms.DataGridView" />, soit le gestionnaire a affecté <see langword="true" /> à la propriété <see cref="P:System.Windows.Forms.DataGridViewDataErrorEventArgs.ThrowException" />. L’objet exception peut généralement être converti en type <see cref="T:System.FormatException" />.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="EditType">
      <MemberSignature Language="C#" Value="public virtual Type EditType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type EditType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.EditType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EditType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ EditType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type du contrôle d'édition hébergé de la cellule.</summary>
        <value>
          <see cref="T:System.Type" /> représentant le type <see cref="T:System.Windows.Forms.DataGridViewTextBoxEditingControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un type de cellule dérivée substitue cette propriété pour retourner le type de son contrôle d’édition hébergé. Si la cellule n’a pas de contrôle d’édition, comme avec <xref:System.Windows.Forms.DataGridViewButtonCell>, le <xref:System.Windows.Forms.DataGridViewCell.EditType%2A> propriété renvoie `null`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la <xref:System.Windows.Forms.DataGridViewCell.EditType%2A> propriété dans un `CalendarCell` classe qui dérive de <xref:System.Windows.Forms.DataGridViewTextBoxCell>. Cet exemple fait partie d’un exemple de code plus complet fourni dans [Comment : héberger des contrôles dans les cellules DataGridView Windows Forms](~/docs/framework/winforms/controls/how-to-host-controls-in-windows-forms-datagridview-cells.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewCalendarColumn#200](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/CS/datagridviewcalendarcolumn.cs#200)]
 [!code-vb[System.Windows.Forms.DataGridViewCalendarColumn#200](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/VB/datagridviewcalendarcolumn.vb#200)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.IDataGridViewEditingControl" />
        <altmember cref="T:System.Windows.Forms.DataGridViewButtonCell" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.FormattedValueType" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.EditType" />
      </Docs>
    </Member>
    <Member MemberName="EnterUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool EnterUnsharesRow (int rowIndex, bool throughMouseClick);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool EnterUnsharesRow(int32 rowIndex, bool throughMouseClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.EnterUnsharesRow(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EnterUnsharesRow (rowIndex As Integer, throughMouseClick As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool EnterUnsharesRow(int rowIndex, bool throughMouseClick);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="throughMouseClick" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <param name="throughMouseClick">
          <see langword="true" /> si une intervention de l'utilisateur a déplacé le focus vers la cellule ; <see langword="false" /> si une opération de programmation a déplacé le focus vers la cellule.</param>
        <summary>Indique si la ligne parente est partagée ou non lorsque le focus est déplacé vers la cellule.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.EnterUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnEnter%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnEnter%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnEnter(System.Int32,System.Boolean)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnLeave(System.Int32,System.Boolean)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseEnterUnsharesRow(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorIconBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ErrorIconBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ErrorIconBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.ErrorIconBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorIconBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ErrorIconBounds { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les limites de l'icône d'erreur pour la cellule.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> qui représente les limites de l'icône d'erreur pour le <see cref="T:System.Windows.Forms.DataGridViewCell" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le rectangle retourné indique les coordonnées clientes, en pixels.  
  
 Lorsque le <xref:System.Windows.Forms.DataGridView.ShowCellErrors%2A?displayProperty=nameWithType> propriété `false`, la valeur de cette propriété est <xref:System.Drawing.Rectangle.Empty>.  
  
 Cette propriété appelle la <xref:System.Windows.Forms.DataGridViewCell.GetErrorIconBounds%2A> méthode à obtenir sa valeur. Pour la base de <xref:System.Windows.Forms.DataGridViewCell> type, cette valeur est toujours <xref:System.Drawing.Rectangle.Empty>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cellule n'appartient pas au contrôle <see cref="T:System.Windows.Forms.DataGridView" />.  
  
 - ou -  
  
 <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La ligne qui contient la cellule est une ligne partagée.  
  
 - ou -  
  
 La cellule est une cellule d'en-tête de colonne.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.GetErrorIconBounds(System.Drawing.Graphics,System.Windows.Forms.DataGridViewCellStyle,System.Int32)" />
        <altmember cref="T:System.Drawing.Rectangle" />
      </Docs>
    </Member>
    <Member MemberName="ErrorText">
      <MemberSignature Language="C#" Value="public string ErrorText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.ErrorText" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte qui décrit une condition d'erreur associée à la cellule.</summary>
        <value>Texte qui décrit une condition d'erreur associée à la cellule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, les <xref:System.Windows.Forms.DataGridViewCell.ErrorText%2A> propriété est utilisée lors du traitement de la <xref:System.Windows.Forms.DataGridView.CellValidating> l’événement de la <xref:System.Windows.Forms.DataGridView>. Si la valeur de cellule échoue à certains critères de validation, définissez la <xref:System.Windows.Forms.DataGridViewCell.ErrorText%2A> propriété et annuler l’opération de validation en définissant le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.Windows.Forms.DataGridViewCellValidatingEventArgs> à `true`. Le texte que vous spécifiez est ensuite affiché par le <xref:System.Windows.Forms.DataGridView>, et l’utilisateur est invité à corriger l’erreur dans les données de cellule.  
  
 Lorsque le <xref:System.Windows.Forms.DataGridView.VirtualMode%2A> propriété de la <xref:System.Windows.Forms.DataGridView> est `true`, vous pouvez fournir le texte d’erreur pour les lignes et cellules à l’aide de la <xref:System.Windows.Forms.DataGridView.RowErrorTextNeeded> et <xref:System.Windows.Forms.DataGridView.CellErrorTextNeeded> événements.  
  
 Lorsque vous affectez une autre <xref:System.Windows.Forms.DataGridViewCell.ErrorText%2A> chaîne à une cellule, la <xref:System.Windows.Forms.DataGridView.CellErrorTextChanged> l’événement de la <xref:System.Windows.Forms.DataGridView> contrôle est déclenché.  
  
 À compter de .NET Framework 4.5.2, redimensionnement de l’icône d’erreur est déterminée par le paramètre PPP système lorsque le fichier app.config contient l’entrée suivante :  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
```  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser cette propriété lors de la gestion des conditions d’erreur dans un indépendant <xref:System.Windows.Forms.DataGridView>. Le `AnnotateCell` méthode définit une chaîne de message d’erreur le <xref:System.Windows.Forms.DataGridViewCell.ErrorText%2A> propriété.  
  
 [!code-cpp[System.Windows.Forms.GridViewUnbound#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.GridViewUnbound/CPP/form1.cpp#9)]
 [!code-csharp[System.Windows.Forms.GridViewUnbound#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.GridViewUnbound/CS/form1.cs#9)]
 [!code-vb[System.Windows.Forms.GridViewUnbound#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.GridViewUnbound/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellValidatingEventArgs" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellValidating" />
        <altmember cref="P:System.Windows.Forms.DataGridView.VirtualMode" />
        <altmember cref="E:System.Windows.Forms.DataGridView.RowErrorTextNeeded" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellErrorTextNeeded" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellErrorTextChanged" />
        <altmember cref="P:System.ComponentModel.CancelEventArgs.Cancel" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~DataGridViewCell ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!DataGridViewCell ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources non managées et effectue d'autres opérations de nettoyage avant que <see cref="T:System.Windows.Forms.DataGridViewCell" /> ne soit récupéré par l'opération garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle la <xref:System.Windows.Forms.DataGridViewCell.Dispose%2A> méthode avec `false` en tant que paramètre.  
  
 Cette méthode se substitue à <xref:System.Object.Finalize%2A>. Code d’application ne doit pas appeler cette méthode ; d’un objet `Finalize` méthode est appelée automatiquement lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée par un appel à la <xref:System.GC.SuppressFinalize%2A> (méthode).  
  
 Pour plus d’informations, consultez [destructeurs et méthodes Finalize](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md), et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="FormattedValue">
      <MemberSignature Language="C#" Value="public object FormattedValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object FormattedValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.FormattedValue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormattedValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ FormattedValue { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur de la cellule telle qu'elle est mise en forme pour l'affichage.</summary>
        <value>Valeur mise en forme de la cellule ou <see langword="null" /> si la cellule n'appartient pas à un contrôle <see cref="T:System.Windows.Forms.DataGridView" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.Value%2A> propriété est l’objet de données réelles contenue dans la cellule, alors que le <xref:System.Windows.Forms.DataGridViewCell.FormattedValue%2A> est la représentation sous forme de mise en forme de cet objet. Le <xref:System.Windows.Forms.DataGridViewCell.ValueType%2A> et <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> les propriétés correspondent aux types de données de ces valeurs, respectivement.  
  
 Obtention de la valeur de cette propriété appelle la <xref:System.Windows.Forms.DataGridViewCell.GetFormattedValue%2A> méthode pour convertir la valeur de cellule en une valeur d’affichage équivalente du type indiqué par la <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> propriété. Cela déclenche la <xref:System.Windows.Forms.DataGridView.CellFormatting?displayProperty=nameWithType> événement que vous pouvez gérer pour personnaliser la conversion de valeur.  
  
 Si la mise en forme échoue, le <xref:System.Windows.Forms.DataGridView.DataError?displayProperty=nameWithType> événement se produit. S’il n’existe aucun gestionnaire pour cet événement ou le gestionnaire affecte la <xref:System.Windows.Forms.DataGridViewDataErrorEventArgs.ThrowException%2A?displayProperty=nameWithType> propriété `true`, une exception est levée.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.DataGridViewCell.FormattedValue%2A> propriété. Dans cet exemple, le <xref:System.Windows.Forms.DataGridView.IsCurrentCellDirty%2A> propriété est utilisée pour déterminer si le contenu de la cellule en cours ont été modifié et non validé et, si la cellule a été modifiée, le <xref:System.Windows.Forms.DataGridViewCell.FormattedValue%2A> est utilisé. Cet exemple fait partie d’un exemple plus complet disponible dans le <xref:System.Windows.Forms.DataGridView.SelectionChanged?displayProperty=nameWithType> événement.  
  
 [!code-csharp[System.Windows.Forms.DataGridViewSelectionSum#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewSelectionSum/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.DataGridViewSelectionSum#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewSelectionSum/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La ligne qui contient la cellule est une ligne partagée.  
  
 - ou -  
  
 La cellule est une cellule d'en-tête de colonne.</exception>
        <exception cref="T:System.Exception">La mise en forme a échoué et soit il n'y a aucun gestionnaire pour l'événement <see cref="E:System.Windows.Forms.DataGridView.DataError" /> du contrôle <see cref="T:System.Windows.Forms.DataGridView" />, soit le gestionnaire a affecté <see langword="true" /> à la propriété <see cref="P:System.Windows.Forms.DataGridViewDataErrorEventArgs.ThrowException" />. L’objet exception peut généralement être converti en type <see cref="T:System.FormatException" />.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.FormattedValueType" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Value" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.ValueType" />
        <altmember cref="T:System.Windows.Forms.IDataGridViewEditingControl" />
      </Docs>
    </Member>
    <Member MemberName="FormattedValueType">
      <MemberSignature Language="C#" Value="public virtual Type FormattedValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type FormattedValueType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.FormattedValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FormattedValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ FormattedValueType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de la valeur mise en forme associée à la cellule.</summary>
        <value>
          <see cref="T:System.Type" /> représentant le type de la valeur mise en forme de la cellule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.Value%2A> propriété est l’objet de données réelles contenue dans la cellule, alors que le <xref:System.Windows.Forms.DataGridViewCell.FormattedValue%2A> propriété est la représentation sous forme de mise en forme des données. Le <xref:System.Windows.Forms.DataGridViewCell.ValueType%2A> et <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> les propriétés correspondent aux types de données de ces valeurs, respectivement.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> propriété pour déterminer le type de contenu de la cellule. Dans cet exemple, le <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> propriété est utilisée pour déterminer si la cellule contient un <xref:System.String> avant d’essayer de convertir la valeur. Cet exemple fait partie d’un exemple plus complet disponible dans le <xref:System.Windows.Forms.DataGridView.SelectionChanged?displayProperty=nameWithType> événement.  
  
 [!code-csharp[System.Windows.Forms.DataGridViewSelectionSum#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewSelectionSum/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.DataGridViewSelectionSum#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewSelectionSum/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.FormattedValue" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.ValueType" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Value" />
      </Docs>
    </Member>
    <Member MemberName="Frozen">
      <MemberSignature Language="C#" Value="public virtual bool Frozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Frozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.Frozen" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Frozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Frozen { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la cellule est figée.</summary>
        <value>
          <see langword="true" /> si la cellule est figée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.Windows.Forms.DataGridViewCell.Frozen%2A> propriété dépend de l’état de la ligne parente de la cellule et de colonne. Si le `Frozen` de la ligne ou la colonne est définie sur `true`, de la cellule <xref:System.Windows.Forms.DataGridViewCell.Frozen%2A> propriété sera également `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewElementStates" />
        <altmember cref="P:System.Windows.Forms.DataGridViewRow.Frozen" />
        <altmember cref="P:System.Windows.Forms.DataGridViewColumn.Frozen" />
      </Docs>
    </Member>
    <Member MemberName="GetClipboardContent">
      <MemberSignature Language="C#" Value="protected virtual object GetClipboardContent (int rowIndex, bool firstCell, bool lastCell, bool inFirstRow, bool inLastRow, string format);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object GetClipboardContent(int32 rowIndex, bool firstCell, bool lastCell, bool inFirstRow, bool inLastRow, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetClipboardContent(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetClipboardContent (rowIndex As Integer, firstCell As Boolean, lastCell As Boolean, inFirstRow As Boolean, inLastRow As Boolean, format As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ GetClipboardContent(int rowIndex, bool firstCell, bool lastCell, bool inFirstRow, bool inLastRow, System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="firstCell" Type="System.Boolean" />
        <Parameter Name="lastCell" Type="System.Boolean" />
        <Parameter Name="inFirstRow" Type="System.Boolean" />
        <Parameter Name="inLastRow" Type="System.Boolean" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de base zéro de la ligne contenant la cellule.</param>
        <param name="firstCell">
          <see langword="true" /> pour indiquer que la cellule se trouve dans la première colonne de la région définie par les cellules sélectionnées ; sinon, <see langword="false" />.</param>
        <param name="lastCell">
          <see langword="true" /> pour indiquer que la cellule se trouve dans la dernière colonne de la région définie par les cellules sélectionnées ; sinon, <see langword="false" />.</param>
        <param name="inFirstRow">
          <see langword="true" /> pour indiquer que la cellule se trouve dans la première ligne de la région définie par les cellules sélectionnées ; sinon, <see langword="false" />.</param>
        <param name="inLastRow">
          <see langword="true" /> pour indiquer que la cellule se trouve dans la dernière ligne de la zone définie par les cellules sélectionnées ; sinon, <see langword="false" />.</param>
        <param name="format">Chaîne de mise en forme actuelle de la cellule.</param>
        <summary>Récupère la valeur mise en forme de la cellule à copier dans <see cref="T:System.Windows.Forms.Clipboard" />.</summary>
        <returns>
          <see cref="T:System.Object" /> qui représente la valeur de la cellule à copier dans <see cref="T:System.Windows.Forms.Clipboard" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le <xref:System.Windows.Forms.DataGridView.GetClipboardContent%2A?displayProperty=nameWithType> méthode pour récupérer une valeur au format Presse-papiers qui représente la valeur de cellule.  
  
 La valeur de cellule est d’abord récupérée dans son format d’affichage à partir de la <xref:System.Windows.Forms.DataGridViewCell.GetEditedFormattedValue%2A> (méthode). Cela peut déclencher la <xref:System.Windows.Forms.DataGridView.CellFormatting?displayProperty=nameWithType> événement à mettre en forme la valeur et le <xref:System.Windows.Forms.DataGridView.DataError?displayProperty=nameWithType> événement si la mise en forme échoue.  
  
 Les paramètres liés à la position de cette méthode indiquent où cette cellule se trouve dans la table de données représentant la région définie par les cellules sélectionnées dans le <xref:System.Windows.Forms.DataGridView> contrôle. En fonction de la position de la cellule, les informations de mise en forme supplémentaires peuvent être retournées par cette méthode, ainsi que la valeur de cellule d’affichage mis en forme. Par exemple, le format HTML d’une cellule dans la première colonne d’une ligne inclut la balise qui indique le début d’une ligne.  
  
 Les formats de Presse-papiers pris en charge <xref:System.Windows.Forms.DataFormats.Text?displayProperty=nameWithType>, <xref:System.Windows.Forms.DataFormats.UnicodeText?displayProperty=nameWithType>, <xref:System.Windows.Forms.DataFormats.Html?displayProperty=nameWithType>, et <xref:System.Windows.Forms.DataFormats.CommaSeparatedValue?displayProperty=nameWithType>.  
  
 Pour plus d'informations, consultez la classe <xref:System.Windows.Forms.Clipboard>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="rowIndex" /> est inférieur à 0 ou supérieur ou égal au nombre de lignes contenues dans le contrôle.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Windows.Forms.DataGridViewElement.DataGridView" /> de la cellule a la valeur <see langword="null" />.  
  
 - ou -  
  
 <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <exception cref="T:System.Exception">La mise en forme a échoué et soit il n'y a aucun gestionnaire pour l'événement <see cref="E:System.Windows.Forms.DataGridView.DataError" /> du contrôle <see cref="T:System.Windows.Forms.DataGridView" />, soit le gestionnaire a affecté <see langword="true" /> à la propriété <see cref="P:System.Windows.Forms.DataGridViewDataErrorEventArgs.ThrowException" />. L’objet exception peut généralement être converti en type <see cref="T:System.FormatException" />.</exception>
        <block subset="none" type="overrides">
          <para>Substituez cette méthode pour fournir des valeurs de Presse-papiers personnalisées. Par exemple, vous pouvez substituer cette méthode pour prendre en charge les valeurs de copie à partir des types de cellules personnalisés.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataFormats" />
        <altmember cref="P:System.Windows.Forms.DataGridView.ClipboardCopyMode" />
        <altmember cref="T:System.Windows.Forms.DataGridViewClipboardCopyMode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetContentBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le rectangle englobant qui définit la zone de contenu de la cellule.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetContentBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle GetContentBounds (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle GetContentBounds(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetContentBounds(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContentBounds (rowIndex As Integer) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle GetContentBounds(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Retourne le rectangle englobant qui définit la zone de contenu de la cellule à l'aide d'un <see cref="T:System.Drawing.Graphics" /> par défaut et le style de cellule actuellement défini pour la cellule.</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" /> qui englobe le contenu de la cellule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille du contenu de la cellule est calculée dynamiquement lorsque cette méthode est appelée. L’implémentation de classe de base toujours retourne <xref:System.Drawing.Rectangle.Empty?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le <paramref name="rowIndex" /> spécifié est inférieur à 0 ou supérieur au nombre de lignes contenues dans le contrôle moins 1.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="GetContentBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetContentBounds (System.Drawing.Graphics graphics, System.Windows.Forms.DataGridViewCellStyle cellStyle, int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetContentBounds(class System.Drawing.Graphics graphics, class System.Windows.Forms.DataGridViewCellStyle cellStyle, int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetContentBounds(System.Drawing.Graphics,System.Windows.Forms.DataGridViewCellStyle,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetContentBounds(System::Drawing::Graphics ^ graphics, System::Windows::Forms::DataGridViewCellStyle ^ cellStyle, int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="cellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="graphics">Contexte graphique pour la cellule.</param>
        <param name="cellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> à appliquer à la cellule.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Retourne le rectangle englobant qui définit la zone de contenu de la cellule, qui est calculée à l'aide de l'objet <see cref="T:System.Drawing.Graphics" /> et du style de cellule spécifiés.</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" /> qui englobe le contenu de la cellule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille du contenu de la cellule est calculée dynamiquement lorsque cette méthode est appelée. L’implémentation de classe de base toujours retourne <xref:System.Drawing.Rectangle.Empty?displayProperty=nameWithType>.  
  
 Cette méthode est appelée en interne lorsque la <xref:System.Windows.Forms.DataGridViewCell.ContentBounds%2A> propriété est en lecture.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.ContentBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetEditedFormattedValue">
      <MemberSignature Language="C#" Value="public object GetEditedFormattedValue (int rowIndex, System.Windows.Forms.DataGridViewDataErrorContexts context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetEditedFormattedValue(int32 rowIndex, valuetype System.Windows.Forms.DataGridViewDataErrorContexts context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetEditedFormattedValue(System.Int32,System.Windows.Forms.DataGridViewDataErrorContexts)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEditedFormattedValue (rowIndex As Integer, context As DataGridViewDataErrorContexts) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetEditedFormattedValue(int rowIndex, System::Windows::Forms::DataGridViewDataErrorContexts context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="context" Type="System.Windows.Forms.DataGridViewDataErrorContexts" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de ligne de la cellule.</param>
        <param name="context">Une combinaison d'opérations de bits de valeurs <see cref="T:System.Windows.Forms.DataGridViewDataErrorContexts" /> qui spécifie le contexte d'erreur de données.</param>
        <summary>Retourne la valeur actuelle mise en forme de la cellule, que la cellule soit en mode édition ou non et que la valeur ait été validée ou non.</summary>
        <returns>Valeur actuelle mise en forme de <see cref="T:System.Windows.Forms.DataGridViewCell" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne la valeur actuelle de la cellule d’édition ou de contrôle d’édition si la cellule est en mode édition. Sinon, cette méthode convertit la valeur de cellule en une valeur d’affichage équivalente du type indiqué par la <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> propriété. Cela déclenche la <xref:System.Windows.Forms.DataGridView.CellFormatting?displayProperty=nameWithType> événement que vous pouvez gérer pour personnaliser la conversion de valeur.  
  
 Si la mise en forme échoue, le <xref:System.Windows.Forms.DataGridView.DataError?displayProperty=nameWithType> événement se produit. S’il n’existe aucun gestionnaire pour cet événement ou le gestionnaire affecte la <xref:System.Windows.Forms.DataGridViewDataErrorEventArgs.ThrowException%2A?displayProperty=nameWithType> propriété `true`, une exception est levée.  
  
 Les classes dérivées qui substituent cette méthode retourne généralement une représentation sous forme de chaîne de la valeur de cellule si la `context` argument inclut la <xref:System.Windows.Forms.DataGridViewDataErrorContexts.ClipboardContent> valeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le <paramref name="rowIndex" /> spécifié est inférieur à 0 ou supérieur au nombre de lignes contenues dans le contrôle moins 1.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <exception cref="T:System.Exception">La mise en forme a échoué et soit il n'y a aucun gestionnaire pour l'événement <see cref="E:System.Windows.Forms.DataGridView.DataError" /> du contrôle <see cref="T:System.Windows.Forms.DataGridView" />, soit le gestionnaire a affecté <see langword="true" /> à la propriété <see cref="P:System.Windows.Forms.DataGridViewDataErrorEventArgs.ThrowException" />. L’objet exception peut généralement être converti en type <see cref="T:System.FormatException" />.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellFormatting" />
      </Docs>
    </Member>
    <Member MemberName="GetErrorIconBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetErrorIconBounds (System.Drawing.Graphics graphics, System.Windows.Forms.DataGridViewCellStyle cellStyle, int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetErrorIconBounds(class System.Drawing.Graphics graphics, class System.Windows.Forms.DataGridViewCellStyle cellStyle, int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetErrorIconBounds(System.Drawing.Graphics,System.Windows.Forms.DataGridViewCellStyle,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetErrorIconBounds(System::Drawing::Graphics ^ graphics, System::Windows::Forms::DataGridViewCellStyle ^ cellStyle, int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="cellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="graphics">Contexte graphique pour la cellule.</param>
        <param name="cellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> à appliquer à la cellule.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Retourne le rectangle qui englobe l'icône d'erreur de la cellule, si affichée.</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" /> qui relie l'icône d'erreur de la cellule, si affichée ; sinon, <see cref="F:System.Drawing.Rectangle.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille de la zone d’icônes erreur de la cellule est calculée dynamiquement lorsque cette méthode est appelée. L’implémentation de classe de base toujours retourne <xref:System.Drawing.Rectangle.Empty?displayProperty=nameWithType>.  
  
 Cette méthode est appelée en interne lorsque la <xref:System.Windows.Forms.DataGridViewCell.ErrorIconBounds%2A> propriété est en lecture.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.ErrorIconBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetErrorText">
      <MemberSignature Language="C#" Value="protected internal virtual string GetErrorText (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetErrorText(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetErrorText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetErrorText (rowIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetErrorText(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de ligne de la cellule.</param>
        <summary>Retourne une chaîne qui représente l'erreur pour la cellule.</summary>
        <returns>Chaîne qui décrit l'erreur pour le <see cref="T:System.Windows.Forms.DataGridViewCell" /> actif.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="GetFormattedValue">
      <MemberSignature Language="C#" Value="protected virtual object GetFormattedValue (object value, int rowIndex, ref System.Windows.Forms.DataGridViewCellStyle cellStyle, System.ComponentModel.TypeConverter valueTypeConverter, System.ComponentModel.TypeConverter formattedValueTypeConverter, System.Windows.Forms.DataGridViewDataErrorContexts context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object GetFormattedValue(object value, int32 rowIndex, class System.Windows.Forms.DataGridViewCellStyle&amp; cellStyle, class System.ComponentModel.TypeConverter valueTypeConverter, class System.ComponentModel.TypeConverter formattedValueTypeConverter, valuetype System.Windows.Forms.DataGridViewDataErrorContexts context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetFormattedValue(System.Object,System.Int32,System.Windows.Forms.DataGridViewCellStyle@,System.ComponentModel.TypeConverter,System.ComponentModel.TypeConverter,System.Windows.Forms.DataGridViewDataErrorContexts)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetFormattedValue (value As Object, rowIndex As Integer, ByRef cellStyle As DataGridViewCellStyle, valueTypeConverter As TypeConverter, formattedValueTypeConverter As TypeConverter, context As DataGridViewDataErrorContexts) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ GetFormattedValue(System::Object ^ value, int rowIndex, System::Windows::Forms::DataGridViewCellStyle ^ % cellStyle, System::ComponentModel::TypeConverter ^ valueTypeConverter, System::ComponentModel::TypeConverter ^ formattedValueTypeConverter, System::Windows::Forms::DataGridViewDataErrorContexts context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="cellStyle" Type="System.Windows.Forms.DataGridViewCellStyle&amp;" RefType="ref" />
        <Parameter Name="valueTypeConverter" Type="System.ComponentModel.TypeConverter" />
        <Parameter Name="formattedValueTypeConverter" Type="System.ComponentModel.TypeConverter" />
        <Parameter Name="context" Type="System.Windows.Forms.DataGridViewDataErrorContexts" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à mettre en forme.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <param name="cellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> en vigueur pour la cellule.</param>
        <param name="valueTypeConverter">
          <see cref="T:System.ComponentModel.TypeConverter" /> associé au type valeur qui fournit la conversion personnalisée en type valeur mise en forme, ou <see langword="null" /> si une telle conversion personnalisée n'est pas nécessaire.</param>
        <param name="formattedValueTypeConverter">
          <see cref="T:System.ComponentModel.TypeConverter" /> associé au type valeur mise en forme qui fournit la conversion personnalisée du type valeur, ou <see langword="null" /> si une telle conversion personnalisée n'est pas nécessaire.</param>
        <param name="context">Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.DataGridViewDataErrorContexts" /> indiquant le contexte dans lequel la valeur mise en forme est nécessaire.</param>
        <summary>Obtient la valeur de la cellule telle qu'elle est mise en forme pour l'affichage.</summary>
        <returns>Valeur mise en forme de la cellule ou <see langword="null" /> si la cellule n'appartient pas à un contrôle <see cref="T:System.Windows.Forms.DataGridView" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridView> contrôle appelle cette méthode pour convertir une valeur de cellule en une valeur d’affichage équivalente du type indiqué par la <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> propriété. Le contrôle passe la valeur de cellule de cette méthode dans le `value` paramètre.  
  
 Cette méthode déclenche la <xref:System.Windows.Forms.DataGridView.CellFormatting?displayProperty=nameWithType> événement. Un gestionnaire pour cet événement peut modifier le `value` et `cellStyle` paramètres. Si le gestionnaire n’affecte pas la <xref:System.Windows.Forms.DataGridViewCellFormattingEventArgs.FormattingApplied%2A?displayProperty=nameWithType> propriété `true`, toutefois, cette méthode met en forme `value` en utilisant les propriétés de mise en forme de la `cellStyle` objet.  
  
> [!NOTE]
>  Cette méthode ne convertit pas `value` à la <xref:System.Windows.Forms.DataGridViewCellStyle.NullValue%2A?displayProperty=nameWithType> valeur de propriété pour les valeurs sont égales à la <xref:System.Windows.Forms.DataGridViewCellStyle.DataSourceNullValue%2A?displayProperty=nameWithType> valeur de propriété lorsque <xref:System.Windows.Forms.DataGridViewCellStyle.DataSourceNullValue%2A> est définie sur une valeur autre que <xref:System.DBNull.Value?displayProperty=nameWithType> ou `null`. Dans ce cas, vous pouvez gérer le <xref:System.Windows.Forms.DataGridView.CellFormatting?displayProperty=nameWithType> événement afin d’afficher le <xref:System.Windows.Forms.DataGridViewCellStyle.NullValue%2A> valeur de propriété. Pour plus d’informations, consultez l’exemple de code <xref:System.Windows.Forms.DataGridViewCellStyle.DataSourceNullValue%2A>.  
  
 Si la mise en forme échoue, le <xref:System.Windows.Forms.DataGridView.DataError> événement se produit. S’il n’existe aucun gestionnaire pour cet événement ou le gestionnaire affecte la <xref:System.Windows.Forms.DataGridViewDataErrorEventArgs.ThrowException%2A?displayProperty=nameWithType> propriété `true`, une exception est levée.  
  
 Les classes dérivées qui substituent cette méthode retourne généralement une représentation sous forme de chaîne de la valeur de cellule si la `context` argument inclut la <xref:System.Windows.Forms.DataGridViewDataErrorContexts.ClipboardContent> valeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">La mise en forme a échoué et soit il n'y a aucun gestionnaire pour l'événement <see cref="E:System.Windows.Forms.DataGridView.DataError" /> du contrôle <see cref="T:System.Windows.Forms.DataGridView" />, soit le gestionnaire a affecté <see langword="true" /> à la propriété <see cref="P:System.Windows.Forms.DataGridViewDataErrorEventArgs.ThrowException" />. L’objet exception peut généralement être converti en type <see cref="T:System.FormatException" />.</exception>
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.FormattedValueType" />
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellFormatting" />
        <altmember cref="E:System.Windows.Forms.DataGridView.DataError" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCellFormattingEventArgs.FormattingApplied" />
        <altmember cref="T:System.ComponentModel.TypeConverter" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCellStyle.Format" />
        <altmember cref="T:System.Windows.Forms.DataGridViewDataErrorContexts" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.ParseFormattedValue(System.Object,System.Windows.Forms.DataGridViewCellStyle,System.ComponentModel.TypeConverter,System.ComponentModel.TypeConverter)" />
      </Docs>
    </Member>
    <Member MemberName="GetInheritedContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip GetInheritedContextMenuStrip (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.ContextMenuStrip GetInheritedContextMenuStrip(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetInheritedContextMenuStrip(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInheritedContextMenuStrip (rowIndex As Integer) As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::ContextMenuStrip ^ GetInheritedContextMenuStrip(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de ligne de la cellule active.</param>
        <summary>Obtient le menu contextuel hérité pour la cellule active.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.ContextMenuStrip" /> si le <see cref="T:System.Windows.Forms.DataGridView" />, <see cref="T:System.Windows.Forms.DataGridViewRow" /> ou <see cref="T:System.Windows.Forms.DataGridViewColumn" /> parent a un <see cref="T:System.Windows.Forms.ContextMenuStrip" /> assigné ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la cellule n’est pas associé à un <xref:System.Windows.Forms.ContextMenuStrip>, il hérite de ses parents, selon la priorité suivante :  
  
1.  De cette cellule. <xref:System.Windows.Forms.DataGridViewCell.ContextMenuStrip%2A>  
  
2.  Propriétaire de la ligne <xref:System.Windows.Forms.DataGridViewRow.ContextMenuStrip%2A?displayProperty=nameWithType>  
  
3.  Propriétaire de la colonne <xref:System.Windows.Forms.DataGridViewColumn.ContextMenuStrip%2A?displayProperty=nameWithType>  
  
4.  La table parente <xref:System.Windows.Forms.ContextMenuStrip?displayProperty=nameWithType>  
  
 Menus contextuels sont des ressources natives de Microsoft Windows dont des durées de vie sont généralement définies par le <xref:System.Windows.Forms.DataGridViewCell.Dispose%2A> méthode ou le destructeur.  
  
 Passez le <xref:System.Windows.Forms.DataGridViewCell.GetInheritedContextMenuStrip%2A> méthode l’index de ligne utilisé pour récupérer le <xref:System.Windows.Forms.DataGridViewCell>. N’utilisez pas le <xref:System.Windows.Forms.DataGridViewCell.RowIndex%2A> propriété pour la `rowIndex` paramètre. Si la ligne est partagée, <xref:System.Windows.Forms.DataGridViewCell.RowIndex%2A> est -1, ce qui n’est pas une valeur valide pour `rowIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de la propriété <see cref="P:System.Windows.Forms.DataGridViewElement.DataGridView" /> de la cellule n'est pas <see langword="null" /> et le <paramref name="rowIndex" /> spécifié est inférieur à 0 ou supérieur au nombre de lignes dans le contrôle moins 1.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.ContextMenuStrip" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenuStrip" />
        <altmember cref="T:System.Windows.Forms.ContextMenuStrip" />
        <altmember cref="T:System.Windows.Forms.DataGridViewRow" />
        <altmember cref="T:System.Windows.Forms.DataGridViewColumn" />
      </Docs>
    </Member>
    <Member MemberName="GetInheritedState">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DataGridViewElementStates GetInheritedState (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Windows.Forms.DataGridViewElementStates GetInheritedState(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetInheritedState(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInheritedState (rowIndex As Integer) As DataGridViewElementStates" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::DataGridViewElementStates GetInheritedState(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridViewElementStates</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne contenant la cellule.</param>
        <summary>Retourne une valeur qui indique l'état actuel de la cellule tel qu'il est hérité de l'état de sa ligne et colonne.</summary>
        <returns>Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.DataGridViewElementStates" /> représentant l'état actuel de la cellule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utile pour déterminer l’état d’une cellule dans une ligne partagée. Les lignes partagées ont <xref:System.Windows.Forms.DataGridViewBand.Index%2A> les valeurs de -1, ce qui vous empêche d’utiliser le <xref:System.Windows.Forms.DataGridViewCell.InheritedState%2A> propriété avec les cellules des lignes partagées. Pour utiliser cette méthode, passez dans l’index de la ligne qui contient cette cellule. Vous pouvez récupérer l’index d’une ligne partagée en appelant le <xref:System.Windows.Forms.DataGridViewRowCollection.IndexOf%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La cellule n'est pas contenue dans un contrôle <see cref="T:System.Windows.Forms.DataGridView" /> et <paramref name="rowIndex" /> n'a pas la valeur -1.  
  
 - ou -  
  
 <paramref name="rowIndex" /> n'est pas l'index de la ligne contenant cette cellule.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La cellule est contenue dans un contrôle <see cref="T:System.Windows.Forms.DataGridView" /> et <paramref name="rowIndex" /> se trouve en dehors de la plage valide comprise entre 0 et le nombre de lignes dans le contrôle moins 1.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="GetInheritedStyle">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DataGridViewCellStyle GetInheritedStyle (System.Windows.Forms.DataGridViewCellStyle inheritedCellStyle, int rowIndex, bool includeColors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.DataGridViewCellStyle GetInheritedStyle(class System.Windows.Forms.DataGridViewCellStyle inheritedCellStyle, int32 rowIndex, bool includeColors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetInheritedStyle(System.Windows.Forms.DataGridViewCellStyle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInheritedStyle (inheritedCellStyle As DataGridViewCellStyle, rowIndex As Integer, includeColors As Boolean) As DataGridViewCellStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::DataGridViewCellStyle ^ GetInheritedStyle(System::Windows::Forms::DataGridViewCellStyle ^ inheritedCellStyle, int rowIndex, bool includeColors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridViewCellStyle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inheritedCellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="includeColors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inheritedCellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> à remplir avec le style de cellule hérité.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <param name="includeColors">
          <see langword="true" /> pour inclure les couleurs héritées dans le style de cellule retourné; sinon, <see langword="false" />.</param>
        <summary>Obtient le style appliqué à la cellule.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> qui inclut les paramètres de style de la cellule héritée de la ligne, de la colonne et de <see cref="T:System.Windows.Forms.DataGridView" /> parents de la cellule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne un <xref:System.Windows.Forms.DataGridViewCellStyle> qui hérite ses paramètres à partir de la <xref:System.Windows.Forms.DataGridViewCellStyle> objets parent de la cellule de ligne, la colonne et <xref:System.Windows.Forms.DataGridView>. Pour plus d’informations, consultez [Styles de cellules dans le contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/cell-styles-in-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cellule ne contient pas de <see cref="T:System.Windows.Forms.DataGridView" /> associé.  
  
 - ou -  
  
 <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="rowIndex" /> est inférieur à 0 ou supérieur ou égal au nombre de lignes contenues dans le <see cref="T:System.Windows.Forms.DataGridView" /> parent.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.InheritedStyle" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.AdjustCellBorderStyle(System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.HasStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Style" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size GetPreferredSize (System.Drawing.Graphics graphics, System.Windows.Forms.DataGridViewCellStyle cellStyle, int rowIndex, System.Drawing.Size constraintSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(class System.Drawing.Graphics graphics, class System.Windows.Forms.DataGridViewCellStyle cellStyle, int32 rowIndex, valuetype System.Drawing.Size constraintSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetPreferredSize(System.Drawing.Graphics,System.Windows.Forms.DataGridViewCellStyle,System.Int32,System.Drawing.Size)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size GetPreferredSize(System::Drawing::Graphics ^ graphics, System::Windows::Forms::DataGridViewCellStyle ^ cellStyle, int rowIndex, System::Drawing::Size constraintSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="cellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="constraintSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> utilisé pour dessiner la cellule.</param>
        <param name="cellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> qui représente le style de la cellule.</param>
        <param name="rowIndex">Index de base zéro de ligne de la cellule sélectionnée.</param>
        <param name="constraintSize">Taille maximale autorisée de la cellule.</param>
        <summary>Calcule la taille par défaut, en pixels, de la cellule.</summary>
        <returns>
          <see cref="T:System.Drawing.Size" /> qui représente la taille par défaut, en pixels, de la cellule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.GetPreferredSize%2A> méthode dans la classe de base <xref:System.Windows.Forms.DataGridViewCell> retourne toujours un <xref:System.Drawing.Size> avec une largeur et une hauteur de -1. Toutefois, cette méthode est substituée dans les classes dérivées de cellule pour retourner les valeurs appropriées.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="GetSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size GetSize (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size GetSize(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetSize(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSize (rowIndex As Integer) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size GetSize(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Obtient la taille de la cellule.</summary>
        <returns>
          <see cref="T:System.Drawing.Size" /> représentant les dimensions de la cellule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne peut pas être utilisée avec une cellule dans une ligne partagée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="rowIndex" /> est -1</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="protected virtual object GetValue (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object GetValue(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetValue (rowIndex As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ GetValue(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Obtient la valeur de la cellule.</summary>
        <returns>Valeur contenue dans <see cref="T:System.Windows.Forms.DataGridViewCell" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Passez le <xref:System.Windows.Forms.DataGridViewCell.GetValue%2A> méthode l’index de ligne utilisé pour récupérer le <xref:System.Windows.Forms.DataGridViewCell>. N’utilisez pas le <xref:System.Windows.Forms.DataGridViewCell.RowIndex%2A> propriété pour la `rowIndex` paramètre. Si la ligne est partagée, <xref:System.Windows.Forms.DataGridViewCell.RowIndex%2A> est -1, ce qui n’est pas une valeur valide pour `rowIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de la propriété <see cref="P:System.Windows.Forms.DataGridViewElement.DataGridView" /> de la cellule n’est pas <see langword="null" /> et <paramref name="rowIndex" /> est inférieur à 0 ou supérieur ou égal au nombre de lignes dans le <see cref="T:System.Windows.Forms.DataGridView" /> parent.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Windows.Forms.DataGridViewElement.DataGridView" /> de la cellule n'a pas la valeur <see langword="null" /> et la propriété <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> a une valeur inférieure à 0, pour indiquer que la cellule est une cellule d'en-tête de ligne.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="HasStyle">
      <MemberSignature Language="C#" Value="public bool HasStyle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.HasStyle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasStyle { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la propriété <see cref="P:System.Windows.Forms.DataGridViewCell.Style" /> a été définie.</summary>
        <value>
          <see langword="true" /> si la propriété <see cref="P:System.Windows.Forms.DataGridViewCell.Style" /> a été définie ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obtention de la valeur de la <xref:System.Windows.Forms.DataGridViewCell.Style%2A> propriété instancie automatiquement un nouveau <xref:System.Windows.Forms.DataGridViewCellStyle> si la propriété n’a pas pu accéder. Par conséquent, vous devez utiliser le <xref:System.Windows.Forms.DataGridViewCell.HasStyle%2A> propriété pour déterminer si le <xref:System.Windows.Forms.DataGridViewCell.Style%2A> est actuellement définie sur une <xref:System.Windows.Forms.DataGridViewCellStyle> instance. Cela est utile pour déterminer quelles propriétés de l’objet retourné par la <xref:System.Windows.Forms.DataGridViewCell.InheritedStyle%2A> propriété représentent des styles définis spécifiquement pour la cellule.  
  
 Pour plus d’informations sur l’héritage de style de cellule, consultez [Styles de cellules dans le contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/cell-styles-in-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridView.DefaultCellStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridViewRow.DefaultCellStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.InheritedStyle" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.AdjustCellBorderStyle(System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.GetInheritedStyle(System.Windows.Forms.DataGridViewCellStyle,System.Int32,System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Style" />
      </Docs>
    </Member>
    <Member MemberName="InheritedState">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGridViewElementStates InheritedState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DataGridViewElementStates InheritedState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.InheritedState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InheritedState As DataGridViewElementStates" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DataGridViewElementStates InheritedState { System::Windows::Forms::DataGridViewElementStates get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridViewElementStates</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'état actuel de la cellule tel qu'il est hérité de l'état de sa ligne ou colonne.</summary>
        <value>Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.DataGridViewElementStates" /> représentant l'état actuel de la cellule.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La cellule n'est pas contenue dans un contrôle <see cref="T:System.Windows.Forms.DataGridView" /> et sa propriété <see cref="P:System.Windows.Forms.DataGridViewCell.RowIndex" /> n'a pas la valeur -1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La cellule est contenue dans un contrôle <see cref="T:System.Windows.Forms.DataGridView" /> et sa propriété <see cref="P:System.Windows.Forms.DataGridViewCell.RowIndex" /> a la valeur -1.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="InheritedStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGridViewCellStyle InheritedStyle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.DataGridViewCellStyle InheritedStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.InheritedStyle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InheritedStyle As DataGridViewCellStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DataGridViewCellStyle ^ InheritedStyle { System::Windows::Forms::DataGridViewCellStyle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridViewCellStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le style actuellement appliqué à la cellule.</summary>
        <value>
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> actuellement appliqué à la cellule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridView> contrôle affiche ses cellules à l’aide des styles indiqués par la cellule <xref:System.Windows.Forms.DataGridViewCell.InheritedStyle%2A> propriété, qui hérite des styles d’autres propriétés de type <xref:System.Windows.Forms.DataGridViewCellStyle>. Les styles spécifiés via le <xref:System.Windows.Forms.DataGridViewCell.Style%2A> propriété substituent les styles spécifiés via toutes les autres propriétés de style de cellule, mais n’indiquent pas nécessairement tous les styles qui contribuent à l’apparence de la cellule.  
  
 Pour plus d’informations, consultez [Styles de cellules dans le contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/cell-styles-in-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cellule n'appartient pas au contrôle <see cref="T:System.Windows.Forms.DataGridView" />.  
  
 - ou -  
  
 <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La ligne qui contient la cellule est une ligne partagée.  
  
 - ou -  
  
 La cellule est une cellule d'en-tête de colonne.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.AdjustCellBorderStyle(System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.GetInheritedStyle(System.Windows.Forms.DataGridViewCellStyle,System.Int32,System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.HasStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Style" />
        <altmember cref="T:System.Windows.Forms.DataGridViewRow" />
        <altmember cref="T:System.Windows.Forms.DataGridViewColumn" />
        <altmember cref="P:System.Windows.Forms.DataGridView.DefaultCellStyle" />
      </Docs>
    </Member>
    <Member MemberName="InitializeEditingControl">
      <MemberSignature Language="C#" Value="public virtual void InitializeEditingControl (int rowIndex, object initialFormattedValue, System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InitializeEditingControl(int32 rowIndex, object initialFormattedValue, class System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.InitializeEditingControl(System.Int32,System.Object,System.Windows.Forms.DataGridViewCellStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void InitializeEditingControl(int rowIndex, System::Object ^ initialFormattedValue, System::Windows::Forms::DataGridViewCellStyle ^ dataGridViewCellStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="initialFormattedValue" Type="System.Object" />
        <Parameter Name="dataGridViewCellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de base zéro de ligne de l'emplacement de la cellule.</param>
        <param name="initialFormattedValue">
          <see cref="T:System.Object" /> qui représente la valeur affichée par la cellule lorsque la modification est démarrée.</param>
        <param name="dataGridViewCellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> qui représente le style de la cellule.</param>
        <summary>Initialise le contrôle utilisé pour modifier la cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comme une technique d’optimisation, en général, toutes les cellules du même type et de la même <xref:System.Windows.Forms.DataGridView> partage une seule hébergé le contrôle d’édition. Toutefois, avant que le contrôle est utilisé par une cellule, il doit être initialisé par le <xref:System.Windows.Forms.DataGridViewCell.InitializeEditingControl%2A> (méthode). La première fois qu’elle est appelée, cette méthode ajoute le contrôle à la liste d’édition des contrôles dans son parent <xref:System.Windows.Forms.DataGridView>. Elle initialise également quelques-unes des propriétés visuelles de la cellule. Par exemple, <xref:System.Windows.Forms.DataGridViewCell.InitializeEditingControl%2A> définit la couleur d’arrière-plan de la zone d’édition pour faire correspondre le paramètre de style de cellule fourni. Les appels suivants à <xref:System.Windows.Forms.DataGridViewCell.InitializeEditingControl%2A> ne rien faire.  
  
 Classes dérivées utilisent cette méthode pour héberger une instance de la <xref:System.Windows.Forms.Control> classe correspondant à leur type. Par exemple, une table qui contient un ou plusieurs <xref:System.Windows.Forms.DataGridViewTextBoxCell> objets appelle cette méthode pour ajouter un seul <xref:System.Windows.Forms.TextBox> contrôle propriétaire d’édition <xref:System.Windows.Forms.DataGridView>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la <xref:System.Windows.Forms.DataGridViewTextBoxCell.InitializeEditingControl%2A> méthode dans une classe simple qui dérive de la <xref:System.Windows.Forms.DataGridViewTextBoxCell> classe. Cet exemple fait partie d’un exemple de code plus complet fourni dans [Comment : héberger des contrôles dans les cellules DataGridView Windows Forms](~/docs/framework/winforms/controls/how-to-host-controls-in-windows-forms-datagridview-cells.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewCalendarColumn#200](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/CS/datagridviewcalendarcolumn.cs#200)]
 [!code-vb[System.Windows.Forms.DataGridViewCalendarColumn#200](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/VB/datagridviewcalendarcolumn.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il n'existe aucun <see cref="T:System.Windows.Forms.DataGridView" /> associé, ou s'il y en a un, celui-ci n'a pas de contrôle d'édition associé.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.DetachEditingControl" />
      </Docs>
    </Member>
    <Member MemberName="IsInEditMode">
      <MemberSignature Language="C#" Value="public bool IsInEditMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInEditMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.IsInEditMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInEditMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInEditMode { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si cette cellule est actuellement en cours de modification.</summary>
        <value>
          <see langword="true" /> si la cellule est en mode édition ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utile lorsque vous travaillez directement avec des instances de cellule. En guise d'alternative, vous pouvez utiliser la propriété <xref:System.Windows.Forms.DataGridView.IsCurrentCellInEditMode%2A?displayProperty=nameWithType>. Vous pouvez également gérer les <xref:System.Windows.Forms.DataGridView.CellBeginEdit?displayProperty=nameWithType> événement pour déterminer quand l’utilisateur passe en mode édition.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La ligne qui contient la cellule est une ligne partagée.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridView.IsCurrentCellInEditMode" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellBeginEdit" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool KeyDownUnsharesRow (System.Windows.Forms.KeyEventArgs e, int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyDownUnsharesRow(class System.Windows.Forms.KeyEventArgs e, int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.KeyDownUnsharesRow(System.Windows.Forms.KeyEventArgs,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyDownUnsharesRow (e As KeyEventArgs, rowIndex As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyDownUnsharesRow(System::Windows::Forms::KeyEventArgs ^ e, int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.KeyEventArgs" /> qui contient les données d'événement.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Indique si la ligne parente est partagée ou non lorsque l'utilisateur appuie sur une touche alors que le focus est placé sur la cellule.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.KeyDownUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnKeyDown%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnKeyDown%2A> avec le même <xref:System.Windows.Forms.KeyEventArgs> argument a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyDown(System.Windows.Forms.KeyEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyPress(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.KeyPressUnsharesRow(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyUp(System.Windows.Forms.KeyEventArgs,System.Int32)" />
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="KeyEntersEditMode">
      <MemberSignature Language="C#" Value="public virtual bool KeyEntersEditMode (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool KeyEntersEditMode(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.KeyEntersEditMode(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function KeyEntersEditMode (e As KeyEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool KeyEntersEditMode(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.KeyEventArgs" /> qui représente la touche enfoncée.</param>
        <summary>Détermine si le mode édition doit être démarré en fonction de la touche donnée.</summary>
        <returns>
          <see langword="true" /> si le mode édition doit être démarré ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituez cette méthode pour créer une cellule personnalisée est modifiable.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="KeyPressUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool KeyPressUnsharesRow (System.Windows.Forms.KeyPressEventArgs e, int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyPressUnsharesRow(class System.Windows.Forms.KeyPressEventArgs e, int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.KeyPressUnsharesRow(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyPressUnsharesRow (e As KeyPressEventArgs, rowIndex As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyPressUnsharesRow(System::Windows::Forms::KeyPressEventArgs ^ e, int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> qui contient les données d'événement.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Indique si une ligne est partagée ou non lorsqu'une touche est enfoncée et que le focus est placé sur une cellule de la ligne.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.KeyPressUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnKeyPress%2A> (méthode). Dans les classes dérivées, elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnKeyPress%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyDown(System.Windows.Forms.KeyEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyPress(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyUp(System.Windows.Forms.KeyEventArgs,System.Int32)" />
        <altmember cref="T:System.Windows.Forms.KeyPressEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool KeyUpUnsharesRow (System.Windows.Forms.KeyEventArgs e, int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyUpUnsharesRow(class System.Windows.Forms.KeyEventArgs e, int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.KeyUpUnsharesRow(System.Windows.Forms.KeyEventArgs,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyUpUnsharesRow (e As KeyEventArgs, rowIndex As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyUpUnsharesRow(System::Windows::Forms::KeyEventArgs ^ e, int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.KeyEventArgs" /> qui contient les données d'événement.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Indique si la ligne parente est partagée ou non lorsque l’utilisateur relâche une touche alors que le focus est placé sur la cellule.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.KeyUpUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnKeyUp%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnKeyUp%2A> avec le même <xref:System.Windows.Forms.KeyEventArgs> argument a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyDown(System.Windows.Forms.KeyEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyPress(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.KeyPressUnsharesRow(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyUp(System.Windows.Forms.KeyEventArgs,System.Int32)" />
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="LeaveUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool LeaveUnsharesRow (int rowIndex, bool throughMouseClick);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LeaveUnsharesRow(int32 rowIndex, bool throughMouseClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.LeaveUnsharesRow(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LeaveUnsharesRow (rowIndex As Integer, throughMouseClick As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LeaveUnsharesRow(int rowIndex, bool throughMouseClick);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="throughMouseClick" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <param name="throughMouseClick">
          <see langword="true" /> si une intervention de l'utilisateur a déplacé le focus vers la cellule ; <see langword="false" /> si une opération de programmation a déplacé le focus vers la cellule.</param>
        <summary>Indique si une ligne est partagée ou non lorsque le focus quitte une cellule de la ligne.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.LeaveUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnLeave%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnLeave%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnLeave(System.Int32,System.Boolean)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseLeaveUnsharesRow(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MeasureTextHeight">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient la hauteur, en pixels, du texte spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MeasureTextHeight">
      <MemberSignature Language="C#" Value="public static int MeasureTextHeight (System.Drawing.Graphics graphics, string text, System.Drawing.Font font, int maxWidth, System.Windows.Forms.TextFormatFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 MeasureTextHeight(class System.Drawing.Graphics graphics, string text, class System.Drawing.Font font, int32 maxWidth, valuetype System.Windows.Forms.TextFormatFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MeasureTextHeight(System.Drawing.Graphics,System.String,System.Drawing.Font,System.Int32,System.Windows.Forms.TextFormatFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int MeasureTextHeight(System::Drawing::Graphics ^ graphics, System::String ^ text, System::Drawing::Font ^ font, int maxWidth, System::Windows::Forms::TextFormatFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="maxWidth" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Windows.Forms.TextFormatFlags" />
      </Parameters>
      <Docs>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> utilisé pour le rendu du texte.</param>
        <param name="text">Texte à mesurer.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" /> appliqué au texte.</param>
        <param name="maxWidth">Largeur maximale du texte.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> à appliquer au texte.</param>
        <summary>Obtient la hauteur, en pixels, du texte spécifié, en fonction des caractéristiques indiquées.</summary>
        <returns>Hauteur, en pixels, du texte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si plusieurs lignes sont requises et la mise en forme spécifiée l’autorise, la hauteur retournée est la hauteur combinée de toutes les lignes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="graphics" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="font" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxWidth" /> est inférieur à 1.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="flags" /> n'est pas une combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> valide.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="MeasureTextHeight">
      <MemberSignature Language="C#" Value="public static int MeasureTextHeight (System.Drawing.Graphics graphics, string text, System.Drawing.Font font, int maxWidth, System.Windows.Forms.TextFormatFlags flags, out bool widthTruncated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 MeasureTextHeight(class System.Drawing.Graphics graphics, string text, class System.Drawing.Font font, int32 maxWidth, valuetype System.Windows.Forms.TextFormatFlags flags, [out] bool&amp; widthTruncated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MeasureTextHeight(System.Drawing.Graphics,System.String,System.Drawing.Font,System.Int32,System.Windows.Forms.TextFormatFlags,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int MeasureTextHeight(System::Drawing::Graphics ^ graphics, System::String ^ text, System::Drawing::Font ^ font, int maxWidth, System::Windows::Forms::TextFormatFlags flags, [Runtime::InteropServices::Out] bool % widthTruncated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="maxWidth" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Windows.Forms.TextFormatFlags" />
        <Parameter Name="widthTruncated" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> utilisé pour le rendu du texte.</param>
        <param name="text">Texte à mesurer.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" /> appliqué au texte.</param>
        <param name="maxWidth">Largeur maximale du texte.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> à appliquer au texte.</param>
        <param name="widthTruncated">A la valeur <see langword="true" /> si la largeur requise du texte est supérieure à <c>maxWidth</c>.</param>
        <summary>Obtient la hauteur, en pixels, du texte spécifié, en fonction des caractéristiques indiquées. Indique également si la largeur requise est supérieure à la largeur maximale spécifiée.</summary>
        <returns>Hauteur, en pixels, du texte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si plusieurs lignes sont requises et la mise en forme spécifiée l’autorise, la hauteur retournée est la hauteur combinée de toutes les lignes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="graphics" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="font" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxWidth" /> est inférieur à 1.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="flags" /> n'est pas une combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> valide.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="MeasureTextPreferredSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.Size MeasureTextPreferredSize (System.Drawing.Graphics graphics, string text, System.Drawing.Font font, float maxRatio, System.Windows.Forms.TextFormatFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.Size MeasureTextPreferredSize(class System.Drawing.Graphics graphics, string text, class System.Drawing.Font font, float32 maxRatio, valuetype System.Windows.Forms.TextFormatFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MeasureTextPreferredSize(System.Drawing.Graphics,System.String,System.Drawing.Font,System.Single,System.Windows.Forms.TextFormatFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Size MeasureTextPreferredSize(System::Drawing::Graphics ^ graphics, System::String ^ text, System::Drawing::Font ^ font, float maxRatio, System::Windows::Forms::TextFormatFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="maxRatio" Type="System.Single" />
        <Parameter Name="flags" Type="System.Windows.Forms.TextFormatFlags" />
      </Parameters>
      <Docs>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> utilisé pour le rendu du texte.</param>
        <param name="text">Texte à mesurer.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" /> appliqué au texte.</param>
        <param name="maxRatio">Rapport largeur-hauteur maximal du bloc de texte.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> à appliquer au texte.</param>
        <summary>Obtient la hauteur et la largeur idéales du texte spécifié en fonction des caractéristiques indiquées.</summary>
        <returns>
          <see cref="T:System.Drawing.Size" /> représentant la hauteur et la largeur idéales du texte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si plusieurs lignes sont requises et la mise en forme spécifiée l’autorise, la taille retournée inclut la hauteur combinée de toutes les lignes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="graphics" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="font" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxRatio" /> est inférieur ou égal à 0.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="flags" /> n'est pas une combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> valide.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="MeasureTextSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.Size MeasureTextSize (System.Drawing.Graphics graphics, string text, System.Drawing.Font font, System.Windows.Forms.TextFormatFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.Size MeasureTextSize(class System.Drawing.Graphics graphics, string text, class System.Drawing.Font font, valuetype System.Windows.Forms.TextFormatFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MeasureTextSize(System.Drawing.Graphics,System.String,System.Drawing.Font,System.Windows.Forms.TextFormatFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Size MeasureTextSize(System::Drawing::Graphics ^ graphics, System::String ^ text, System::Drawing::Font ^ font, System::Windows::Forms::TextFormatFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="flags" Type="System.Windows.Forms.TextFormatFlags" />
      </Parameters>
      <Docs>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> utilisé pour le rendu du texte.</param>
        <param name="text">Texte à mesurer.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" /> appliqué au texte.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> à appliquer au texte.</param>
        <summary>Obtient la hauteur et la largeur du texte spécifié en fonction des caractéristiques indiquées.</summary>
        <returns>
          <see cref="T:System.Drawing.Size" /> représentant la hauteur et la largeur du texte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si plusieurs lignes sont requises et la mise en forme spécifiée l’autorise, la taille retournée inclut la hauteur combinée de toutes les lignes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="graphics" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="font" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="flags" /> n'est pas une combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> valide.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="MeasureTextWidth">
      <MemberSignature Language="C#" Value="public static int MeasureTextWidth (System.Drawing.Graphics graphics, string text, System.Drawing.Font font, int maxHeight, System.Windows.Forms.TextFormatFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 MeasureTextWidth(class System.Drawing.Graphics graphics, string text, class System.Drawing.Font font, int32 maxHeight, valuetype System.Windows.Forms.TextFormatFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MeasureTextWidth(System.Drawing.Graphics,System.String,System.Drawing.Font,System.Int32,System.Windows.Forms.TextFormatFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int MeasureTextWidth(System::Drawing::Graphics ^ graphics, System::String ^ text, System::Drawing::Font ^ font, int maxHeight, System::Windows::Forms::TextFormatFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="maxHeight" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Windows.Forms.TextFormatFlags" />
      </Parameters>
      <Docs>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> utilisé pour le rendu du texte.</param>
        <param name="text">Texte à mesurer.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" /> appliqué au texte.</param>
        <param name="maxHeight">Hauteur maximale du texte.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> à appliquer au texte.</param>
        <summary>Obtient la largeur, en pixels, du texte spécifié, en fonction des caractéristiques indiquées.</summary>
        <returns>Largeur, en pixels, du texte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="graphics" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="font" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxHeight" /> est inférieur à 1.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="flags" /> n'est pas une combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.TextFormatFlags" /> valide.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="MouseClickUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool MouseClickUnsharesRow (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool MouseClickUnsharesRow(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MouseClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MouseClickUnsharesRow (e As DataGridViewCellMouseEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool MouseClickUnsharesRow(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Indique si une ligne est partagée ou non lorsque l'utilisateur clique sur le bouton de la souris alors que le pointeur est placé sur une cellule de la ligne.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.MouseClickUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnMouseClick%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnMouseClick%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDownUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseEnterUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseLeaveUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseMoveUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseUpUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClickUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool MouseDoubleClickUnsharesRow (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool MouseDoubleClickUnsharesRow(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MouseDoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MouseDoubleClickUnsharesRow (e As DataGridViewCellMouseEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool MouseDoubleClickUnsharesRow(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Indique si une ligne est partagée ou non lorsque l'utilisateur double-clique sur une cellule de la ligne.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.MouseDoubleClickUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnMouseDoubleClick%2A> (méthode). Elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnMouseDoubleClick%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="MouseDownUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool MouseDownUnsharesRow (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool MouseDownUnsharesRow(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MouseDownUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MouseDownUnsharesRow (e As DataGridViewCellMouseEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool MouseDownUnsharesRow(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Indique si une ligne est partagée ou non lorsque l'utilisateur appuie sur le bouton de la souris alors que le pointeur est placé sur une cellule de la ligne.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.MouseDownUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnMouseDown%2A> (méthode). Dans les classes dérivées, elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnMouseDown%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDown(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseEnterUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseLeaveUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseMoveUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseUpUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseEnterUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool MouseEnterUnsharesRow (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool MouseEnterUnsharesRow(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MouseEnterUnsharesRow(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MouseEnterUnsharesRow (rowIndex As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool MouseEnterUnsharesRow(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Indique si une ligne est partagée ou non lorsque le pointeur de la souris se déplace sur une cellule de la ligne.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.MouseEnterUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnMouseEnter%2A> (méthode). Dans les classes dérivées, elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnMouseEnter%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDownUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseEnter(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseLeaveUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseMoveUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseUpUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool MouseLeaveUnsharesRow (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool MouseLeaveUnsharesRow(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MouseLeaveUnsharesRow(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MouseLeaveUnsharesRow (rowIndex As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool MouseLeaveUnsharesRow(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Indique si une ligne est partagée ou non lorsque le pointeur de la souris s'écarte de la ligne.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.MouseLeaveUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnMouseLeave%2A> (méthode). Dans les classes dérivées, elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnMouseLeave%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDownUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseEnterUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseLeave(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseMoveUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseUpUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool MouseMoveUnsharesRow (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool MouseMoveUnsharesRow(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MouseMoveUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MouseMoveUnsharesRow (e As DataGridViewCellMouseEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool MouseMoveUnsharesRow(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Indique si une ligne est partagée ou non lorsque le pointeur de la souris se déplace sur une cellule de la ligne.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.MouseMoveUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnMouseMove%2A> (méthode). Dans les classes dérivées, elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnMouseMove%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDownUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseEnterUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseLeaveUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseMove(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseUpUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseUpUnsharesRow">
      <MemberSignature Language="C#" Value="protected virtual bool MouseUpUnsharesRow (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool MouseUpUnsharesRow(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.MouseUpUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MouseUpUnsharesRow (e As DataGridViewCellMouseEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool MouseUpUnsharesRow(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Indique si une ligne est partagée ou non lorsque l’utilisateur relâche le bouton de la souris alors que le pointeur est placé sur une cellule de la ligne.</summary>
        <returns>
          <see langword="true" /> si la ligne ne doit pas être partagée ; sinon, <see langword="false" />. La classe de base <see cref="T:System.Windows.Forms.DataGridViewCell" /> retourne toujours <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.MouseUpUnsharesRow%2A> méthode est appelée juste avant la <xref:System.Windows.Forms.DataGridViewCell.OnMouseUp%2A> (méthode). Dans les classes dérivées, elle doit retourner `true` si l’appel à <xref:System.Windows.Forms.DataGridViewCell.OnMouseUp%2A> a pour effet de l’annulation du partage de la ligne contenant la cellule. Sinon, elle doit retourner `false`.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDownUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseEnterUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseLeaveUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseMoveUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (System.Windows.Forms.DataGridViewCellEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.Windows.Forms.DataGridViewCellEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As DataGridViewCellEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(System::Windows::Forms::DataGridViewCellEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelé à la suite d'un clic sur la cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellClick%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellClick?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellClick" />
      </Docs>
    </Member>
    <Member MemberName="OnContentClick">
      <MemberSignature Language="C#" Value="protected virtual void OnContentClick (System.Windows.Forms.DataGridViewCellEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentClick(class System.Windows.Forms.DataGridViewCellEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnContentClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentClick (e As DataGridViewCellEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentClick(System::Windows::Forms::DataGridViewCellEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelé lorsque l'utilisateur clique sur le contenu de la cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellContentClick%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellContentClick?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellContentClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellContentClick" />
      </Docs>
    </Member>
    <Member MemberName="OnContentDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnContentDoubleClick (System.Windows.Forms.DataGridViewCellEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentDoubleClick(class System.Windows.Forms.DataGridViewCellEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnContentDoubleClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentDoubleClick (e As DataGridViewCellEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentDoubleClick(System::Windows::Forms::DataGridViewCellEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelé lorsque l'utilisateur double-clique sur le contenu de la cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellContentDoubleClick%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellContentDoubleClick?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellContentDoubleClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellContentDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnDataGridViewChanged">
      <MemberSignature Language="C#" Value="protected override void OnDataGridViewChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDataGridViewChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnDataGridViewChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDataGridViewChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDataGridViewChanged();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé lorsque la propriété <see cref="P:System.Windows.Forms.DataGridViewElement.DataGridView" /> de la cellule est modifiée.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewElement.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (System.Windows.Forms.DataGridViewCellEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.Windows.Forms.DataGridViewCellEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnDoubleClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoubleClick (e As DataGridViewCellEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoubleClick(System::Windows::Forms::DataGridViewCellEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelé à la suite d'un double-clic sur la cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellDoubleClick%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellDoubleClick?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellDoubleClick(System.Windows.Forms.DataGridViewCellEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (int rowIndex, bool throughMouseClick);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(int32 rowIndex, bool throughMouseClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnEnter(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnter (rowIndex As Integer, throughMouseClick As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnter(int rowIndex, bool throughMouseClick);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="throughMouseClick" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <param name="throughMouseClick">
          <see langword="true" /> si une intervention de l'utilisateur a déplacé le focus vers la cellule ; <see langword="false" /> si une opération de programmation a déplacé le focus vers la cellule.</param>
        <summary>Appelé quand le focus se déplace vers une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellEnter%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellEnter?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnLeave(System.Int32,System.Boolean)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseEnter(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellEnter(System.Windows.Forms.DataGridViewCellEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e, int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e, int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnKeyDown(System.Windows.Forms.KeyEventArgs,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs, rowIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e, int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.KeyEventArgs" /> qui contient les données d'événement.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Appelé lorsqu'une touche de caractère est enfoncée tandis que le focus est sur une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.Control.OnKeyDown%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.Control.KeyDown> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyPress(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.KeyPressUnsharesRow(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyUp(System.Windows.Forms.KeyEventArgs,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e, int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e, int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnKeyPress(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyPress (e As KeyPressEventArgs, rowIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ e, int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> qui contient les données d'événement.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Appelé lorsqu'une touche est enfoncée tandis que le focus est placé sur une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.Control.OnKeyPress%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.Control.KeyPress> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyDown(System.Windows.Forms.KeyEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.KeyPressUnsharesRow(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyUp(System.Windows.Forms.KeyEventArgs,System.Int32)" />
        <altmember cref="T:System.Windows.Forms.KeyPressEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e, int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e, int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnKeyUp(System.Windows.Forms.KeyEventArgs,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs, rowIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e, int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.KeyEventArgs" /> qui contient les données d'événement.</param>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Appelé lorsqu’une touche de caractère est relâchée tandis que le focus est sur une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.Control.OnKeyUp%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.Control.KeyUp> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyDown(System.Windows.Forms.KeyEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnKeyPress(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.KeyPressUnsharesRow(System.Windows.Forms.KeyPressEventArgs,System.Int32)" />
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (int rowIndex, bool throughMouseClick);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(int32 rowIndex, bool throughMouseClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnLeave(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLeave (rowIndex As Integer, throughMouseClick As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLeave(int rowIndex, bool throughMouseClick);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="throughMouseClick" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <param name="throughMouseClick">
          <see langword="true" /> si une intervention de l'utilisateur a déplacé le focus de la cellule ; <see langword="false" /> si une opération de programmation a déplacé le focus de la cellule.</param>
        <summary>Appelé lorsque le focus se déplace d'une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellLeave%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellLeave?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnEnter(System.Int32,System.Boolean)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseLeave(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellLeave(System.Windows.Forms.DataGridViewCellEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnMouseClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseClick (e As DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseClick(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelée quand l’utilisateur clique avec un bouton de la souris pendant que le pointeur se trouve sur une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellMouseClick%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellMouseClick?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette méthode.  
  
 [!code-csharp[System.Windows.Forms.DataGridViewMisc2#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewMisc2/cs/misc2.cs#10)]
 [!code-vb[System.Windows.Forms.DataGridViewMisc2#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewMisc2/vb/misc2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDoubleClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDown(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseEnter(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseLeave(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseMove(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnMouseDoubleClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelé lorsque l'utilisateur double-clique sur le bouton de la souris alors que le pointeur est placé sur une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellMouseDoubleClick%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellMouseDoubleClick?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellMouseDoubleClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellMouseDoubleClick" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDoubleClickUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDown(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseEnter(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseLeave(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseMove(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnMouseDown(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelé lorsque l'utilisateur appuie sur le bouton de la souris alors que le pointeur est placé sur une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellMouseDown%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellMouseDown?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellMouseDown(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellMouseDown" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDoubleClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseDownUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseEnter(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseLeave(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseMove(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnMouseEnter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (rowIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Appelé lorsque le pointeur de la souris se déplace sur une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellMouseEnter%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellMouseEnter?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette méthode. Cet exemple fait partie d’un exemple plus complet disponible dans [Comment : personnaliser des cellules et des colonnes dans le contrôle DataGridView Windows Forms à l’apparence et le comportement de leur extension](~/docs/framework/winforms/controls/customize-cells-and-columns-in-the-datagrid-by-extending-behavior.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewRolloverCell#220](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewRolloverCell/CS/rollovercell.cs#220)]
 [!code-vb[System.Windows.Forms.DataGridViewRolloverCell#220](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewRolloverCell/VB/rollovercell.vb#220)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellMouseEnter(System.Windows.Forms.DataGridViewCellEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellMouseEnter" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDoubleClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDown(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseEnterUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseLeave(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseMove(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (int rowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(int32 rowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnMouseLeave(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (rowIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(int rowIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <summary>Appelée lorsque le pointeur de la souris s'écarte de la cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellMouseLeave%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellMouseLeave?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette méthode. Cet exemple fait partie d’un exemple plus complet disponible dans [Comment : personnaliser des cellules et des colonnes dans le contrôle DataGridView Windows Forms à l’apparence et le comportement de leur extension](~/docs/framework/winforms/controls/customize-cells-and-columns-in-the-datagrid-by-extending-behavior.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewRolloverCell#220](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewRolloverCell/CS/rollovercell.cs#220)]
 [!code-vb[System.Windows.Forms.DataGridViewRolloverCell#220](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewRolloverCell/VB/rollovercell.vb#220)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellMouseLeave(System.Windows.Forms.DataGridViewCellEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellMouseLeave" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDoubleClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDown(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseEnter(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseLeaveUnsharesRow(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseMove(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnMouseMove(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelé lorsque le pointeur de la souris se déplace dans une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellMouseMove%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellMouseMove?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellMouseMove(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellMouseMove" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDoubleClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDown(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseEnter(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseLeave(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseMoveUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.DataGridViewCellMouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.DataGridViewCellMouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.OnMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As DataGridViewCellMouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Forms::DataGridViewCellMouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelée quand l’utilisateur relâche un bouton de la souris alors que le pointeur est placé sur une cellule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à la <xref:System.Windows.Forms.DataGridView.OnCellMouseUp%2A?displayProperty=nameWithType> (méthode). Elle est appelée dans les mêmes circonstances dans lesquelles un <xref:System.Windows.Forms.DataGridView.CellMouseUp?displayProperty=nameWithType> événement est déclenché, mais elle ne déclenche pas réellement l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridView.OnCellMouseUp(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellMouseUp" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDoubleClick(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseDown(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseEnter(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseLeave(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.OnMouseMove(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.MouseUpUnsharesRow(System.Windows.Forms.DataGridViewCellMouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellMouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OwningColumn">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGridViewColumn OwningColumn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.DataGridViewColumn OwningColumn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.OwningColumn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwningColumn As DataGridViewColumn" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DataGridViewColumn ^ OwningColumn { System::Windows::Forms::DataGridViewColumn ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridViewColumn</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la colonne qui contient cette cellule.</summary>
        <value>
          <see cref="T:System.Windows.Forms.DataGridViewColumn" /> qui contient la cellule, ou <see langword="null" /> si la cellule n'est pas contenue dans une colonne.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.OwningRow" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" />
      </Docs>
    </Member>
    <Member MemberName="OwningRow">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGridViewRow OwningRow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.DataGridViewRow OwningRow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.OwningRow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwningRow As DataGridViewRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DataGridViewRow ^ OwningRow { System::Windows::Forms::DataGridViewRow ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridViewRow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la ligne qui contient cette cellule.</summary>
        <value>
          <see cref="T:System.Windows.Forms.DataGridViewRow" /> qui contient la cellule, ou <see langword="null" /> si la cellule n'est pas contenue dans une ligne.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.OwningColumn" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.RowIndex" />
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="protected virtual void Paint (System.Drawing.Graphics graphics, System.Drawing.Rectangle clipBounds, System.Drawing.Rectangle cellBounds, int rowIndex, System.Windows.Forms.DataGridViewElementStates cellState, object value, object formattedValue, string errorText, System.Windows.Forms.DataGridViewCellStyle cellStyle, System.Windows.Forms.DataGridViewAdvancedBorderStyle advancedBorderStyle, System.Windows.Forms.DataGridViewPaintParts paintParts);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Paint(class System.Drawing.Graphics graphics, valuetype System.Drawing.Rectangle clipBounds, valuetype System.Drawing.Rectangle cellBounds, int32 rowIndex, valuetype System.Windows.Forms.DataGridViewElementStates cellState, object value, object formattedValue, string errorText, class System.Windows.Forms.DataGridViewCellStyle cellStyle, class System.Windows.Forms.DataGridViewAdvancedBorderStyle advancedBorderStyle, valuetype System.Windows.Forms.DataGridViewPaintParts paintParts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.Paint(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Int32,System.Windows.Forms.DataGridViewElementStates,System.Object,System.Object,System.String,System.Windows.Forms.DataGridViewCellStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Windows.Forms.DataGridViewPaintParts)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Paint(System::Drawing::Graphics ^ graphics, System::Drawing::Rectangle clipBounds, System::Drawing::Rectangle cellBounds, int rowIndex, System::Windows::Forms::DataGridViewElementStates cellState, System::Object ^ value, System::Object ^ formattedValue, System::String ^ errorText, System::Windows::Forms::DataGridViewCellStyle ^ cellStyle, System::Windows::Forms::DataGridViewAdvancedBorderStyle ^ advancedBorderStyle, System::Windows::Forms::DataGridViewPaintParts paintParts);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="clipBounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="cellBounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="cellState" Type="System.Windows.Forms.DataGridViewElementStates" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="formattedValue" Type="System.Object" />
        <Parameter Name="errorText" Type="System.String" />
        <Parameter Name="cellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
        <Parameter Name="advancedBorderStyle" Type="System.Windows.Forms.DataGridViewAdvancedBorderStyle" />
        <Parameter Name="paintParts" Type="System.Windows.Forms.DataGridViewPaintParts" />
      </Parameters>
      <Docs>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> utilisé pour peindre <see cref="T:System.Windows.Forms.DataGridViewCell" />.</param>
        <param name="clipBounds">
          <see cref="T:System.Drawing.Rectangle" /> qui représente la zone de <see cref="T:System.Windows.Forms.DataGridView" /> qui doit être repeinte.</param>
        <param name="cellBounds">
          <see cref="T:System.Drawing.Rectangle" /> qui contient les limites de <see cref="T:System.Windows.Forms.DataGridViewCell" /> qui est en cours de peinture.</param>
        <param name="rowIndex">Index de ligne de la cellule qui est en train d'être peinte.</param>
        <param name="cellState">Combinaison d'opérations de bits de valeurs <see cref="T:System.Windows.Forms.DataGridViewElementStates" /> qui spécifie l'état de la cellule.</param>
        <param name="value">Données de <see cref="T:System.Windows.Forms.DataGridViewCell" /> qui est en cours de peinture.</param>
        <param name="formattedValue">Données mises en forme de <see cref="T:System.Windows.Forms.DataGridViewCell" /> qui est en cours de peinture.</param>
        <param name="errorText">Message d'erreur associé à la cellule.</param>
        <param name="cellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> qui contient les informations de mise en forme et de style relatives à la cellule.</param>
        <param name="advancedBorderStyle">
          <see cref="T:System.Windows.Forms.DataGridViewAdvancedBorderStyle" /> qui contient les styles de bordure de la cellule en cours de peinture.</param>
        <param name="paintParts">Combinaison d'opérations de bits de valeurs <see cref="T:System.Windows.Forms.DataGridViewPaintParts" />, qui spécifie les parties de la cellule qui doivent être peintes.</param>
        <summary>Peint le <see cref="T:System.Windows.Forms.DataGridViewCell" /> actif.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment substituer la <xref:System.Windows.Forms.DataGridViewCell.Paint%2A> méthode d’un <xref:System.Windows.Forms.DataGridViewButtonCell>. Cet exemple de code fait partie d’un exemple plus complet fourni dans [Comment : désactiver les boutons d’une colonne de bouton dans le contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/disable-buttons-in-a-button-column-in-the-datagrid.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridView.DisabledButtons#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.DisabledButtons/CS/form1.cs#20)]
 [!code-vb[System.Windows.Forms.DataGridView.DisabledButtons#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.DisabledButtons/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.PaintBorder(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Windows.Forms.DataGridViewCellStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle)" />
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="T:System.Windows.Forms.DataGridViewElementStates" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellStyle" />
        <altmember cref="T:System.Windows.Forms.DataGridViewAdvancedBorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="PaintBorder">
      <MemberSignature Language="C#" Value="protected virtual void PaintBorder (System.Drawing.Graphics graphics, System.Drawing.Rectangle clipBounds, System.Drawing.Rectangle bounds, System.Windows.Forms.DataGridViewCellStyle cellStyle, System.Windows.Forms.DataGridViewAdvancedBorderStyle advancedBorderStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void PaintBorder(class System.Drawing.Graphics graphics, valuetype System.Drawing.Rectangle clipBounds, valuetype System.Drawing.Rectangle bounds, class System.Windows.Forms.DataGridViewCellStyle cellStyle, class System.Windows.Forms.DataGridViewAdvancedBorderStyle advancedBorderStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.PaintBorder(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Windows.Forms.DataGridViewCellStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void PaintBorder(System::Drawing::Graphics ^ graphics, System::Drawing::Rectangle clipBounds, System::Drawing::Rectangle bounds, System::Windows::Forms::DataGridViewCellStyle ^ cellStyle, System::Windows::Forms::DataGridViewAdvancedBorderStyle ^ advancedBorderStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="clipBounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="cellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
        <Parameter Name="advancedBorderStyle" Type="System.Windows.Forms.DataGridViewAdvancedBorderStyle" />
      </Parameters>
      <Docs>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> utilisé pour peindre la bordure.</param>
        <param name="clipBounds">
          <see cref="T:System.Drawing.Rectangle" /> qui représente la zone de <see cref="T:System.Windows.Forms.DataGridView" /> qui doit être repeinte.</param>
        <param name="bounds">
          <see cref="T:System.Drawing.Rectangle" /> qui contient la zone de la bordure en cours de peinture.</param>
        <param name="cellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> qui contient les informations de mise en forme et de style relatives à la cellule active.</param>
        <param name="advancedBorderStyle">
          <see cref="T:System.Windows.Forms.DataGridViewAdvancedBorderStyle" /> qui contient les styles de bordure de la bordure en cours de peinture.</param>
        <summary>Peint la bordure du <see cref="T:System.Windows.Forms.DataGridViewCell" /> actif.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette méthode. Cet exemple fait partie d’un exemple plus complet disponible dans [Comment : désactiver les boutons d’une colonne de bouton dans le contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/disable-buttons-in-a-button-column-in-the-datagrid.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridView.DisabledButtons#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.DisabledButtons/CS/form1.cs#20)]
 [!code-vb[System.Windows.Forms.DataGridView.DisabledButtons#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.DisabledButtons/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.Paint(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Int32,System.Windows.Forms.DataGridViewElementStates,System.Object,System.Object,System.String,System.Windows.Forms.DataGridViewCellStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Windows.Forms.DataGridViewPaintParts)" />
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellStyle" />
        <altmember cref="T:System.Windows.Forms.DataGridViewAdvancedBorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="PaintErrorIcon">
      <MemberSignature Language="C#" Value="protected virtual void PaintErrorIcon (System.Drawing.Graphics graphics, System.Drawing.Rectangle clipBounds, System.Drawing.Rectangle cellValueBounds, string errorText);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void PaintErrorIcon(class System.Drawing.Graphics graphics, valuetype System.Drawing.Rectangle clipBounds, valuetype System.Drawing.Rectangle cellValueBounds, string errorText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.PaintErrorIcon(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Rectangle,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void PaintErrorIcon(System::Drawing::Graphics ^ graphics, System::Drawing::Rectangle clipBounds, System::Drawing::Rectangle cellValueBounds, System::String ^ errorText);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
        <Parameter Name="clipBounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="cellValueBounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="errorText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> utilisé pour peindre la bordure.</param>
        <param name="clipBounds">
          <see cref="T:System.Drawing.Rectangle" /> qui représente la zone de <see cref="T:System.Windows.Forms.DataGridView" /> qui doit être repeinte.</param>
        <param name="cellValueBounds">Rectangle <see cref="T:System.Drawing.Rectangle" /> englobant qui définit la zone de contenu de la cellule.</param>
        <param name="errorText">Message d'erreur associé à la cellule.</param>
        <summary>Peint l'icône d'erreur du <see cref="T:System.Windows.Forms.DataGridViewCell" /> actif.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `errorText` paramètre signale la présence d’une erreur. Si `errorText` est `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, le <xref:System.Windows.Forms.DataGridViewCell.PaintErrorIcon%2A> méthode ne fait rien.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.Paint(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Int32,System.Windows.Forms.DataGridViewElementStates,System.Object,System.Object,System.String,System.Windows.Forms.DataGridViewCellStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Windows.Forms.DataGridViewPaintParts)" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.PaintBorder(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Windows.Forms.DataGridViewCellStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle)" />
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Drawing.Rectangle" />
      </Docs>
    </Member>
    <Member MemberName="ParseFormattedValue">
      <MemberSignature Language="C#" Value="public virtual object ParseFormattedValue (object formattedValue, System.Windows.Forms.DataGridViewCellStyle cellStyle, System.ComponentModel.TypeConverter formattedValueTypeConverter, System.ComponentModel.TypeConverter valueTypeConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ParseFormattedValue(object formattedValue, class System.Windows.Forms.DataGridViewCellStyle cellStyle, class System.ComponentModel.TypeConverter formattedValueTypeConverter, class System.ComponentModel.TypeConverter valueTypeConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.ParseFormattedValue(System.Object,System.Windows.Forms.DataGridViewCellStyle,System.ComponentModel.TypeConverter,System.ComponentModel.TypeConverter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ParseFormattedValue (formattedValue As Object, cellStyle As DataGridViewCellStyle, formattedValueTypeConverter As TypeConverter, valueTypeConverter As TypeConverter) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ParseFormattedValue(System::Object ^ formattedValue, System::Windows::Forms::DataGridViewCellStyle ^ cellStyle, System::ComponentModel::TypeConverter ^ formattedValueTypeConverter, System::ComponentModel::TypeConverter ^ valueTypeConverter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattedValue" Type="System.Object" />
        <Parameter Name="cellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
        <Parameter Name="formattedValueTypeConverter" Type="System.ComponentModel.TypeConverter" />
        <Parameter Name="valueTypeConverter" Type="System.ComponentModel.TypeConverter" />
      </Parameters>
      <Docs>
        <param name="formattedValue">Valeur d'affichage de la cellule.</param>
        <param name="cellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> en vigueur pour la cellule.</param>
        <param name="formattedValueTypeConverter">
          <see cref="T:System.ComponentModel.TypeConverter" /> pour le type valeur de l'affichage ou <see langword="null" /> pour utiliser le convertisseur par défaut.</param>
        <param name="valueTypeConverter">
          <see cref="T:System.ComponentModel.TypeConverter" /> pour le type valeur de la cellule ou <see langword="null" /> pour utiliser le convertisseur par défaut.</param>
        <summary>Convertit une valeur mise en forme pour l'affichage en une valeur de cellule réelle.</summary>
        <returns>Valeur de la cellule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’utilisateur modifie une valeur de cellule et valide la modification, le <xref:System.Windows.Forms.DataGridView> contrôle appelle cette méthode pour convertir la valeur affichée à partir de la <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> à la <xref:System.Windows.Forms.DataGridViewCell.ValueType%2A>. Le contrôle affecte ensuite la valeur de cellule sous-jacente ou la valeur de source de données à la valeur convertie.  
  
 L’implémentation par défaut de cette méthode analyse la `formattedValue` à l’aide du paramètre le <xref:System.Windows.Forms.DataGridViewCellStyle.NullValue%2A>, <xref:System.Windows.Forms.DataGridViewCellStyle.DataSourceNullValue%2A>, et <xref:System.Windows.Forms.DataGridViewCellStyle.FormatProvider%2A> propriétés du style de cellule indiquaient par le `cellStyle` paramètre.  
  
 Si `formattedValue` est égal à <xref:System.Windows.Forms.DataGridViewCellStyle.NullValue%2A>, cette méthode retourne la valeur de la <xref:System.Windows.Forms.DataGridViewCellStyle.DataSourceNullValue%2A> propriété ou `null` si <xref:System.Windows.Forms.DataGridViewCellStyle.DataSourceNullValue%2A> est <xref:System.DBNull.Value?displayProperty=nameWithType> et la cellule <xref:System.Windows.Forms.DataGridViewCell.ValueType%2A> est un type référence.  
  
 Si `formattedValue` n’est pas égal à <xref:System.Windows.Forms.DataGridViewCellStyle.NullValue%2A>, cette méthode analyse `formattedValue` à l’aide de la <xref:System.Windows.Forms.DataGridViewCellStyle.FormatProvider%2A> propriété et le texte spécifié ou les convertisseurs de valeur par défaut.  
  
 Si la cellule <xref:System.Windows.Forms.DataGridViewCell.ValueType%2A> est nullable, cette méthode encapsule la valeur de retour comme un <xref:System.Nullable%601> type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cellStyle" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La valeur de la propriété <see cref="P:System.Windows.Forms.DataGridViewCell.FormattedValueType" /> est <see langword="null" />.  
  
 - ou -  
  
 La valeur de la propriété <see cref="P:System.Windows.Forms.DataGridViewCell.ValueType" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="formattedValue" /> ne peut pas être converti.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="formattedValue" /> est <see langword="null" />.  
  
 - ou -  
  
 Le type de <paramref name="formattedValue" /> ne correspond pas au type indiqué par la propriété <see cref="P:System.Windows.Forms.DataGridViewCell.FormattedValueType" />.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCellStyle.NullValue" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCellStyle.DataSourceNullValue" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCellStyle.FormatProvider" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.ValueType" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.GetFormattedValue(System.Object,System.Int32,System.Windows.Forms.DataGridViewCellStyle@,System.ComponentModel.TypeConverter,System.ComponentModel.TypeConverter,System.Windows.Forms.DataGridViewDataErrorContexts)" />
        <altmember cref="T:System.Nullable`1" />
      </Docs>
    </Member>
    <Member MemberName="PositionEditingControl">
      <MemberSignature Language="C#" Value="public virtual void PositionEditingControl (bool setLocation, bool setSize, System.Drawing.Rectangle cellBounds, System.Drawing.Rectangle cellClip, System.Windows.Forms.DataGridViewCellStyle cellStyle, bool singleVerticalBorderAdded, bool singleHorizontalBorderAdded, bool isFirstDisplayedColumn, bool isFirstDisplayedRow);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PositionEditingControl(bool setLocation, bool setSize, valuetype System.Drawing.Rectangle cellBounds, valuetype System.Drawing.Rectangle cellClip, class System.Windows.Forms.DataGridViewCellStyle cellStyle, bool singleVerticalBorderAdded, bool singleHorizontalBorderAdded, bool isFirstDisplayedColumn, bool isFirstDisplayedRow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.PositionEditingControl(System.Boolean,System.Boolean,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Windows.Forms.DataGridViewCellStyle,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PositionEditingControl (setLocation As Boolean, setSize As Boolean, cellBounds As Rectangle, cellClip As Rectangle, cellStyle As DataGridViewCellStyle, singleVerticalBorderAdded As Boolean, singleHorizontalBorderAdded As Boolean, isFirstDisplayedColumn As Boolean, isFirstDisplayedRow As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PositionEditingControl(bool setLocation, bool setSize, System::Drawing::Rectangle cellBounds, System::Drawing::Rectangle cellClip, System::Windows::Forms::DataGridViewCellStyle ^ cellStyle, bool singleVerticalBorderAdded, bool singleHorizontalBorderAdded, bool isFirstDisplayedColumn, bool isFirstDisplayedRow);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="setLocation" Type="System.Boolean" />
        <Parameter Name="setSize" Type="System.Boolean" />
        <Parameter Name="cellBounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="cellClip" Type="System.Drawing.Rectangle" />
        <Parameter Name="cellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
        <Parameter Name="singleVerticalBorderAdded" Type="System.Boolean" />
        <Parameter Name="singleHorizontalBorderAdded" Type="System.Boolean" />
        <Parameter Name="isFirstDisplayedColumn" Type="System.Boolean" />
        <Parameter Name="isFirstDisplayedRow" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="setLocation">
          <see langword="true" /> pour que le contrôle soit placé de la manière spécifiée par les autres arguments ; <see langword="false" /> pour que le contrôle se place lui-même.</param>
        <param name="setSize">
          <see langword="true" /> pour spécifier la taille ; <see langword="false" /> pour que le contrôle définisse sa taille lui-même.</param>
        <param name="cellBounds">
          <see cref="T:System.Drawing.Rectangle" /> qui définit les limites de la cellule.</param>
        <param name="cellClip">Zone utilisée pour peindre le contrôle d'édition.</param>
        <param name="cellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> qui représente le style de la cellule en cours modification.</param>
        <param name="singleVerticalBorderAdded">
          <see langword="true" /> pour ajouter une bordure verticale à la cellule ; sinon, <see langword="false" />.</param>
        <param name="singleHorizontalBorderAdded">
          <see langword="true" /> pour ajouter une bordure horizontale à la cellule ; sinon, <see langword="false" />.</param>
        <param name="isFirstDisplayedColumn">
          <see langword="true" /> si la cellule d'hébergement figure dans la première colonne visible ; sinon, <see langword="false" />.</param>
        <param name="isFirstDisplayedRow">
          <see langword="true" /> si la cellule d'hébergement figure dans la première ligne visible ; sinon, <see langword="false" />.</param>
        <summary>Définit l'emplacement et la taille du contrôle d'édition hébergé par une cellule dans le contrôle <see cref="T:System.Windows.Forms.DataGridView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certaines classes dérivées de la <xref:System.Windows.Forms.DataGridViewCell> class, telle que <xref:System.Windows.Forms.DataGridViewComboBoxCell>, héberger un contrôle dans la cellule sélectionnée. Le <xref:System.Windows.Forms.DataGridViewCell.PositionEditingControl%2A> méthode positionne le contrôle d’édition dans la cellule de l’hôte. Étant donné que le contrôle d’édition peut prendre plus d’espace qu’une cellule unique, il devra être positionné différemment lors de la modification d’une cellule dans la première colonne visible ou la première ligne visible afin qu’il ne dessinera pas en dehors de la <xref:System.Windows.Forms.DataGridView>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cellule n'est pas contenue dans un contrôle <see cref="T:System.Windows.Forms.DataGridView" />.</exception>
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.AdjustCellBorderStyle(System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Windows.Forms.DataGridViewAdvancedBorderStyle,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.DataGridViewComboBoxCell" />
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="PositionEditingPanel">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle PositionEditingPanel (System.Drawing.Rectangle cellBounds, System.Drawing.Rectangle cellClip, System.Windows.Forms.DataGridViewCellStyle cellStyle, bool singleVerticalBorderAdded, bool singleHorizontalBorderAdded, bool isFirstDisplayedColumn, bool isFirstDisplayedRow);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Rectangle PositionEditingPanel(valuetype System.Drawing.Rectangle cellBounds, valuetype System.Drawing.Rectangle cellClip, class System.Windows.Forms.DataGridViewCellStyle cellStyle, bool singleVerticalBorderAdded, bool singleHorizontalBorderAdded, bool isFirstDisplayedColumn, bool isFirstDisplayedRow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.PositionEditingPanel(System.Drawing.Rectangle,System.Drawing.Rectangle,System.Windows.Forms.DataGridViewCellStyle,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PositionEditingPanel (cellBounds As Rectangle, cellClip As Rectangle, cellStyle As DataGridViewCellStyle, singleVerticalBorderAdded As Boolean, singleHorizontalBorderAdded As Boolean, isFirstDisplayedColumn As Boolean, isFirstDisplayedRow As Boolean) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Rectangle PositionEditingPanel(System::Drawing::Rectangle cellBounds, System::Drawing::Rectangle cellClip, System::Windows::Forms::DataGridViewCellStyle ^ cellStyle, bool singleVerticalBorderAdded, bool singleHorizontalBorderAdded, bool isFirstDisplayedColumn, bool isFirstDisplayedRow);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cellBounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="cellClip" Type="System.Drawing.Rectangle" />
        <Parameter Name="cellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
        <Parameter Name="singleVerticalBorderAdded" Type="System.Boolean" />
        <Parameter Name="singleHorizontalBorderAdded" Type="System.Boolean" />
        <Parameter Name="isFirstDisplayedColumn" Type="System.Boolean" />
        <Parameter Name="isFirstDisplayedRow" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cellBounds">
          <see cref="T:System.Drawing.Rectangle" /> qui définit les limites de la cellule.</param>
        <param name="cellClip">Zone utilisée pour peindre le panneau d'édition.</param>
        <param name="cellStyle">
          <see cref="T:System.Windows.Forms.DataGridViewCellStyle" /> qui représente le style de la cellule en cours modification.</param>
        <param name="singleVerticalBorderAdded">
          <see langword="true" /> pour ajouter une bordure verticale à la cellule ; sinon, <see langword="false" />.</param>
        <param name="singleHorizontalBorderAdded">
          <see langword="true" /> pour ajouter une bordure horizontale à la cellule ; sinon, <see langword="false" />.</param>
        <param name="isFirstDisplayedColumn">
          <see langword="true" /> si la cellule est contenue dans la première colonne actuellement affichée dans le contrôle ; sinon, <see langword="false" />.</param>
        <param name="isFirstDisplayedRow">
          <see langword="true" /> si la cellule est contenue dans la première ligne actuellement affichée dans le contrôle ; sinon, <see langword="false" />.</param>
        <summary>Définit l'emplacement et la taille du panneau d'édition hébergé par la cellule, et retourne les limites normales du contrôle d'édition dans le panneau d'édition.</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" /> qui représente les limites normales du contrôle d'édition dans le panneau d'édition.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La cellule n'a pas été ajoutée à un contrôle <see cref="T:System.Windows.Forms.DataGridView" />.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.PreferredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size PreferredSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille, en pixels, d'une zone rectangulaire qui peut contenir la cellule.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> contenant la hauteur et largeur, en pixels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.PreferredSize%2A> propriété retourne la taille physique de la cellule calculée par la cellule propriétaire de ligne et colonne. <xref:System.Windows.Forms.DataGridViewCell.PreferredSize%2A> Retourne un <xref:System.Drawing.Size> avec une largeur et une hauteur de -1 si la cellule n’est pas contenue dans une table.  
  
 Si la cellule est dans un <xref:System.Windows.Forms.DataGridViewColumn> qui a son <xref:System.Windows.Forms.DataGridViewColumn.Resizable%2A> propriété `false`, -1 est retourné pour la largeur.  
  
 Cette méthode s’appuie sur la <xref:System.Windows.Forms.DataGridViewCell.GetFormattedValue%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La ligne qui contient la cellule est une ligne partagée.  
  
 - ou -  
  
 La cellule est une cellule d'en-tête de colonne.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.GetPreferredSize(System.Drawing.Graphics,System.Windows.Forms.DataGridViewCellStyle,System.Int32,System.Drawing.Size)" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Size" />
        <altmember cref="T:System.Drawing.Size" />
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellStyle" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les données de la cellule peuvent être modifiées.</summary>
        <value>
          <see langword="true" /> si les données de la cellule ne peuvent pas être modifiées ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridViewCell.ReadOnly%2A> propriété indique si les données affichées par la cellule peuvent être modifiées. Vous pouvez définir <xref:System.Windows.Forms.DataGridViewCell.ReadOnly%2A> pour les cellules individuelles, ou vous pouvez définir un ensemble de la ligne ou la colonne de cellules en lecture seule en définissant le <xref:System.Windows.Forms.DataGridViewRow.ReadOnly%2A?displayProperty=nameWithType> ou <xref:System.Windows.Forms.DataGridViewColumn.ReadOnly%2A?displayProperty=nameWithType> propriétés. Par défaut, si la ligne parente d’une cellule ou une colonne est définie en lecture seule, les cellules enfants adoptent la même valeur. Vous pouvez substituer ce comportement par défaut en définissant <xref:System.Windows.Forms.DataGridViewCell.ReadOnly%2A> pour les cellules individuelles.  
  
 Vous pouvez accéder à une cellule en lecture seule, et vous pouvez définir une cellule en lecture seule à la cellule en cours.  
  
 <xref:System.Windows.Forms.DataGridViewCell.ReadOnly%2A> affecte uniquement si une cellule est modifiable ; Il n’affecte pas si l’utilisateur peut supprimer des lignes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il n'existe aucune ligne propriétaire lors de la définition de cette propriété.  
  
 - ou -  
  
 La ligne propriétaire est partagée lors de la définition de cette propriété.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewElementStates" />
        <altmember cref="P:System.Windows.Forms.DataGridViewRow.ReadOnly" />
        <altmember cref="P:System.Windows.Forms.DataGridViewColumn.ReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Resizable">
      <MemberSignature Language="C#" Value="public virtual bool Resizable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Resizable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.Resizable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Resizable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Resizable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la cellule peut être redimensionnée.</summary>
        <value>
          <see langword="true" /> si la cellule peut être redimensionnée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.Windows.Forms.DataGridViewCell.Resizable%2A> propriété est définie par la ligne parente de la cellule ou la colonne.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewElementStates" />
      </Docs>
    </Member>
    <Member MemberName="RowIndex">
      <MemberSignature Language="C#" Value="public int RowIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RowIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.RowIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RowIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RowIndex { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'index de la ligne parente de la cellule.</summary>
        <value>Index de la ligne qui contient la cellule ; -1 s'il n'y a aucune ligne propriétaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.DataGridViewCell.RowIndex%2A> propriété retourne -1, la cellule est un en-tête de colonne ou ligne de la cellule est partagée.  
  
 Pour plus d’informations sur le partage de lignes, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette propriété.  
  
 [!code-csharp[System.Windows.Forms.DataGridViewMisc#080](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewMisc/CS/datagridviewmisc.cs#080)]
 [!code-vb[System.Windows.Forms.DataGridViewMisc#080](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewMisc/VB/datagridviewmisc.vb#080)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" />
      </Docs>
    </Member>
    <Member MemberName="Selected">
      <MemberSignature Language="C#" Value="public virtual bool Selected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Selected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.Selected" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Selected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Selected { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la cellule a été sélectionnée.</summary>
        <value>
          <see langword="true" /> si la cellule a été sélectionnée ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Il n'existe aucun <see cref="T:System.Windows.Forms.DataGridView" /> associé lors de la définition de cette propriété.  
  
 - ou -  
  
 La ligne propriétaire est partagée lors de la définition de cette propriété.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewElementStates" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="protected virtual bool SetValue (int rowIndex, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool SetValue(int32 rowIndex, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.SetValue(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SetValue (rowIndex As Integer, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool SetValue(int rowIndex, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Index de la ligne parente de la cellule.</param>
        <param name="value">Valeur de cellule à définir.</param>
        <summary>Définit la valeur de la cellule.</summary>
        <returns>
          <see langword="true" /> si la valeur a été définie ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="rowIndex" /> est inférieur à 0 ou supérieur ou égal au nombre de lignes contenues dans le <see cref="T:System.Windows.Forms.DataGridView" /> parent.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Value" />
        <altmember cref="M:System.Windows.Forms.DataGridViewCell.GetValue(System.Int32)" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.FormattedValue" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille de la cellule.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> qui a la valeur de la hauteur de la ligne propriétaire et la largeur de la colonne propriétaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la cellule n’est pas associée à un <xref:System.Windows.Forms.DataGridView> (contrôle), le <xref:System.Windows.Forms.DataGridViewCell.Size%2A> propriété retourne un <xref:System.Drawing.Size> avec une largeur et une hauteur de -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La ligne qui contient la cellule est une ligne partagée.  
  
 - ou -  
  
 La cellule est une cellule d'en-tête de colonne.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.PreferredSize" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGridViewCellStyle Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.DataGridViewCellStyle Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As DataGridViewCellStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DataGridViewCellStyle ^ Style { System::Windows::Forms::DataGridViewCellStyle ^ get(); void set(System::Windows::Forms::DataGridViewCellStyle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridViewCellStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le style de la cellule.</summary>
        <value>Style associé à la cellule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DataGridView> contrôle affiche ses cellules à l’aide des styles indiqués par la cellule <xref:System.Windows.Forms.DataGridViewCell.InheritedStyle%2A> propriété, qui hérite des styles d’autres propriétés de type <xref:System.Windows.Forms.DataGridViewCellStyle>. Les styles spécifiés via le <xref:System.Windows.Forms.DataGridViewCell.Style%2A> propriété substituent les styles spécifiés via toutes les autres propriétés de style de cellule, mais n’indiquent pas nécessairement tous les styles qui contribuent à l’apparence de la cellule.  
  
 Pour plus d’informations, consultez [Styles de cellules dans le contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/cell-styles-in-the-windows-forms-datagridview-control.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.DataGridViewCell.Style%2A> propriété à obtenir la couleur d’arrière-plan d’une cellule. Cet exemple fait partie d’un exemple de code plus complet fourni pour la <xref:System.Windows.Forms.DataGridViewColumn> classe.  
  
 [!code-cpp[System.Windows.Forms.DataGridView.ButtonDemos#120](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.ButtonDemos/CPP/DataGridViewColumnDemo.cpp#120)]
 [!code-csharp[System.Windows.Forms.DataGridView.ButtonDemos#120](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.ButtonDemos/CS/DataGridViewColumnDemo.cs#120)]
 [!code-vb[System.Windows.Forms.DataGridView.ButtonDemos#120](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.ButtonDemos/VB/datagridviewcolumndemo.vb#120)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellStyle" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellStyleChanged" />
        <altmember cref="P:System.Windows.Forms.DataGridView.DefaultCellStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridViewRow.DefaultCellStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridViewColumn.DefaultCellStyle" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet qui contient les données supplémentaires relatives à la cellule.</summary>
        <value>
          <see cref="T:System.Object" /> qui contient les données relatives à la cellule. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’importe quel type dérivé de la <xref:System.Object> classe peut être affectée à cette propriété. Le <xref:System.Windows.Forms.DataGridViewCell.Tag%2A> propriété est généralement utilisée pour stocker les données qui sont étroitement associées à la valeur affichée par la cellule.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Value" />
        <altmember cref="T:System.Object" />
        <altmember cref="P:System.Windows.Forms.Control.Tag" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipText">
      <MemberSignature Language="C#" Value="public string ToolTipText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ToolTipText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.ToolTipText" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTipText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ToolTipText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte d'info-bulle associé à cette cellule.</summary>
        <value>Texte d'info-bulle associé à la cellule. La valeur par défaut est <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété s’affiche en tant que la cellule info-bulle lorsque le pointeur de la souris est sur la cellule et la valeur de propriété n’est pas <xref:System.String.Empty>. Si la valeur de cette propriété est <xref:System.String.Empty>, la cellule affiche une info-bulle contenant la valeur de la cellule si la valeur est tronquée dans l’affichage de la cellule ; sinon, la cellule n’affichera pas une info-bulle. Vous pouvez également empêcher l’affichage d’une info-bulle en définissant le <xref:System.Windows.Forms.DataGridView.ShowCellToolTips%2A?displayProperty=nameWithType> propriété `false`.  
  
 Lorsque le <xref:System.Windows.Forms.DataGridView> contrôle <xref:System.Windows.Forms.DataGridView.DataSource%2A> est définie ou son <xref:System.Windows.Forms.DataGridView.VirtualMode%2A> propriété est `true`, obtention de la valeur de la <xref:System.Windows.Forms.DataGridViewCell.ToolTipText%2A> propriété déclenche le <xref:System.Windows.Forms.DataGridView.CellToolTipTextNeeded> événement du contrôle et retourne la valeur de la <xref:System.Windows.Forms.DataGridViewCellToolTipTextNeededEventArgs.ToolTipText%2A?displayProperty=nameWithType> la propriété spécifiée dans l’événement gestionnaire. S’il n’y a aucun gestionnaire pour l’événement, obtenir la valeur de la <xref:System.Windows.Forms.DataGridViewCell.ToolTipText%2A> propriété retourne la valeur précédemment spécifiée ou sa valeur par défaut <xref:System.String.Empty>.  
  
 Gère la <xref:System.Windows.Forms.DataGridView.CellToolTipTextNeeded> événement est particulièrement utile lorsque vous travaillez avec de grandes quantités de données pour éviter de trop handicaper les performances lors de la définition de la cellule <xref:System.Windows.Forms.DataGridViewCell.ToolTipText%2A> valeur pour plusieurs cellules. Pour plus d’informations, consultez [meilleures pratiques pour la mise à l’échelle du contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/best-practices-for-scaling-the-windows-forms-datagridview-control.md).  
  
 La modification de cette propriété déclenche le <xref:System.Windows.Forms.DataGridView.CellToolTipTextChanged> événement sur le propriétaire <xref:System.Windows.Forms.DataGridView>, s’il en existe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir la <xref:System.Windows.Forms.DataGridViewCell.ToolTipText%2A> propriété dans un gestionnaire d’événements pour le <xref:System.Windows.Forms.DataGridView.CellFormatting> événement. Cet exemple fait partie d’un exemple de code plus complet fourni dans [Comment : ajouter des info-bulles à des cellules dans un contrôle Windows Forms DataGridView](~/docs/framework/winforms/controls/add-tooltips-to-individual-cells-in-a-wf-datagridview-control.md).  
  
 [!code-cpp[System.Windows.Forms.DataGridViewCell.ToolTipText#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCell.ToolTipText/cpp/datagridviewcell.tooltiptext.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataGridViewCell.ToolTipText#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCell.ToolTipText/CS/datagridviewcell.tooltiptext.cs#1)]
 [!code-vb[System.Windows.Forms.DataGridViewCell.ToolTipText#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCell.ToolTipText/VB/datagridviewcell.tooltiptext.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridView.ShowCellToolTips" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellToolTipTextChanged" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellToolTipTextNeeded" />
        <altmember cref="P:System.Windows.Forms.DataGridView.DataSource" />
        <altmember cref="P:System.Windows.Forms.DataGridView.VirtualMode" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGridViewCell.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne qui décrit l’objet actif.</summary>
        <returns>Chaîne qui représente l'objet actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sauf indication contraire, la <xref:System.Windows.Forms.DataGridViewCell.ToString%2A> méthode pour tous les types de cellules retourne une chaîne au format indiqué dans l’exemple de code suivant :  
  
 `Classname {RowIndex = #, ColumnIndex = #}`  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.Value" />
      <MemberSignature Language="VB.NET" Value="Public Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur associée à cette cellule.</summary>
        <value>Obtient ou définit les données à afficher par la cellule. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous affectez une valeur différente à une cellule, la <xref:System.Windows.Forms.DataGridView.CellValueChanged> l’événement de la <xref:System.Windows.Forms.DataGridView> contrôle est déclenché.  
  
 Le <xref:System.Windows.Forms.DataGridViewCell.Value%2A> propriété est l’objet de données réelles contenue dans la cellule, alors que le <xref:System.Windows.Forms.DataGridViewCell.FormattedValue%2A> propriété est la représentation sous forme de mise en forme des données. Le <xref:System.Windows.Forms.DataGridViewCell.ValueType%2A> et <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> les propriétés correspondent aux types de données de ces valeurs, respectivement.  
  
 Lorsque vous définissez le <xref:System.Windows.Forms.DataGridViewCell.Value%2A> propriété, la valeur spécifiée n’est pas automatiquement converti à partir d’une mise en forme, une valeur d’affichage en une valeur de cellule sous-jacente. Par exemple, le <xref:System.Windows.Forms.DataGridViewCellStyle> en vigueur pour la cellule est ignorée, affectant ainsi <xref:System.Windows.Forms.DataGridViewCell.Value%2A> à <xref:System.Windows.Forms.DataGridViewCellStyle.NullValue%2A?displayProperty=nameWithType> n’entraîne pas une valeur de propriété <xref:System.Windows.Forms.DataGridViewCellStyle.DataSourceNullValue%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment mettre à jour le contenu d’une cellule avec la <xref:System.Windows.Forms.DataGridViewCell.Value%2A> propriété. Cet exemple fait partie d’un exemple de code plus complet fourni dans [Comment : manipuler les lignes dans le contrôle DataGridView Windows Forms](~/docs/framework/winforms/controls/how-to-manipulate-rows-in-the-windows-forms-datagridview-control.md).  
  
 [!code-cpp[System.Windows.Forms.DataGridView.ButtonDemos#211](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.ButtonDemos/CPP/DataGridViewRowDemo.cpp#211)]
 [!code-csharp[System.Windows.Forms.DataGridView.ButtonDemos#211](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.ButtonDemos/CS/DataGridViewRowDemo.cs#211)]
 [!code-vb[System.Windows.Forms.DataGridView.ButtonDemos#211](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridView.ButtonDemos/VB/datagridviewrowdemo.vb#211)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Windows.Forms.DataGridViewCell.RowIndex" /> est en dehors de la plage valide comprise entre 0 et le nombre de lignes du contrôle moins 1.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.DataGridViewCell.ColumnIndex" /> est inférieur à 0, ce qui indique que la cellule est une cellule d'en-tête de ligne.</exception>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Tag" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.ValueType" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.FormattedValue" />
        <altmember cref="E:System.Windows.Forms.DataGridView.CellValueChanged" />
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); void set(Type ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type de données des valeurs de la cellule.</summary>
        <value>
          <see cref="T:System.Type" /> représentant le type de données de la valeur de la cellule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Forms.DataGridViewCell.ValueType%2A> propriété pour la cellule n’a pas été définie, le <xref:System.Windows.Forms.DataGridViewColumn.ValueType%2A?displayProperty=nameWithType> propriété de la colonne propriétaire est utilisée, si elle existe.  
  
 Le <xref:System.Windows.Forms.DataGridViewCell.Value%2A> propriété est l’objet de données réelles contenue dans la cellule, alors que le <xref:System.Windows.Forms.DataGridViewCell.FormattedValue%2A> propriété est la représentation sous forme de mise en forme des données. Le <xref:System.Windows.Forms.DataGridViewCell.ValueType%2A> et <xref:System.Windows.Forms.DataGridViewCell.FormattedValueType%2A> les propriétés correspondent aux types de données de ces valeurs, respectivement.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette propriété.  
  
 [!code-csharp[System.Windows.Forms.DataGridViewMisc2#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewMisc2/cs/misc2.cs#20)]
 [!code-vb[System.Windows.Forms.DataGridViewMisc2#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewMisc2/vb/misc2.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Value" />
        <altmember cref="P:System.Windows.Forms.DataGridViewColumn.ValueType" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.FormattedValueType" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGridViewCell.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la cellule est contenue dans une ligne ou une colonne masquée.</summary>
        <value>
          <see langword="true" /> si la cellule est visible ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété indique si la cellule est dans une ligne ou une colonne avec son <xref:System.Windows.Forms.DataGridViewBand.Visible%2A> propriété `false`. Il n’indique pas si la cellule a été atteint hors écran. Pour déterminer si une cellule est visible dans la zone d’affichage du contrôle, utilisez le <xref:System.Windows.Forms.DataGridViewCell.Displayed%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.DataGridViewColumn.Visible" />
        <altmember cref="P:System.Windows.Forms.DataGridViewRow.Visible" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.Displayed" />
      </Docs>
    </Member>
  </Members>
</Type>