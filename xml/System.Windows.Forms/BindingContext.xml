<Type Name="BindingContext" FullName="System.Windows.Forms.BindingContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8f6ddb435768b87888bde88d1f6cab997cd0f531" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56378525" /></Metadata><TypeSignature Language="C#" Value="public class BindingContext : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingContext extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingContext" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingContext&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingContext : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BindingContext = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("CollectionChanged")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gère la collection d'objets <see cref="T:System.Windows.Forms.BindingManagerBase" /> pour tout objet héritant de la classe <see cref="T:System.Windows.Forms.Control" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque formulaire Windows possède au moins un <xref:System.Windows.Forms.BindingContext> objet qui gère la <xref:System.Windows.Forms.BindingManagerBase> objets pour le formulaire. Étant donné que le <xref:System.Windows.Forms.BindingManagerBase> classe est abstraite, le type de retour de la <xref:System.Windows.Forms.BindingContext.Item%2A> propriété est un <xref:System.Windows.Forms.CurrencyManager> ou un <xref:System.Windows.Forms.PropertyManager>. Si la source de données est un objet qui peut retourner qu’une seule propriété (au lieu d’une liste d’objets), le <xref:System.Type> est un <xref:System.Windows.Forms.PropertyManager>. Par exemple, si vous spécifiez un <xref:System.Windows.Forms.TextBox> comme source de données, un <xref:System.Windows.Forms.PropertyManager> est retourné. En revanche, si la source de données est un objet qui implémente <xref:System.Collections.IList> ou <xref:System.ComponentModel.IBindingList>, un <xref:System.Windows.Forms.CurrencyManager> est retourné.  
  
 Pour chaque source de données sur un formulaire Windows, il existe un seul <xref:System.Windows.Forms.CurrencyManager> ou <xref:System.Windows.Forms.PropertyManager>. Car il peut y avoir plusieurs sources de données associées à un formulaire Windows, le <xref:System.Windows.Forms.BindingContext> vous permet de récupérer n’importe quel <xref:System.Windows.Forms.CurrencyManager> associé à une source de données.  
  
> [!NOTE]
>  Lorsque vous utilisez le <xref:System.Windows.Forms.BindingContext.Item%2A> propriété, le <xref:System.Windows.Forms.BindingContext> crée un nouveau <xref:System.Windows.Forms.BindingManagerBase> si celle-ci n’existe pas. Cela peut entraîner une certaine confusion, comme l’objet retourné ne peut pas gérer la liste (ou n’importe quelle liste) que vous avez l’intention. Pour éviter de retourner un non valide <xref:System.Windows.Forms.BindingManagerBase>, utilisez le <xref:System.Windows.Forms.BindingContext.Contains%2A> méthode pour déterminer si le prévu <xref:System.Windows.Forms.BindingManagerBase> existe déjà.  
  
 Si vous utilisez un contrôle conteneur, comme un <xref:System.Windows.Forms.GroupBox>, <xref:System.Windows.Forms.Panel>, ou <xref:System.Windows.Forms.TabControl>, pour contenir des contrôles liés aux données, vous pouvez créer un <xref:System.Windows.Forms.BindingContext> uniquement pour ce conteneur contrôle et ses contrôles. Ensuite, chaque partie de votre formulaire peut être géré par son propre <xref:System.Windows.Forms.BindingManagerBase>. Consultez le <xref:System.Windows.Forms.BindingContext.%23ctor%2A> constructeur pour plus d’informations sur la création de plusieurs <xref:System.Windows.Forms.BindingManagerBase> objets pour la même source de données.  
  
 Si vous ajoutez un <xref:System.Windows.Forms.TextBox> contrôle à un formulaire et le lier à une colonne d’une table dans un jeu de données, le contrôle communique avec le <xref:System.Windows.Forms.BindingContext> de ce formulaire. Le <xref:System.Windows.Forms.BindingContext>, à son tour, communique avec le spécifique <xref:System.Windows.Forms.CurrencyManager> pour cette association de données. Si vous l’interrogé le `Position` propriété de la <xref:System.Windows.Forms.CurrencyManager>, elle signalait l’enregistrement en cours pour la liaison de ce <xref:System.Windows.Forms.TextBox> contrôle. Dans l’exemple de code suivant, un <xref:System.Windows.Forms.TextBox> contrôle est lié à la `FirstName` colonne d’un `Customers` table sur le `dataSet1` jeu de données via le <xref:System.Windows.Forms.BindingContext> pour le formulaire, il se trouve sur.  
  
```vb  
TextBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName")  
  
```  
  
```csharp  
textBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName");  
  
```  
  
```cpp  
textBox1->DataBindings->Add("Text", dataSet1, "Customers.FirstName");  
```  
  
 Vous pouvez ajouter un deuxième <xref:System.Windows.Forms.TextBox> contrôle (`TextBox2`) au formulaire et liez-le à le `LastName` colonne de la `Customers` table dans le même jeu de données. Le <xref:System.Windows.Forms.BindingContext> tient compte de la première liaison (`TextBox1` à `Customers.FirstName`), il utilise le même <xref:System.Windows.Forms.CurrencyManager>, comme les deux zones de texte sont liés à un même dataset (`DataSet1`).  
  
```vb  
TextBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName")  
  
```  
  
```csharp  
textBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName");  
  
```  
  
```cpp  
textBox2->DataBindings->Add("Text", dataSet1, "Customers.LastName");  
```  
  
 Si vous liez `TextBox2` à un dataset différent, le <xref:System.Windows.Forms.BindingContext> crée et gère un deuxième <xref:System.Windows.Forms.CurrencyManager>.  
  
 Il est important d’être cohérent dans la façon dont vous définissez la <xref:System.Windows.Forms.ListControl.DataSource%2A> et <xref:System.Windows.Forms.ListControl.DisplayMember%2A> propriétés ; sinon, le <xref:System.Windows.Forms.BindingContext> crée plusieurs gestionnaires pour le même jeu de données, ce qui provoque des erreurs. L’exemple de code suivant montre quelques façons de définir les propriétés et leur sont associées <xref:System.Windows.Forms.BindingContext> objets. Vous pouvez définir les propriétés à l’aide d’une des méthodes suivantes, tant que vous êtes cohérent dans tout votre code.  
  
```vb  
ComboBox1.DataSource = DataSet1  
ComboBox1.DisplayMember = "Customers.FirstName"  
Me.BindingContext(dataSet1, "Customers").Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1;  
comboBox1.DisplayMember = "Customers.FirstName";  
this.BindingContext[dataSet1, "Customers"].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1;  
comboBox1->DisplayMember = "Customers.FirstName";  
this->BindingContext->get_Item(dataSet1, "Customers")->Position = 1;  
  
```  
  
```vb  
ComboBox1.DataSource = DataSet1.Customers  
ComboBox1.DisplayMember = "FirstName"  
Me.BindingContext(dataSet1.Customers).Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1.Customers;  
comboBox1.DisplayMember = "FirstName";  
this.BindingContext[dataSet1.Customers].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1->Customers;  
comboBox1->DisplayMember = "FirstName";  
this->BindingContext->get_Item(dataSet1->Customers)->Position = 1;  
  
```  
  
> [!NOTE]
>  La plupart des applications Windows Forms lier via un <xref:System.Windows.Forms.BindingSource>. Le <xref:System.Windows.Forms.BindingSource> composant encapsule un <xref:System.Windows.Forms.CurrencyManager> et expose le <xref:System.Windows.Forms.CurrencyManager> interface de programmation. Lorsque vous utilisez un <xref:System.Windows.Forms.BindingSource> pour la liaison, vous devez utiliser les membres exposés par le <xref:System.Windows.Forms.BindingSource> pour manipuler des « devise » (autrement dit, `Position`) au lieu de traverser le <xref:System.Windows.Forms.BindingContext>.  
  
   
  
## Examples  
 L’exemple de code suivant crée quatre <xref:System.Windows.Forms.Binding> objets à lier des cinq contrôles - un <xref:System.Windows.Forms.DateTimePicker> et quatre <xref:System.Windows.Forms.TextBox> contrôles - à plusieurs sources de données. Le <xref:System.Windows.Forms.BindingContext> est ensuite utilisé pour obtenir le <xref:System.Windows.Forms.BindingManagerBase> pour chaque source de données.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
    <altmember cref="T:System.Windows.Forms.Binding" />
    <altmember cref="T:System.Windows.Forms.BindingsCollection" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.BindingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous souhaitez avoir plusieurs <xref:System.Windows.Forms.BindingManagerBase> instances pour la même source de données, créez un <xref:System.Windows.Forms.BindingContext> et affectez-lui le <xref:System.Windows.Forms.Control.BindingContext%2A> propriété d’un objet qui hérite de la <xref:System.Windows.Forms.Control> classe. Par exemple, si vous disposez de deux <xref:System.Windows.Forms.BindingManagerBase> objets (à partir de deux différentes <xref:System.Windows.Forms.BindingContext> objets), vous pouvez définir le <xref:System.Windows.Forms.BindingManagerBase.Position%2A> propriétés de chaque <xref:System.Windows.Forms.BindingManagerBase> à des valeurs différentes. Ainsi, chaque jeu de contrôles liés aux données pour afficher des valeurs différentes de la même source de données.  
  
   
  
## Examples  
 L’exemple de code suivant crée deux nouvelles <xref:System.Windows.Forms.BindingContext> objets et assigne chaque objet à la <xref:System.Windows.Forms.BindingContext> propriété d’un <xref:System.Windows.Forms.GroupBox> contrôle. `GroupBox1` contient `TextBox1`, et `GroupBox2` contient `TextBox2` (qui s’effectue à l’aide de la <xref:System.Windows.Forms.Control.ControlCollection.AddRange%2A> méthode de la <xref:System.Windows.Forms.Control.ControlCollection> classe). L’exemple ajoute ensuite <xref:System.Windows.Forms.Binding> objets aux deux <xref:System.Windows.Forms.TextBox> contrôles, chacun d’eux à la même membre de données source et les données de liaison. L’exemple montre également deux gestionnaires d’événements qui utilisent le <xref:System.Windows.Forms.BindingContext> à partir de la <xref:System.Windows.Forms.GroupBox> contrôles pour définir le <xref:System.Windows.Forms.BindingManagerBase.Position%2A> propriété sur autre <xref:System.Windows.Forms.BindingManagerBase> objets.  
  
 [!code-cpp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="protected internal void Add (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Add(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Add(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Add (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Add(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberSignature Language="F#" Value="member this.Add : obj * System.Windows.Forms.BindingManagerBase -&gt; unit" Usage="bindingContext.Add (dataSource, listManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Objet <see cref="T:System.Object" /> associé au <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <param name="listManager"><see cref="T:System.Windows.Forms.BindingManagerBase" /> à ajouter.</param>
        <summary>Ajoute le <see cref="T:System.Windows.Forms.BindingManagerBase" /> associé à une source de données spécifique à la collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCore">
      <MemberSignature Language="C#" Value="protected virtual void AddCore (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddCore(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.AddCore(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddCore (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddCore(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberSignature Language="F#" Value="abstract member AddCore : obj * System.Windows.Forms.BindingManagerBase -&gt; unit&#xA;override this.AddCore : obj * System.Windows.Forms.BindingManagerBase -&gt; unit" Usage="bindingContext.AddCore (dataSource, listManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Objet associé à <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <param name="listManager"><see cref="T:System.Windows.Forms.BindingManagerBase" /> à ajouter.</param>
        <summary>Ajoute le <see cref="T:System.Windows.Forms.BindingManagerBase" /> associé à une source de données spécifique à la collection.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSource" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="listManager" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="protected internal void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Clear" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="bindingContext.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface de la collection tout objet <see cref="T:System.Windows.Forms.BindingManagerBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearCore">
      <MemberSignature Language="C#" Value="protected virtual void ClearCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.ClearCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearCore();" />
      <MemberSignature Language="F#" Value="abstract member ClearCore : unit -&gt; unit&#xA;override this.ClearCore : unit -&gt; unit" Usage="bindingContext.ClearCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface la collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CollectionChangeEventHandler CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CollectionChangeEventHandler CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingContext.CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CollectionChanged As CollectionChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CollectionChangeEventHandler ^ CollectionChanged;" />
      <MemberSignature Language="F#" Value="member this.CollectionChanged : System.ComponentModel.CollectionChangeEventHandler " Usage="member this.CollectionChanged : System.ComponentModel.CollectionChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CollectionChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lève systématiquement une exception <see cref="T:System.NotImplementedException" /> en cas de gestion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingContext.CollectionChanged> événement est obsolète et lève systématiquement une <xref:System.NotImplementedException> lors du traitement. Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Se produit dans tous les cas.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Windows.Forms.BindingContext" /> contient le <see cref="T:System.Windows.Forms.BindingManagerBase" /> spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="member this.Contains : obj -&gt; bool" Usage="bindingContext.Contains dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource"><see cref="T:System.Object" /> représentant la source de données.</param>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Windows.Forms.BindingContext" /> contient le <see cref="T:System.Windows.Forms.BindingManagerBase" /> associé à la source de données spécifiée.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Windows.Forms.BindingContext" /> contient le <see cref="T:System.Windows.Forms.BindingManagerBase" /> spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez la <xref:System.Windows.Forms.Binding> classe pour obtenir la liste des sources de données possibles et des informations sur la création de liaisons entre les contrôles et les sources de données.  
  
 Consultez le <xref:System.Windows.Forms.BindingContext.Item%2A> propriété pour plus d’informations sur le renvoi d’un <xref:System.Windows.Forms.BindingManagerBase> à l’aide d’une source de données uniquement.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Windows.Forms.BindingContext.Contains%2A> méthode pour déterminer si un <xref:System.Windows.Forms.BindingManagerBase> existe pour chaque contrôle sur un formulaire. L’exemple passe chaque <xref:System.Data.DataTable> dans un <xref:System.Data.DataSet> à la méthode.  
  
 [!code-cpp[Classic BindingContext.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object, dataMember As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="member this.Contains : obj * string -&gt; bool" Usage="bindingContext.Contains (dataSource, dataMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource"><see cref="T:System.Object" /> représentant la source de données.</param>
        <param name="dataMember">Informations nécessaires pour correspondre à un <see cref="T:System.Windows.Forms.BindingManagerBase" /> spécifique.</param>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Windows.Forms.BindingContext" /> contient le <see cref="T:System.Windows.Forms.BindingManagerBase" /> associé aux sources de données et données membres spécifiées.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Windows.Forms.BindingContext" /> contient le <see cref="T:System.Windows.Forms.BindingManagerBase" /> spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez la <xref:System.Windows.Forms.Binding> classe pour obtenir la liste de sources de données possibles et pour plus d’informations sur la création de liaisons entre les contrôles et les sources de données.  
  
 Consultez le <xref:System.Windows.Forms.BindingContext.Item%2A> propriété pour plus d’informations sur le renvoi d’un <xref:System.Windows.Forms.BindingManagerBase> à l’aide d’une source de données et un membre de données.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Windows.Forms.BindingContext.Contains%2A> méthode pour tester si un spécifique <xref:System.Windows.Forms.BindingManagerBase> existe avant d’essayer de le télécharger à partir du <xref:System.Windows.Forms.BindingContext.Item%2A> propriété.  
  
 [!code-cpp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Forms.BindingContext.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la collection est en lecture seule.</summary>
        <value><see langword="true" /> si la collection est en lecture seule ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est dérivée de <xref:System.Collections.ICollection> ; elle est substituée de telle sorte que `false` soit toujours retourné.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient <see cref="T:System.Windows.Forms.BindingManagerBase" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : System.Windows.Forms.BindingManagerBase" Usage="System.Windows.Forms.BindingContext.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Source de données associée à un <see cref="T:System.Windows.Forms.BindingManagerBase" /> particulier.</param>
        <summary>Obtient le <see cref="T:System.Windows.Forms.BindingManagerBase" /> qui est associé à la source de données spécifiée.</summary>
        <value><see cref="T:System.Windows.Forms.BindingManagerBase" /> pour la source de données spécifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge si le <xref:System.Windows.Forms.BindingManagerBase> souhaité ne nécessite pas un chemin de navigation. Par exemple, si le <xref:System.Windows.Forms.BindingManagerBase> gère un ensemble de <xref:System.Windows.Forms.Binding> objets qui utilisent un <xref:System.Collections.ArrayList> ou <xref:System.Data.DataTable> en tant que le <xref:System.Windows.Forms.Binding.DataSource%2A>, aucun chemin de navigation est nécessaire.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.BindingContext.Item%2A> propriété retourne toujours un <xref:System.Windows.Forms.BindingManagerBase>et ne retournent jamais `null`.  
  
 Consultez la <xref:System.Windows.Forms.Binding> classe pour obtenir la liste de sources de données possibles et pour plus d’informations sur la création de liaisons entre les contrôles et les sources de données.  
  
   
  
## Examples  
 L’exemple de code suivant retourne trois <xref:System.Windows.Forms.BindingManagerBase> objets : un pour un <xref:System.Data.DataView>, un pour un <xref:System.Collections.ArrayList>et l’autre pour le <xref:System.Windows.Forms.Binding.DataSource%2A> d’un <xref:System.Windows.Forms.Binding> qui appartient à un <xref:System.Windows.Forms.TextBox> contrôle.  
  
 [!code-cpp[Classic BindingContext.this Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.this Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.this Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.this Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.this Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.this Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource, string dataMember] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object, string)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object, dataMember As String) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^, System::String ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource, System::String ^ dataMember); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj * string) : System.Windows.Forms.BindingManagerBase" Usage="System.Windows.Forms.BindingContext.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Source de données associée à un <see cref="T:System.Windows.Forms.BindingManagerBase" /> particulier.</param>
        <param name="dataMember">Chemin de navigation contenant les informations qui conduisent à un <see cref="T:System.Windows.Forms.BindingManagerBase" /> spécifique.</param>
        <summary>Obtient un <see cref="T:System.Windows.Forms.BindingManagerBase" /> qui est associé aux sources de données et données membres spécifiées.</summary>
        <value><see cref="T:System.Windows.Forms.BindingManagerBase" /> pour les sources de données et données membres spécifiées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge si le <xref:System.Windows.Forms.BindingManagerBase> gère un ensemble de <xref:System.Windows.Forms.Binding> objets pour lesquels la source de données contient plusieurs objets. Par exemple, un <xref:System.Data.DataSet> peut contenir plusieurs <xref:System.Data.DataTable> objets liés par <xref:System.Data.DataRelation> objets. Dans ce cas, le chemin de navigation est requis pour activer la <xref:System.Windows.Forms.BindingContext> pour renvoyer la bonne <xref:System.Windows.Forms.BindingManagerBase>.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.BindingContext.Item%2A> propriété retourne toujours un <xref:System.Windows.Forms.BindingManagerBase>, lorsque le `dataMember` paramètre n’est valide. Il ne retourne jamais `null`.  
  
 Consultez la <xref:System.Windows.Forms.Binding> classe pour obtenir la liste de sources de données possibles et pour plus d’informations sur la création de liaisons entre les contrôles et les sources de données.  
  
 Si le texte souhaité <xref:System.Windows.Forms.BindingManagerBase> gère une liste, le chemin de navigation doit également se terminer avec une liste. Par exemple, le code c# suivant lie un <xref:System.Windows.Forms.TextBox> contrôle à la date de commande dans une table de commandes. Le chemin d’accès de navigation inclut le <xref:System.Data.DataTable.TableName%2A>, le <xref:System.Data.DataRelation.RelationName%2A>et le <xref:System.Data.DataColumn.ColumnName%2A>. Toutefois, le <xref:System.Windows.Forms.BindingManagerBase> doit être récupéré en utilisant uniquement le <xref:System.Data.DataTable.TableName%2A> et <xref:System.Data.DataRelation.RelationName%2A> (ce qui donne une liste).  
  
```  
// The navigation path for a Binding ends with a property.  
textBox1.DataBindings.Add  
("Text", dataSet1, "Customers.custToOrders.OrderDate");  
// The navigation path for the BindingManagerBase ends with a list.  
BindingManagerBase bmOrders = this.BindingContext  
[dataSet1, "Customers.custToOrders"];  
```  
  
 Lors du retour d’un <xref:System.Windows.Forms.BindingManagerBase>, vous devez utiliser la même source de données que le <xref:System.Windows.Forms.Binding> et modifier uniquement le chemin d’accès de navigation.  
  
 Utilisez le <xref:System.Windows.Forms.BindingContext.Contains%2A> méthode pour déterminer si le texte souhaité <xref:System.Windows.Forms.BindingManagerBase> existe déjà.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.BindingContext.Item%2A> pour récupérer le <xref:System.Windows.Forms.BindingManagerBase> pour une liaison particulière. Il montre également comment gérer le <xref:System.Windows.Forms.BindingManagerBase.BindingComplete> événement pour le <xref:System.Windows.Forms.BindingManagerBase> pour garantir que plusieurs contrôles liés à la même source de données restent synchronisés lorsque l’une des valeurs de contrôle est modifiée. Pour exécuter cet exemple, collez le code dans un Windows Form et appelez le `InitializeControlsAndData` méthode à partir du constructeur du formulaire ou <xref:System.Windows.Forms.Form.Load> méthode de gestion des événements.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Le <paramref name="dataMember" /> spécifié n'existe pas dans la source de données.</exception>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCollectionChanged (System.ComponentModel.CollectionChangeEventArgs ccevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCollectionChanged(class System.ComponentModel.CollectionChangeEventArgs ccevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCollectionChanged (ccevent As CollectionChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCollectionChanged(System::ComponentModel::CollectionChangeEventArgs ^ ccevent);" />
      <MemberSignature Language="F#" Value="abstract member OnCollectionChanged : System.ComponentModel.CollectionChangeEventArgs -&gt; unit&#xA;override this.OnCollectionChanged : System.ComponentModel.CollectionChangeEventArgs -&gt; unit" Usage="bindingContext.OnCollectionChanged ccevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ccevent" Type="System.ComponentModel.CollectionChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="ccevent"><see cref="T:System.ComponentModel.CollectionChangeEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingContext.CollectionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingContext.OnCollectionChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected internal void Remove (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Remove(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Remove (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Remove(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="bindingContext.Remove dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Source de données associée au <see cref="T:System.Windows.Forms.BindingManagerBase" /> à supprimer.</param>
        <summary>Supprime le <see cref="T:System.Windows.Forms.BindingManagerBase" /> associé à la source de données spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveCore">
      <MemberSignature Language="C#" Value="protected virtual void RemoveCore (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RemoveCore(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.RemoveCore(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RemoveCore (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RemoveCore(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="abstract member RemoveCore : obj -&gt; unit&#xA;override this.RemoveCore : obj -&gt; unit" Usage="bindingContext.RemoveCore dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Source de données associée au <see cref="T:System.Windows.Forms.BindingManagerBase" /> à supprimer.</param>
        <summary>Supprime le <see cref="T:System.Windows.Forms.BindingManagerBase" /> associé à la source de données spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array ar, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array ar, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (ar As Array, index As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ ar, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ar" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ar"><see cref="T:System.Array" /> dans lequel effectuer la copie.</param>
        <param name="index">Index de collection à partir duquel commencer la copie.</param>
        <summary>Copie les éléments de la collection au niveau de l’index de collection dans un tableau spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre total d'objets <see cref="T:System.Windows.Forms.CurrencyManager" /> managés par le <see cref="T:System.Windows.Forms.BindingContext" />.</summary>
        <value>Nombre de sources de données managées par le <see cref="T:System.Windows.Forms.BindingContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant retourne le nombre de <xref:System.Windows.Forms.CurrencyManager> objets gérés par le <xref:System.Windows.Forms.BindingContext>.  
  
 [!code-cpp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la collection est synchronisée.</summary>
        <value><see langword="true" /> si la collection est thread-safe ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est dérivée de <xref:System.Collections.ICollection> ; elle est substituée de telle sorte que `false` soit toujours retourné.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet à utiliser pour la synchronisation (sécurité des threads).</summary>
        <value>Cette propriété est dérivée de <see cref="T:System.Collections.ICollection" /> ; elle est substituée de telle sorte que <see langword="null" /> soit toujours retourné.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un énumérateur pour la collection.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.IEnumerator> retourné par la <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> méthode vous permet d’itérer sur la collection managée par le <xref:System.Windows.Forms.BindingContext>.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> méthode pour retourner un <xref:System.Collections.IEnumerator> pour le <xref:System.Windows.Forms.BindingContext>.  
  
 [!code-cpp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBinding">
      <MemberSignature Language="C#" Value="public static void UpdateBinding (System.Windows.Forms.BindingContext newBindingContext, System.Windows.Forms.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateBinding(class System.Windows.Forms.BindingContext newBindingContext, class System.Windows.Forms.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.UpdateBinding(System.Windows.Forms.BindingContext,System.Windows.Forms.Binding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateBinding(System::Windows::Forms::BindingContext ^ newBindingContext, System::Windows::Forms::Binding ^ binding);" />
      <MemberSignature Language="F#" Value="static member UpdateBinding : System.Windows.Forms.BindingContext * System.Windows.Forms.Binding -&gt; unit" Usage="System.Windows.Forms.BindingContext.UpdateBinding (newBindingContext, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBindingContext" Type="System.Windows.Forms.BindingContext" />
        <Parameter Name="binding" Type="System.Windows.Forms.Binding" />
      </Parameters>
      <Docs>
        <param name="newBindingContext">Nouveau <see cref="T:System.Windows.Forms.BindingContext" /> à associer au <see cref="T:System.Windows.Forms.Binding" />.</param>
        <param name="binding"><see cref="T:System.Windows.Forms.Binding" /> à associer au nouveau <see cref="T:System.Windows.Forms.BindingContext" />.</param>
        <summary>Associe un <see cref="T:System.Windows.Forms.Binding" /> à un nouveau <see cref="T:System.Windows.Forms.BindingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est destinée à mettre à jour les liaisons de composants qui implémentent <xref:System.Windows.Forms.IBindableComponent>, lorsque leur <xref:System.Windows.Forms.BindingContext> modifications.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>